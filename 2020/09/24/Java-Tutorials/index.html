<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基于Java8翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Tutorials">
<meta property="og:url" content="http://yoursite.com/2020/09/24/Java-Tutorials/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="基于Java8翻译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif">
<meta property="article:published_time" content="2020-09-24T00:11:11.000Z">
<meta property="article:modified_time" content="2020-10-09T06:45:09.580Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="Java-tutorials">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif">

<link rel="canonical" href="http://yoursite.com/2020/09/24/Java-Tutorials/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java-Tutorials | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/24/Java-Tutorials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-Tutorials
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-24 08:11:11" itemprop="dateCreated datePublished" datetime="2020-09-24T08:11:11+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-09 14:45:09" itemprop="dateModified" datetime="2020-10-09T14:45:09+08:00">2020-10-09</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/09/24/Java-Tutorials/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/24/Java-Tutorials/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基于Java8翻译</p>
<a id="more"></a>
<p><strong>基础</strong></p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>Java技术简介和安装Java开发软件并使用它创建简单程序的课程。</p>
<h1 id="学习Java语言"><a href="#学习Java语言" class="headerlink" title="学习Java语言"></a>学习Java语言</h1><p><a href="#java-concepts">面向对象的编程概念</a>教您面向对象的编程背后的核心概念：对象，消息，类和继承。 本课最后向您展示这些概念如何转换为代码。 如果您已经熟悉面向对象的编程，请随时跳过本课程。</p>
<p><a href="#java-nutsandbolts">语言基础</a>描述了语言的传统功能，包括变量，数组，数据类型，运算符和控制流。</p>
<p><a href="#java-javaOO">类和对象</a>描述了如何编写从中创建对象的类，以及如何创建和使用对象。</p>
<p><a href="#java-annotations">注解</a>是元数据的一种形式，为编译器提供信息。 本课描述了在程序中的何处以及如何有效使用注释。</p>
<p><a href="#java-IandI">接口和继承</a>描述了接口-它们是什么，为什么要编写一个接口以及如何编写一个接口。 本节还描述了可以从另一个类派生一个类的方法。 也就是说，子类如何可以从超类继承字段和方法。 您将了解所有类都派生自Object类，以及如何修改子类从超类继承的方法。</p>
<p><a href="#java-data">Numbers和Strings</a>本课程描述如何使用数字和字符串对象。本课程还向您展示如何格式化数据以输出。</p>
<p><a href="#java-generics">泛型</a>是Java编程语言的强大功能。 它们提高了代码的类型安全性，使您在编译时可以检测到更多错误。</p>
<p><a href="#java-package">包</a>是Java编程语言的一项功能，可帮助您组织和构造类及其之间的关系。</p>
<p><span id="java-concepts"></span></p>
<h2 id="面向对象编程概念"><a href="#面向对象编程概念" class="headerlink" title="面向对象编程概念"></a>面向对象编程概念</h2><p>如果您以前从未使用过面向对象的编程语言，则需要学习一些基本概念，然后才能开始编写任何代码。本课将向您介绍对象，类，继承，接口和包。每个讨论都集中在这些概念如何与现实世界相关的同时，同时提供对Java编程语言语法的介绍。</p>
<p><a href="#什么是对象">什么是对象</a>？<br>对象是具有相关状态和行为的软件包。软件对象通常用于建模您在日常生活中发现的现实世界对象。本课说明了对象中状态和行为的表示方式，介绍了数据封装的概念，并说明了以这种方式设计软件的好处。</p>
<p><a href="#什么是类">什么是类</a>？<br>类是从中创建对象的蓝图或原型。本节定义了一个模型，用于对实际对象的状态和行为进行建模。它特意侧重于基础知识，展示了即使是简单的类也可以如何清晰地对状态和行为进行建模。</p>
<p><a href="#什么是继承">什么是继承</a>？<br>继承为组织和构造软件提供了强大而自然的机制。本节说明类如何从其超类继承状态和行为，并说明如何使用Java编程语言提供的简单语法从另一个类派生一个类。</p>
<p><a href="#什么是接口">什么是接口</a>？<br>接口是类与外界之间的契约。当一个类实现一个接口时，它承诺提供该接口发布的行为。本节定义了一个简单的接口，并说明了实现该接口的任何类的必要更改。</p>
<p><a href="#什么是包">什么是包</a>？<br>包是用于以逻辑方式组织类和接口的名称空间。将您的代码放入程序包使大型软件项目更易于管理。本节说明了这样做的用处，并向您介绍Java平台提供的应用程序编程接口（API）。</p>
<p>问题与练习：面向对象的编程概念<br>使用本节中提出的问题和练习来测试您对对象，类，继承，接口和包的理解。</p>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>对象是理解面向对象技术的关键。现在环顾四周，您会发现许多真实物体的示例：您的狗，书桌，电视机，自行车。</p>
<p>现实世界中的对象共有两个特征：它们都具有状态和行为。狗具有状态（名称，颜色，品种，饥饿）和行为（吠叫，抓捕，摇尾巴）。自行车还具有状态（当前档位，当前踏板节奏，当前速度）和行为（换档，改变踏板节奏，施加制动）。识别现实世界对象的状态和行为是从面向对象编程的角度出发思考的一种好方法。</p>
<p>现在花一分钟时间观察您附近区域中的真实对象。对于您看到的每个对象，问自己两个问题：“该对象可能处于什么状态？”和“此对象可能执行什么行为？”。确保写下您的观察结果。在执行操作时，您会注意到现实世界中对象的复杂性各不相同。您的台式机灯可能只有两种可能的状态（打开和关闭）和两种可能的行为（打开，关闭），但是您的台式收音机可能具有其他状态（打开，关闭，当前音量，当前电台）和行为（打开） ，关闭，增加音量，减少音量，搜索，扫描和调整）。您可能还会注意到，某些对象也将包含其他对象。这些真实的观察结果都转化为面向对象编程的世界。</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif" alt="软件中的对象"></p>
<p>软件对象在概念上与现实世界中的对象相似：它们也由状态和相关行为组成。 对象将其状态存储在字段中（某些编程语言中的变量），并通过方法（某些编程语言中的函数）公开其行为。 方法在对象的内部状态上运行，并用作对象间通信的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互被称为数据封装-面向对象编程的基本原理。</p>
<p>考虑一辆自行车，例如：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif" alt="软件中的自行车模型"></p>
<p>通过归因于状态（当前速度，当前踏板踏频和当前档位）并提供更改状态的方法，对象可以控制外部世界如何使用它。例如，如果自行车只有6档，则更改齿轮的方法可能会拒绝任何小于1或大于6的值。</p>
<p>将代码捆绑到单个软件对象中可带来许多好处，包括：</p>
<ol>
<li>模块化：可以独立于其他对象的源代码编写和维护对象的源代码。创建对象后，可以轻松地在系统内部传递对象。</li>
<li>信息隐藏：通过仅与对象的方法进行交互，其内部实现的细节仍对外界隐藏。</li>
<li>代码重用：如果某个对象已经存在（也许由其他软件开发人员编写），则可以在程序中使用该对象。这使专家可以实现/测试/调试特定于任务的复杂对象，然后您可以信任它们以自己的代码运行。</li>
<li>可插拔性和调试简便性：如果发现某个特定对象有问题，则只需将其从应用程序中删除，然后插入另一个对象作为替换对象即可。这类似于解决现实世界中的机械问题。如果螺栓断裂，请更换，而不是整个机器。</li>
</ol>
<h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><p>在现实世界中，您经常会发现许多同一种个体。 可能还有成千上万的其他自行车，都具有相同的品牌和型号。 每辆自行车都是根据相同的设计图制造的，因此包含相同的组件。 用面向对象的术语来说，我们说您的自行车是称为自行车的一类对象的实例。 类是从中创建单个对象的蓝图。</p>
<p>以下Bicycle类是自行车的一种可能实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cadence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">         speed = speed + increment;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">         speed = speed - decrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;cadence:&quot;</span> +</span><br><span class="line">             cadence + <span class="string">&quot; speed:&quot;</span> + </span><br><span class="line">             speed + <span class="string">&quot; gear:&quot;</span> + gear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编程语言的语法对您来说似乎很新，但是此类的设计是基于先前对自行车对象的讨论。 节奏，速度和齿轮字段表示对象的状态，方法（<code>changeCadence</code>，<code>changeGear</code>，<code>speedUp</code>等）定义了对象与外界的交互。</p>
<p>您可能已经注意到Bicycle类不包含main方法。 那是因为它不是一个完整的应用程序。 它只是应用程序中可能使用的自行车的蓝图。 创建和使用新的Bicycle对象的职责属于应用程序中的其他一些类。</p>
<p>这是一个<code>BicycleDemo</code>类，它创建两个单独的Bicycle对象并调用它们的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BicycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create two different </span></span><br><span class="line">        <span class="comment">// Bicycle objects</span></span><br><span class="line">        Bicycle bike1 = <span class="keyword">new</span> Bicycle();</span><br><span class="line">        Bicycle bike2 = <span class="keyword">new</span> Bicycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke methods on </span></span><br><span class="line">        <span class="comment">// those objects</span></span><br><span class="line">        bike1.changeCadence(<span class="number">50</span>);</span><br><span class="line">        bike1.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike1.changeGear(<span class="number">2</span>);</span><br><span class="line">        bike1.printStates();</span><br><span class="line"></span><br><span class="line">        bike2.changeCadence(<span class="number">50</span>);</span><br><span class="line">        bike2.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike2.changeGear(<span class="number">2</span>);</span><br><span class="line">        bike2.changeCadence(<span class="number">40</span>);</span><br><span class="line">        bike2.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike2.changeGear(<span class="number">3</span>);</span><br><span class="line">        bike2.printStates();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此测试的输出显示两辆自行车的结束踏板节奏，速度和齿轮：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cadence:50 speed:10 gear:2</span><br><span class="line">cadence:40 speed:20 gear:3</span><br></pre></td></tr></table></figure>
<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>不同种类的对象通常彼此之间有一定数量的共同点。 例如，山地车，公路车和双人自行车都具有自行车的特征（当前速度，当前踏板节奏，当前档位）。 然而，每个自行车还定义了使其与众不同的其他功能：双人自行车有两个座位和两组车把； 公路自行车有下降的车把； 一些山地自行车带有附加的链环，从而降低了齿轮比。</p>
<p>面向对象的编程允许类从其他类继承常用的状态和行为。 在此示例中，Bicycle现在成为<code>MountainBike</code>，<code>RoadBike</code>和<code>TandemBike</code>的超类。 在Java编程语言中，每个类都可以具有一个直接超类，并且每个超类都具有无限数量的子类的潜力：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif" alt="自行车类的继承"></p>
<p>创建子类的语法很简单。 在类声明的开头，使用extends关键字，后跟要从其继承的类的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MountainBike</span> <span class="keyword">extends</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new fields and methods defining </span></span><br><span class="line">    <span class="comment">// a mountain bike would go here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这为<code>MountainBike</code>提供了与Bicycle相同的字段和方法，但允许其代码仅专注于使其独特的功能。 这使子类的代码易于阅读。 但是，您必须注意正确记录每个超类定义的状态和行为，因为该代码不会出现在每个子类的源文件中。</p>
<h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>如您所知，对象通过其公开的方法定义了它们与外界的交互。 方法形成对象与外界的接口； 例如，电视机正面的按钮是您与塑料外壳另一侧的电线之间的接口。 您按下“电源”按钮可以打开和关闭电视。</p>
<p>在最常见的形式中，接口是一组具有空主体的相关方法。 如果将自行车的行为指定为接口，则可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  wheel revolutions per minute</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现此接口，您的类的名称将更改（更改为特定品牌的自行车，例如<code>ACMEBicycle</code>），然后在类声明中使用Implements关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACMEBicycle</span> <span class="keyword">implements</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cadence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The compiler will now require that methods</span></span><br><span class="line">   <span class="comment">// changeCadence, changeGear, speedUp, and applyBrakes</span></span><br><span class="line">   <span class="comment">// all be implemented. Compilation will fail if those</span></span><br><span class="line">   <span class="comment">// methods are missing from this class.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">         speed = speed + increment;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">         speed = speed - decrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;cadence:&quot;</span> +</span><br><span class="line">             cadence + <span class="string">&quot; speed:&quot;</span> + </span><br><span class="line">             speed + <span class="string">&quot; gear:&quot;</span> + gear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口可以使类对其承诺提供的行为更加正式。 接口在类和外部世界之间形成契约，并且该契约在编译时由编译器强制执行。 如果您的类声称要实现一个接口，则在成功编译该类之前，该接口定义的所有方法都必须出现在其源代码中。</p>
<blockquote>
<p>注意：要实际编译<code>ACMEBicycle</code>类，您需要将public关键字添加到已实现的接口方法的开头。 稍后，您将在有关<a href="#类和对象">类和对象</a>，<a href="#接口和继承">接口和继承</a>的课程中了解造成这种情况的原因。</p>
</blockquote>
<h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><p>程序包是一个命名空间，用于组织一组相关的类和接口。从概念上讲，您可以将软件包视为类似于计算机上的不同文件夹。您可以将HTML页面保留在一个文件夹中，将图像保留在另一个文件夹中，并将脚本或应用程序保留在另一个文件夹中。因为用Java编程语言编写的软件可以由成百上千个单独的类组成，所以通过将相关的类和接口放入包中来使事情井井有条是很有意义的。</p>
<p>Java平台提供了适合在您自己的应用程序中使用的庞大的类库（一组软件包）。该库称为“应用程序编程接口”或简称“ API”。它的程序包代表与通用编程最常关联的任务。例如，一个String对象包含字符串的状态和行为。 File对象允许程序员轻松创建，删除，检查，比较或修改文件系统上的文件；套接字对象允许创建和使用网络套接字；各种GUI对象控制按钮和复选框，以及与图形用户界面有关的其他任何内容。从字面上看，有数千种课程可供选择。程序员，这使您可以专注于特定应用程序的设计，而不是使其工作所需的基础结构。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/index.html">Java Platform API Specification</a>包含Java SE平台提供的所有软件包，接口，类，字段和方法的完整列表。在浏览器中加载页面并将其添加为书签。作为程序员，它将成为您最重要的参考文档。</p>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><ol>
<li>Real-world objects contain <strong>_ and _</strong>.</li>
<li>A software object’s state is stored in ___.</li>
<li>A software object’s behavior is exposed through ___.</li>
<li>Hiding internal data from the outside world, and accessing it only through publicly exposed methods is known as data ___.</li>
<li>A blueprint for a software object is called a ___.</li>
<li>Common behavior can be defined in a <strong>_ and inherited into a _</strong> using the ___ keyword.</li>
<li>A collection of methods with no implementation is called an ___.</li>
<li>A namespace that organizes classes and interfaces by functionality is called a ___.</li>
<li>The term API stands for ___?</li>
</ol>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Create new classes for each real-world object that you observed at the beginning of this trail. Refer to the Bicycle class if you forget the required syntax.</li>
<li>For each new class that you’ve created above, create an interface that defines its behavior, then require your class to implement it. Omit one or two methods and try compiling. What does the error look like?</li>
</ol>
<p><span id="java-nutsandbolts"></span></p>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><p><a href="#Variables"><strong>变量</strong></a><br>您已经了解到对象存储在字段中。但是，Java编程语言也使用术语“变量”。本节讨论这种关系，以及变量命名规则和约定，基本数据类型（原始类型，字符串和数组），默认值和文字。<br><a href="#Operators"><strong>经营者</strong></a><br>本节描述Java编程语言的运算符。它首先显示最常用的运算符，然后显示最不常用的运算符。每个讨论都包含可编译和运行的代码示例。<br><a href="#表达式，语句和块"><strong>表达式，语句和块</strong></a><br>运算符可用于构建表达式，以计算值。表达式是语句的核心组成部分；语句可以分为多个块。本节使用您已经看到的示例代码讨论表达式，语句和块。<br><a href="#控制流语句"><strong>控制流语句</strong></a><br>本节描述Java编程语言支持的控制流语句。它涵盖了决策，循环和分支语句，使您的程序可以有条件地执行特定的代码块。</p>
<p><span id="Variables"></span></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><span id="Operators"></span></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h3 id="表达式，语句和块"><a href="#表达式，语句和块" class="headerlink" title="表达式，语句和块"></a>表达式，语句和块</h3><h3 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h3><p><span id="java-javaOO"></span></p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>现在，您掌握了Java编程语言的基础知识，就可以学习编写自己的类。在本课程中，您将找到有关定义自己的类的信息，包括声明成员变量，方法和构造函数。</p>
<p>您将学习如何使用类来创建对象，以及如何使用所创建的对象。</p>
<p>本课还介绍了其他类中的嵌套类以及枚举</p>
<p><a href="#类">类</a><br>本节向您展示类的剖析，以及如何声明字段，方法和构造函数。<br><a href="#对象">对象</a><br>本节介绍创建和使用对象。您将学习如何实例化一个对象，以及实例化后如何使用点运算符访问该对象的实例变量和方法。<br><a href="#有关类的更多信息">有关类的更多信息</a><br>本节介绍了类的更多方面，这些方面取决于使用对象引用和上一节中学习的点运算符：从方法，this关键字，类与实例成员以及访问控制返回值。<br><a href="#嵌套类">嵌套类</a><br>涵盖了静态嵌套类，内部类，匿名内部类，局部类和lambda表达式。还有关于何时使用哪种方法的讨论。<br><a href="#枚举类型">枚举类型</a><br>本节介绍枚举和专用类，这些类使您可以定义和使用常量集。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在名为“面向对象编程概念”的课程中，对<a href="#面向对象编程概念">面向对象概念</a>的介绍以自行车类为例，赛车，山地自行车和双人自行车是子类。 这是一个可能的Bicycle类实现的示例代码，为您提供类声明的概述。 本课的后续部分将备份并逐步解释类声明。 目前，不要担心细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// three fields</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cadence;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gear;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> speed;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// one constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        gear = startGear;</span><br><span class="line">        cadence = startCadence;</span><br><span class="line">        speed = startSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// four methods</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyBrake</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">        speed -= decrement;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">        speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为Bicycle的子类的<code>MountainBike</code>类的类声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MountainBike</span> <span class="keyword">extends</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one field</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> seatHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MountainBike</span><span class="params">(<span class="keyword">int</span> startHeight, <span class="keyword">int</span> startCadence,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(startCadence, startSpeed, startGear);</span><br><span class="line">        seatHeight = startHeight;</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        seatHeight = newValue;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MountainBike</code>继承了Bicycle的所有字段和方法，并添加了<code>seatHeight</code>字段和一种设置方法（山地自行车的座椅可以根据地形要求上下移动）。</p>
<h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><p>您已经看到以以下方式定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// field, constructor, and </span></span><br><span class="line">    <span class="comment">// method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个类声明。类主体（大括号之间的区域）包含提供从类创建的对象的生命周期的所有代码：用于初始化新对象的构造函数，用于提供类及其对象状态的字段的声明，以及实现类及其对象行为的方法。</p>
<p>前面的类声明是最小的。它仅包含类声明中必需的那些组件。您可以在类声明的开头提供有关该类的更多信息，例如其超类的名称，是否实现任何接口等等。例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MySuperClass</span> <span class="keyword">implements</span> <span class="title">YourInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// field, constructor, and</span></span><br><span class="line">    <span class="comment">// method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示<code>MyClass</code>是<code>MySuperClass</code>的子类，并且它实现<code>YourInterface</code>接口。</p>
<p>您还可以在开始时添加诸如public或private之类的修饰符，因此您可以看到类声明的开头可能会变得非常复杂。本课后面将讨论修饰符public和private，这些修饰符确定哪些其他类可以访问<code>MyClass</code>。关于接口和继承的课程将说明如何以及为什么要在类声明中使用扩展并实现关键字。目前，您无需担心这些额外的并发症。</p>
<p>通常，类声明可以按顺序包括以下组件：</p>
<ol>
<li>修饰符，例如<code>public</code>，<code>private</code>以及以后会遇到的许多其他修饰符。</li>
<li>类名，首字母大写为约定。</li>
<li>类的父级（超类）的名称（如果有的话），以关键字<code>extends</code>开头。一个类只能扩展（子类）一个父级。</li>
<li>由类实现的接口的列表，以逗号分隔（如果有的话），并以关键字<code>Implements</code>开头。一个 类可以实现多个接口。</li>
<li>类主体，用大括号{}包围。</li>
</ol>
<h4 id="声明成员变量"><a href="#声明成员变量" class="headerlink" title="声明成员变量"></a>声明成员变量</h4><p>有几种变量：</p>
<ul>
<li>类中的成员变量-这些称为字段。</li>
<li>方法或代码块中的变量-这些称为局部变量。</li>
<li>方法声明中的变量-这些称为参数。</li>
</ul>
<p><code>Bicycle</code>类使用以下代码行定义其字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> cadence;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> gear;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> speed;</span><br></pre></td></tr></table></figure>
<p>字段声明按顺序由三个部分组成：</p>
<ol>
<li>零个或多个修饰符，例如public或private。</li>
<li>字段的类型。</li>
<li>字段名称。</li>
</ol>
<p><code>Bicycle</code>的字段被称为节奏，档位和速度，并且都是数据类型整数（int）。 <code>public</code>关键字将这些字段标识为公共成员，任何可以访问该类的对象都可以访问它们。</p>
<h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><p>使用第一个（最左侧）修饰符可以控制其他哪些类可以访问成员字段。目前，仅考虑公开和私有。其他访问修饰符将在后面讨论。</p>
<ul>
<li>公共修饰符-该字段可从所有类访问。</li>
<li>private修饰符-该字段只能在其自己的类中访问。</li>
</ul>
<p>本着封装的精神，通常将字段设为私有。这意味着只能从Bicycle类直接访问它们。但是，我们仍然需要访问这些值。这可以通过添加公共方法来间接完成，这些方法可以为我们获取字段值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cadence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> speed;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        gear = startGear;</span><br><span class="line">        cadence = startCadence;</span><br><span class="line">        speed = startSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCadence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cadence;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gear;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyBrake</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">        speed -= decrement;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">        speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><p>所有变量必须具有类型。您可以使用基本类型，例如int，float，boolean等。也可以使用引用类型，例如字符串，数组或对象。</p>
<h5 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h5><p>所有变量，无论它们是字段，局部变量还是参数，都遵循“语言基础”课程“变量—命名”中涉及的相同命名规则和约定。</p>
<p>在本课程中，请注意，方法和类名使用相同的命名规则和约定，但</p>
<ul>
<li><p>类名的首字母应大写，并且</p>
</li>
<li><p>方法名称中的第一个（或唯一）词应为动词。</p>
</li>
</ul>
<h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><h4 id="构造方法支持"><a href="#构造方法支持" class="headerlink" title="构造方法支持"></a>构造方法支持</h4><h4 id="传递信息给方法或构造方法"><a href="#传递信息给方法或构造方法" class="headerlink" title="传递信息给方法或构造方法"></a>传递信息给方法或构造方法</h4><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><h3 id="有关类的更多信息"><a href="#有关类的更多信息" class="headerlink" title="有关类的更多信息"></a>有关类的更多信息</h3><h4 id="从方法返回值"><a href="#从方法返回值" class="headerlink" title="从方法返回值"></a>从方法返回值</h4><h4 id="使用关键字"><a href="#使用关键字" class="headerlink" title="使用关键字"></a>使用关键字</h4><h4 id="控制类成员的访问"><a href="#控制类成员的访问" class="headerlink" title="控制类成员的访问"></a>控制类成员的访问</h4><h4 id="理解类成员"><a href="#理解类成员" class="headerlink" title="理解类成员"></a>理解类成员</h4><h4 id="初始化字段"><a href="#初始化字段" class="headerlink" title="初始化字段"></a>初始化字段</h4><h4 id="总结类和对象的创建和使用"><a href="#总结类和对象的创建和使用" class="headerlink" title="总结类和对象的创建和使用"></a>总结类和对象的创建和使用</h4><h3 id="问题和练习-类"><a href="#问题和练习-类" class="headerlink" title="问题和练习:类"></a>问题和练习:类</h3><h3 id="问题和练习-对象"><a href="#问题和练习-对象" class="headerlink" title="问题和练习:对象"></a>问题和练习:对象</h3><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>Java编程语言允许您在另一个类中定义一个类。 这样的类称为嵌套类，并在此处进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>术语：嵌套类分为两类：静态和非静态。 声明为静态的嵌套类称为静态嵌套类。 非静态嵌套类称为内部类。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套类是其封闭类的成员。非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有的也是如此。静态嵌套类无权访问封闭类的其他成员。作为OuterClass的成员，可以将嵌套类声明为私有，公共，受保护或包私有。 （回想一下，外部类只能声明为公共或包私有。）</p>
<p><strong>为什么要使用嵌套类</strong>？<br>使用嵌套类的令人信服的原因包括：</p>
<ul>
<li><strong>这是一种对仅在一个地方使用的类进行逻辑分组的方法</strong>：如果一个类仅对另一个类有用，那么将其嵌入该类并将两者保持在一起是合乎逻辑的。嵌套此类“帮助程序类”可使它们的程序包更加简化。</li>
<li><strong>它增加了封装</strong>：考虑两个顶级类A和B，其中B需要访问A的成员，否则将其声明为私有。通过将类B隐藏在类A中，可以将A的成员声明为私有，而B可以访问它们。另外，B本身可以对外界隐藏。</li>
<li><strong>它可以导致更具可读性和可维护性的代码</strong>：在顶级类中嵌套小型类会使代码更靠近使用位置。</li>
</ul>
<p><strong>静态嵌套类</strong><br>与类方法和变量一样，静态嵌套类与其外部类相关联。与静态类方法一样，静态嵌套类不能直接引用其封闭类中定义的实例变量或方法：它只能通过对象引用来使用它们。</p>
<blockquote>
<p>注意：静态嵌套类与它的外部类（和其他类）的实例成员进行交互，就像其他任何顶级类一样。实际上，静态嵌套类在行为上是顶级类，为了包装方便，该顶级类已嵌套在另一个顶级类中。</p>
</blockquote>
<p>静态嵌套类使用封闭的类名称访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass</span><br></pre></td></tr></table></figure>
<p>例如，要为静态嵌套类创建一个对象，请使用以下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass nestedObject &#x3D;</span><br><span class="line">     new OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure>
<p><strong>内部类</strong><br>与实例方法和变量一样，内部类与其所在类的实例相关联，并且可以直接访问该对象的方法和字段。另外，由于内部类与实例相关联，因此它本身不能定义任何静态成员。</p>
<p>作为内部类实例的对象存在于外部类实例中。考虑以下类别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InnerClass</code>的实例只能存在于<code>OuterClass</code>的实例中，并且可以直接访问其封闭实例的方法和字段。</p>
<p>要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象内创建内部对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass innerObject &#x3D; externalObject.new InnerClass（）;</span><br></pre></td></tr></table></figure>
<p>内部类有两种特殊类型：<a href="#本地类">本地类</a>和<a href="#匿名类">匿名类</a>。</p>
<p><strong>重影</strong><br>如果在特定范围（例如内部类或方法定义）中的类型声明（例如成员变量或参数名称）与封闭范围中的另一个声明具有相同的名称，则该声明将覆盖该声明封闭范围。您不能仅凭其名称引用带阴影的声明。下面的示例ShadowTest演示了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">            System.out.println(<span class="string">&quot;this.x = &quot;</span> + <span class="keyword">this</span>.x);</span><br><span class="line">            System.out.println(<span class="string">&quot;ShadowTest.this.x = &quot;</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        ShadowTest st = <span class="keyword">new</span> ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.<span class="function">new <span class="title">FirstLevel</span><span class="params">()</span></span>;</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是此示例的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">this.x = 1</span><br><span class="line">ShadowTest.this.x = 0</span><br></pre></td></tr></table></figure>
<p>此示例定义了三个名为x的变量：<code>ShadowTest</code>类的成员变量，内部类FirstLevel的成员变量以及<code>methodInFirstLevel</code>方法中的参数。定义为方法<code>methodInFirstLevel</code>的参数的变量x遮盖了内部类<code>FirstLevel</code>的变量。因此，在方法<code>methodInFirstLevel</code>中使用变量x时，它引用方法参数。要引用内部类<code>FirstLevel</code>的成员变量，请使用关键字this表示封闭范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println（“ <span class="keyword">this</span>.x =” + <span class="keyword">this</span>.x）;</span><br></pre></td></tr></table></figure>
<p>请参阅成员变量，这些成员变量使用它们所属的类名将更大的范围括起来。例如，以下语句从<code>methodInFirstLevel</code>方法访问<code>ShadowTest</code>类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println（<span class="string">&quot;ShadowTest.this.x =&quot;</span> + ShadowTest.<span class="keyword">this</span>.x）;</span><br></pre></td></tr></table></figure>
<p><strong>序列化</strong><br>强烈建议不要对内部类（包括<a href="本地类">本地类</a>和<a href="#匿名类">匿名类</a>）进行序列化。 当Java编译器编译某些构造（例如内部类）时，它会创建综合构造。 它们是类，方法，字段以及其他在源代码中没有相应构造的构造。 合成构造使Java编译器无需更改JVM就可以实现新的Java语言功能。 但是，合成构造在不同的Java编译器实现中可能有所不同，这意味着.class文件在不同的实现中也可能有所不同。 因此，如果序列化一个内部类，然后使用其他JRE实现对其进行反序列化，则可能会遇到兼容性问题。 有关在编译内部类时生成的综合构造的更多信息，请参见<a href="">“获取方法参数的名称”</a>一节中的<a href="">“隐式参数和综合参数”</a>部分。</p>
<h4 id="内部类例子"><a href="#内部类例子" class="headerlink" title="内部类例子"></a>内部类例子</h4><h4 id="本地类"><a href="#本地类" class="headerlink" title="本地类"></a>本地类</h4><h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>参考<a href="#lambda-expression">Lambda expression</a></p>
<h4 id="什么时候使用内部类-本地类-匿名类-Lambda表达式"><a href="#什么时候使用内部类-本地类-匿名类-Lambda表达式" class="headerlink" title="什么时候使用内部类,本地类,匿名类,Lambda表达式"></a>什么时候使用内部类,本地类,匿名类,Lambda表达式</h4><p>如嵌套类一节中所述，<a href="#嵌套类">嵌套类</a>使您能够对仅在一个地方使用的类进行逻辑分组，增加封装的使用，并创建更具可读性和可维护性的代码。本地类，匿名类和lambda表达式也具有这些优点。但是，它们旨在用于更特定的情况：</p>
<ul>
<li><p><a href="#本地类">本地类</a>：如果需要创建一个类的多个实例，访问其构造函数或引入新的命名类型（例如，因为稍后需要调用其他方法），请使用它。</p>
</li>
<li><p><a href="#匿名类">匿名类</a>：如果需要声明字段或其他方法，请使用它。</p>
</li>
<li><p><a href="#Lambda表达式">Lambda表达式</a>：</p>
<ul>
<li>如果要封装要传递给其他代码的单个行为单位，请使用它。例如，如果要在集合的每个元素上执行特定操作，流程完成或流程遇到错误时，可以使用lambda表达式。</li>
<li>如果您需要功能接口的简单实例并且不符合上述条件（例如，不需要构造函数，命名类型，字段或其他方法），请使用它。</li>
</ul>
</li>
<li><p><a href="#嵌套类">嵌套类</a>：如果您的要求与本地类的要求相似，并且您想使该类型更广泛地使用，并且您不需要访问本地变量或方法参数，请使用它。</p>
<ul>
<li>如果您需要访问封闭实例的非公共字段和方法，请使用非静态嵌套类（或内部类）。如果您不需要此访问，请使用静态嵌套类。</li>
</ul>
</li>
</ul>
<h3 id="问题和练习-内部类"><a href="#问题和练习-内部类" class="headerlink" title="问题和练习:内部类"></a>问题和练习:内部类</h3><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><h3 id="问题和练习-枚举类型"><a href="#问题和练习-枚举类型" class="headerlink" title="问题和练习:枚举类型"></a>问题和练习:枚举类型</h3><p><span id="java-annotations"></span></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p><span id="java-IandI"></span></p>
<h2 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h2><p><span id="java-data"></span></p>
<h2 id="Numbers和Strings"><a href="#Numbers和Strings" class="headerlink" title="Numbers和Strings"></a>Numbers和Strings</h2><p><span id="java-generics"></span></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><span id="java-package"></span></p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h1 id="基本Java类"><a href="#基本Java类" class="headerlink" title="基本Java类"></a>基本Java类</h1><p>有关异常，基本输入/输出，并发，正则表达式和平台环境的课程。</p>
<p><strong>高级</strong></p>
<p>准备深入研究该技术了吗？请参阅以下主题：</p>
<ul>
<li>集合-有关使用和扩展Java集合框架的课程。</li>
<li>Lambda表达式：了解如何以及为什么在应用程序中使用Lambda表达式。</li>
<li>聚合操作：探索聚合操作，流和Lambda表达式如何协同工作以提供强大的过滤功能。</li>
<li>在JAR文件中打包程序–创建和签名JAR文件的课程。</li>
<li>国际化–设计软件的简介，以便可以轻松地将其修改（本地化）为各种语言和地区。</li>
<li>反射–表示（“反射”）当前Java虚拟机中的类，接口和对象的API。</li>
<li>安全性– Java平台功能可帮助保护应用程序免受恶意软件的侵害。</li>
<li>JavaBeans – Java平台的组件技术。</li>
<li>扩展机制–如何使自定义API对Java平台上运行的所有应用程序可用。</li>
<li>泛型–类型系统的增强，它支持对各种类型的对象进行操作，同时提供编译时类型安全。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><span id="lambda-expression"></span></p>
<h1 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>匿名类的一个问题是，如果匿名类的实现非常简单（例如仅包含一个方法的接口），则匿名类的语法可能看起来笨拙且不清楚。 在这些情况下，您通常试图将功能作为参数传递给另一种方法，例如当某人单击按钮时应采取的措施。 Lambda表达式使您能够执行此操作，将功能视为方法参数，或将代码视为数据。</p>
<p>上一节“匿名类”介绍了如何在不给基类命名的情况下实现它。 尽管这通常比命名类更简洁，但是对于仅具有一种方法的类，即使是匿名类也显得有些繁琐。 Lambda表达式使您可以更紧凑地表达单方法类的实例。</p>
<p>本节涵盖以下主题：</p>
<ul>
<li><a href="#use-case">Lambda表达式的理想用例</a><ul>
<li><a href="#approach1">方法1：创建搜索匹配一个特征的成员的方法</a></li>
<li><a href="#approach2">方法2：创建更通用的搜索方法</a></li>
<li><a href="#approach3">方法3：在本地类中指定搜索条件代码</a></li>
<li><a href="#approach4">方法4：在匿名类中指定搜索条件代码</a></li>
<li><a href="#approach5">方法5：使用Lambda表达式指定搜索条件代码</a></li>
<li><a href="#approach6">方法6：将标准功能接口与Lambda表达式一起使用</a></li>
<li><a href="#approach7">方法7：在整个应用程序中使用Lambda表达式</a></li>
<li><a href="#approach8">方法8：更广泛地使用泛型</a></li>
<li><a href="#approach9">方法9：使用接受Lambda表达式作为参数的聚合操作</a></li>
</ul>
</li>
<li><a href="#lambda-expressions-in-gui-applications">GUI应用程序中的Lambda表达式</a></li>
<li><a href="#syntax">Lambda表达式的语法</a></li>
<li><a href="#accessing-local-variables">访问封闭范围的局部变量</a></li>
<li><a href="#target-typing">目标类型</a><ul>
<li><a href="#target-types-and-method-arguments">目标类型和方法参数</a></li>
</ul>
</li>
<li><a href="#serialization">序列化</a></li>
</ul>
<p><span id="use-case"></span></p>
<h2 id="Lambda表达式的理想用例"><a href="#Lambda表达式的理想用例" class="headerlink" title="Lambda表达式的理想用例"></a>Lambda表达式的理想用例</h2><p>假设您正在创建一个社交网络应用程序。您想创建一个功能，使管理员可以对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。下表详细描述了该用例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Perform action on selected members</td>
</tr>
<tr>
<td>Primary Actor</td>
<td>Administrator</td>
</tr>
<tr>
<td>Preconditions</td>
<td>Administrator is logged in to the system.</td>
</tr>
<tr>
<td>Postconditions</td>
<td>仅对符合指定条件的成员执行操作。</td>
</tr>
<tr>
<td>Main Success Scenario</td>
<td>管理员指定对其执行特定操作的成员条件。<br/>管理员指定要对那些选定成员执行的操作。<br/>管理员选择提交按钮。<br/>系统查找与指定条件匹配的所有成员。<br/>系统对所有匹配成员执行指定的操作。</td>
</tr>
<tr>
<td>Extensions</td>
<td>1a. 管理员可以选择在指定操作之前或选择“提交”按钮之前预览符合指定条件的成员。</td>
</tr>
<tr>
<td>Frequency of Occurrence</td>
<td>Many times during the day.</td>
</tr>
</tbody>
</table>
</div>
<p>假设此社交网络应用程序的成员由以下Person类表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    LocalDate birthday;</span><br><span class="line">    Sex gender;</span><br><span class="line">    String emailAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设您的社交网络应用程序的成员存储在<code>List &lt;Person&gt;</code>实例中。</p>
<p>本节以对这种用例的幼稚方法开始。 它使用本地和匿名类对该方法进行了改进，然后使用lambda表达式以一种高效而简洁的方法结束了。 在示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java">RosterTest</a>中找到本节中描述的代码摘录。</p>
<p><span id="approach1"></span></p>
<h2 id="方法1：创建搜索匹配一个特征的成员的方法"><a href="#方法1：创建搜索匹配一个特征的成员的方法" class="headerlink" title="方法1：创建搜索匹配一个特征的成员的方法"></a>方法1：创建搜索匹配一个特征的成员的方法</h2><p>一种简单的方法是创建几种方法。 每种方法都会搜索与一个特征（例如性别或年龄）相匹配的成员。 下面的方法将打印超过指定年龄的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsOlderThan</span><span class="params">(List&lt;Person&gt; roster, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &gt;= age) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>是有序<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>。集合是将多个元素分组为一个单元的对象。集合用于存储，检索，操作和传达聚合数据。有关集合的更多信息，请参阅<a href="#集合">“集合”</a>路径。</p>
<p>这种方法可能会使您的应用程序变脆，这是由于引入了更新（例如更新的数据类型）而导致应用程序无法工作的可能性。假设您升级了应用程序，并更改了Person类的结构，使其包含不同的成员变量；也许该班级使用不同的数据类型或算法记录和衡量年龄。您将不得不重写许多API来适应此更改。另外，这种方法是不必要的限制。例如，如果要打印小于特定年龄的成员该怎么办？</p>
<p><span id="approach2"></span></p>
<h2 id="方法2：创建更通用的搜索方法"><a href="#方法2：创建更通用的搜索方法" class="headerlink" title="方法2：创建更通用的搜索方法"></a>方法2：创建更通用的搜索方法</h2><p>以下方法比<code>printPersonsOlderThan</code>更通用；它打印指定年龄范围内的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithinAgeRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要打印指定性别或指定性别和年龄范围的组合，该怎么办？ 如果您决定更改Person类并添加其他属性（例如关系状态或地理位置）怎么办？ 尽管此方法比printPersonsOlderThan更通用，但是尝试为每个可能的搜索查询创建单独的方法仍会导致代码变脆。 相反，您可以在其他类中分隔指定要搜索标准的代码。</p>
<p><span id="approach3"></span></p>
<h2 id="方法3：在本地类中指定搜索条件代码"><a href="#方法3：在本地类中指定搜索条件代码" class="headerlink" title="方法3：在本地类中指定搜索条件代码"></a>方法3：在本地类中指定搜索条件代码</h2><p>下面的方法打印与您指定的搜索条件匹配的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersons</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, CheckPerson tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法通过调用方法<code>tester.test</code>来检查<code>List</code>参数名册中包含的每个<code>Person</code>实例是否满足<code>CheckPerson</code>参数测试器中指定的搜索条件。 如果方法<code>tester.test</code>返回一个真值，则在<code>Person</code>实例上调用方法<code>printPersons</code>。</p>
<p>要指定搜索条件，请实现CheckPerson界面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列类通过指定方法test的实现来实现CheckPerson接口。 此方法过滤在美国符合资格使用“选择性服务”的成员：如果其Person参数是男性且年龄在18至25之间，则它返回一个真值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPersonEligibleForSelectiveService</span> <span class="keyword">implements</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.gender == Person.Sex.MALE &amp;&amp;</span><br><span class="line">            p.getAge() &gt;= <span class="number">18</span> &amp;&amp;</span><br><span class="line">            p.getAge() &lt;= <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用此类，请创建该类的新实例并调用printPersons方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster, <span class="keyword">new</span> CheckPersonEligibleForSelectiveService());</span><br></pre></td></tr></table></figure>
<p>尽管这种方法不那么灵活（如果更改Person的结构，您不必重写方法），但是您仍然拥有其他代码：计划在应用程序中执行的每个搜索都需要一个新接口和一个本地类。 因为CheckPersonEligibleForSelectiveService实现了一个接口，所以您可以使用匿名类而不是本地类，并且无需为每次搜索声明一个新类。</p>
<p><span id="approach4"></span></p>
<h2 id="方法4：在匿名类中指定搜索条件代码"><a href="#方法4：在匿名类中指定搜索条件代码" class="headerlink" title="方法4：在匿名类中指定搜索条件代码"></a>方法4：在匿名类中指定搜索条件代码</h2><p>以下调用方法printPersons的参数之一是一个匿名类，该类过滤在美国符合资格参加选择性服务的成员：男性，年龄在18至25岁之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    <span class="keyword">new</span> CheckPerson() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p.getGender() == Person.Sex.MALE</span><br><span class="line">                &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">                &amp;&amp; p.getAge() &lt;= <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种方法减少了所需的代码量，因为您不必为要执行的每个搜索创建一个新类。 但是，考虑到CheckPerson接口仅包含一种方法，匿名类的语法非常庞大。 在这种情况下，您可以使用lambda表达式代替匿名类，如下一节所述。</p>
<p><span id="approach5"></span></p>
<h2 id="方法5：使用Lambda表达式指定搜索条件代码"><a href="#方法5：使用Lambda表达式指定搜索条件代码" class="headerlink" title="方法5：使用Lambda表达式指定搜索条件代码"></a>方法5：使用Lambda表达式指定搜索条件代码</h2><p>CheckPerson接口是功能接口。 功能接口是仅包含一种<a href="#abstract">抽象方法</a>的任何接口。 （一个功能接口可能包含一个或多个<a href="#defaultmethods">默认方法</a>或<a href="#defaultmethods-static">静态方法</a>。）由于一个功能接口仅包含一个抽象方法，因此在实现该方法时可以省略该方法的名称。 为此，您可以使用lambda表达式（而不是使用匿名类表达式），该表达式在以下方法调用中突出显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>有关如何定义lambda表达式的信息，请参见<a href="#syntax">Lambda表达式的语法</a>。</p>
<p>您可以使用标准功能接口代替CheckPerson接口，从而进一步减少了所需的代码量。</p>
<p><span id="approach6"></span></p>
<h2 id="方法6：将标准功能接口与Lambda表达式一起使用"><a href="#方法6：将标准功能接口与Lambda表达式一起使用" class="headerlink" title="方法6：将标准功能接口与Lambda表达式一起使用"></a>方法6：将标准功能接口与Lambda表达式一起使用</h2><p>重新考虑CheckPerson接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的界面。 这是一个功能接口，因为它仅包含一个抽象方法。 此方法采用一个参数并返回布尔值。 该方法是如此简单，以至于在您的应用程序中定义一个方法可能不值得。 因此，JDK定义了几个标准功能接口，您可以在包java.util.function中找到它们。</p>
<p>例如，您可以使用Predicate <T>接口代替CheckPerson。 该接口包含方法boolean test（T t）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口Predicate <T>是通用接口的示例。 （有关泛型的更多信息，请参见<a href="#generics">泛型（更新）课程</a>。）泛型（例如，泛型接口）在尖括号（&lt;&gt;）中指定一个或多个类型参数。 此接口仅包含一个类型参数T。使用实际类型参数声明或实例化泛型类型时，将具有参数化类型。 例如，参数化的类型Predicate <Person>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此参数化类型包含一个方法，该方法具有与CheckPerson.boolean test（Person p）相同的返回类型和参数。 因此，可以使用Predicate <T>代替CheckPerson，如以下方法所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithPredicate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果，以下方法调用与您在<a href="#approach3">方法3中</a>调用printPersons时相同：在本地类中指定搜索条件代码以获取有资格使用选择性服务的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这不是使用lambda表达式的唯一方法。 以下方法建议了使用lambda表达式的其他方法。</p>
<p><span id="approach7"></span></p>
<h2 id="方法7：在整个应用程序中使用Lambda表达式"><a href="#方法7：在整个应用程序中使用Lambda表达式" class="headerlink" title="方法7：在整个应用程序中使用Lambda表达式"></a>方法7：在整个应用程序中使用Lambda表达式</h2><p>重新考虑方法printPersonsWithPredicate，看看还能在哪里使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithPredicate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法检查List参数名册中包含的每个Person实例是否满足Predicate参数测试器中指定的条件。如果Person实例确实满足测试人员指定的条件，则在Person实例上调用方法printPersron。</p>
<p>除了可以调用方法printPerson之外，您还可以指定其他操作来对那些满足测试人员指定条件的Person实例执行。您可以使用lambda表达式指定此操作。假设您想要一个类似于printPerson的lambda表达式，该表达式需要一个参数（Person类型的对象）并返回void。请记住，要使用lambda表达式，您需要实现一个功能接口。在这种情况下，您需要一个包含抽象方法的功能接口，该抽象方法可以采用Person类型的一个参数并返回void。 Consumer <T>接口包含具有这些特征的方法void accept（T）。以下方法将使用调用方法accept的Consumer <Person>实例替换调用p.printPerson（）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPersons</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;Person&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;Person&gt; block)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">                block.accept(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，以下方法调用与您在<a href="#approach3">方法3中</a>调用printPersons时相同：在本地类中指定搜索条件代码以获取符合选择性服务资格的成员。 用于打印成员的lambda表达式突出显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">processPersons(</span><br><span class="line">     roster,</span><br><span class="line">     p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">         &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">         &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">     p -&gt; p.printPerson()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果您想对会员个人资料进行更多处理而不是打印出来，该怎么办。 假设您要验证成员的个人资料或检索他们的联系信息？ 在这种情况下，您需要一个功能接口，其中包含一个返回值的抽象方法。 Function <T，R>接口包含方法R apply（T t）。 以下方法检索由参数映射器指定的数据，然后对由参数块指定的数据执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPersonsWithFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;Person&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt;Person, String&gt; mapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;String&gt; block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            String data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下方法从名册中包含有资格使用“选择性服务”的每个成员中检索电子邮件地址，然后进行打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processPersonsWithFunction(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><span id="approach8"></span></p>
<h2 id="方法8：更广泛地使用泛型"><a href="#方法8：更广泛地使用泛型" class="headerlink" title="方法8：更广泛地使用泛型"></a>方法8：更广泛地使用泛型</h2><p>重新考虑方法processPersonsWithFunction。 以下是其通用版本，该通用版本接受包含任何数据类型的元素的集合作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X, Y&gt; <span class="function"><span class="keyword">void</span> <span class="title">processElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Iterable&lt;X&gt; source,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;X&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Function &lt;X, Y&gt; mapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;Y&gt; block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (X p : source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            Y data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要打印符合选择服务资格的成员的电子邮件地址，请按以下方式调用processElements方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processElements(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>此方法调用执行以下操作：</p>
<ol>
<li>从收集源获取对象的源。 在此示例中，它从集合名册中获取Person对象的源。 请注意，集合名册是List类型的集合，也是Iterable类型的对象。</li>
<li>筛选与谓词对象测试器匹配的对象。 在此示例中，谓词对象是一个lambda表达式，用于指定哪些成员符合选择服务的条件。</li>
<li>将每个过滤的对象映射到Function对象映射器指定的值。 在此示例中，Function对象是一个lambda表达式，该表达式返回成员的电子邮件地址。</li>
<li>对使用者对象块指定的每个映射对象执行操作。 在此示例中，Consumer对象是一个lambda表达式，该表达式输出一个字符串，该字符串是Function对象返回的电子邮件地址。</li>
</ol>
<p>您可以将这些操作中的每一个替换为聚合操作。</p>
<p><span id="approach9"></span></p>
<h2 id="方法9：使用接受Lambda表达式作为参数的聚合操作"><a href="#方法9：使用接受Lambda表达式作为参数的聚合操作" class="headerlink" title="方法9：使用接受Lambda表达式作为参数的聚合操作"></a>方法9：使用接受Lambda表达式作为参数的聚合操作</h2><p>下面的示例使用聚合操作来打印集合名册中包含的符合选择性服务资格的那些成员的电子邮件地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(</span><br><span class="line">        p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">            &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">            &amp;&amp; p.getAge() &lt;= <span class="number">25</span>)</span><br><span class="line">    .map(p -&gt; p.getEmailAddress())</span><br><span class="line">    .forEach(email -&gt; System.out.println(email));</span><br></pre></td></tr></table></figure>
<p>下表映射了processElements方法使用相应的聚合操作执行的每个操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>processElements</code> Action</th>
<th>Aggregate Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtain a source of objects</td>
<td><code>Stream&lt;E&gt; **stream**()</code></td>
</tr>
<tr>
<td>Filter objects that match a <code>Predicate</code> object</td>
<td><code>Stream&lt;T&gt; **filter**(Predicate&lt;? super T&gt; predicate)</code></td>
</tr>
<tr>
<td>Map objects to another value as specified by a <code>Function</code> object</td>
<td><code>&lt;R&gt; Stream&lt;R&gt; **map**(Function&lt;? super T,? extends R&gt; mapper)</code></td>
</tr>
<tr>
<td>Perform an action as specified by a <code>Consumer</code> object</td>
<td><code>void **forEach**(Consumer&lt;? super T&gt; action)</code></td>
</tr>
</tbody>
</table>
</div>
<p>操作filter，map和forEach是聚合操作。 聚合操作从流而不是直接从集合中处理元素（这就是在本示例中调用的第一个方法是流的原因）。 流是元素序列。 与集合不同，它不是存储元素的数据结构。 取而代之的是，流通过管道携带来自源（如集合）的值。 流水线是一系列流操作，在此示例中为filtermap-forEach。 此外，聚合操作通常接受lambda表达式作为参数，使您能够自定义它们的行为。</p>
<p>有关聚合操作的更详尽讨论，请参阅<a href="#collections-streams">“聚合操作”</a>课程。</p>
<p><span id="lambda-expressions-in-gui-applications"></span></p>
<h2 id="GUI应用程序中的Lambda表达式"><a href="#GUI应用程序中的Lambda表达式" class="headerlink" title="GUI应用程序中的Lambda表达式"></a>GUI应用程序中的Lambda表达式</h2><p>为了处理图形用户界面（GUI）应用程序中的事件，例如键盘操作，鼠标操作和滚动操作，通常需要创建事件处理程序，这通常涉及实现特定的界面。通常，事件处理程序接口是功能接口。他们往往只有一种方法。</p>
<p>在JavaFX示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">HelloWorld.java</a>（在上一节<a href="#anonymousclasses">“匿名类”</a>中讨论过）中，您可以在此语句中用lambda表达式替换突出显示的匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>方法调用btn.setOnAction指定当您选择由btn对象表示的按钮时发生的情况。此方法需要一个EventHandler <ActionEvent>类型的对象。 EventHandler <ActionEvent>接口仅包含一种方法，即void handle（T event）。此接口是功能性接口，因此您可以使用以下突出显示的lambda表达式来替换它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnAction(</span><br><span class="line">    event -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><span id="syntax"></span></p>
<h2 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h2><p>Lambda表达式包含以下内容：</p>
<ul>
<li>用括号括起来的形式参数的逗号分隔列表。 CheckPerson.test方法包含一个参数p，它表示Person类的实例。</li>
</ul>
<blockquote>
<p>注意：您可以省略lambda表达式中参数的数据类型。此外，如果只有一个参数，则可以省略括号。例如，以下lambda表达式也有效：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt; p.getGender（）== Person.Sex.MALE</span><br><span class="line">    &amp;&amp; p.getAge（）&gt; = <span class="number">18</span></span><br><span class="line">    &amp;&amp; p.getAge（）&lt;= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>箭头标记-&gt;</p>
</li>
<li><p>主体，由单个表达式或语句块组成。本示例使用以下表达式：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.getGender（）== Person.Sex.MALE</span><br><span class="line">    &amp;&amp; p.getAge（）&gt; = <span class="number">18</span></span><br><span class="line">    &amp;&amp; p.getAge（）&lt;= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>如果指定单个表达式，则Java运行时将评估该表达式，然后返回其值。另外，您可以使用return语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return语句不是表达式。在lambda表达式中，必须将语句括在大括号（{}）中。但是，您不必在括号中包含void方法调用。例如，以下是有效的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">email -&gt; System.out.println(email)</span><br></pre></td></tr></table></figure>
<p>注意，lambda表达式看起来很像方法声明。您可以将lambda表达式视为匿名方法，即没有名称的方法。</p>
<p>以下示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/Calculator.java">Calculator</a>是使用多个形式参数的lambda表达式的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">IntegerMath</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;   </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">operateBinary</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, IntegerMath op)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> op.operation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Calculator myApp = <span class="keyword">new</span> Calculator();</span><br><span class="line">        IntegerMath addition = (a, b) -&gt; a + b;</span><br><span class="line">        IntegerMath subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        System.out.println(<span class="string">&quot;40 + 2 = &quot;</span> +</span><br><span class="line">            myApp.operateBinary(<span class="number">40</span>, <span class="number">2</span>, addition));</span><br><span class="line">        System.out.println(<span class="string">&quot;20 - 10 = &quot;</span> +</span><br><span class="line">            myApp.operateBinary(<span class="number">20</span>, <span class="number">10</span>, subtraction));    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>operatorBinary</code>对两个整数操作数执行数学运算。 该操作本身由<code>IntegerMath</code>的实例指定。 该示例使用lambda表达式定义了两个操作：加法和减法。 该示例打印以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">40 + 2 &#x3D; 42</span><br><span class="line">20 - 10 &#x3D; 10</span><br></pre></td></tr></table></figure>
<p><span id="accessing-local-variables"></span></p>
<h2 id="访问封闭范围的局部变量"><a href="#访问封闭范围的局部变量" class="headerlink" title="访问封闭范围的局部变量"></a>访问封闭范围的局部变量</h2><p>像本地和匿名类一样，lambda表达式可以<a href="#local-classes-accessing-members-of-an-enclosing-class">捕获变量</a>。 它们对封闭范围的局部变量具有相同的访问权限。 但是，与本地和匿名类不同，lambda表达式没有任何阴影问题（有关更多信息，请参见<a href="#shadowing">阴影</a>）。 Lambda表达式具有词法范围。 这意味着它们不会从超类型继承任何名称，也不会引入新的作用域范围。 解释lambda表达式中的声明就像在封闭环境中一样。 以下示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/LambdaScopeTest.java">LambdaScopeTest</a>演示了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaScopeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// The following statement causes the compiler to generate</span></span><br><span class="line">            <span class="comment">// the error &quot;local variables referenced from a lambda expression</span></span><br><span class="line">            <span class="comment">// must be final or effectively final&quot; in statement A:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// x = 99;</span></span><br><span class="line">            </span><br><span class="line">            Consumer&lt;Integer&gt; myConsumer = (y) -&gt; </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// Statement A</span></span><br><span class="line">                System.out.println(<span class="string">&quot;y = &quot;</span> + y);</span><br><span class="line">                System.out.println(<span class="string">&quot;this.x = &quot;</span> + <span class="keyword">this</span>.x);</span><br><span class="line">                System.out.println(<span class="string">&quot;LambdaScopeTest.this.x = &quot;</span> +</span><br><span class="line">                    LambdaScopeTest.<span class="keyword">this</span>.x);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            myConsumer.accept(x);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        LambdaScopeTest st = <span class="keyword">new</span> LambdaScopeTest();</span><br><span class="line">        LambdaScopeTest.FirstLevel fl = st.<span class="function">new <span class="title">FirstLevel</span><span class="params">()</span></span>;</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子生成的输出打印:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">23</span></span><br><span class="line">y = <span class="number">23</span></span><br><span class="line"><span class="keyword">this</span>.x = <span class="number">1</span></span><br><span class="line">LambdaScopeTest.<span class="keyword">this</span>.x = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>如果在lambda表达式<code>myConsumer</code>的声明中用参数x代替y，则编译器将生成错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Integer&gt; myConsumer = (x) -&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会生成错误“方法x中已经定义了变量x，因为<code>methodInFirstLevel(int)</code>已定义”，因为lambda表达式未引入新的作用域范围。因此，您可以直接访问封闭范围的字段，方法和局部变量。例如，lambda表达式直接访问方法methodInFirstLevel的参数x。要访问封闭类中的变量，请使用关键字<code>this</code>。在此示例中，<code>this.x</code>引用成员变量<code>FirstLevel.x</code>。</p>
<p>但是，与本地和匿名类一样，lambda表达式只能访问最终或有效最终的封闭块的局部变量和参数。例如，假设您在methodInFirstLevel定义语句之后立即添加以下赋值语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> methodInFirstLevel（<span class="keyword">int</span> x）&#123;</span><br><span class="line">    x = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于该赋值语句，变量<code>FirstLevel.x</code>不再有效地变为final。结果，Java编译器生成一条错误消息，类似于“从lambda表达式引用的本地变量必须是final或有效地是final”，其中lambda表达式<code>myConsumer</code>尝试访问<code>FirstLevel.x</code>变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br></pre></td></tr></table></figure>
<p><span id="target-typing"></span></p>
<h2 id="目标类型"><a href="#目标类型" class="headerlink" title="目标类型"></a>目标类型</h2><p>您如何确定Lambda表达式的类型？回忆一下选择了男性且年龄在18至25岁之间的成员的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt; p.getGender（）== Person.Sex.MALE</span><br><span class="line">    &amp;&amp; p.getAge（）&gt; = <span class="number">18</span></span><br><span class="line">    &amp;&amp; p.getAge（）&lt;= <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p>此lambda表达式用于以下两种方法：</p>
<ul>
<li><p><a href="#approach3">方法3</a>中的在本地类中指定搜索条件代码：<code>public static void printPersons(List&lt;Person&gt; roster, CheckPerson tester)</code></p>
</li>
<li><p><a href="#approach6">方法6</a>：使用带有Lambda表达式的标准功能接口的<code>public void printPersonsWithPredicate(List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</code></p>
</li>
</ul>
<p>当Java运行时调用方法printPersons时，它期望的数据类型为<code>CheckPerson</code>，因此lambda表达式就是这种类型。但是，当Java运行时调用方法<code>printPersonsWithPredicate</code>时，期望的数据类型为<code>Predicate&lt;Person&gt;</code>，因此lambda表达式就是这种类型。这些方法期望的数据类型称为目标类型。为了确定lambda表达式的类型，Java编译器使用找到lambda表达式的上下文或情况的目标类型。因此，您只能在Java编译器可以确定目标类型的情况下使用lambda表达式：</p>
<ul>
<li><p>变量声明</p>
</li>
<li><p>作业</p>
</li>
<li><p>退货声明</p>
</li>
<li><p>数组初始化器</p>
</li>
<li><p>方法或构造函数参数</p>
</li>
<li><p>Lambda表达体</p>
</li>
<li><p>条件表达式，？：</p>
</li>
<li><p>转换表达式</p>
</li>
</ul>
<p><span id="target-types-and-method-arguments"></span></p>
<h2 id="目标类型和方法参数"><a href="#目标类型和方法参数" class="headerlink" title="目标类型和方法参数"></a>目标类型和方法参数</h2><p>对于方法参数，Java编译器使用其他两种语言功能确定目标类型：重载解析和类型参数推断。</p>
<p>考虑以下两个功能接口（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">java.lang.Runnable</a>和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html">java.util.concurrent.Callable <V></a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法<code>Runnable.run</code>不返回值，而<code>Callable&lt;V&gt; .call</code>则返回值。</p>
<p>假设您已按以下方式重载了方法调用（有关重载方法的更多信息，请参见定义方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invoke</span><span class="params">(Callable&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下语句将调用哪种方法？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = invoke(() -&gt; <span class="string">&quot;done&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将调用<code>invoke(Callable&lt;T&gt;)</code>方法，因为该方法返回一个值。方法<code>invoke(Runnable)</code>则没有。在这种情况下，lambda表达式（）-&gt;“ done”的类型为<code>Callable &lt;T&gt;</code>。</p>
<p><span id="serialization"></span></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>如果lambda表达式的目标类型和捕获的参数可<a href="#serial">序列化</a>，则可以对其进行序列化。但是，像<a href="#nested-serialization">内部类</a>一样，强烈建议不要对lambda表达式进行序列化。</p>
<p><span id="methodreferences"></span></p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>您使用lambda表达式创建匿名方法。 但是，有时lambda表达式除了调用现有方法外什么也不做。 在这种情况下，通常更容易按名称引用现有方法。 方法引用使您可以执行此操作； 它们是紧凑的，易于阅读的<a href="#lambda-expression">lambda表达式</a>，用于已经具有名称的方法。</p>
<p>再次考虑Lambda表达式部分中讨论的Person类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    LocalDate birthday;</span><br><span class="line">    Sex gender;</span><br><span class="line">    String emailAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calendar <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByAge</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.birthday.compareTo(b.birthday);</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>假设您的社交网络应用程序的成员包含在一个数组中，并且您想按年龄对数组进行排序。您可以使用以下代码（在示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/MethodReferencesTest.java">MethodReferencesTest</a>示例中找到本节中描述的代码摘录）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person[] rosterAsArray = roster.toArray(<span class="keyword">new</span> Person[roster.size()]);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonAgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getBirthday().compareTo(b.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">Arrays.sort(rosterAsArray, <span class="keyword">new</span> PersonAgeComparator());</span><br></pre></td></tr></table></figure>
<p>这种调用的方法签名如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></span><br></pre></td></tr></table></figure>
<p>请注意，接口<code>Comparator</code>是功能接口。因此，可以使用lambda表达式来代替定义然后创建实现<code>Comparator</code>的类的新实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(rosterAsArray,</span><br><span class="line">    (Person a, Person b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a.getBirthday().compareTo(b.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>但是，这种用于比较两个Person实例的出生日期的方法已经作为Person.compareByAge存在。您可以改为在lambda表达式的主体中调用此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(rosterAsArray,</span><br><span class="line">    (a, b) -&gt; Person.compareByAge(a, b)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>由于此lambda表达式调用现有方法，因此可以使用方法引用代替lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(rosterAsArray, Person::compareByAge);</span><br></pre></td></tr></table></figure>
<p>方法引用<code>Person :: compareByAge</code>在语义上与lambda表达式<code>（a，b）-&gt; Person.compareByAge（a，b）</code>相同。每个都有以下特征：</p>
<ul>
<li>它的形式参数列表是从Comparator <Person> .compare复制的，该文件是（Person，Person）。</li>
<li>它的主体调用方法Person.compareByAge。</li>
</ul>
<p><span id="kinds-of-method-references"></span></p>
<h3 id="方法引用的种类"><a href="#方法引用的种类" class="headerlink" title="方法引用的种类"></a>方法引用的种类</h3><p>有4种方法引用:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Kind</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reference to a static method</td>
<td><code>ContainingClass::staticMethodName</code></td>
</tr>
<tr>
<td>Reference to an instance method of a particular object</td>
<td><code>containingObject::instanceMethodName</code></td>
</tr>
<tr>
<td>Reference to an instance method of an arbitrary object of a particular type</td>
<td><code>ContainingType::methodName</code></td>
</tr>
<tr>
<td>Reference to a constructor</td>
<td><code>ClassName::new</code></td>
</tr>
</tbody>
</table>
</div>
<p><span id="references-static-method"></span></p>
<h4 id="静态方法引用"><a href="#静态方法引用" class="headerlink" title="静态方法引用"></a>静态方法引用</h4><p>方法引用<code>Person :: compareByAge</code>是对静态方法的引用。</p>
<p><span id="references-instance-method-po"></span></p>
<h4 id="引用特定对象的实例方法"><a href="#引用特定对象的实例方法" class="headerlink" title="引用特定对象的实例方法"></a>引用特定对象的实例方法</h4><p>以下是对特定对象的实例方法的引用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparisonProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByName</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByAge</span><span class="params">(Person a, Person b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.getBirthday().compareTo(b.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ComparisonProvider myComparisonProvider = <span class="keyword">new</span> ComparisonProvider();</span><br><span class="line">Arrays.sort(rosterAsArray, myComparisonProvider::compareByName);</span><br></pre></td></tr></table></figure>
<p>方法引用myComparisonProvider :: compareByName调用方法compareByName，它是对象myComparisonProvider的一部分。 JRE推断方法类型参数，在这种情况下为（Person，Person）。</p>
<p><span id="references-instance-method-aopt"></span></p>
<p>以下是对特定类型的任意对象的实例方法的引用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">&quot;Barbara&quot;</span>, <span class="string">&quot;James&quot;</span>, <span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;John&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Patricia&quot;</span>, <span class="string">&quot;Robert&quot;</span>, <span class="string">&quot;Michael&quot;</span>, <span class="string">&quot;Linda&quot;</span> &#125;;</span><br><span class="line">Arrays.sort(stringArray, String::compareToIgnoreCase);</span><br></pre></td></tr></table></figure>
<p>方法参考String :: compareToIgnoreCase的等效lambda表达式将具有形式参数列表（字符串a，字符串b），其中a和b是用于更好地描述此示例的任意名称。 方法引用将调用方法a.compareToIgnoreCase（b）。</p>
<p><span id="references-constructor"></span></p>
<h4 id="构造方法引用"><a href="#构造方法引用" class="headerlink" title="构造方法引用"></a>构造方法引用</h4><p>您可以使用名称new来引用与静态方法相同的方法来引用构造函数。以下方法将元素从一个集合复制到另一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, SOURCE extends Collection&lt;T&gt;, DEST extends Collection&lt;T&gt;&gt;</span><br><span class="line">    <span class="function">DEST <span class="title">transferElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        SOURCE sourceCollection,</span></span></span><br><span class="line"><span class="function"><span class="params">        Supplier&lt;DEST&gt; collectionFactory)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        DEST result = collectionFactory.get();</span><br><span class="line">        <span class="keyword">for</span> (T t : sourceCollection) &#123;</span><br><span class="line">            result.add(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能接口Supplier包含一个方法get，该方法不带任何参数并返回一个对象。因此，您可以使用lambda表达式调用方法transferElements，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; rosterSetLambda =</span><br><span class="line">    transferElements(roster, () -&gt; &#123; <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(); &#125;);</span><br></pre></td></tr></table></figure>
<p>您可以使用构造函数引用代替lambda表达式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p>Java编译器推断您要创建一个HashSet集合，其中包含Person类型的元素。另外，您可以指定如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Person&gt; rosterSet = transferElements(roster, HashSet&lt;Person&gt;::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>
<p><span id="collections-streams"></span></p>
<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><p>注意：为了更好地理解本节中的概念，请查看“ <a href="#lambda-expression">Lambda表达式</a>和<a href="#methodreferences">方法参考</a>”部分。</p>
<p>您使用什么集合？您不只是将对象存储在集合中并留在其中。在大多数情况下，您可以使用集合来检索存储在其中的项目。</p>
<p>再次考虑Lambda表达式部分中描述的方案。假设您正在创建一个社交网络应用程序。您想创建一个功能，使管理员可以对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。</p>
<p>和以前一样，假定此社交网络应用程序的成员由以下<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/Person.java">Person</a>类表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    LocalDate birthday;</span><br><span class="line">    Sex gender;</span><br><span class="line">    String emailAddress;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例通过for-each循环打印集合名册中包含的所有成员的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">    System.out.println(p.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示集合名册中包含但具有聚合操作forEach的所有成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName());</span><br></pre></td></tr></table></figure>
<p>尽管在此示例中，使用聚合操作的版本比使用for-each循环的版本长，但是您将看到使用批量数据操作的版本对于更复杂的任务将更加简洁。</p>
<p>涵盖以下主题：</p>
<ul>
<li><a href="#collections-streams-pipelines">管道和流</a></li>
<li><a href="#collections-streams-differences">集合操作和迭代器之间的差异</a></li>
</ul>
<p>在示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/BulkDataOperationsExamples.java">BulkDataOperationsExamples</a>中找到本节中描述的代码摘录。</p>
<p><span id="collections-streams-pipelines"></span></p>
<p>管道和流<br>管道是一系列聚合操作。下面的示例使用包含聚合操作过滤器和forEach的管道来打印集合列表中包含的公成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(e -&gt; e.getGender() == Person.Sex.MALE)</span><br><span class="line">    .forEach(e -&gt; System.out.println(e.getName()));</span><br></pre></td></tr></table></figure>
<p>将此示例与以下示例进行比较，该示例将使用for-each循环打印集合名册中包含的公成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管道包含以下组件：</p>
<ul>
<li><p>源：可以是集合，数组，生成器函数或I / O通道。在此示例中，源是集合名册。</p>
</li>
<li><p>零个或多个中间操作。诸如过滤器之类的中间操作产生新的流。</p>
<p>流是元素序列。与集合不同，它不是存储元素的数据结构。相反，流通过管道从源携带值。本示例通过调用方法流从集合名册创建流。</p>
<p>筛选器操作返回一个新流，该流包含与其谓词相匹配的元素（此操作的参数）。在此示例中，谓词是lambda表达式<code>e-&gt; e.getGender（）== Person.Sex.MALE</code>。如果对象e的性别字段的值为<code>Person.Sex.MALE</code>，则返回布尔值true。因此，此示例中的筛选操作返回一个流，其中包含集合花名册中的所有公成员。</p>
</li>
<li><p>终端操作。终端操作（例如forEach）会产生非流结果，例如原始值（如double值），集合，或者在forEach的情况下根本没有任何结果。在此示例中，forEach操作的参数是lambda表达式<code>e-&gt; System.out.println（e.getName（））</code>，该表达式在对象e上调用方法<code>getName</code>。 （Java运行时和编译器推断对象e的类型为Person。）</p>
</li>
</ul>
<p>下面的示例使用包含聚合操作<code>filter</code>，<code>mapToInt</code>和<code>average</code>的管道来计算集合名册中包含的所有男性成员的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
<p><code>mapToInt</code>操作将返回一个新的IntStream类型的流（该流仅包含整数值）。该操作将其参数中指定的功能应用于特定流中的每个元素。在此示例中，函数是<code>Person :: getAge</code>，这是一个返回成员年龄的方法引用。 （或者，您可以使用lambda表达式<code>e-&gt; e.getAge（）</code>。）因此，本示例中的<code>mapToInt</code>操作返回一个流，其中包含集合名册中所有男性成员的年龄。</p>
<p>平均操作将计算IntStream类型的流中包含的元素的平均值。它返回类型为<code>OptionalDouble</code>的对象。如果流不包含任何元素，则平均操作将返回<code>OptionalDouble</code>的空实例，并且调用方法<code>getAsDouble</code>会引发<code>NoSuchElementException</code>。 JDK包含许多终端操作，例如平均值，它们通过组合流的内容返回一个值。这些操作称为归约操作。有关更多信息，请参见<a href="#collections-streams-reduction">Reduction</a>部分。</p>
<p><span id="Differences-ggregate-Operations-and-Iterators"></span></p>
<p><strong>集合操作和迭代器之间的差异</strong><br>聚合操作（例如forEach）似乎像迭代器。但是，它们有几个基本差异：</p>
<ul>
<li><p>它们使用内部迭代：聚合操作不包含诸如next的方法来指示它们处理集合的下一个元素。使用内部委派，您的应用程序确定要迭代的集合，而JDK确定如何迭代该集合。通过外部迭代，您的应用程序可以确定迭代哪个集合以及如何迭代。但是，外部迭代只能顺序地迭代集合的元素。内部迭代没有此限制。它可以更轻松地利用并行计算的优势，这涉及将一个问题分解为多个子问题，同时解决这些问题，然后将这些解决方案的结果组合为子问题。有关更多信息，请参见<a href="#collections-streams-parallelism">并行性</a>一节。</p>
</li>
<li><p>它们处理流中的元素：聚合操作从流中而不是直接从集合中处理元素。因此，它们也称为流操作。</p>
</li>
<li><p>它们支持将行为作为参数：您可以将lambda表达式指定为大多数聚合操作的参数。这使您可以自定义特定聚合操作的行为。</p>
</li>
</ul>
<p><span id="collections-streams-reduction"></span></p>
<h2 id="Reduction"><a href="#Reduction" class="headerlink" title="Reduction"></a>Reduction</h2><p><a href="#collections-streams">“汇总操作”</a>部分描述了以下操作流程，该操作流程计算了收集名单中所有男性成员的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
<p>JDK包含许多终端操作（例如<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#average--java/lang/reflect/Executable.html">平均值</a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--">总和</a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#min-java.util.Comparator-">最小值</a>，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#max-java.util.Comparator-">最大值</a>和<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#count--">计数</a>），这些操作通过组合流的内容来返回一个值。这些操作称为归约操作。 JDK还包含归约操作，这些操作返回集合而不是单个值。许多归约运算执行特定任务，例如查找值的平均值或将元素分组为类别。但是，JDK为您提供了通用的减少和收集操作，本节将对此进行详细介绍。</p>
<p>本节涵盖以下主题：</p>
<ul>
<li><a href="#collections-streams-reduce">The Stream.reduce Method</a></li>
<li><a href="#collections-streams-collect">The Stream.collect Method</a></li>
</ul>
<p>您可以在示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/ReductionExamples.java">ReductionExamples</a>中找到本节中描述的代码摘录。</p>
<p><span id="collections-streams-reduce"></span></p>
<p><strong>Stream.reduce方法</strong><br><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#reduce-T-java.util.function.BinaryOperator-">Stream.reduce</a>方法是通用的约简操作。考虑以下管道，该管道计算集合名册中男性成员的年龄总和。它使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/IntStream.html#sum--">Stream.sum</a>减少操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer totalAge = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure>
<p>将其与以下管道进行比较，该管道使用Stream.reduce操作计算相同的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer totalAgeReduce = roster</span><br><span class="line">   .stream()</span><br><span class="line">   .map(Person::getAge)</span><br><span class="line">   .reduce(</span><br><span class="line">       <span class="number">0</span>,</span><br><span class="line">       (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure>
<p>本示例中的reduce操作采用两个参数：</p>
<ul>
<li><p>identity：如果流中没有元素，则identity元素既是reduce的初始值，也是默认结果。在此示例中，标识元素为0；这是年龄总和的初始值，如果集合名册中不存在成员，则为默认值。</p>
</li>
<li><p>accumulator：累加器函数有两个参数：约简的部分结果（在此示例中，是到目前为止所有已处理整数的总和）和流的下一个元素（在此示例中，是整数）。它返回一个新的部分结果。在此示例中，accumulator函数是一个lambda表达式，该表达式将两个Integer值相加并返回一个Integer值：</p>
<p>（a，b）-&gt; a + b</p>
</li>
</ul>
<p>reduce操作始终返回新值。但是，累加器函数每次处理流的元素时也会返回一个新值。假设您希望将流的元素简化为一个更复杂的对象，例如集合。这可能会妨碍您的应用程序的性能。如果您的reduce操作涉及将元素添加到集合中，那么每次累加器函数处理一个元素时，它都会创建一个包含该元素的新集合，这效率很低。相反，对您而言，更新现有集合会更有效。您可以使用下一节介绍的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-">Stream.collect</a>方法来执行此操作。</p>
<p><span id="collections-streams-collect"></span></p>
<p><strong>Stream.collect方法</strong></p>
<p>与reduce方法（在处理元素时总是会创建新值）不同，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#collect-java.util.function.Supplier-java.util.function.BiConsumer-java.util.function.BiConsumer-">collect</a>方法会修改或变异现有值。</p>
<p>考虑如何查找流中的平均值。您需要两个数据：值的总数和这些值的总和。但是，像reduce方法和所有其他reduce方法一样，collect方法仅返回一个值。您可以创建一个包含成员变量的新数据类型，该成员变量跟踪值的总数和这些值的总和，例如以下类<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/collections/streams/examples/Averager.java">Averager</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span> <span class="keyword">implements</span> <span class="title">IntConsumer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">average</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count &gt; <span class="number">0</span> ? ((<span class="keyword">double</span>) total)/count : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; total += i; count++; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">combine</span><span class="params">(Averager other)</span> </span>&#123;</span><br><span class="line">        total += other.total;</span><br><span class="line">        count += other.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下管道使用<code>Averager</code>类和<code>collect</code>方法来计算所有男性成员的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Averager averageCollect = roster.stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .map(Person::getAge)</span><br><span class="line">    .collect(Averager::<span class="keyword">new</span>, Averager::accept, Averager::combine);</span><br><span class="line">                   </span><br><span class="line">System.out.println(<span class="string">&quot;Average age of male members: &quot;</span> +</span><br><span class="line">    averageCollect.average());</span><br></pre></td></tr></table></figure>
<p>在此示例中，<code>collect</code>操作采用三个参数：</p>
<ul>
<li>supplier：supplier是工厂的职能；它构造了新的实例。对于收集操作，它将创建结果容器的实例。在此示例中，它是Averager类的新实例。</li>
<li>accumulator：累加器功能将流元素合并到结果容器中。在此示例中，它通过将计数变量加1并将流元素的值添加到总成员变量中来修改<code>Averager</code>结果容器，该流元素的值是代表男性成员年龄的整数。</li>
<li>combiner：组合器函数采用两个结果容器并将其内容合并。在此示例中，它通过将另一个Variabler实例的count成员变量递增count变量，并将另一个<code>Averager</code>实例的total成员变量的值添加到total成员变量，来修改<code>Averager</code>结果容器。</li>
</ul>
<p>请注意以下几点：</p>
<ul>
<li>供应商是lambda表达式（或方法引用），与reduce操作中类似于identity元素的值相反。</li>
<li>累加器和合并器函数不返回值。</li>
<li>您可以对并行流使用收集操作；有关更多信息，请参见<a href="#collections-streams-parallelism">并行性</a>一节。 （如果使用并行流运行collect方法，那么只要组合器函数创建新对象（例如本示例中的Averager对象），JDK就会创建一个新线程。因此，您不必担心同步。）</li>
</ul>
<p>尽管JDK为您提供了平均值操作来计算流中元素的平均值，但是如果需要从流元素中计算多个值，则可以使用collect操作和自定义类。</p>
<p>收集操作最适合收集。下面的示例通过collect操作将男性成员的姓名放入一个集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesOfMaleMembersCollect = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .map(p -&gt; p.getName())</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>此版本的collect操作采用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.html">Collector</a>类型的一个参数。此类封装用作需要三个参数（供应商，累加器和组合器函数）的collect操作中用作参数的函数。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html">Collector</a>类包含许多有用的归约运算，例如将元素累积到集合中并根据各种标准对元素进行汇总。这些归约操作将返回类Collector的实例，因此您可以将它们用作收集操作的参数。</p>
<p>本示例使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toList--">Collectors.toList</a>操作，该操作将流元素累积到List的新实例中。与<code>Collectors</code>类中的大多数操作一样，<code>toList</code>运算符返回<code>Collector</code>的实例，而不是<code>List</code>。</p>
<p>以下示例按性别对集合名册的成员进行分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(Person::getGender));</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingBy-java.util.function.Function-">groupingBy</a>操作返回一个映射，该映射的键是应用指定为其参数的lambda表达式（称为分类函数）而得到的值。在此示例中，返回的映射包含两个键：<code>Person.Sex.MALE</code>和<code>Person.Sex.FEMALE</code>。这两个键的对应值是List的实例，这些实例包含流元素，这些流元素在由分类功能处理时对应于键值。例如，与键<code>Person.Sex.MALE</code>对应的值是包含所有男性成员的List的实例。</p>
<p>以下示例检索集合名册中每个成员的名称，并按性别将其分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;String&gt;&gt; namesByGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(</span><br><span class="line">                Person::getGender,                      </span><br><span class="line">                Collectors.mapping(</span><br><span class="line">                    Person::getName,</span><br><span class="line">                    Collectors.toList())));</span><br></pre></td></tr></table></figure>
<p>本示例中的groupingBy操作采用两个参数，一个分类函数和一个Collector实例。 Collector参数称为下游收集器。这是一个收集器，Java运行时将其应用于另一个收集器的结果。因此，此groupingBy操作使您可以将collect方法应用于groupingBy运算符创建的List值。本示例应用收集器映射，该映射器将映射函数Person :: getName应用于流的每个元素。因此，结果流仅包含成员名称。像此示例一样，包含一个或多个下游收集器的管道称为多级归约。</p>
<p>以下示例检索每个性别成员的总年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, Integer&gt; totalAgeByGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(</span><br><span class="line">                Person::getGender,                      </span><br><span class="line">                Collectors.reducing(</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    Person::getAge,</span><br><span class="line">                    Integer::sum)));</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#reducing-U-java.util.function.Function-java.util.function.BinaryOperator-">reducing</a>运算采用三个参数：</p>
<ul>
<li>identity：与Stream.reduce操作一样，如果流中没有元素，则identity元素既是reduce的初始值，也是默认结果。在此示例中，标识元素为0；这是年龄总和的初始值，如果不存在成员，则为默认值。</li>
<li>mapper：缩减操作将此映射器功能应用于所有流元素。在此示例中，映射器检索每个成员的年龄。</li>
<li>operation：操作功能用于减少映射的值。在此示例中，操作函数将添加整数值。</li>
</ul>
<p>以下示例检索每种性别的成员的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, Double&gt; averageAgeByGender = roster</span><br><span class="line">    .stream()</span><br><span class="line">    .collect(</span><br><span class="line">        Collectors.groupingBy(</span><br><span class="line">            Person::getGender,                      </span><br><span class="line">            Collectors.averagingInt(Person::getAge)));</span><br></pre></td></tr></table></figure>
<p><span id="collections-streams-parallelism"></span></p>
<h2 id="Parallelism"><a href="#Parallelism" class="headerlink" title="Parallelism"></a>Parallelism</h2><p>并行计算包括将一个问题分为多个子问题，同时解决这些问题（并行处理，每个子问题都在单独的线程中运行），然后将解决方案的结果组合到子问题中。 Java SE提供了<a href="#essential-concurrency-forkjoin">fork/join框架</a>，使您能够更轻松地在应用程序中实现并行计算。但是，在此框架下，您必须指定如何细分（划分）问题。通过聚合操作，Java运行时将为您执行此分区和解决方案合并。</p>
<p>在使用集合的应用程序中实现并行性的一个困难是集合不是线程安全的，这意味着多个线程在不引入<a href="#essential-concurrency-interfere">线程干扰</a>或<a href="#essential-concurrency-memconsist">内存一致性错误</a>的情况下无法操纵集合。 Collections Framework提供了<a href="#collections-implementations-wrapper">同步包装器</a>，该包装器将自动同步添加到任意集合中，使其成为线程安全的。但是，同步会引入线程争用。您要避免线程争用，因为这会阻止线程并行运行。聚合操作和并行流使您能够使用非线程安全的集合实现并行性，前提是您在操作集合时不修改集合。</p>
<p>请注意，并行性并不会比串行执行操作自动地更快，但是如果您具有足够的数据和处理器核心，并行性可能会更快。虽然聚合操作使您可以更轻松地实现并行性，但是确定应用程序是否适合并行性仍然是您的责任。</p>
<p>本节涵盖以下主题：</p>
<ul>
<li><a href="#executing_streams_in_parallel">并行执行流</a></li>
<li><a href="#concurrent_reduction">并发减少</a></li>
<li><a href="#collections-streams-parallelism-ordering">Ordering</a></li>
<li><a href="#collections-streams-parallelism-side_effects">副作用</a><ul>
<li><a href="#collections-streams-parallelism-laziness">懒惰</a></li>
<li><a href="#collections-streams-parallelism-interference">干扰</a></li>
<li><a href="#collections-streams-parallelism-stateful_lambda_expressions">有状态Lambda表达式</a></li>
</ul>
</li>
</ul>
<p>您可以在示例ParallelismExamples中找到本节中描述的代码摘录。</p>
<p><span id="executing_streams_in_parallel"></span></p>
<p><strong>并行执行流</strong><br>您可以串行或并行执行流。 当流并行执行时，Java运行时将流划分为多个子流。 聚合操作迭代并并行处理这些子流，然后合并结果。</p>
<p>创建流时，除非另有说明，否则它始终是串行流。 要创建并行流，请调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--">Collection.parallelStream</a>操作。 或者，调用操作<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#parallel--">BaseStream.parallel</a>。 例如，以下语句并行计算所有男性成员的平均年龄：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> average = roster</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .filter(p -&gt; p.getGender() == Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
<p><span id="concurrent_reduction"></span></p>
<p><strong>并发减少</strong><br>再次考虑以下示例（在<a href="#collections-streams-reduction">“减少”</a>部分中进行了描述），该示例按性别对成员进行分组。此示例调用collect操作，该操作将收集名册简化为Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .stream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingBy(Person::getGender));</span><br></pre></td></tr></table></figure>
<p>以下是并行等效项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentMap&lt;Person.Sex, List&lt;Person&gt;&gt; byGender =</span><br><span class="line">    roster</span><br><span class="line">        .parallelStream()</span><br><span class="line">        .collect(</span><br><span class="line">            Collectors.groupingByConcurrent(Person::getGender));</span><br></pre></td></tr></table></figure>
<p>这称为并发减少。如果满足以下所有条件的特定管道包含收集操作，则Java运行时将执行并发缩减：</p>
<ul>
<li>流是并行的。</li>
<li>收集操作的参数收集器具有特征<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#CONCURRENT">Collector.Characteristics.CONCURRENT</a>。要确定收集器的特征，请调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html">Collector.characteristics</a>方法。</li>
<li>流是无序的，或者收集器具有特征<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collector.Characteristics.html#UNORDERED">Collector.Characteristics.UNORDERED</a>。为确保流是无序的，请调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#unordered--">BaseStream.unordered</a>操作。</li>
</ul>
<p>注意：此示例返回<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentMap.html">ConcurrentMap</a>的实例而不是Map，并调用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-">groupingByConcurrent</a>操作而不是<code>groupingBy</code>。 （有关ConcurrentMap的更多信息，请参见<a href="#essential-concurrency-collections">并发集合</a>部分。）与操作<code>groupingByConcurrent</code>不同，操作groupingBy在并行流中的性能较差。 （这是因为它通过按键合并两个映射进行操作，这在计算上是昂贵的。）类似地，与并行流相比，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toConcurrentMap-java.util.function.Function-java.util.function.Function-">Collectors.toConcurrentMap</a>操作的性能要好于<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Collectors.html#toMap-java.util.function.Function-java.util.function.Function-">Collectors.toMap</a>操作。</p>
<p><span id="collections-streams-parallelism-ordering"></span></p>
<p><strong>Ordering</strong></p>
<p>管道处理流元素的顺序取决于流是串行还是并行执行，流的源以及中间操作。 例如，考虑以下示例，该示例使用forEach操作多次打印ArrayList实例的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Integer[] intArray = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; listOfIntegers =</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(intArray));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;listOfIntegers:&quot;</span>);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;listOfIntegers sorted in reverse order:&quot;</span>);</span><br><span class="line">Comparator&lt;Integer&gt; normal = Integer::compare;</span><br><span class="line">Comparator&lt;Integer&gt; reversed = normal.reversed(); </span><br><span class="line">Collections.sort(listOfIntegers, reversed);  </span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     </span><br><span class="line">System.out.println(<span class="string">&quot;Parallel stream&quot;</span>);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">System.out.println(<span class="string">&quot;Another parallel stream:&quot;</span>);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEach(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     </span><br><span class="line">System.out.println(<span class="string">&quot;With forEachOrdered:&quot;</span>);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>此示例包含五个管道。它输出类似于以下内容的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">listOfIntegers:</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">listOfIntegers sorted <span class="keyword">in</span> reverse order:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">Parallel stream:</span><br><span class="line">3 4 1 6 2 5 7 8</span><br><span class="line">Another parallel stream:</span><br><span class="line">6 3 1 5 7 8 4 2</span><br><span class="line">With forEachOrdered:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>
<p>此示例执行以下操作：</p>
<ul>
<li>第一个管道按添加到列表中的顺序打印列表listOfIntegers的元素。</li>
<li>第二个管道将打印listOfIntegers的元素，在使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-">Collections.sort</a>方法对listOfIntegers进行排序之后。。</li>
<li>第三和第四管道以明显随机的顺序打印列表的元素。请记住，在处理流元素时，流操作使用内部迭代。因此，在并行执行流时，除非由流操作另行指定，否则Java编译器和运行时将确定处理流元素的顺序，以最大程度地发挥并行计算的优势。</li>
<li>第五条管道使用<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#forEachOrdered-java.util.function.Consumer-">forEachOrdered</a>方法，该方法以其源指定的顺序处理流的元素，而不管您是以串行还是并行方式执行该流。请注意，如果对并行流使用诸如forEachOrdered之类的操作，则可能会失去并行性的好处。</li>
</ul>
<p><span id="collections-streams-parallelism-side_effects"></span></p>
<p><strong>副作用</strong></p>
<p>如果方法或表达式除了返回或产生值之外还修改了计算机的状态，则它具有副作用。示例包括可变的约简（使用collect操作的约简；有关更多信息，请参见<a href="#collections-streams-reduction">“约简”</a>部分），以及调用<code>System.out.println</code>方法进行调试。 JDK很好地处理了管道中的某些副作用。特别是，collect方法设计为以并行安全的方式执行具有副作用的最常见的流操作。 forEach和peek等操作旨在解决副作用；一个返回void的lambda表达式（例如，调用System.out.println的表达式）只能产生副作用。即使这样，您也应谨慎使用forEach和peek操作；如果将这些操作之一与并行流一起使用，则Java运行时可能会从多个线程同时调用指定为其参数的lambda表达式。此外，切勿将在过滤器和映射等操作中具有副作用的lambda表达式作为参数传递。以下各节讨论了<a href="#collections-streams-parallelism-interference">干扰</a>和<a href="#collections-streams-parallelism-stateful_lambda_expressions">有状态的lambda表达式</a>，这两者都是副作用的来源，并且可能返回不一致或不可预测的结果，尤其是在并行流中。但是，首先讨论<a href="#collections-streams-parallelism-laziness">懒惰</a>的概念，因为它会直接影响干扰。</p>
<p><span id="collections-streams-parallelism-laziness"></span></p>
<p><strong>懒惰</strong></p>
<p>所有中间操作都是惰性的。如果仅在需要时才求值，则表达式，方法或算法是惰性的。 （如果算法需要立即评估或处理，则非常渴望。）中间操作是延迟的，因为它们直到终端操作开始才开始处理流的内容。延迟处理流使Java编译器和运行时能够优化它们如何处理流。例如，在诸如<a href="#collections-streams">“聚合操作”</a>部分中描述的filter-mapToInt-average示例之类的管道中，平均值操作可以从mapToInt操作创建的流中获取前几个整数，后者从filter操作中获取元素。平均操作将重复此过程，直到从流中获取所有必需的元素，然后再计算平均值。</p>
<p><span id="collections-streams-parallelism-interference"></span></p>
<p><strong>干扰</strong></p>
<p>流操作中的Lambda表达式不应产生干扰。在管道处理流时修改流的源时会发生干扰。例如，以下代码尝试连接列表ListOfStrings中包含的字符串。但是，它将引发ConcurrentModificationException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    List&lt;String&gt; listOfStrings =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>));</span><br><span class="line">         </span><br><span class="line">    <span class="comment">// This will fail as the peek operation will attempt to add the</span></span><br><span class="line">    <span class="comment">// string &quot;three&quot; to the source after the terminal operation has</span></span><br><span class="line">    <span class="comment">// commenced. </span></span><br><span class="line">             </span><br><span class="line">    String concatenatedString = listOfStrings</span><br><span class="line">        .stream()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Don&#x27;t do this! Interference occurs here.</span></span><br><span class="line">        .peek(s -&gt; listOfStrings.add(<span class="string">&quot;three&quot;</span>))</span><br><span class="line">        </span><br><span class="line">        .reduce((a, b) -&gt; a + <span class="string">&quot; &quot;</span> + b)</span><br><span class="line">        .get();</span><br><span class="line">                 </span><br><span class="line">    System.out.println(<span class="string">&quot;Concatenated string: &quot;</span> + concatenatedString);</span><br><span class="line">         </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Exception caught: &quot;</span> + e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本示例使用reduce操作（这是终端操作）将listOfStrings中包含的字符串连接为<code>Optional&lt;String&gt;</code>值。但是，此处的管道调用了中间操作peek，该操作将尝试向<code>listOfStrings</code>添加新元素。请记住，所有中间操作都是惰性的。这意味着此示例中的管道在调用操作<code>get</code>时开始执行，并在<code>get</code>操作完成时结束执行。 <code>peek</code>操作的参数尝试在管道执行期间修改流源，这会导致Java运行时抛出<code>ConcurrentModificationException</code>。</p>
<p><span id="collections-streams-parallelism-stateful_lambda_expressions"></span></p>
<p><strong>有状态Lambda表达式</strong></p>
<p>避免在流操作中使用有状态的lambda表达式作为参数。有状态lambda表达式是一种有状态的lambda表达式，其结果取决于在管道执行期间可能更改的任何状态。以下示例通过map中间操作将List listOfIntegers中的元素添加到新的List实例中。它执行两次，首先使用串行流，然后使用并行流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; serialStorage = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     </span><br><span class="line">System.out.println(<span class="string">&quot;Serial stream:&quot;</span>);</span><br><span class="line">listOfIntegers</span><br><span class="line">    .stream()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Don&#x27;t do this! It uses a stateful lambda expression.</span></span><br><span class="line">    .map(e -&gt; &#123; serialStorage.add(e); <span class="keyword">return</span> e; &#125;)</span><br><span class="line">    </span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     </span><br><span class="line">serialStorage</span><br><span class="line">    .stream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;Parallel stream:&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; parallelStorage = Collections.synchronizedList(</span><br><span class="line">    <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">listOfIntegers</span><br><span class="line">    .parallelStream()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Don&#x27;t do this! It uses a stateful lambda expression.</span></span><br><span class="line">    .map(e -&gt; &#123; parallelStorage.add(e); <span class="keyword">return</span> e; &#125;)</span><br><span class="line">    </span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">     </span><br><span class="line">parallelStorage</span><br><span class="line">    .stream()</span><br><span class="line">    .forEachOrdered(e -&gt; System.out.print(e + <span class="string">&quot; &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Lambda表达式<code>e-&gt; &#123;parallelStorage.add（e）;return e; &#125;</code>是有状态的lambda表达式。每次运行代码时，其结果可能会有所不同。本示例打印以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Serial stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">Parallel stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">1 3 6 2 4 5 8 7</span><br></pre></td></tr></table></figure>
<p>无论流是以串行还是并行方式执行，<code>forEachOrdered</code>的操作均按流指定的顺序处理元素。但是，当并行执行流时，映射操作将处理Java运行时和编译器指定的流的元素。因此，lambda表达式<code>e-&gt; &#123;parallelStorage.add（e）;return e;</code>每次向代码添加元素时，<code>List parallelStorage</code>都会有所不同。为了获得确定性和可预测的结果，请确保流操作中的lambda表达式参数不是有状态的。</p>
<p>注意：此示例调用方法<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedList-java.util.List-">SynchronizedList</a>，以便<code>List parallelStorage</code>是线程安全的。请记住，集合不是线程安全的。这意味着多个线程不应同时访问特定的集合。假设您在创建<code>parallelStorage</code>时未调用方法<code>synchronizedList</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; parallelStorage = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>该示例的行为不正常，因为多个线程访问和修改parallelStorage时没有像同步这样的机制来调度特定线程何时可以访问List实例。因此，该示例可以输出类似于以下内容的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parallel stream:</span><br><span class="line">8 7 6 5 4 3 2 1</span><br><span class="line">null 3 5 4 7 8 1 2</span><br></pre></td></tr></table></figure>
<p><span id="collections-streams-QandE-questions"></span></p>
<h2 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习"></a>问题与练习</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>A sequence of aggregate operations is known as a ___ .</p>
</li>
<li><p>Each pipeline contains zero or more ___ operations.</p>
</li>
<li><p>Each pipeline ends with a ___ operation.</p>
</li>
<li><p>What kind of operation produces another stream as its output?</p>
</li>
<li><p>Describe one way in which the <code>forEach</code> aggregate operation differs from the enhanced <code>for</code> statement or iterators.</p>
</li>
<li><p>True or False: A stream is similar to a collection in that it is a data structure that stores elements.</p>
</li>
<li><p>Identify the intermediate and terminal operations in this code:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double average &#x3D; roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(p -&gt; p.getGender() &#x3D;&#x3D; Person.Sex.MALE)</span><br><span class="line">    .mapToInt(Person::getAge)</span><br><span class="line">    .average()</span><br><span class="line">    .getAsDouble();</span><br></pre></td></tr></table></figure>
</li>
<li><p>The code <code>p -&gt; p.getGender() == Person.Sex.MALE</code>is an example of what?</p>
</li>
<li><p>The code <code>Person::getAge</code>is an example of what?</p>
</li>
<li><p>Terminal operations that combine the contents of a stream and return one value are known as what?</p>
</li>
<li><p>Name one important difference between the <code>Stream.reduce</code> method and the <code>Stream.collect</code> method.</p>
</li>
<li><p>If you wanted to process a stream of names, extract the male names, and store them in a new <code>List</code>, would <code>Stream.reduce</code> or <code>Stream.collect</code> be the most appropriate operation to use?</p>
</li>
<li><p>True or False: Aggregate operations make it possible to implement parallelism with non-thread-safe collections.</p>
</li>
<li><p>Streams are always serial unless otherwise specified. How do you request that a stream be processed in parallel?</p>
</li>
</ol>
<h2 id="Exercises-1"><a href="#Exercises-1" class="headerlink" title="Exercises"></a>Exercises</h2><ol>
<li>Write the following enhanced <code>for</code> statement as a pipeline with lambda expressions. Hint: Use the <code>filter</code> intermediate operation and the <code>forEach</code> terminal operation.</li>
</ol>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p.getGender() == Person.Sex.MALE) &#123;</span><br><span class="line">        System.out.println(p.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.Convert the following code into a new implementation that uses lambda expressions and aggregate operations instead of nested <code>for</code> loops. Hint: Make a pipeline that invokes the <code>filter</code>, <code>sorted</code>, and <code>collect</code> operations, in that order.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Album&gt; favs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Album a : albums) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasFavorite = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Track t : a.tracks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.rating &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            hasFavorite = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasFavorite)</span><br><span class="line">        favs.add(a);</span><br><span class="line">&#125;</span><br><span class="line">Collections.sort(favs, <span class="keyword">new</span> Comparator&lt;Album&gt;() &#123;</span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Album a1, Album a2)</span> </span>&#123;</span><br><span class="line">                               <span class="keyword">return</span> a1.name.compareTo(a2.name);</span><br><span class="line">                           &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/collections/streams/QandE/answers.html">Check your answers.</a></p>
<h1 id="在JAR文件中打包程序"><a href="#在JAR文件中打包程序" class="headerlink" title="在JAR文件中打包程序"></a>在JAR文件中打包程序</h1><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Trail：反射API<br><strong>反射的用途</strong><br>反射通常由需要检查或修改Java虚拟机中运行的应用程序的运行时行为的程序使用。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一警告，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。</p>
<p><strong>扩展功能</strong><br>应用程序可以通过使用其完全限定的名称创建可扩展性对象的实例来使用外部用户定义的类。<br><strong>类浏览器和可视化开发环境</strong><br>一个类浏览器需要能够枚举类的成员。可视化开发环境可以受益于利用反射中可用的类型信息来帮助开发人员编写正确的代码。<br><strong>调试器和测试工具</strong><br>调试器需要能够检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的集合API，以确保测试套件中的代码覆盖率很高。<br><strong>反射的缺点</strong><br>反射功能强大，但不应任意使用。如果可以在不使用反射的情况下执行操作，那么最好避免使用它。通过反射访问代码时，应牢记以下注意事项。</p>
<p><strong>性能开销</strong><br>由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能比非反射操作慢，因此应避免在对性能敏感的应用程序中经常调用的代码段中。<br><strong>安全限制</strong><br>反射需要运行时许可，而在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。<br><strong>内部暴露</strong><br>由于反射允许代码执行在非反射代码中是非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射性代码破坏了抽象，因此可能会随着平台的升级而改变行为。<br>经验教训<br>本教程介绍了反射在访问和操作类，字段，方法和构造函数方面的常见用法。每节课均包含代码示例，技巧和故障排除信息。</p>
<p><a href="#Reflect-Classes">Classes</a><br>本课显示了获取Class对象并使用它检查类的属性的各种方法，包括其声明和内容。<br><a href="#Reflect-members">Members</a><br>本课描述如何使用反射API查找类的字段，方法和构造函数。提供了用于设置和获取字段值，调用方法以及使用特定构造函数创建对象的新实例的示例。<br><a href="#Reflect-array-enum-type">Arrays和枚举类型</a><br>本课介绍了两种特殊类型的类：在运行时生成的数组和定义唯一命名对象实例的枚举类型。示例代码显示了如何检索数组的组件类型以及如何设置和获取具有数组或枚举类型的字段。</p>
<blockquote>
<p>注意：<br>本教程中的示例旨在用于尝试使用反射API。因此，异常的处理与生产代码中使用的处理不同。特别是，在生产代码中，不建议转储用户可见的堆栈跟踪。</p>
</blockquote>
<p><span id="Reflect-Classes"></span></p>
<h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><p>每种类型都是引用或原始类型。类，枚举和数组（都继承自<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a>）以及接口都是引用类型。引用类型的示例包括<code>java.lang.String</code>，原始类型的所有包装器类，例如<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html">java.lang.Double</a>，接口<code>java.io.Serializable</code>和枚举<code>javax.swing.SortOrder</code>。有一组固定的原始类型：布尔值，字节，短型，整数，长型，字符，浮点型和双精度型。</p>
<p>对于每种类型的对象，Java虚拟机都会实例化一个不可变的<code>java.lang.Class</code>实例，该实例提供检查对象的运行时属性（包括其成员和类型信息）的方法。类还提供了创建新类和对象的能力。最重要的是，它是所有反射API的入口点。本课涵盖了最常见的涉及类的反射操作：</p>
<ul>
<li><a href="#retrieving-class-objects">检索类对象</a>描述了获取类的方法</li>
<li><a href="#Examining-Class-Modifiers-and-Types">检查类修饰符和类型</a>显示了如何访问类声明信息</li>
<li><a href="#Discovering-Class-Members">发现类成员</a>说明了如何在类中列出构造函数，字段，方法和嵌套类</li>
<li><a href="#reflect-Troubleshooting">故障排除</a>描述了使用类时遇到的常见错误</li>
</ul>
<p><span id="retrieving-class-objects"></span></p>
<h3 id="检索类对象"><a href="#检索类对象" class="headerlink" title="检索类对象"></a>检索类对象</h3><p><span id="Examining-Class-Modifiers-and-Types"></span></p>
<h3 id="检查类修饰符和类型"><a href="#检查类修饰符和类型" class="headerlink" title="检查类修饰符和类型"></a>检查类修饰符和类型</h3><p><span id="Discovering-Class-Members"></span></p>
<h3 id="发现类成员"><a href="#发现类成员" class="headerlink" title="发现类成员"></a>发现类成员</h3><p><span id="reflect-Troubleshooting"></span></p>
<h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><p><span id="Reflect-members"></span></p>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p><span id="Reflect-array-enum-type"></span></p>
<h2 id="Arrays和枚举类型"><a href="#Arrays和枚举类型" class="headerlink" title="Arrays和枚举类型"></a>Arrays和枚举类型</h2><p><span id=""></span></p>
<p><span id=""></span></p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h1 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h1><h1 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h1><h1 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-tutorials/" rel="tag"># Java-tutorials</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/23/Spring-security/" rel="prev" title="Spring-security">
      <i class="fa fa-chevron-left"></i> Spring-security
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/28/Spring-Data/" rel="next" title="Spring-Data">
      Spring-Data <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0Java%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">学习Java语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象编程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">什么是类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="nav-number">2.1.3.</span> <span class="nav-text">什么是继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.4.</span> <span class="nav-text">什么是接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85"><span class="nav-number">2.1.5.</span> <span class="nav-text">什么是包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Questions"><span class="nav-number">2.1.6.</span> <span class="nav-text">Questions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercises"><span class="nav-number">2.1.7.</span> <span class="nav-text">Exercises</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">2.2.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.2.2.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">表达式，语句和块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.4.</span> <span class="nav-text">控制流语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">声明类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">声明成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="nav-number">2.3.1.2.3.</span> <span class="nav-text">变量名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">定义方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%94%AF%E6%8C%81"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">构造方法支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E7%BB%99%E6%96%B9%E6%B3%95%E6%88%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">传递信息给方法或构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">使用对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">2.3.3.</span> <span class="nav-text">有关类的更多信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">从方法返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">使用关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">控制类成员的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">理解类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E6%AE%B5"><span class="nav-number">2.3.3.5.</span> <span class="nav-text">初始化字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.3.6.</span> <span class="nav-text">总结类和对象的创建和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E7%B1%BB"><span class="nav-number">2.3.4.</span> <span class="nav-text">问题和练习:类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.5.</span> <span class="nav-text">问题和练习:对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="nav-number">2.3.6.</span> <span class="nav-text">嵌套类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E4%BE%8B%E5%AD%90"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">内部类例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%B1%BB"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">本地类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">匿名类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB-%E6%9C%AC%E5%9C%B0%E7%B1%BB-%E5%8C%BF%E5%90%8D%E7%B1%BB-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.6.5.</span> <span class="nav-text">什么时候使用内部类,本地类,匿名类,Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.3.7.</span> <span class="nav-text">问题和练习:内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.8.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.9.</span> <span class="nav-text">问题和练习:枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.</span> <span class="nav-text">接口和继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Numbers%E5%92%8CStrings"><span class="nav-number">2.6.</span> <span class="nav-text">Numbers和Strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.7.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">2.8.</span> <span class="nav-text">包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACJava%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">基本Java类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-number">5.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%90%86%E6%83%B3%E7%94%A8%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">Lambda表达式的理想用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%90%9C%E7%B4%A2%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">方法1：创建搜索匹配一个特征的成员的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%80%9A%E7%94%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">方法2：创建更通用的搜索方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.4.</span> <span class="nav-text">方法3：在本地类中指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E5%9C%A8%E5%8C%BF%E5%90%8D%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.5.</span> <span class="nav-text">方法4：在匿名类中指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9A%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.6.</span> <span class="nav-text">方法5：使用Lambda表达式指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%956%EF%BC%9A%E5%B0%86%E6%A0%87%E5%87%86%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">方法6：将标准功能接口与Lambda表达式一起使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%957%EF%BC%9A%E5%9C%A8%E6%95%B4%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.8.</span> <span class="nav-text">方法7：在整个应用程序中使用Lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%958%EF%BC%9A%E6%9B%B4%E5%B9%BF%E6%B3%9B%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.9.</span> <span class="nav-text">方法8：更广泛地使用泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%959%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%97Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.10.</span> <span class="nav-text">方法9：使用接受Lambda表达式作为参数的聚合操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GUI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.11.</span> <span class="nav-text">GUI应用程序中的Lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">5.12.</span> <span class="nav-text">Lambda表达式语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%B0%81%E9%97%AD%E8%8C%83%E5%9B%B4%E7%9A%84%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">5.13.</span> <span class="nav-text">访问封闭范围的局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.14.</span> <span class="nav-text">目标类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%AE%E6%A0%87%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="nav-number">5.15.</span> <span class="nav-text">目标类型和方法参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">5.16.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">5.17.</span> <span class="nav-text">方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">5.17.1.</span> <span class="nav-text">方法引用的种类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">5.17.1.1.</span> <span class="nav-text">静态方法引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%89%B9%E5%AE%9A%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.17.1.2.</span> <span class="nav-text">引用特定对象的实例方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">5.17.1.3.</span> <span class="nav-text">构造方法引用</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">聚合操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Reduction"><span class="nav-number">6.1.</span> <span class="nav-text">Reduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Parallelism"><span class="nav-number">6.2.</span> <span class="nav-text">Parallelism</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E4%B8%8E%E7%BB%83%E4%B9%A0"><span class="nav-number">6.3.</span> <span class="nav-text">问题与练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">6.3.1.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exercises-1"><span class="nav-number">6.4.</span> <span class="nav-text">Exercises</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8JAR%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">在JAR文件中打包程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">国际化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">9.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB-1"><span class="nav-number">9.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.1.1.</span> <span class="nav-text">检索类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%B1%BB%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">检查类修饰符和类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">9.1.3.</span> <span class="nav-text">发现类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="nav-number">9.1.4.</span> <span class="nav-text">故障排除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98"><span class="nav-number">9.2.</span> <span class="nav-text">成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.3.</span> <span class="nav-text">Arrays和枚举类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaBeans"><span class="nav-number">11.</span> <span class="nav-text">JavaBeans</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">扩展机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-1"><span class="nav-number">13.</span> <span class="nav-text">泛型</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/09/24/Java-Tutorials/";
    this.page.identifier = "2020/09/24/Java-Tutorials/";
    this.page.title = "Java-Tutorials";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
