<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基于Java8翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Tutorials">
<meta property="og:url" content="http://yoursite.com/2020/09/24/Java-Tutorials/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="基于Java8翻译">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif">
<meta property="og:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif">
<meta property="article:published_time" content="2020-09-24T00:11:11.000Z">
<meta property="article:modified_time" content="2020-09-28T09:29:12.497Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="Java-tutorials">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif">

<link rel="canonical" href="http://yoursite.com/2020/09/24/Java-Tutorials/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java-Tutorials | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/24/Java-Tutorials/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-Tutorials
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-24 08:11:11" itemprop="dateCreated datePublished" datetime="2020-09-24T08:11:11+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-28 17:29:12" itemprop="dateModified" datetime="2020-09-28T17:29:12+08:00">2020-09-28</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/09/24/Java-Tutorials/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/24/Java-Tutorials/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>基于Java8翻译</p>
<a id="more"></a>
<p><strong>基础</strong></p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>Java技术简介和安装Java开发软件并使用它创建简单程序的课程。</p>
<h1 id="学习Java语言"><a href="#学习Java语言" class="headerlink" title="学习Java语言"></a>学习Java语言</h1><p><a href="">面向对象的编程概念</a>教您面向对象的编程背后的核心概念：对象，消息，类和继承。 本课最后向您展示这些概念如何转换为代码。 如果您已经熟悉面向对象的编程，请随时跳过本课程。</p>
<p><a href="">语言基础</a>描述了语言的传统功能，包括变量，数组，数据类型，运算符和控制流。</p>
<p><a href="">类和对象</a>描述了如何编写从中创建对象的类，以及如何创建和使用对象。</p>
<p><a href="">注解</a>是元数据的一种形式，为编译器提供信息。 本课描述了在程序中的何处以及如何有效使用注释。</p>
<p><a href="">接口和继承</a>描述了接口-它们是什么，为什么要编写一个接口以及如何编写一个接口。 本节还描述了可以从另一个类派生一个类的方法。 也就是说，子类如何可以从超类继承字段和方法。 您将了解所有类都派生自Object类，以及如何修改子类从超类继承的方法。</p>
<p><a href="">Numbers和Strings</a>本课程描述如何使用数字和字符串对象。本课程还向您展示如何格式化数据以输出。</p>
<p><a href="">泛型</a>是Java编程语言的强大功能。 它们提高了代码的类型安全性，使您在编译时可以检测到更多错误。</p>
<p><a href="">包</a>是Java编程语言的一项功能，可帮助您组织和构造类及其之间的关系。</p>
<h2 id="面向对象编程概念"><a href="#面向对象编程概念" class="headerlink" title="面向对象编程概念"></a>面向对象编程概念</h2><p>如果您以前从未使用过面向对象的编程语言，则需要学习一些基本概念，然后才能开始编写任何代码。本课将向您介绍对象，类，继承，接口和包。每个讨论都集中在这些概念如何与现实世界相关的同时，同时提供对Java编程语言语法的介绍。</p>
<p><a href="#什么是对象">什么是对象</a>？<br>对象是具有相关状态和行为的软件包。软件对象通常用于建模您在日常生活中发现的现实世界对象。本课说明了对象中状态和行为的表示方式，介绍了数据封装的概念，并说明了以这种方式设计软件的好处。</p>
<p><a href="#什么是类">什么是类</a>？<br>类是从中创建对象的蓝图或原型。本节定义了一个模型，用于对实际对象的状态和行为进行建模。它特意侧重于基础知识，展示了即使是简单的类也可以如何清晰地对状态和行为进行建模。</p>
<p><a href="#什么是继承">什么是继承</a>？<br>继承为组织和构造软件提供了强大而自然的机制。本节说明类如何从其超类继承状态和行为，并说明如何使用Java编程语言提供的简单语法从另一个类派生一个类。</p>
<p><a href="#什么是接口">什么是接口</a>？<br>接口是类与外界之间的契约。当一个类实现一个接口时，它承诺提供该接口发布的行为。本节定义了一个简单的接口，并说明了实现该接口的任何类的必要更改。</p>
<p><a href="#什么是包">什么是包</a>？<br>包是用于以逻辑方式组织类和接口的名称空间。将您的代码放入程序包使大型软件项目更易于管理。本节说明了这样做的用处，并向您介绍Java平台提供的应用程序编程接口（API）。</p>
<p>问题与练习：面向对象的编程概念<br>使用本节中提出的问题和练习来测试您对对象，类，继承，接口和包的理解。</p>
<h3 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h3><p>对象是理解面向对象技术的关键。现在环顾四周，您会发现许多真实物体的示例：您的狗，书桌，电视机，自行车。</p>
<p>现实世界中的对象共有两个特征：它们都具有状态和行为。狗具有状态（名称，颜色，品种，饥饿）和行为（吠叫，抓捕，摇尾巴）。自行车还具有状态（当前档位，当前踏板节奏，当前速度）和行为（换档，改变踏板节奏，施加制动）。识别现实世界对象的状态和行为是从面向对象编程的角度出发思考的一种好方法。</p>
<p>现在花一分钟时间观察您附近区域中的真实对象。对于您看到的每个对象，问自己两个问题：“该对象可能处于什么状态？”和“此对象可能执行什么行为？”。确保写下您的观察结果。在执行操作时，您会注意到现实世界中对象的复杂性各不相同。您的台式机灯可能只有两种可能的状态（打开和关闭）和两种可能的行为（打开，关闭），但是您的台式收音机可能具有其他状态（打开，关闭，当前音量，当前电台）和行为（打开） ，关闭，增加音量，减少音量，搜索，扫描和调整）。您可能还会注意到，某些对象也将包含其他对象。这些真实的观察结果都转化为面向对象编程的世界。</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-object.gif" alt="软件中的对象"></p>
<p>软件对象在概念上与现实世界中的对象相似：它们也由状态和相关行为组成。 对象将其状态存储在字段中（某些编程语言中的变量），并通过方法（某些编程语言中的函数）公开其行为。 方法在对象的内部状态上运行，并用作对象间通信的主要机制。 隐藏内部状态并要求通过对象的方法执行所有交互被称为数据封装-面向对象编程的基本原理。</p>
<p>考虑一辆自行车，例如：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bicycleObject.gif" alt="软件中的自行车模型"></p>
<p>通过归因于状态（当前速度，当前踏板踏频和当前档位）并提供更改状态的方法，对象可以控制外部世界如何使用它。例如，如果自行车只有6档，则更改齿轮的方法可能会拒绝任何小于1或大于6的值。</p>
<p>将代码捆绑到单个软件对象中可带来许多好处，包括：</p>
<ol>
<li>模块化：可以独立于其他对象的源代码编写和维护对象的源代码。创建对象后，可以轻松地在系统内部传递对象。</li>
<li>信息隐藏：通过仅与对象的方法进行交互，其内部实现的细节仍对外界隐藏。</li>
<li>代码重用：如果某个对象已经存在（也许由其他软件开发人员编写），则可以在程序中使用该对象。这使专家可以实现/测试/调试特定于任务的复杂对象，然后您可以信任它们以自己的代码运行。</li>
<li>可插拔性和调试简便性：如果发现某个特定对象有问题，则只需将其从应用程序中删除，然后插入另一个对象作为替换对象即可。这类似于解决现实世界中的机械问题。如果螺栓断裂，请更换，而不是整个机器。</li>
</ol>
<h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><p>在现实世界中，您经常会发现许多同一种个体。 可能还有成千上万的其他自行车，都具有相同的品牌和型号。 每辆自行车都是根据相同的设计图制造的，因此包含相同的组件。 用面向对象的术语来说，我们说您的自行车是称为自行车的一类对象的实例。 类是从中创建单个对象的蓝图。</p>
<p>以下Bicycle类是自行车的一种可能实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cadence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">         speed = speed + increment;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">         speed = speed - decrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;cadence:&quot;</span> +</span><br><span class="line">             cadence + <span class="string">&quot; speed:&quot;</span> + </span><br><span class="line">             speed + <span class="string">&quot; gear:&quot;</span> + gear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java编程语言的语法对您来说似乎很新，但是此类的设计是基于先前对自行车对象的讨论。 节奏，速度和齿轮字段表示对象的状态，方法（<code>changeCadence</code>，<code>changeGear</code>，<code>speedUp</code>等）定义了对象与外界的交互。</p>
<p>您可能已经注意到Bicycle类不包含main方法。 那是因为它不是一个完整的应用程序。 它只是应用程序中可能使用的自行车的蓝图。 创建和使用新的Bicycle对象的职责属于应用程序中的其他一些类。</p>
<p>这是一个<code>BicycleDemo</code>类，它创建两个单独的Bicycle对象并调用它们的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BicycleDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create two different </span></span><br><span class="line">        <span class="comment">// Bicycle objects</span></span><br><span class="line">        Bicycle bike1 = <span class="keyword">new</span> Bicycle();</span><br><span class="line">        Bicycle bike2 = <span class="keyword">new</span> Bicycle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke methods on </span></span><br><span class="line">        <span class="comment">// those objects</span></span><br><span class="line">        bike1.changeCadence(<span class="number">50</span>);</span><br><span class="line">        bike1.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike1.changeGear(<span class="number">2</span>);</span><br><span class="line">        bike1.printStates();</span><br><span class="line"></span><br><span class="line">        bike2.changeCadence(<span class="number">50</span>);</span><br><span class="line">        bike2.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike2.changeGear(<span class="number">2</span>);</span><br><span class="line">        bike2.changeCadence(<span class="number">40</span>);</span><br><span class="line">        bike2.speedUp(<span class="number">10</span>);</span><br><span class="line">        bike2.changeGear(<span class="number">3</span>);</span><br><span class="line">        bike2.printStates();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此测试的输出显示两辆自行车的结束踏板节奏，速度和齿轮：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cadence:50 speed:10 gear:2</span><br><span class="line">cadence:40 speed:20 gear:3</span><br></pre></td></tr></table></figure>
<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><p>不同种类的对象通常彼此之间有一定数量的共同点。 例如，山地车，公路车和双人自行车都具有自行车的特征（当前速度，当前踏板节奏，当前档位）。 然而，每个自行车还定义了使其与众不同的其他功能：双人自行车有两个座位和两组车把； 公路自行车有下降的车把； 一些山地自行车带有附加的链环，从而降低了齿轮比。</p>
<p>面向对象的编程允许类从其他类继承常用的状态和行为。 在此示例中，Bicycle现在成为<code>MountainBike</code>，<code>RoadBike</code>和<code>TandemBike</code>的超类。 在Java编程语言中，每个类都可以具有一个直接超类，并且每个超类都具有无限数量的子类的潜力：</p>
<p><img src="https://docs.oracle.com/javase/tutorial/figures/java/concepts-bikeHierarchy.gif" alt="自行车类的继承"></p>
<p>创建子类的语法很简单。 在类声明的开头，使用extends关键字，后跟要从其继承的类的名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MountainBike</span> <span class="keyword">extends</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new fields and methods defining </span></span><br><span class="line">    <span class="comment">// a mountain bike would go here</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这为<code>MountainBike</code>提供了与Bicycle相同的字段和方法，但允许其代码仅专注于使其独特的功能。 这使子类的代码易于阅读。 但是，您必须注意正确记录每个超类定义的状态和行为，因为该代码不会出现在每个子类的源文件中。</p>
<h3 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h3><p>如您所知，对象通过其公开的方法定义了它们与外界的交互。 方法形成对象与外界的接口； 例如，电视机正面的按钮是您与塑料外壳另一侧的电线之间的接口。 您按下“电源”按钮可以打开和关闭电视。</p>
<p>在最常见的形式中，接口是一组具有空主体的相关方法。 如果将自行车的行为指定为接口，则可能如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  wheel revolutions per minute</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现此接口，您的类的名称将更改（更改为特定品牌的自行车，例如<code>ACMEBicycle</code>），然后在类声明中使用Implements关键字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACMEBicycle</span> <span class="keyword">implements</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cadence = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> speed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gear = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// The compiler will now require that methods</span></span><br><span class="line">   <span class="comment">// changeCadence, changeGear, speedUp, and applyBrakes</span></span><br><span class="line">   <span class="comment">// all be implemented. Compilation will fail if those</span></span><br><span class="line">   <span class="comment">// methods are missing from this class.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">         gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">         speed = speed + increment;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyBrakes</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">         speed = speed - decrement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;cadence:&quot;</span> +</span><br><span class="line">             cadence + <span class="string">&quot; speed:&quot;</span> + </span><br><span class="line">             speed + <span class="string">&quot; gear:&quot;</span> + gear);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现接口可以使类对其承诺提供的行为更加正式。 接口在类和外部世界之间形成契约，并且该契约在编译时由编译器强制执行。 如果您的类声称要实现一个接口，则在成功编译该类之前，该接口定义的所有方法都必须出现在其源代码中。</p>
<blockquote>
<p>注意：要实际编译<code>ACMEBicycle</code>类，您需要将public关键字添加到已实现的接口方法的开头。 稍后，您将在有关<a href="#类和对象">类和对象</a>，<a href="#接口和继承">接口和继承</a>的课程中了解造成这种情况的原因。</p>
</blockquote>
<h3 id="什么是包"><a href="#什么是包" class="headerlink" title="什么是包"></a>什么是包</h3><p>程序包是一个命名空间，用于组织一组相关的类和接口。从概念上讲，您可以将软件包视为类似于计算机上的不同文件夹。您可以将HTML页面保留在一个文件夹中，将图像保留在另一个文件夹中，并将脚本或应用程序保留在另一个文件夹中。因为用Java编程语言编写的软件可以由成百上千个单独的类组成，所以通过将相关的类和接口放入包中来使事情井井有条是很有意义的。</p>
<p>Java平台提供了适合在您自己的应用程序中使用的庞大的类库（一组软件包）。该库称为“应用程序编程接口”或简称“ API”。它的程序包代表与通用编程最常关联的任务。例如，一个String对象包含字符串的状态和行为。 File对象允许程序员轻松创建，删除，检查，比较或修改文件系统上的文件；套接字对象允许创建和使用网络套接字；各种GUI对象控制按钮和复选框，以及与图形用户界面有关的其他任何内容。从字面上看，有数千种课程可供选择。程序员，这使您可以专注于特定应用程序的设计，而不是使其工作所需的基础结构。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/index.html">Java Platform API Specification</a>包含Java SE平台提供的所有软件包，接口，类，字段和方法的完整列表。在浏览器中加载页面并将其添加为书签。作为程序员，它将成为您最重要的参考文档。</p>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><ol>
<li>Real-world objects contain <strong>_ and _</strong>.</li>
<li>A software object’s state is stored in ___.</li>
<li>A software object’s behavior is exposed through ___.</li>
<li>Hiding internal data from the outside world, and accessing it only through publicly exposed methods is known as data ___.</li>
<li>A blueprint for a software object is called a ___.</li>
<li>Common behavior can be defined in a <strong>_ and inherited into a _</strong> using the ___ keyword.</li>
<li>A collection of methods with no implementation is called an ___.</li>
<li>A namespace that organizes classes and interfaces by functionality is called a ___.</li>
<li>The term API stands for ___?</li>
</ol>
<h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><ol>
<li>Create new classes for each real-world object that you observed at the beginning of this trail. Refer to the Bicycle class if you forget the required syntax.</li>
<li>For each new class that you’ve created above, create an interface that defines its behavior, then require your class to implement it. Omit one or two methods and try compiling. What does the error look like?</li>
</ol>
<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><p><a href="#Variables"><strong>变量</strong></a><br>您已经了解到对象存储在字段中。但是，Java编程语言也使用术语“变量”。本节讨论这种关系，以及变量命名规则和约定，基本数据类型（原始类型，字符串和数组），默认值和文字。<br><a href="#Operators"><strong>经营者</strong></a><br>本节描述Java编程语言的运算符。它首先显示最常用的运算符，然后显示最不常用的运算符。每个讨论都包含可编译和运行的代码示例。<br><a href="#表达式，语句和块"><strong>表达式，语句和块</strong></a><br>运算符可用于构建表达式，以计算值。表达式是语句的核心组成部分；语句可以分为多个块。本节使用您已经看到的示例代码讨论表达式，语句和块。<br><a href="#控制流语句"><strong>控制流语句</strong></a><br>本节描述Java编程语言支持的控制流语句。它涵盖了决策，循环和分支语句，使您的程序可以有条件地执行特定的代码块。</p>
<p><span id="Variables"></span></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><span id="Operators"></span></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h3 id="表达式，语句和块"><a href="#表达式，语句和块" class="headerlink" title="表达式，语句和块"></a>表达式，语句和块</h3><h3 id="控制流语句"><a href="#控制流语句" class="headerlink" title="控制流语句"></a>控制流语句</h3><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>现在，您掌握了Java编程语言的基础知识，就可以学习编写自己的类。在本课程中，您将找到有关定义自己的类的信息，包括声明成员变量，方法和构造函数。</p>
<p>您将学习如何使用类来创建对象，以及如何使用所创建的对象。</p>
<p>本课还介绍了其他类中的嵌套类以及枚举</p>
<p><a href="#类">类</a><br>本节向您展示类的剖析，以及如何声明字段，方法和构造函数。<br><a href="#对象">对象</a><br>本节介绍创建和使用对象。您将学习如何实例化一个对象，以及实例化后如何使用点运算符访问该对象的实例变量和方法。<br><a href="#有关类的更多信息">有关类的更多信息</a><br>本节介绍了类的更多方面，这些方面取决于使用对象引用和上一节中学习的点运算符：从方法，this关键字，类与实例成员以及访问控制返回值。<br><a href="#嵌套类">嵌套类</a><br>涵盖了静态嵌套类，内部类，匿名内部类，局部类和lambda表达式。还有关于何时使用哪种方法的讨论。<br><a href="#枚举类型">枚举类型</a><br>本节介绍枚举和专用类，这些类使您可以定义和使用常量集。</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在名为“面向对象编程概念”的课程中，对<a href="#面向对象编程概念">面向对象概念</a>的介绍以自行车类为例，赛车，山地自行车和双人自行车是子类。 这是一个可能的Bicycle类实现的示例代码，为您提供类声明的概述。 本课的后续部分将备份并逐步解释类声明。 目前，不要担心细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// three fields</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> cadence;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> gear;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> speed;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// one constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        gear = startGear;</span><br><span class="line">        cadence = startCadence;</span><br><span class="line">        speed = startSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the Bicycle class has</span></span><br><span class="line">    <span class="comment">// four methods</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyBrake</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">        speed -= decrement;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">        speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为Bicycle的子类的<code>MountainBike</code>类的类声明如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MountainBike</span> <span class="keyword">extends</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one field</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> seatHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MountainBike</span><span class="params">(<span class="keyword">int</span> startHeight, <span class="keyword">int</span> startCadence,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(startCadence, startSpeed, startGear);</span><br><span class="line">        seatHeight = startHeight;</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// the MountainBike subclass has</span></span><br><span class="line">    <span class="comment">// one method</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        seatHeight = newValue;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MountainBike</code>继承了Bicycle的所有字段和方法，并添加了<code>seatHeight</code>字段和一种设置方法（山地自行车的座椅可以根据地形要求上下移动）。</p>
<h4 id="声明类"><a href="#声明类" class="headerlink" title="声明类"></a>声明类</h4><p>您已经看到以以下方式定义的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// field, constructor, and </span></span><br><span class="line">    <span class="comment">// method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个类声明。类主体（大括号之间的区域）包含提供从类创建的对象的生命周期的所有代码：用于初始化新对象的构造函数，用于提供类及其对象状态的字段的声明，以及实现类及其对象行为的方法。</p>
<p>前面的类声明是最小的。它仅包含类声明中必需的那些组件。您可以在类声明的开头提供有关该类的更多信息，例如其超类的名称，是否实现任何接口等等。例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MySuperClass</span> <span class="keyword">implements</span> <span class="title">YourInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// field, constructor, and</span></span><br><span class="line">    <span class="comment">// method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示<code>MyClass</code>是<code>MySuperClass</code>的子类，并且它实现<code>YourInterface</code>接口。</p>
<p>您还可以在开始时添加诸如public或private之类的修饰符，因此您可以看到类声明的开头可能会变得非常复杂。本课后面将讨论修饰符public和private，这些修饰符确定哪些其他类可以访问<code>MyClass</code>。关于接口和继承的课程将说明如何以及为什么要在类声明中使用扩展并实现关键字。目前，您无需担心这些额外的并发症。</p>
<p>通常，类声明可以按顺序包括以下组件：</p>
<ol>
<li>修饰符，例如<code>public</code>，<code>private</code>以及以后会遇到的许多其他修饰符。</li>
<li>类名，首字母大写为约定。</li>
<li>类的父级（超类）的名称（如果有的话），以关键字<code>extends</code>开头。一个类只能扩展（子类）一个父级。</li>
<li>由类实现的接口的列表，以逗号分隔（如果有的话），并以关键字<code>Implements</code>开头。一个 类可以实现多个接口。</li>
<li>类主体，用大括号{}包围。</li>
</ol>
<h4 id="声明成员变量"><a href="#声明成员变量" class="headerlink" title="声明成员变量"></a>声明成员变量</h4><p>有几种变量：</p>
<ul>
<li>类中的成员变量-这些称为字段。</li>
<li>方法或代码块中的变量-这些称为局部变量。</li>
<li>方法声明中的变量-这些称为参数。</li>
</ul>
<p><code>Bicycle</code>类使用以下代码行定义其字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> cadence;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> gear;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> speed;</span><br></pre></td></tr></table></figure>
<p>字段声明按顺序由三个部分组成：</p>
<ol>
<li>零个或多个修饰符，例如public或private。</li>
<li>字段的类型。</li>
<li>字段名称。</li>
</ol>
<p><code>Bicycle</code>的字段被称为节奏，档位和速度，并且都是数据类型整数（int）。 <code>public</code>关键字将这些字段标识为公共成员，任何可以访问该类的对象都可以访问它们。</p>
<h5 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h5><p>使用第一个（最左侧）修饰符可以控制其他哪些类可以访问成员字段。目前，仅考虑公开和私有。其他访问修饰符将在后面讨论。</p>
<ul>
<li>公共修饰符-该字段可从所有类访问。</li>
<li>private修饰符-该字段只能在其自己的类中访问。</li>
</ul>
<p>本着封装的精神，通常将字段设为私有。这意味着只能从Bicycle类直接访问它们。但是，我们仍然需要访问这些值。这可以通过添加公共方法来间接完成，这些方法可以为我们获取字段值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bicycle</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cadence;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> gear;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> speed;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bicycle</span><span class="params">(<span class="keyword">int</span> startCadence, <span class="keyword">int</span> startSpeed, <span class="keyword">int</span> startGear)</span> </span>&#123;</span><br><span class="line">        gear = startGear;</span><br><span class="line">        cadence = startCadence;</span><br><span class="line">        speed = startSpeed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCadence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cadence;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCadence</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        cadence = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gear;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGear</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        gear = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyBrake</span><span class="params">(<span class="keyword">int</span> decrement)</span> </span>&#123;</span><br><span class="line">        speed -= decrement;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speedUp</span><span class="params">(<span class="keyword">int</span> increment)</span> </span>&#123;</span><br><span class="line">        speed += increment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h5><p>所有变量必须具有类型。您可以使用基本类型，例如int，float，boolean等。也可以使用引用类型，例如字符串，数组或对象。</p>
<h5 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h5><p>所有变量，无论它们是字段，局部变量还是参数，都遵循“语言基础”课程“变量—命名”中涉及的相同命名规则和约定。</p>
<p>在本课程中，请注意，方法和类名使用相同的命名规则和约定，但</p>
<ul>
<li><p>类名的首字母应大写，并且</p>
</li>
<li><p>方法名称中的第一个（或唯一）词应为动词。</p>
</li>
</ul>
<h4 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h4><h4 id="构造方法支持"><a href="#构造方法支持" class="headerlink" title="构造方法支持"></a>构造方法支持</h4><h4 id="传递信息给方法或构造方法"><a href="#传递信息给方法或构造方法" class="headerlink" title="传递信息给方法或构造方法"></a>传递信息给方法或构造方法</h4><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><h4 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h4><h3 id="有关类的更多信息"><a href="#有关类的更多信息" class="headerlink" title="有关类的更多信息"></a>有关类的更多信息</h3><h4 id="从方法返回值"><a href="#从方法返回值" class="headerlink" title="从方法返回值"></a>从方法返回值</h4><h4 id="使用关键字"><a href="#使用关键字" class="headerlink" title="使用关键字"></a>使用关键字</h4><h4 id="控制类成员的访问"><a href="#控制类成员的访问" class="headerlink" title="控制类成员的访问"></a>控制类成员的访问</h4><h4 id="理解类成员"><a href="#理解类成员" class="headerlink" title="理解类成员"></a>理解类成员</h4><h4 id="初始化字段"><a href="#初始化字段" class="headerlink" title="初始化字段"></a>初始化字段</h4><h4 id="总结类和对象的创建和使用"><a href="#总结类和对象的创建和使用" class="headerlink" title="总结类和对象的创建和使用"></a>总结类和对象的创建和使用</h4><h3 id="问题和练习-类"><a href="#问题和练习-类" class="headerlink" title="问题和练习:类"></a>问题和练习:类</h3><h3 id="问题和练习-对象"><a href="#问题和练习-对象" class="headerlink" title="问题和练习:对象"></a>问题和练习:对象</h3><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><p>Java编程语言允许您在另一个类中定义一个类。 这样的类称为嵌套类，并在此处进行说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>术语：嵌套类分为两类：静态和非静态。 声明为静态的嵌套类称为静态嵌套类。 非静态嵌套类称为内部类。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNestedClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套类是其封闭类的成员。非静态嵌套类（内部类）可以访问封闭类的其他成员，即使它们被声明为私有的也是如此。静态嵌套类无权访问封闭类的其他成员。作为OuterClass的成员，可以将嵌套类声明为私有，公共，受保护或包私有。 （回想一下，外部类只能声明为公共或包私有。）</p>
<p><strong>为什么要使用嵌套类</strong>？<br>使用嵌套类的令人信服的原因包括：</p>
<ul>
<li><strong>这是一种对仅在一个地方使用的类进行逻辑分组的方法</strong>：如果一个类仅对另一个类有用，那么将其嵌入该类并将两者保持在一起是合乎逻辑的。嵌套此类“帮助程序类”可使它们的程序包更加简化。</li>
<li><strong>它增加了封装</strong>：考虑两个顶级类A和B，其中B需要访问A的成员，否则将其声明为私有。通过将类B隐藏在类A中，可以将A的成员声明为私有，而B可以访问它们。另外，B本身可以对外界隐藏。</li>
<li><strong>它可以导致更具可读性和可维护性的代码</strong>：在顶级类中嵌套小型类会使代码更靠近使用位置。</li>
</ul>
<p><strong>静态嵌套类</strong><br>与类方法和变量一样，静态嵌套类与其外部类相关联。与静态类方法一样，静态嵌套类不能直接引用其封闭类中定义的实例变量或方法：它只能通过对象引用来使用它们。</p>
<blockquote>
<p>注意：静态嵌套类与它的外部类（和其他类）的实例成员进行交互，就像其他任何顶级类一样。实际上，静态嵌套类在行为上是顶级类，为了包装方便，该顶级类已嵌套在另一个顶级类中。</p>
</blockquote>
<p>静态嵌套类使用封闭的类名称访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass</span><br></pre></td></tr></table></figure>
<p>例如，要为静态嵌套类创建一个对象，请使用以下语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.StaticNestedClass nestedObject &#x3D;</span><br><span class="line">     new OuterClass.StaticNestedClass();</span><br></pre></td></tr></table></figure>
<p><strong>内部类</strong><br>与实例方法和变量一样，内部类与其所在类的实例相关联，并且可以直接访问该对象的方法和字段。另外，由于内部类与实例相关联，因此它本身不能定义任何静态成员。</p>
<p>作为内部类实例的对象存在于外部类实例中。考虑以下类别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InnerClass</code>的实例只能存在于<code>OuterClass</code>的实例中，并且可以直接访问其封闭实例的方法和字段。</p>
<p>要实例化内部类，必须首先实例化外部类。然后，使用以下语法在外部对象内创建内部对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OuterClass.InnerClass innerObject &#x3D; externalObject.new InnerClass（）;</span><br></pre></td></tr></table></figure>
<p>内部类有两种特殊类型：<a href="#本地类">本地类</a>和<a href="#匿名类">匿名类</a>。</p>
<p><strong>重影</strong><br>如果在特定范围（例如内部类或方法定义）中的类型声明（例如成员变量或参数名称）与封闭范围中的另一个声明具有相同的名称，则该声明将覆盖该声明封闭范围。您不能仅凭其名称引用带阴影的声明。下面的示例ShadowTest演示了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShadowTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FirstLevel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">methodInFirstLevel</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;x = &quot;</span> + x);</span><br><span class="line">            System.out.println(<span class="string">&quot;this.x = &quot;</span> + <span class="keyword">this</span>.x);</span><br><span class="line">            System.out.println(<span class="string">&quot;ShadowTest.this.x = &quot;</span> + ShadowTest.<span class="keyword">this</span>.x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        ShadowTest st = <span class="keyword">new</span> ShadowTest();</span><br><span class="line">        ShadowTest.FirstLevel fl = st.<span class="function">new <span class="title">FirstLevel</span><span class="params">()</span></span>;</span><br><span class="line">        fl.methodInFirstLevel(<span class="number">23</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下是此示例的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = 23</span><br><span class="line">this.x = 1</span><br><span class="line">ShadowTest.this.x = 0</span><br></pre></td></tr></table></figure>
<p>此示例定义了三个名为x的变量：<code>ShadowTest</code>类的成员变量，内部类FirstLevel的成员变量以及<code>methodInFirstLevel</code>方法中的参数。定义为方法<code>methodInFirstLevel</code>的参数的变量x遮盖了内部类<code>FirstLevel</code>的变量。因此，在方法<code>methodInFirstLevel</code>中使用变量x时，它引用方法参数。要引用内部类<code>FirstLevel</code>的成员变量，请使用关键字this表示封闭范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println（“ <span class="keyword">this</span>.x =” + <span class="keyword">this</span>.x）;</span><br></pre></td></tr></table></figure>
<p>请参阅成员变量，这些成员变量使用它们所属的类名将更大的范围括起来。例如，以下语句从<code>methodInFirstLevel</code>方法访问<code>ShadowTest</code>类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println（<span class="string">&quot;ShadowTest.this.x =&quot;</span> + ShadowTest.<span class="keyword">this</span>.x）;</span><br></pre></td></tr></table></figure>
<p><strong>序列化</strong><br>强烈建议不要对内部类（包括<a href="本地类">本地类</a>和<a href="#匿名类">匿名类</a>）进行序列化。 当Java编译器编译某些构造（例如内部类）时，它会创建综合构造。 它们是类，方法，字段以及其他在源代码中没有相应构造的构造。 合成构造使Java编译器无需更改JVM就可以实现新的Java语言功能。 但是，合成构造在不同的Java编译器实现中可能有所不同，这意味着.class文件在不同的实现中也可能有所不同。 因此，如果序列化一个内部类，然后使用其他JRE实现对其进行反序列化，则可能会遇到兼容性问题。 有关在编译内部类时生成的综合构造的更多信息，请参见<a href="">“获取方法参数的名称”</a>一节中的<a href="">“隐式参数和综合参数”</a>部分。</p>
<h4 id="内部类例子"><a href="#内部类例子" class="headerlink" title="内部类例子"></a>内部类例子</h4><h4 id="本地类"><a href="#本地类" class="headerlink" title="本地类"></a>本地类</h4><h4 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h4><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><p>参考<a href="#lambda-expression">Lambda expression</a></p>
<h4 id="什么时候使用内部类-本地类-匿名类-Lambda表达式"><a href="#什么时候使用内部类-本地类-匿名类-Lambda表达式" class="headerlink" title="什么时候使用内部类,本地类,匿名类,Lambda表达式"></a>什么时候使用内部类,本地类,匿名类,Lambda表达式</h4><p>如嵌套类一节中所述，<a href="#嵌套类">嵌套类</a>使您能够对仅在一个地方使用的类进行逻辑分组，增加封装的使用，并创建更具可读性和可维护性的代码。本地类，匿名类和lambda表达式也具有这些优点。但是，它们旨在用于更特定的情况：</p>
<ul>
<li><p><a href="#本地类">本地类</a>：如果需要创建一个类的多个实例，访问其构造函数或引入新的命名类型（例如，因为稍后需要调用其他方法），请使用它。</p>
</li>
<li><p><a href="#匿名类">匿名类</a>：如果需要声明字段或其他方法，请使用它。</p>
</li>
<li><p><a href="#Lambda表达式">Lambda表达式</a>：</p>
<ul>
<li>如果要封装要传递给其他代码的单个行为单位，请使用它。例如，如果要在集合的每个元素上执行特定操作，流程完成或流程遇到错误时，可以使用lambda表达式。</li>
<li>如果您需要功能接口的简单实例并且不符合上述条件（例如，不需要构造函数，命名类型，字段或其他方法），请使用它。</li>
</ul>
</li>
<li><p><a href="#嵌套类">嵌套类</a>：如果您的要求与本地类的要求相似，并且您想使该类型更广泛地使用，并且您不需要访问本地变量或方法参数，请使用它。</p>
<ul>
<li>如果您需要访问封闭实例的非公共字段和方法，请使用非静态嵌套类（或内部类）。如果您不需要此访问，请使用静态嵌套类。</li>
</ul>
</li>
</ul>
<h3 id="问题和练习-内部类"><a href="#问题和练习-内部类" class="headerlink" title="问题和练习:内部类"></a>问题和练习:内部类</h3><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><h3 id="问题和练习-枚举类型"><a href="#问题和练习-枚举类型" class="headerlink" title="问题和练习:枚举类型"></a>问题和练习:枚举类型</h3><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="接口和继承"><a href="#接口和继承" class="headerlink" title="接口和继承"></a>接口和继承</h2><h2 id="Numbers和Strings"><a href="#Numbers和Strings" class="headerlink" title="Numbers和Strings"></a>Numbers和Strings</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h1 id="基本Java类"><a href="#基本Java类" class="headerlink" title="基本Java类"></a>基本Java类</h1><p>有关异常，基本输入/输出，并发，正则表达式和平台环境的课程。</p>
<p><strong>高级</strong></p>
<p>准备深入研究该技术了吗？请参阅以下主题：</p>
<ul>
<li>集合-有关使用和扩展Java集合框架的课程。</li>
<li>Lambda表达式：了解如何以及为什么在应用程序中使用Lambda表达式。</li>
<li>聚合操作：探索聚合操作，流和Lambda表达式如何协同工作以提供强大的过滤功能。</li>
<li>在JAR文件中打包程序–创建和签名JAR文件的课程。</li>
<li>国际化–设计软件的简介，以便可以轻松地将其修改（本地化）为各种语言和地区。</li>
<li>反射–表示（“反射”）当前Java虚拟机中的类，接口和对象的API。</li>
<li>安全性– Java平台功能可帮助保护应用程序免受恶意软件的侵害。</li>
<li>JavaBeans – Java平台的组件技术。</li>
<li>扩展机制–如何使自定义API对Java平台上运行的所有应用程序可用。</li>
<li>泛型–类型系统的增强，它支持对各种类型的对象进行操作，同时提供编译时类型安全。</li>
</ul>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p><span id="lambda-expression"></span></p>
<h1 id="Lambda表达式-1"><a href="#Lambda表达式-1" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>匿名类的一个问题是，如果匿名类的实现非常简单（例如仅包含一个方法的接口），则匿名类的语法可能看起来笨拙且不清楚。 在这些情况下，您通常试图将功能作为参数传递给另一种方法，例如当某人单击按钮时应采取的措施。 Lambda表达式使您能够执行此操作，将功能视为方法参数，或将代码视为数据。</p>
<p>上一节“匿名类”介绍了如何在不给基类命名的情况下实现它。 尽管这通常比命名类更简洁，但是对于仅具有一种方法的类，即使是匿名类也显得有些繁琐。 Lambda表达式使您可以更紧凑地表达单方法类的实例。</p>
<p>本节涵盖以下主题：</p>
<ul>
<li><a href="#use-case">Lambda表达式的理想用例</a><ul>
<li><a href="#approach1">方法1：创建搜索匹配一个特征的成员的方法</a></li>
<li><a href="#approach2">方法2：创建更通用的搜索方法</a></li>
<li><a href="#approach3">方法3：在本地类中指定搜索条件代码</a></li>
<li><a href="#approach4">方法4：在匿名类中指定搜索条件代码</a></li>
<li><a href="#approach5">方法5：使用Lambda表达式指定搜索条件代码</a></li>
<li><a href="#approach6">方法6：将标准功能接口与Lambda表达式一起使用</a></li>
<li><a href="#approach7">方法7：在整个应用程序中使用Lambda表达式</a></li>
<li><a href="#approach8">方法8：更广泛地使用泛型</a></li>
<li><a href="#approach9">方法9：使用接受Lambda表达式作为参数的聚合操作</a></li>
</ul>
</li>
<li><a href="#lambda-expressions-in-gui-applications">GUI应用程序中的Lambda表达式</a></li>
<li><a href="#syntax">Lambda表达式的语法</a></li>
<li><a href="#accessing-local-variables">访问封闭范围的局部变量</a></li>
<li><a href="#target-typing">目标类型</a><ul>
<li><a href="#target-types-and-method-arguments">目标类型和方法参数</a></li>
</ul>
</li>
<li><a href="#serialization">序列化</a></li>
</ul>
<p><span id="use-case"></span></p>
<h2 id="Lambda表达式的理想用例"><a href="#Lambda表达式的理想用例" class="headerlink" title="Lambda表达式的理想用例"></a>Lambda表达式的理想用例</h2><p>假设您正在创建一个社交网络应用程序。您想创建一个功能，使管理员可以对满足特定条件的社交网络应用程序成员执行任何类型的操作，例如发送消息。下表详细描述了该用例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Name</td>
<td>Perform action on selected members</td>
</tr>
<tr>
<td>Primary Actor</td>
<td>Administrator</td>
</tr>
<tr>
<td>Preconditions</td>
<td>Administrator is logged in to the system.</td>
</tr>
<tr>
<td>Postconditions</td>
<td>仅对符合指定条件的成员执行操作。</td>
</tr>
<tr>
<td>Main Success Scenario</td>
<td>管理员指定对其执行特定操作的成员条件。<br/>管理员指定要对那些选定成员执行的操作。<br/>管理员选择提交按钮。<br/>系统查找与指定条件匹配的所有成员。<br/>系统对所有匹配成员执行指定的操作。</td>
</tr>
<tr>
<td>Extensions</td>
<td>1a. 管理员可以选择在指定操作之前或选择“提交”按钮之前预览符合指定条件的成员。</td>
</tr>
<tr>
<td>Frequency of Occurrence</td>
<td>Many times during the day.</td>
</tr>
</tbody>
</table>
</div>
<p>假设此社交网络应用程序的成员由以下Person类表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</span><br><span class="line">        MALE, FEMALE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    LocalDate birthday;</span><br><span class="line">    Sex gender;</span><br><span class="line">    String emailAddress;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设您的社交网络应用程序的成员存储在<code>List &lt;Person&gt;</code>实例中。</p>
<p>本节以对这种用例的幼稚方法开始。 它使用本地和匿名类对该方法进行了改进，然后使用lambda表达式以一种高效而简洁的方法结束了。 在示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/examples/RosterTest.java">RosterTest</a>中找到本节中描述的代码摘录。</p>
<p><span id="approach1"></span></p>
<h2 id="方法1：创建搜索匹配一个特征的成员的方法"><a href="#方法1：创建搜索匹配一个特征的成员的方法" class="headerlink" title="方法1：创建搜索匹配一个特征的成员的方法"></a>方法1：创建搜索匹配一个特征的成员的方法</h2><p>一种简单的方法是创建几种方法。 每种方法都会搜索与一个特征（例如性别或年龄）相匹配的成员。 下面的方法将打印超过指定年龄的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsOlderThan</span><span class="params">(List&lt;Person&gt; roster, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.getAge() &gt;= age) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html">List</a>是有序<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html">Collection</a>。集合是将多个元素分组为一个单元的对象。集合用于存储，检索，操作和传达聚合数据。有关集合的更多信息，请参阅<a href="#集合">“集合”</a>路径。</p>
<p>这种方法可能会使您的应用程序变脆，这是由于引入了更新（例如更新的数据类型）而导致应用程序无法工作的可能性。假设您升级了应用程序，并更改了Person类的结构，使其包含不同的成员变量；也许该班级使用不同的数据类型或算法记录和衡量年龄。您将不得不重写许多API来适应此更改。另外，这种方法是不必要的限制。例如，如果要打印小于特定年龄的成员该怎么办？</p>
<p><span id="approach2"></span></p>
<h2 id="方法2：创建更通用的搜索方法"><a href="#方法2：创建更通用的搜索方法" class="headerlink" title="方法2：创建更通用的搜索方法"></a>方法2：创建更通用的搜索方法</h2><p>以下方法比<code>printPersonsOlderThan</code>更通用；它打印指定年龄范围内的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithinAgeRange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt;= p.getAge() &amp;&amp; p.getAge() &lt; high) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要打印指定性别或指定性别和年龄范围的组合，该怎么办？ 如果您决定更改Person类并添加其他属性（例如关系状态或地理位置）怎么办？ 尽管此方法比printPersonsOlderThan更通用，但是尝试为每个可能的搜索查询创建单独的方法仍会导致代码变脆。 相反，您可以在其他类中分隔指定要搜索标准的代码。</p>
<p><span id="approach3"></span></p>
<h2 id="方法3：在本地类中指定搜索条件代码"><a href="#方法3：在本地类中指定搜索条件代码" class="headerlink" title="方法3：在本地类中指定搜索条件代码"></a>方法3：在本地类中指定搜索条件代码</h2><p>下面的方法打印与您指定的搜索条件匹配的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersons</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, CheckPerson tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法通过调用方法<code>tester.test</code>来检查<code>List</code>参数名册中包含的每个<code>Person</code>实例是否满足<code>CheckPerson</code>参数测试器中指定的搜索条件。 如果方法<code>tester.test</code>返回一个真值，则在<code>Person</code>实例上调用方法<code>printPersons</code>。</p>
<p>要指定搜索条件，请实现CheckPerson界面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列类通过指定方法test的实现来实现CheckPerson接口。 此方法过滤在美国符合资格使用“选择性服务”的成员：如果其Person参数是男性且年龄在18至25之间，则它返回一个真值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CheckPersonEligibleForSelectiveService</span> <span class="keyword">implements</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.gender == Person.Sex.MALE &amp;&amp;</span><br><span class="line">            p.getAge() &gt;= <span class="number">18</span> &amp;&amp;</span><br><span class="line">            p.getAge() &lt;= <span class="number">25</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用此类，请创建该类的新实例并调用printPersons方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster, <span class="keyword">new</span> CheckPersonEligibleForSelectiveService());</span><br></pre></td></tr></table></figure>
<p>尽管这种方法不那么灵活（如果更改Person的结构，您不必重写方法），但是您仍然拥有其他代码：计划在应用程序中执行的每个搜索都需要一个新接口和一个本地类。 因为CheckPersonEligibleForSelectiveService实现了一个接口，所以您可以使用匿名类而不是本地类，并且无需为每次搜索声明一个新类。</p>
<p><span id="approach4"></span></p>
<h2 id="方法4：在匿名类中指定搜索条件代码"><a href="#方法4：在匿名类中指定搜索条件代码" class="headerlink" title="方法4：在匿名类中指定搜索条件代码"></a>方法4：在匿名类中指定搜索条件代码</h2><p>以下调用方法printPersons的参数之一是一个匿名类，该类过滤在美国符合资格参加选择性服务的成员：男性，年龄在18至25岁之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    <span class="keyword">new</span> CheckPerson() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p.getGender() == Person.Sex.MALE</span><br><span class="line">                &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">                &amp;&amp; p.getAge() &lt;= <span class="number">25</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这种方法减少了所需的代码量，因为您不必为要执行的每个搜索创建一个新类。 但是，考虑到CheckPerson接口仅包含一种方法，匿名类的语法非常庞大。 在这种情况下，您可以使用lambda表达式代替匿名类，如下一节所述。</p>
<p><span id="approach5"></span></p>
<h2 id="方法5：使用Lambda表达式指定搜索条件代码"><a href="#方法5：使用Lambda表达式指定搜索条件代码" class="headerlink" title="方法5：使用Lambda表达式指定搜索条件代码"></a>方法5：使用Lambda表达式指定搜索条件代码</h2><p>CheckPerson接口是功能接口。 功能接口是仅包含一种<a href="#abstract">抽象方法</a>的任何接口。 （一个功能接口可能包含一个或多个<a href="#defaultmethods">默认方法</a>或<a href="#defaultmethods-static">静态方法</a>。）由于一个功能接口仅包含一个抽象方法，因此在实现该方法时可以省略该方法的名称。 为此，您可以使用lambda表达式（而不是使用匿名类表达式），该表达式在以下方法调用中突出显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersons(</span><br><span class="line">    roster,</span><br><span class="line">    (Person p) -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>有关如何定义lambda表达式的信息，请参见<a href="#syntax">Lambda表达式的语法</a>。</p>
<p>您可以使用标准功能接口代替CheckPerson接口，从而进一步减少了所需的代码量。</p>
<p><span id="approach6"></span></p>
<h2 id="方法6：将标准功能接口与Lambda表达式一起使用"><a href="#方法6：将标准功能接口与Lambda表达式一起使用" class="headerlink" title="方法6：将标准功能接口与Lambda表达式一起使用"></a>方法6：将标准功能接口与Lambda表达式一起使用</h2><p>重新考虑CheckPerson接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CheckPerson</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person p)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的界面。 这是一个功能接口，因为它仅包含一个抽象方法。 此方法采用一个参数并返回布尔值。 该方法是如此简单，以至于在您的应用程序中定义一个方法可能不值得。 因此，JDK定义了几个标准功能接口，您可以在包java.util.function中找到它们。</p>
<p>例如，您可以使用Predicate <T>接口代替CheckPerson。 该接口包含方法boolean test（T t）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口Predicate <T>是通用接口的示例。 （有关泛型的更多信息，请参见<a href="#generics">泛型（更新）课程</a>。）泛型（例如，泛型接口）在尖括号（&lt;&gt;）中指定一个或多个类型参数。 此接口仅包含一个类型参数T。使用实际类型参数声明或实例化泛型类型时，将具有参数化类型。 例如，参数化的类型Predicate <Person>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Person t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此参数化类型包含一个方法，该方法具有与CheckPerson.boolean test（Person p）相同的返回类型和参数。 因此，可以使用Predicate <T>代替CheckPerson，如以下方法所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithPredicate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果，以下方法调用与您在<a href="#approach3">方法3中</a>调用printPersons时相同：在本地类中指定搜索条件代码以获取有资格使用选择性服务的成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">printPersonsWithPredicate(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这不是使用lambda表达式的唯一方法。 以下方法建议了使用lambda表达式的其他方法。</p>
<p><span id="approach7"></span></p>
<h2 id="方法7：在整个应用程序中使用Lambda表达式"><a href="#方法7：在整个应用程序中使用Lambda表达式" class="headerlink" title="方法7：在整个应用程序中使用Lambda表达式"></a>方法7：在整个应用程序中使用Lambda表达式</h2><p>重新考虑方法printPersonsWithPredicate，看看还能在哪里使用lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printPersonsWithPredicate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster, Predicate&lt;Person&gt; tester)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            p.printPerson();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法检查List参数名册中包含的每个Person实例是否满足Predicate参数测试器中指定的条件。如果Person实例确实满足测试人员指定的条件，则在Person实例上调用方法printPersron。</p>
<p>除了可以调用方法printPerson之外，您还可以指定其他操作来对那些满足测试人员指定条件的Person实例执行。您可以使用lambda表达式指定此操作。假设您想要一个类似于printPerson的lambda表达式，该表达式需要一个参数（Person类型的对象）并返回void。请记住，要使用lambda表达式，您需要实现一个功能接口。在这种情况下，您需要一个包含抽象方法的功能接口，该抽象方法可以采用Person类型的一个参数并返回void。 Consumer <T>接口包含具有这些特征的方法void accept（T）。以下方法将使用调用方法accept的Consumer <Person>实例替换调用p.printPerson（）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPersons</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;Person&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;Person&gt; block)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">                block.accept(p);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，以下方法调用与您在<a href="#approach3">方法3中</a>调用printPersons时相同：在本地类中指定搜索条件代码以获取符合选择性服务资格的成员。 用于打印成员的lambda表达式突出显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">processPersons(</span><br><span class="line">     roster,</span><br><span class="line">     p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">         &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">         &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">     p -&gt; p.printPerson()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果您想对会员个人资料进行更多处理而不是打印出来，该怎么办。 假设您要验证成员的个人资料或检索他们的联系信息？ 在这种情况下，您需要一个功能接口，其中包含一个返回值的抽象方法。 Function <T，R>接口包含方法R apply（T t）。 以下方法检索由参数映射器指定的数据，然后对由参数块指定的数据执行操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processPersonsWithFunction</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Person&gt; roster,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;Person&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Function&lt;Person, String&gt; mapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;String&gt; block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Person p : roster) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            String data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下方法从名册中包含有资格使用“选择性服务”的每个成员中检索电子邮件地址，然后进行打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processPersonsWithFunction(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><span id="approach8"></span></p>
<h2 id="方法8：更广泛地使用泛型"><a href="#方法8：更广泛地使用泛型" class="headerlink" title="方法8：更广泛地使用泛型"></a>方法8：更广泛地使用泛型</h2><p>重新考虑方法processPersonsWithFunction。 以下是其通用版本，该通用版本接受包含任何数据类型的元素的集合作为参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;X, Y&gt; <span class="function"><span class="keyword">void</span> <span class="title">processElements</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Iterable&lt;X&gt; source,</span></span></span><br><span class="line"><span class="function"><span class="params">    Predicate&lt;X&gt; tester,</span></span></span><br><span class="line"><span class="function"><span class="params">    Function &lt;X, Y&gt; mapper,</span></span></span><br><span class="line"><span class="function"><span class="params">    Consumer&lt;Y&gt; block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (X p : source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tester.test(p)) &#123;</span><br><span class="line">            Y data = mapper.apply(p);</span><br><span class="line">            block.accept(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要打印符合选择服务资格的成员的电子邮件地址，请按以下方式调用processElements方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">processElements(</span><br><span class="line">    roster,</span><br><span class="line">    p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">        &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">        &amp;&amp; p.getAge() &lt;= <span class="number">25</span>,</span><br><span class="line">    p -&gt; p.getEmailAddress(),</span><br><span class="line">    email -&gt; System.out.println(email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>此方法调用执行以下操作：</p>
<ol>
<li>从收集源获取对象的源。 在此示例中，它从集合名册中获取Person对象的源。 请注意，集合名册是List类型的集合，也是Iterable类型的对象。</li>
<li>筛选与谓词对象测试器匹配的对象。 在此示例中，谓词对象是一个lambda表达式，用于指定哪些成员符合选择服务的条件。</li>
<li>将每个过滤的对象映射到Function对象映射器指定的值。 在此示例中，Function对象是一个lambda表达式，该表达式返回成员的电子邮件地址。</li>
<li>对使用者对象块指定的每个映射对象执行操作。 在此示例中，Consumer对象是一个lambda表达式，该表达式输出一个字符串，该字符串是Function对象返回的电子邮件地址。</li>
</ol>
<p>您可以将这些操作中的每一个替换为聚合操作。</p>
<p><span id="approach9"></span></p>
<h2 id="方法9：使用接受Lambda表达式作为参数的聚合操作"><a href="#方法9：使用接受Lambda表达式作为参数的聚合操作" class="headerlink" title="方法9：使用接受Lambda表达式作为参数的聚合操作"></a>方法9：使用接受Lambda表达式作为参数的聚合操作</h2><p>下面的示例使用聚合操作来打印集合名册中包含的符合选择性服务资格的那些成员的电子邮件地址：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">roster</span><br><span class="line">    .stream()</span><br><span class="line">    .filter(</span><br><span class="line">        p -&gt; p.getGender() == Person.Sex.MALE</span><br><span class="line">            &amp;&amp; p.getAge() &gt;= <span class="number">18</span></span><br><span class="line">            &amp;&amp; p.getAge() &lt;= <span class="number">25</span>)</span><br><span class="line">    .map(p -&gt; p.getEmailAddress())</span><br><span class="line">    .forEach(email -&gt; System.out.println(email));</span><br></pre></td></tr></table></figure>
<p>下表映射了processElements方法使用相应的聚合操作执行的每个操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>processElements</code> Action</th>
<th>Aggregate Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obtain a source of objects</td>
<td><code>Stream&lt;E&gt; **stream**()</code></td>
</tr>
<tr>
<td>Filter objects that match a <code>Predicate</code> object</td>
<td><code>Stream&lt;T&gt; **filter**(Predicate&lt;? super T&gt; predicate)</code></td>
</tr>
<tr>
<td>Map objects to another value as specified by a <code>Function</code> object</td>
<td><code>&lt;R&gt; Stream&lt;R&gt; **map**(Function&lt;? super T,? extends R&gt; mapper)</code></td>
</tr>
<tr>
<td>Perform an action as specified by a <code>Consumer</code> object</td>
<td><code>void **forEach**(Consumer&lt;? super T&gt; action)</code></td>
</tr>
</tbody>
</table>
</div>
<p>操作filter，map和forEach是聚合操作。 聚合操作从流而不是直接从集合中处理元素（这就是在本示例中调用的第一个方法是流的原因）。 流是元素序列。 与集合不同，它不是存储元素的数据结构。 取而代之的是，流通过管道携带来自源（如集合）的值。 流水线是一系列流操作，在此示例中为filtermap-forEach。 此外，聚合操作通常接受lambda表达式作为参数，使您能够自定义它们的行为。</p>
<p>有关聚合操作的更详尽讨论，请参阅<a href="#collections-streams">“聚合操作”</a>课程。</p>
<p><span id="lambda-expressions-in-gui-applications"></span></p>
<h2 id="GUI应用程序中的Lambda表达式"><a href="#GUI应用程序中的Lambda表达式" class="headerlink" title="GUI应用程序中的Lambda表达式"></a>GUI应用程序中的Lambda表达式</h2><p>为了处理图形用户界面（GUI）应用程序中的事件，例如键盘操作，鼠标操作和滚动操作，通常需要创建事件处理程序，这通常涉及实现特定的界面。通常，事件处理程序接口是功能接口。他们往往只有一种方法。</p>
<p>在JavaFX示例<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/javafx/get-started-tutorial/hello_world.htm">HelloWorld.java</a>（在上一节<a href="#anonymousclasses">“匿名类”</a>中讨论过）中，您可以在此语句中用lambda表达式替换突出显示的匿名类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnAction(<span class="keyword">new</span> EventHandler&lt;ActionEvent&gt;() &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>方法调用btn.setOnAction指定当您选择由btn对象表示的按钮时发生的情况。此方法需要一个EventHandler <ActionEvent>类型的对象。 EventHandler <ActionEvent>接口仅包含一种方法，即void handle（T event）。此接口是功能性接口，因此您可以使用以下突出显示的lambda表达式来替换它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.setOnAction(</span><br><span class="line">    event -&gt; System.out.println(<span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><span id="syntax"></span></p>
<p><span id="accessing-local-variables"></span></p>
<p><span id="target-typing"></span></p>
<p><span id="target-types-and-method-arguments"></span></p>
<p><span id="serialization"></span></p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><h1 id="在JAR文件中打包程序"><a href="#在JAR文件中打包程序" class="headerlink" title="在JAR文件中打包程序"></a>在JAR文件中打包程序</h1><h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p>Trail：反射API<br><strong>反射的用途</strong><br>反射通常由需要检查或修改Java虚拟机中运行的应用程序的运行时行为的程序使用。这是一个相对高级的功能，只应由对语言基础有很深了解的开发人员使用。考虑到这一警告，反射是一种强大的技术，可以使应用程序执行原本不可能的操作。</p>
<p><strong>扩展功能</strong><br>应用程序可以通过使用其完全限定的名称创建可扩展性对象的实例来使用外部用户定义的类。<br><strong>类浏览器和可视化开发环境</strong><br>一个类浏览器需要能够枚举类的成员。可视化开发环境可以受益于利用反射中可用的类型信息来帮助开发人员编写正确的代码。<br><strong>调试器和测试工具</strong><br>调试器需要能够检查类的私有成员。测试工具可以利用反射来系统地调用在类上定义的可发现的集合API，以确保测试套件中的代码覆盖率很高。<br><strong>反射的缺点</strong><br>反射功能强大，但不应任意使用。如果可以在不使用反射的情况下执行操作，那么最好避免使用它。通过反射访问代码时，应牢记以下注意事项。</p>
<p><strong>性能开销</strong><br>由于反射涉及动态解析的类型，因此无法执行某些Java虚拟机优化。因此，反射操作的性能比非反射操作慢，因此应避免在对性能敏感的应用程序中经常调用的代码段中。<br><strong>安全限制</strong><br>反射需要运行时许可，而在安全管理器下运行时可能不存在。对于必须在受限的安全上下文（例如Applet）中运行的代码，这是一个重要的考虑因素。<br><strong>内部暴露</strong><br>由于反射允许代码执行在非反射代码中是非法的操作，例如访问私有字段和方法，因此使用反射可能会导致意外的副作用，这可能会使代码无法正常工作并可能破坏可移植性。反射性代码破坏了抽象，因此可能会随着平台的升级而改变行为。<br>经验教训<br>本教程介绍了反射在访问和操作类，字段，方法和构造函数方面的常见用法。每节课均包含代码示例，技巧和故障排除信息。</p>
<p><a href="#Reflect-Classes">Classes</a><br>本课显示了获取Class对象并使用它检查类的属性的各种方法，包括其声明和内容。<br><a href="#Reflect-members">Members</a><br>本课描述如何使用反射API查找类的字段，方法和构造函数。提供了用于设置和获取字段值，调用方法以及使用特定构造函数创建对象的新实例的示例。<br><a href="#Reflect-array-enum-type">Arrays和枚举类型</a><br>本课介绍了两种特殊类型的类：在运行时生成的数组和定义唯一命名对象实例的枚举类型。示例代码显示了如何检索数组的组件类型以及如何设置和获取具有数组或枚举类型的字段。</p>
<blockquote>
<p>注意：<br>本教程中的示例旨在用于尝试使用反射API。因此，异常的处理与生产代码中使用的处理不同。特别是，在生产代码中，不建议转储用户可见的堆栈跟踪。</p>
</blockquote>
<p><span id="Reflect-Classes"></span></p>
<h2 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h2><p>每种类型都是引用或原始类型。类，枚举和数组（都继承自<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">java.lang.Object</a>）以及接口都是引用类型。引用类型的示例包括<code>java.lang.String</code>，原始类型的所有包装器类，例如<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html">java.lang.Double</a>，接口<code>java.io.Serializable</code>和枚举<code>javax.swing.SortOrder</code>。有一组固定的原始类型：布尔值，字节，短型，整数，长型，字符，浮点型和双精度型。</p>
<p>对于每种类型的对象，Java虚拟机都会实例化一个不可变的<code>java.lang.Class</code>实例，该实例提供检查对象的运行时属性（包括其成员和类型信息）的方法。类还提供了创建新类和对象的能力。最重要的是，它是所有反射API的入口点。本课涵盖了最常见的涉及类的反射操作：</p>
<ul>
<li><a href="#retrieving-class-objects">检索类对象</a>描述了获取类的方法</li>
<li><a href="#Examining-Class-Modifiers-and-Types">检查类修饰符和类型</a>显示了如何访问类声明信息</li>
<li><a href="#Discovering-Class-Members">发现类成员</a>说明了如何在类中列出构造函数，字段，方法和嵌套类</li>
<li><a href="#reflect-Troubleshooting">故障排除</a>描述了使用类时遇到的常见错误</li>
</ul>
<p><span id="retrieving-class-objects"></span></p>
<h3 id="检索类对象"><a href="#检索类对象" class="headerlink" title="检索类对象"></a>检索类对象</h3><p><span id="Examining-Class-Modifiers-and-Types"></span></p>
<h3 id="检查类修饰符和类型"><a href="#检查类修饰符和类型" class="headerlink" title="检查类修饰符和类型"></a>检查类修饰符和类型</h3><p><span id="Discovering-Class-Members"></span></p>
<h3 id="发现类成员"><a href="#发现类成员" class="headerlink" title="发现类成员"></a>发现类成员</h3><p><span id="reflect-Troubleshooting"></span></p>
<h3 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h3><p><span id="Reflect-members"></span></p>
<h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><p><span id="Reflect-array-enum-type"></span></p>
<h2 id="Arrays和枚举类型"><a href="#Arrays和枚举类型" class="headerlink" title="Arrays和枚举类型"></a>Arrays和枚举类型</h2><p><span id=""></span></p>
<p><span id=""></span></p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h1 id="JavaBeans"><a href="#JavaBeans" class="headerlink" title="JavaBeans"></a>JavaBeans</h1><h1 id="扩展机制"><a href="#扩展机制" class="headerlink" title="扩展机制"></a>扩展机制</h1><h1 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-tutorials/" rel="tag"># Java-tutorials</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/23/Spring-security/" rel="prev" title="Spring-security">
      <i class="fa fa-chevron-left"></i> Spring-security
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/28/Spring-Data/" rel="next" title="Spring-Data">
      Spring-Data <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%A5%E9%97%A8"><span class="nav-number">1.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0Java%E8%AF%AD%E8%A8%80"><span class="nav-number">2.</span> <span class="nav-text">学习Java语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">面向对象编程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.1.</span> <span class="nav-text">什么是对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">什么是类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="nav-number">2.1.3.</span> <span class="nav-text">什么是继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="nav-number">2.1.4.</span> <span class="nav-text">什么是接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%85"><span class="nav-number">2.1.5.</span> <span class="nav-text">什么是包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Questions"><span class="nav-number">2.1.6.</span> <span class="nav-text">Questions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exercises"><span class="nav-number">2.1.7.</span> <span class="nav-text">Exercises</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-number">2.2.</span> <span class="nav-text">语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="nav-number">2.2.2.</span> <span class="nav-text">操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%8C%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%9D%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">表达式，语句和块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.2.4.</span> <span class="nav-text">控制流语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">2.3.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%B1%BB"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">声明类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">声明成员变量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">2.3.1.2.1.</span> <span class="nav-text">访问修饰符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A7%8D%E7%B1%BB"><span class="nav-number">2.3.1.2.2.</span> <span class="nav-text">种类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="nav-number">2.3.1.2.3.</span> <span class="nav-text">变量名</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">定义方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%94%AF%E6%8C%81"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">构造方法支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF%E7%BB%99%E6%96%B9%E6%B3%95%E6%88%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.1.5.</span> <span class="nav-text">传递信息给方法或构造方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.</span> <span class="nav-text">对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">创建对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">使用对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF"><span class="nav-number">2.3.3.</span> <span class="nav-text">有关类的更多信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">从方法返回值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">使用关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">控制类成员的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">理解类成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E6%AE%B5"><span class="nav-number">2.3.3.5.</span> <span class="nav-text">初始化字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.3.3.6.</span> <span class="nav-text">总结类和对象的创建和使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E7%B1%BB"><span class="nav-number">2.3.4.</span> <span class="nav-text">问题和练习:类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.3.5.</span> <span class="nav-text">问题和练习:对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%B1%BB"><span class="nav-number">2.3.6.</span> <span class="nav-text">嵌套类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E4%BE%8B%E5%AD%90"><span class="nav-number">2.3.6.1.</span> <span class="nav-text">内部类例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E7%B1%BB"><span class="nav-number">2.3.6.2.</span> <span class="nav-text">本地类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="nav-number">2.3.6.3.</span> <span class="nav-text">匿名类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.6.4.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB-%E6%9C%AC%E5%9C%B0%E7%B1%BB-%E5%8C%BF%E5%90%8D%E7%B1%BB-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">2.3.6.5.</span> <span class="nav-text">什么时候使用内部类,本地类,匿名类,Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.3.7.</span> <span class="nav-text">问题和练习:内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.8.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%92%8C%E7%BB%83%E4%B9%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.3.9.</span> <span class="nav-text">问题和练习:枚举类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.4.</span> <span class="nav-text">注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.</span> <span class="nav-text">接口和继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Numbers%E5%92%8CStrings"><span class="nav-number">2.6.</span> <span class="nav-text">Numbers和Strings</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">2.7.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85"><span class="nav-number">2.8.</span> <span class="nav-text">包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACJava%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">基本Java类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="nav-number">5.</span> <span class="nav-text">Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%90%86%E6%83%B3%E7%94%A8%E4%BE%8B"><span class="nav-number">5.1.</span> <span class="nav-text">Lambda表达式的理想用例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%90%9C%E7%B4%A2%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">方法1：创建搜索匹配一个特征的成员的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%9B%B4%E9%80%9A%E7%94%A8%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">方法2：创建更通用的搜索方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E5%9C%A8%E6%9C%AC%E5%9C%B0%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.4.</span> <span class="nav-text">方法3：在本地类中指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A%E5%9C%A8%E5%8C%BF%E5%90%8D%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.5.</span> <span class="nav-text">方法4：在匿名类中指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9A%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8C%87%E5%AE%9A%E6%90%9C%E7%B4%A2%E6%9D%A1%E4%BB%B6%E4%BB%A3%E7%A0%81"><span class="nav-number">5.6.</span> <span class="nav-text">方法5：使用Lambda表达式指定搜索条件代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%956%EF%BC%9A%E5%B0%86%E6%A0%87%E5%87%86%E5%8A%9F%E8%83%BD%E6%8E%A5%E5%8F%A3%E4%B8%8ELambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">5.7.</span> <span class="nav-text">方法6：将标准功能接口与Lambda表达式一起使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%957%EF%BC%9A%E5%9C%A8%E6%95%B4%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.8.</span> <span class="nav-text">方法7：在整个应用程序中使用Lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%958%EF%BC%9A%E6%9B%B4%E5%B9%BF%E6%B3%9B%E5%9C%B0%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.9.</span> <span class="nav-text">方法8：更广泛地使用泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%959%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%97Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E7%9A%84%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">5.10.</span> <span class="nav-text">方法9：使用接受Lambda表达式作为参数的聚合操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GUI%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.11.</span> <span class="nav-text">GUI应用程序中的Lambda表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">5.12.</span> <span class="nav-text">方法引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">聚合操作</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8JAR%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%93%E5%8C%85%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">在JAR文件中打包程序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">8.</span> <span class="nav-text">国际化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">9.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB-1"><span class="nav-number">9.1.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">9.1.1.</span> <span class="nav-text">检索类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%B1%BB%E4%BF%AE%E9%A5%B0%E7%AC%A6%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.1.2.</span> <span class="nav-text">检查类修饰符和类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E7%8E%B0%E7%B1%BB%E6%88%90%E5%91%98"><span class="nav-number">9.1.3.</span> <span class="nav-text">发现类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4"><span class="nav-number">9.1.4.</span> <span class="nav-text">故障排除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%88%90%E5%91%98"><span class="nav-number">9.2.</span> <span class="nav-text">成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arrays%E5%92%8C%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-number">9.3.</span> <span class="nav-text">Arrays和枚举类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">10.</span> <span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JavaBeans"><span class="nav-number">11.</span> <span class="nav-text">JavaBeans</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">扩展机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B-1"><span class="nav-number">13.</span> <span class="nav-text">泛型</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/09/24/Java-Tutorials/";
    this.page.identifier = "2020/09/24/Java-Tutorials/";
    this.page.title = "Java-Tutorials";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
