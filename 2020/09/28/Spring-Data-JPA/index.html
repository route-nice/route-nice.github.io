<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="version 2.3.4.RELEASE 前言Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-Data-JPA">
<meta property="og:url" content="http://yoursite.com/2020/09/28/Spring-Data-JPA/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="version 2.3.4.RELEASE 前言Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-28T05:39:16.000Z">
<meta property="article:modified_time" content="2020-10-12T05:44:00.410Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="Spring-Data">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/09/28/Spring-Data-JPA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring-Data-JPA | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/28/Spring-Data-JPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring-Data-JPA
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-28 13:39:16" itemprop="dateCreated datePublished" datetime="2020-09-28T13:39:16+08:00">2020-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-12 13:44:00" itemprop="dateModified" datetime="2020-10-12T13:44:00+08:00">2020-10-12</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/09/28/Spring-Data-JPA/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/28/Spring-Data-JPA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>version 2.3.4.RELEASE</p>
<p><strong>前言</strong><br>Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。</p>
<a id="more"></a>
<p><span id="project"></span></p>
<h1 id="项目元数据"><a href="#项目元数据" class="headerlink" title="项目元数据"></a>项目元数据</h1><ul>
<li>版本控制-<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-jpa">https://github.com/spring-projects/spring-data-jpa</a></li>
<li>Bugtracker-<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJPA">https://jira.spring.io/browse/DATAJPA</a></li>
<li>发布存储库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release">https://repo.spring.io/libs-release</a></li>
<li>里程碑资料库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-milestone">https://repo.spring.io/libs-milestone</a></li>
<li>快照存储库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-snapshot">https://repo.spring.io/libs-snapshot</a></li>
</ul>
<p><span id="new-features"></span></p>
<h1 id="新的和值得注意的"><a href="#新的和值得注意的" class="headerlink" title="新的和值得注意的"></a>新的和值得注意的</h1><p><span id="dependencies"></span></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>由于各个Spring Data模块的起始日期不同，因此大多数模块带有不同的主要和次要版本号。 查找兼容版本的最简单方法是依赖于我们附带定义的兼容版本的Spring Data Release Train BOM。 在Maven项目中，您可以在POM的<code>&lt;dependencyManagement /&gt;</code>部分中声明此依赖关系，如下所示：</p>
<p>例子1.使用Spring Data Release系列BOM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>Neumann-SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="dependencies.train-names"></span></p>
<p>当前的发行列车版本是Neumann-SR4。 火车名称按字母顺序升序，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">此处</a>列出了当前可用的火车。 版本名称遵循以下模式：<code>$ &#123;name&#125;-$ &#123;release&#125;</code>，其中release可以是以下之一：</p>
<ul>
<li><code>BUILD-SNAPSHOT</code>：当前快照</li>
<li><code>M1，M2</code>等：里程碑</li>
<li><code>RC1，RC2</code>等：发布候选</li>
<li><code>RELEASE</code>：GA发布</li>
<li><code>SR1，SR2</code>等：服务版本</li>
</ul>
<p>在我们的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data示例存储库</a>中可以找到使用BOM的工作示例。 有了它，您可以在<code>&lt;dependencies /&gt;</code>块中声明要使用的Spring Data模块而无需版本，如下所示：</p>
<p>例子2.声明对Spring Data模块的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="dependencies.spring-boot"></span></p>
<h2 id="使用Spring-Boot进行依赖管理"><a href="#使用Spring-Boot进行依赖管理" class="headerlink" title="使用Spring Boot进行依赖管理"></a>使用Spring Boot进行依赖管理</h2><p>Spring Boot为您选择了Spring Data模块的最新版本。 如果仍要升级到较新的版本，请将属性<code>spring-data-releasetrain.version</code>配置为要使用的<a href="#dependencies.train-names">火车名称和迭代</a>。</p>
<p><span id="dependencies.spring-framework"></span></p>
<h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><p>当前版本的Spring Data模块要求使用5.2.9.RELEASE或更高版本的Spring Framework。 这些模块也可以与该次要版本的较旧错误修正版本一起使用。 但是，强烈建议使用该版本中的最新版本。</p>
<p><span id="repositories"></span></p>
<h1 id="使用Spring数据存储库"><a href="#使用Spring数据存储库" class="headerlink" title="使用Spring数据存储库"></a>使用Spring数据存储库</h1><p>Spring数据存储库抽象的目标是显着减少实现各种持久性存储的数据访问层所需的样板代码量。</p>
<blockquote>
<p>Important</p>
<p>Spring Data Repository文档和您的模块</p>
<p>本章介绍了Spring Data存储库的核心概念和接口。 本章中的信息来自Spring Data Commons模块。 它使用Java Persistence API（JPA）模块的配置和代码示例。 您应该使XML名称空间声明和类型适应于所使用的特定模块的等效项。 <a href="#repositories.namespace-reference">“命名空间参考”</a>涵盖XML配置，所有支持存储库API的Spring Data模块均支持该配置。 <a href="#repository-query-keywords">“存储库查询关键字”</a>通常涵盖存储库抽象支持的查询方法关键字。 有关模块的特定功能的详细信息，请参阅本文档中有关该模块的章节。</p>
</blockquote>
<p><span id="repositories.core-concepts"></span></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Spring Data存储库抽象中的中央接口是<code>Repository</code>。 它需要域类以及域类的ID类型作为类型参数来进行管理。 该接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展该接口的接口。 <code>CrudRepository</code>为正在管理的实体类提供复杂的CRUD功能。</p>
<p>例子3. CrudRepository接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;      </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID primaryKey)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;                        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID primaryKey)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>保存给定的实体。</li>
<li>返回由给定ID标识的实体。</li>
<li>返回所有实体。</li>
<li>返回实体数。</li>
<li>删除给定的实体。</li>
<li>指示是否存在具有给定ID的实体。</li>
</ol>
<blockquote>
<p>我们还提供特定于持久性技术的抽象，例如<code>JpaRepository</code>或<code>MongoRepository</code>。 这些接口扩展了<code>CrudRepository</code>，并除了诸如<code>CrudRepository</code>之类的与通用技术无关的通用接口之外，还公开了基础持久性技术的功能。</p>
</blockquote>
<p>在<code>CrudRepository</code>之上，有一个<code>PagingAndSortingRepository</code>抽象，它添加了其他方法来简化对实体的分页访问：</p>
<p>例子4. PagingAndSortingRepository接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要以20页的页面大小访问<code>User</code>的第二页，您可以执行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<p>除了查询方法之外，还可以使用计数和删除查询的查询派生。 以下列表显示派生计数查询的接口定义：</p>
<p>例子5.派生计数查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下列表显示了派生的删除查询的接口定义：</p>
<p>例子6.派生的删除查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.query-methods"></span></p>
<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><p>标准CRUD功能存储库通常在基础数据存储上进行查询。 使用Spring Data，声明这些查询将分为四个步骤：</p>
<ol>
<li><p>声明扩展存储库的接口或其子接口之一，然后将其键入到它应处理的域类和ID类型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口上声明查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置Spring以使用<a href="#repositories.create-instances.java-config">JavaConfig</a>或<a href="#repositories.create-instances">XML配置</a>为这些接口创建代理实例。</p>
<ol>
<li><p>要使用Java配置，请创建类似于以下内容的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要使用XML配置，请定义类似于以下内容的bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在此示例中使用了JPA命名空间。 如果将存储库抽象用于任何其他商店，则需要将其更改为商店模块的适当名称空间声明。 换句话说，您应该将<code>jpa</code>换成<code>mongodb</code>。</p>
<p>+另外，请注意，JavaConfig变量不会显式配置程序包，因为默认情况下使用带注释的类的程序包。 要自定义要扫描的包，请使用特定于数据存储的存储库的<code>@Enable$&#123;store&#125;Repositories</code>-annotation的<code>basePackage…</code>属性之一。</p>
</li>
</ol>
</li>
<li><p>注入存储库实例并使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">&quot;Matthews&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下各节详细说明了每个步骤：</p>
<ul>
<li><a href="#repositories.definition">定义存储库接口</a></li>
<li><a href="#repositories.query-methods.details">定义查询方法</a></li>
<li><a href="#repositories.create-instances">创建存储库实例</a></li>
<li><a href="#repositories.custom-implementations">Spring数据存储库的定制实现</a></li>
</ul>
<p><span id="repositories.definition"></span></p>
<h2 id="定义Repository接口"><a href="#定义Repository接口" class="headerlink" title="定义Repository接口"></a>定义Repository接口</h2><p>首先，定义特定于域类的存储库接口。 接口必须扩展<code>Repository</code>，并且必须输入域类和ID类型。 如果要公开该域类型的CRUD方法，请扩展<code>CrudRepository</code>而不是<code>Repository</code>。</p>
<p><span id="repositories.definition-tuning"></span></p>
<h3 id="微调存储库定义"><a href="#微调存储库定义" class="headerlink" title="微调存储库定义"></a>微调存储库定义</h3><p>通常，您的存储库接口扩展了<code>Repository</code>，<code>CrudRepository</code>或<code>PagingAndSortingRepository</code>。 另外，如果您不想扩展Spring Data接口，也可以使用<code>@RepositoryDefinition</code>注解存储库接口。 扩展<code>CrudRepository</code>公开了一套完整的方法来操纵您的实体。 如果您希望对公开的方法保持选择性，请将要公开的方法从<code>CrudRepository</code>复制到域存储库中。</p>
<p>这样做可以让您在提供的Spring Data Repositories功能之上定义自己的抽象。<br>下面的示例演示如何有选择地公开CRUD方法（在这种情况下，<code>findById</code>和<code>save</code>）：</p>
<p>例子7.有选择地公开CRUD方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，您为所有域存储库定义了一个通用的基本接口，并公开了<code>findById(...)</code>和<code>save(...)</code>。这些方法被路由到Spring Data提供的所选存储的基本存储库实现中（例如，如果使用JPA，则实现为<code>SimpleJpaRepository</code>，因为它们与<code>CrudRepository</code>中的方法签名匹配。因此，<code>UserRepository</code>现在可以保存用户，按ID查找单个用户，并触发查询以按电子邮件地址查找<code>Users</code>。</p>
<blockquote>
<p>中间存储库接口使用<code>@NoRepositoryBean</code>注解。确保将注释添加到所有存储库接口，Spring Data不应在运行时为其创建实例。</p>
</blockquote>
<p><span id="repositories.multiple-modules"></span></p>
<h3 id="将存储库与多个Spring数据模块一起使用"><a href="#将存储库与多个Spring数据模块一起使用" class="headerlink" title="将存储库与多个Spring数据模块一起使用"></a>将存储库与多个Spring数据模块一起使用</h3><p>在您的应用程序中使用唯一的Spring Data模块使事情变得简单，因为已定义范围中的所有存储库接口均已绑定到Spring Data模块。有时，应用程序需要使用多个Spring Data模块。在这种情况下，存储库定义必须区分持久性技术。当它在类路径上检测到多个存储库工厂时，Spring Data进入严格的存储库配置模式。严格的配置使用存储库或域类上的详细信息来决定有关存储库定义的Spring Data模块绑定：</p>
<ol>
<li><p>如果存储库定义<a href="#repositories.multiple-modules.types">扩展了特定于模块的存储库</a>，则它是特定Spring Data模块的有效候选者。</p>
</li>
<li><p>如果域类使用模块<a href="#repositories.multiple-modules.annotations">特定的类型注解来注解</a>，则它是特定Spring Data模块的有效候选者。 Spring Data模块可以接受第三方注解（例如JPA的<code>@Entity</code>），也可以提供自己的注解（例如Spring Data MongoDB的<code>@Document</code>和Spring Data Elasticsearch）。</p>
</li>
</ol>
<p><span id="repositories.multiple-modules.types"></span></p>
<p>以下示例显示了使用模块特定接口（在这种情况下为JPA）的存储库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>MyRepository</code>和<code>UserRepository</code>在其类型层次结构中扩展了<code>JpaRepository</code>。 它们是Spring Data JPA模块的有效候选者。</p>
<p>以下示例显示了使用通用接口的存储库：</p>
<p>示例9.使用通用接口的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>仅在其类型层次结构中扩展<code>Repository</code>和<code>CrudRepository</code>。 尽管在使用唯一的Spring Data模块时这很好，但是多个模块无法区分这些存储库应绑定到哪个特定的Spring Data。</p>
<p>以下示例显示了使用带注解的域类的存储库：</p>
<p><span id="repositories.multiple-modules.annotations"></span></p>
<p>例子10.使用带有注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>PersonRepository</code>引用使用JPA <code>@Entity</code>注解进行注解的Person，因此该存储库显然属于Spring Data JPA。 <code>UserRepository</code>引用用户，该用户使用Spring Data MongoDB的<code>@Document</code>注解进行注解。</p>
<p>以下不良示例显示了使用带有混合注解的域类的存储库：</p>
<p>例子11.使用带有混合注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此示例显示了同时使用JPA和Spring Data MongoDB注解的域类。它定义了两个存储库，<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>。一个用于JPA，另一个用于MongoDB。 Spring Data不再能够区分存储库，这导致不确定的行为。</p>
</blockquote>
<p><a href="#repositories.multiple-modules.types">存储库类型详细信息</a>和<a href="#repositories.multiple-modules.annotations">可区分的域类注解</a>用于严格的存储库配置，以标识特定Spring Data模块的存储库候选对象。在同一个域类型上使用多个特定于持久性技术的注解是可能的，并且可以跨多种持久性技术重用域类型。但是，Spring Data无法再确定用于绑定存储库的唯一模块。</p>
<p>区分存储库的最后一种方法是确定存储库基础包的范围。基本软件包定义了扫描存储库接口定义的起点，这意味着将存储库定义放在适当的软件包中。默认情况下，注解驱动的配置使用配置类的包。<a href="#repositories.create-instances.spring">基于XML的配置</a>中的基本软件包是必需的。</p>
<p>以下示例显示了基础包的注解驱动配置：</p>
<p>例子12.基础包的注解驱动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.query-methods.details"></span></p>
<h2 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h2><p>存储库代理有两种从方法名称派生特定于储存的查询的方式：</p>
<ul>
<li><p>通过直接从方法名称派生查询。</p>
</li>
<li><p>通过使用手动定义的查询。</p>
</li>
</ul>
<p>可用选项取决于实际存储。但是，必须有一个策略来决定要创建的实际查询。下一节将介绍可用的选项。</p>
<p><span id="repositories.query-methods.query-lookup-strategies"></span></p>
<h3 id="查询查找策略"><a href="#查询查找策略" class="headerlink" title="查询查找策略"></a>查询查找策略</h3><p>以下策略可用于存储库基础结构来解决查询。使用XML配置，您可以通过<code>query-lookup-strategy</code>属性在名称空间中配置策略。对于Java配置，可以使用<code>Enable$&#123;store&#125;Repositories</code>注解的<code>queryLookupStrategy</code>属性。某些数据存储可能不支持某些策略。</p>
<ul>
<li><code>CREATE</code>尝试从查询方法名称构造特定于存储的查询。通用方法是从方法名称中删除一组给定的众所周知的前缀，然后解析该方法的其余部分。您可以在<a href="#repositories.query-methods.query-creation">“查询创建”</a>中阅读有关查询构造的更多信息。</li>
<li><code>USE_DECLARED_QUERY</code>尝试查找已声明的查询，如果找不到则抛出异常。该查询可以通过某处的注解定义，也可以通过其他方式声明。请查阅特定存储的文档以找到该商店的可用选项。如果存储库基础结构在引导时找不到该方法的声明查询，则它将失败。</li>
<li><code>CREATE_IF_NOT_FOUND</code>（默认）结合了<code>CREATE</code>和<code>USE_DECLARED_QUERY</code>。它首先查找一个声明的查询，如果找不到声明的查询，它将创建一个基于名称的自定义方法查询。这是默认的查找策略，因此，如果未显式配置任何内容，则使用该策略。它允许通过方法名称快速定义查询，还可以通过根据需要引入已声明的查询来自定义调整这些查询。</li>
</ul>
<p><span id="repositories.query-methods.query-creation"></span></p>
<h3 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h3><p>内置于Spring Data存储库基础结构中的查询生成器机制对于在存储库实体上构建约束查询很有用。该机制从方法中剥离前缀<code>find ... By</code>，<code>read...By</code>，<code>query ... By</code>，<code>count ... By</code>和<code>get ... By</code>，然后开始解析其余部分。 Introduction子句可以包含其他表达式，例如<code>Distinct</code>，用于在要创建的查询上设置不同的标志。但是，第一个By用作分隔符，以指示实际标准的开始。在最基本的级别上，您可以定义实体属性的条件，并将其与<code>And</code>和<code>Or</code>串联。以下示例显示了如何创建许多查询：</p>
<p>例子13.从方法名查询创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析该方法的实际结果取决于您为其创建查询的持久性存储。但是，需要注意一些一般事项：</p>
<ul>
<li><p>表达式通常是属性遍历，并带有可串联的运算符。您可以将属性表达式与<code>AND</code>和<code>OR</code>结合使用。您还将获得属性表达式的支持，例如<code>between</code>，<code>LessThan</code>，<code>GreaterThan</code>和<code>Like</code>。支持的运算符可能因数据存储而异，因此请参考参考文档的相应部分。</p>
</li>
<li><p>方法解析器支持为单个属性（例如，<code>findByLastnameIgnoreCase（…）</code>）或支持忽略大小写的类型的所有属性（通常为String实例，例如，<code>findByLastnameAndFirstnameAllIgnoreCase(...)</code>）设置<code>IgnoreCase</code>标志。是否支持忽略大小写可能因商店而异，因此请参考参考文档中有关存储特定查询方法的相关部分。</p>
</li>
<li><p>您可以通过将<code>OrderBy</code>子句附加到引用属性的查询方法并提供排序方向（<code>Asc</code>或<code>Desc</code>）来应用静态排序。要创建支持动态排序的查询方法，请参见<a href="#repositories.special-parameters">“特殊参数处理”</a>。</p>
</li>
</ul>
<p><span id="repositories.query-methods.query-property-expressions"></span></p>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>如上例所示，属性表达式只能引用被管实体的直接属性。在查询创建时，您已经确保已解析的属性是托管域类的属性。但是，您也可以通过遍历嵌套属性来定义约束。考虑以下方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>假设<code>Person</code>的<code>Address</code>带有<code>ZipCode</code>。在这种情况下，该方法将创建遍历属性<code>x.address.zipCode</code>。解析算法首先将整个部分（<code>AddressZipCode</code>）解释为属性，然后在域类中检查具有该名称的属性（未大写）。如果算法成功，它将使用该属性。如果不是，该算法将骆驼箱部分的源从右侧分为头和尾，并尝试找到对应的属性，在我们的示例中为<code>AddressZip</code>和<code>Code</code>。如果该算法找到了具有该头部的属性，则将其取为尾部，并继续从此处开始构建树，以刚才描述的方式将尾部向上拆分。如果第一个拆分不匹配，则算法将拆分点移到左侧（地址，邮政编码）并继续。</p>
<p>尽管这在大多数情况下应该可行，但算法可能会选择错误的属性。假设<code>Person</code>类也具有<code>addressZip</code>属性。该算法将在第一个拆分回合中匹配，选择错误的属性，然后失败（因为<code>addressZip</code>的类型可能没有代码属性）。</p>
<p>要解决这种歧义，您可以在方法名称中使用_来手动定义遍历点。因此，我们的方法名称如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为我们将下划线字符视为保留字符，所以我们强烈建议您遵循以下标准Java命名约定（即，在属性名称中不使用下划线，而使用驼峰大小写）。</p>
<p><span id="repositories.special-parameters"></span></p>
<h3 id="特殊参数处理"><a href="#特殊参数处理" class="headerlink" title="特殊参数处理"></a>特殊参数处理</h3><p>要处理查询中的参数，请定义方法参数，如前面的示例所示。除此之外，基础架构还可以识别某些特定类型，例如<code>Pageable</code>和<code>Sort</code>，以将分页和排序动态应用于您的查询。下面的示例演示了这些功能：</p>
<p>例子14.在查询方法中使用<code>Pageable</code>，<code>Slice</code>和<code>Sort</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用<code>Sort</code>和<code>Pageable</code>的API期望将非<code>null</code>值传递到方法中。如果您不想应用任何排序或分页，请使用<code>Sort.unsorted()</code>和<code>Pageable.unpaged()</code>。</p>
</blockquote>
<p>第一种方法使您可以将<code>org.springframework.data.domain.Pageable</code>实例传递给查询方法，以将分页动态添加到静态定义的查询中。页面了解可用元素和页面的总数。它是通过基础结构触发计数查询来计算总数来实现的。由于这可能很昂贵（取决于所使用的商店），因此您可以改为返回<code>Slice</code>。切片仅知道下一个切片是否可用，当遍历较大的结果集时这可能就足够了。</p>
<p>排序选项也通过<code>Pageable</code>实例处理。如果只需要排序，则将<code>org.springframework.data.domain.Sort</code>参数添加到您的方法中。如您所见，返回列表也是可能的。在这种情况下，将不会创建构建实际的<code>Page</code>实例所需的其他元数据（这反过来意味着不会发出本来必要的其他计数查询）。而是，它将查询限制为仅查找给定范围的实体。</p>
<blockquote>
<p>要查明整个查询可获得多少页，您必须触发另一个计数查询。默认情况下，此查询源自您实际触发的查询。</p>
</blockquote>
<p><span id="repositories.paging-and-sorting"></span></p>
<h4 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h4><p>可以使用属性名称定义简单的排序表达式。可以将表达式连接起来，以将多个条件收集到一个表达式中。</p>
<p>例子15.定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"></span><br><span class="line">Sort sort = person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>
<p>对于定义排序表达式的类型安全性更高的方法，请从该类型开始为定义排序表达式，然后使用方法引用来定义要进行排序的属性。</p>
<p>例子16.使用类型安全的API定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"></span><br><span class="line">Sort sort = person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TypedSort.by（…）通常通过使用CGlib来使用运行时代理，当使用Graal VM Native等工具时，CGlib可能会干扰本机映像的编译。<br>如果您的商店实现支持Querydsl，则还可以使用生成的元模型类型来定义排序表达式：</p>
</blockquote>
<p>例子17.使用Querydsl API定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSort sort = QSort.by(QPerson.firstname.asc())</span><br><span class="line">  .and(QSort.by(QPerson.lastname.desc()));</span><br></pre></td></tr></table></figure>
<p><span id="repositories.limit-query-result"></span></p>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>可以通过使用<code>first</code>或<code>top</code>关键字来限制查询方法的结果，它们可以互换使用。可以将可选的数值附加到顶部或顶部，以指定要返回的最大结果大小。如果省略该数字，则假定结果大小为1。以下示例显示了如何限制查询大小：</p>
<p>例子18.用<code>Top</code>和<code>First</code>限制查询的结果大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<p>限制表达式还支持<code>Distinct</code>关键字。此外，对于将结果集限制为一个实例的查询，支持使用<code>Optional</code>关键字将结果包装到其中。</p>
<p>如果将分页或切片应用于限制查询分页（以及对可用页面数的计算），则会在限制结果内应用分页或切片。</p>
<blockquote>
<p>通过使用Sort参数来限制结果与动态排序的组合，可以让您表达对最小的“ K”元素和对“ K”的最大元素的查询方法。</p>
</blockquote>
<p><span id="repositories.collections-and-iterables"></span></p>
<h3 id="存储库方法返回集合或可迭代对象"><a href="#存储库方法返回集合或可迭代对象" class="headerlink" title="存储库方法返回集合或可迭代对象"></a>存储库方法返回集合或可迭代对象</h3><p>返回多个结果的查询方法可以使用标准的Java <code>Iterable，List，Set</code>。除此之外，我们还支持返回Spring Data的<code>Streamable</code>，<code>Iterable</code>的自定义扩展以及<a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>提供的集合类型。</p>
<p><span id="repositories.collections-and-iterables.streamable"></span></p>
<h4 id="使用Streamable作为查询方法返回类型"><a href="#使用Streamable作为查询方法返回类型" class="headerlink" title="使用Streamable作为查询方法返回类型"></a>使用Streamable作为查询方法返回类型</h4><p><code>Streamable</code>可用作<code>Iterable</code>或任何集合类型的替代。它提供了方便的方法来访问非并行流（缺少Iterable），能够直接在元素上进行<code>….filter(...)</code>和<code>….map(...)</code>并将<code>Streamable</code>连接到其他元素：</p>
<p>例子19.使用Streamable合并查询方法结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByFirstnameContaining</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByLastnameContaining</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Streamable&lt;Person&gt; result = repository.findByFirstnameContaining(<span class="string">&quot;av&quot;</span>)</span><br><span class="line">  .and(repository.findByLastnameContaining(<span class="string">&quot;ea&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><span id="repositories.collections-and-iterables.streamable-wrapper"></span></p>
<h4 id="返回自定义流式包装器类型"><a href="#返回自定义流式包装器类型" class="headerlink" title="返回自定义流式包装器类型"></a>返回自定义流式包装器类型</h4><p>为集合提供专用的包装器类型是一种常用的模式，用于在返回多个元素的查询执行结果上提供API。通常，这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的。如果Spring Data允许这些包装器类型满足以下条件，则可以避免使用这些包装器类型作为查询方法返回类型：</p>
<ol>
<li><p>该类型实现<code>Streamable</code>。</p>
</li>
<li><p>该类型以<code>Streamable</code>作为参数公开构造函数或名为<code>of(...)</code>或<code>valueOf(...)</code>的静态工厂方法。</p>
</li>
</ol>
<p>示例用例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123; <span class="number">1</span></span><br><span class="line">  <span class="function">MonetaryAmount <span class="title">getPrice</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">Product</span>&gt; </span>&#123; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Streamable&lt;Product&gt; streamable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MonetaryAmount <span class="title">getTotal</span><span class="params">()</span> </span>&#123; <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> streamable.stream() <span class="comment">//</span></span><br><span class="line">      .map(Priced::getPrice)</span><br><span class="line">      .reduce(Money.of(<span class="number">0</span>), MonetaryAmount::add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Products <span class="title">findAllByDescriptionContaining</span><span class="params">(String text)</span></span>; <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>公开API以访问产品价格的产品实体。</li>
<li>可以通过<code>Products.of(...)</code>（通过Lombok注解创建的工厂方法）构造的<code>Streamable &lt;Product&gt;</code>的包装器类型。</li>
<li>包装器类型在<code>Streamable &lt;Product&gt;</code>上公开其他用于计算新值的API。</li>
<li>该包装器类型可以直接用作查询方法返回类型。无需返回<code>Stremable &lt;Product&gt;</code>并将其手动包装在存储库客户端中。</li>
</ol>
<p><span id="repositories.collections-and-iterables.vavr"></span></p>
<h4 id="支持Vavr集合"><a href="#支持Vavr集合" class="headerlink" title="支持Vavr集合"></a>支持Vavr集合</h4><p><a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>是一个包含Java功能编程概念的库。它附带了一组自定义的收集类型，可用作查询方法返回类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Vavr collection type</th>
<th style="text-align:left">Used Vavr implementation type</th>
<th style="text-align:left">Valid Java source types</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Seq</code></td>
<td style="text-align:left"><code>io.vavr.collection.List</code></td>
<td style="text-align:left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Set</code></td>
<td style="text-align:left"><code>io.vavr.collection.LinkedHashSet</code></td>
<td style="text-align:left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Map</code></td>
<td style="text-align:left"><code>io.vavr.collection.LinkedHashMap</code></td>
<td style="text-align:left"><code>java.util.Map</code></td>
</tr>
</tbody>
</table>
</div>
<p>第一列中的类型（或其子类型）可以用作查询方法返回类型，并将根据实际查询结果的Java类型（第三列）获取第二列中的类型作为实现类型。或者，可以声明<code>Traversable</code>（等效于Vavr <code>Iterable</code>），然后从实际返回值派生实现类，即<code>java.util.List</code>将被转换为Vavr List / Seq，而java.util.Set变为Vavr <code>LinkedHashSet</code>/<code>Set</code>等</p>
<p><span id="repositories.nullability"></span></p>
<p>从Spring Data 2.0开始，返回单个聚合实例的存储库CRUD方法使用Java 8的<code>Optional</code>来指示可能缺少值。 除此之外，Spring Data支持在查询方法上返回以下包装器类型：</p>
<ul>
<li><code>com.google.common.base.Optional</code></li>
<li><code>scala.Option</code></li>
<li><code>io.vavr.control.Option</code></li>
</ul>
<p>另外，查询方法可以选择根本不使用包装器类型。 然后，通过返回null来指示是否缺少查询结果。 保证返回集合，集合替代项，包装器和流的存储库方法永远不会返回<code>null</code>，而是会返回相应的空表示形式。 有关详细信息，请参见<a href="#repository-query-return-types">“存储库查询返回类型”</a>。</p>
<p><span id="repositories.nullability.annotations"></span></p>
<h4 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h4><p>您可以使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#Null-safety">Spring Framework的可空性注解</a>来表达存储库方法的可空性约束。它们提供了一种工具友好的方法，并且在运行时提供了选择加入的空检查，如下所示：</p>
<ul>
<li><code>@NonNullApi</code>：在包级别用于声明参数和返回值的默认行为是不接受或产生空值。</li>
<li><code>@NonNull</code>：用于不能为空的参数或返回值（<code>@NonNullApi</code>适用的参数和返回值不需要）。</li>
<li><code>@Nullable</code>：用于可以为空的参数或返回值。</li>
</ul>
<p>Spring注解使用<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注解（休眠但分布广泛的JSR）进行元注解。 JSR 305元注解使工具供应商（例如<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>，<a target="_blank" rel="noopener" href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a>和<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a>）以通用方式提供了空安全支持，而不必对Spring注解进行硬编码支持。为了对查询方法的可空性约束进行运行时检查，您需要使用package-info.java中的Spring的<code>@NonNullApi</code>在包级别激活非空性，如以下示例所示：</p>
<p>例子20.在package-info.java中声明不可为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi</span><br><span class="line"><span class="keyword">package</span> com.acme;</span><br></pre></td></tr></table></figure>
<p>一旦设置了非null的默认值，就可以在运行时验证存储库查询方法的调用是否具有可空性约束。如果查询执行结果违反了定义的约束，则会引发异常。当该方法返回null但被声明为不可为null时（在存储库所在的包中定义了注解的默认值），就会发生这种情况。如果要再次选择接受可为空的结果，请在各个方法上有选择地使用<code>@Nullable</code>。使用本节开头提到的结果包装器类型可以按预期继续工作：将空结果转换为表示缺席的值。</p>
<p>以下示例显示了刚才描述的许多技术：</p>
<p>例子21.使用不同的可空性约束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme;             <span class="number">1</span>                                          </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;          <span class="number">2</span>          </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span></span>;    <span class="number">3</span>      </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;User&gt; <span class="title">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>; <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.nullability.kotlin"></span></p>
<h4 id="Nullability-in-Kotlin-based-Repositories"><a href="#Nullability-in-Kotlin-based-Repositories" class="headerlink" title="Nullability in Kotlin-based Repositories"></a>Nullability in Kotlin-based Repositories</h4><p>Kotlin定义了语言中包含的<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">可空性约束</a>。 Kotlin代码编译为字节码，该字节码不通过方法签名来表达可空性约束，而是通过内置的元数据来表达。请确保在您的项目中包含<code>kotlin-reflect</code>的JAR，以对Kotlin的可空性约束进行自省。 Spring Data存储库使用语言机制来定义这些约束以应用相同的运行时检查，如下所示：</p>
<p>例子22.在Kotlin仓库上使用可空性约束</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> : <span class="type">Repository</span>&lt;<span class="type">User, String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByUsername</span><span class="params">(username: <span class="type">String</span>)</span></span>: User     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByFirstname</span><span class="params">(firstname: <span class="type">String</span>?)</span></span>: User? <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>该方法将参数和结果都定义为不可为空（Kotlin默认值）。 Kotlin编译器拒绝将null传递给方法的方法调用。如果查询执行产生空结果，则抛出<code>EmptyResultDataAccessException</code>。</li>
<li>此方法的<code>firstname</code>参数接受<code>null</code>，如果查询执行未产生结果，则返回<code>null</code>。</li>
</ol>
<p><span id="repositories.query-streaming"></span></p>
<h3 id="流查询结果"><a href="#流查询结果" class="headerlink" title="流查询结果"></a>流查询结果</h3><p>通过使用Java 8 <code>Stream&lt;T&gt;</code>作为返回类型，可以递增地处理查询方法的结果。 并非将查询结果包装在<code>Stream</code>中，而是使用特定于数据存储的方法来执行流传输，如以下示例所示：</p>
<p>例子23.用Java 8 <code>Stream&lt;T&gt;</code>流查询的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Stream</code>可能包装了特定于底层数据存储的资源，因此必须在使用后关闭。 您可以使用<code>close()</code>方法或使用Java 7 <code>try-with-resources</code>块来手动关闭<code>Stream</code>，如以下示例所示：</p>
</blockquote>
<p>例子24.使用<code>Stream&lt;T&gt;</code>导致<code>try-with-resources</code>块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前，并非所有的Spring Data模块都支持Stream <T>作为返回类型。</p>
</blockquote>
<p><span id="repositories.query-async"></span></p>
<h3 id="异步查询结果"><a href="#异步查询结果" class="headerlink" title="异步查询结果"></a>异步查询结果</h3><p>使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/#任务执行和调度">Spring的异步方法执行功能</a>，可以异步运行存储库查询。 这意味着该方法在调用时立即返回，而实际查询执行发生在已提交给Spring <code>TaskExecutor</code>的任务中。 异步查询执行与反应式查询执行不同，因此不应混为一谈。 有关响应式支持的更多详细信息，请参阅商店特定的文档。 以下示例显示了许多异步查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>;               </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;    </span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>java.util.concurrent.Future</code>作为返回类型。</li>
<li>使用Java 8 <code>java.util.concurrent.CompletableFuture</code>作为返回类型。</li>
<li>使用<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型。</li>
</ol>
<p><span id="repositories.create-instances"></span></p>
<h2 id="创建Repository实例"><a href="#创建Repository实例" class="headerlink" title="创建Repository实例"></a>创建Repository实例</h2><p>在本部分中，将为已定义的存储库接口创建实例和Bean定义。 一种方法是使用支持存储库机制的每个Spring Data模块随附的Spring名称空间，尽管我们通常建议使用Java配置。</p>
<p><span id="repositories.create-instances.spring"></span></p>
<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>每个Spring Data模块都包含一个<code>repositories</code>元素，可用于定义Spring会为您扫描的基本软件包，如以下示例所示：</p>
<p>例子25.通过XML启用Spring Data仓库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns:beans</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，指示Spring扫描<code>com.acme.repositories</code>及其所有子包，以查找扩展<code>Repository</code>的接口或其子接口之一。对于找到的每个接口，基础结构都会注册特定于持久性技术的<code>FactoryBean</code>，以创建处理查询方法调用的适当代理。每个bean都使用从接口名称派生的bean名称进行注册，因此<code>UserRepository</code>的接口将注册在<code>userRepository</code>下。 <code>base-package</code>属性允许使用通配符，以便您可以定义扫描程序包的模式。</p>
<p><span id=""></span></p>
<p><strong>使用过滤器</strong><br>默认情况下，基础架构会拾取扩展位于配置的基本包下的特定于持久性技术的<code>Repository</code>子接口的每个接口，并为其创建一个bean实例。 但是，您可能希望更精细地控制哪些接口具有为其创建的Bean实例。 为此，请在<code>&lt;repositories /&gt;</code>元素内使用<code>&lt;include-filter /&gt;</code>和<code>&lt;exclude-filter /&gt;</code>元素。 语义完全等同于Spring的上下文命名空间中的元素。 有关详细信息，请参见这些元素的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#使用过滤器自定义扫描">Spring参考文档</a>。</p>
<p>例如，要将某些接口从实例中排除为存储库Bean，可以使用以下配置：</p>
<p>例子26.使用exclude-filter元素</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;.*SomeRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面的示例排除了实例化以<code>SomeRepository</code>结尾的所有接口。</p>
</blockquote>
<p><span id="repositories.create-instances.java-config"></span></p>
<h3 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h3><p>还可以通过在JavaConfig类上使用特定于商店的<code>@Enable$&#123;store&#125;Repositories</code>注解来触发存储库基础结构。 有关Spring容器的基于Java的配置的介绍，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#基于Java的容器配置">Spring参考文档中的JavaConfig</a>。</p>
<p>启用Spring数据存储库的示例配置类似于以下内容：</p>
<p>例子27.基于样本注释的存储库配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(&quot;com.acme.repositories&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function">EntityManagerFactory <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面的示例使用特定于JPA的注解，您将根据实际使用的商店模块对其进行更改。 这同样适用于<code>EntityManagerFactory</code> bean的定义。 请参阅有关商店特定配置的部分。</p>
</blockquote>
<p><span id="repositories.create-instances.standalone"></span></p>
<h3 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h3><p>您还可以在Spring容器之外使用存储库基础结构，例如在CDI环境中。 您的类路径中仍然需要一些Spring库，但是，通常，您也可以通过编程方式来设置存储库。 提供存储库支持的Spring Data模块附带了特定于持久性技术的RepositoryFactory，您可以按以下方式使用它：</p>
<p>例子28.仓库工厂的独立使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RepositoryFactorySupport factory = … <span class="comment">// Instantiate factory here</span></span><br><span class="line">UserRepository repository = factory.getRepository(UserRepository.class);</span><br></pre></td></tr></table></figure>
<p><span id="repositories.custom-implementations"></span></p>
<h2 id="Spring-Data-Repositories的自定义实现"><a href="#Spring-Data-Repositories的自定义实现" class="headerlink" title="Spring Data Repositories的自定义实现"></a>Spring Data Repositories的自定义实现</h2><p>本节介绍存储库定制以及片段如何形成复合存储库。</p>
<p>当查询方法需要不同的行为或无法通过查询派生实现时，则有必要提供自定义实现。 Spring Data存储库使您可以提供自定义存储库代码，并将其与通用CRUD抽象和查询方法功能集成。</p>
<p><span id="repositories.single-repository-behavior"></span></p>
<h3 id="自定义单个存储库"><a href="#自定义单个存储库" class="headerlink" title="自定义单个存储库"></a>自定义单个存储库</h3><p>要使用自定义功能丰富存储库，必须首先定义片段接口和自定义功能的实现，如以下示例所示：</p>
<p>例子29.定制仓库功能的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子30.定制仓库功能的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与片段接口相对应的类名称中最重要的部分是<code>Impl</code>后缀。</p>
</blockquote>
<p>实现本身不依赖于Spring Data，可以是常规的Spring bean。因此，您可以使用标准的依赖项注入行为来注入对其他bean（例如<code>JdbcTemplate</code>）的引用，参与各个方面，等等。</p>
<p>然后，可以让您的存储库接口扩展片段接口，如以下示例所示：</p>
<p>示例31.对您的存储库界面的更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将片段接口扩展为您的存储库接口，将CRUD和自定义功能结合在一起，并使它可用于客户端。</p>
<p>Spring Data存储库是通过使用构成存储库组成的片段来实现的。片段是基础存储库，功能方面（例如<a href="#core.extensions.querydsl">QueryDsl</a>）以及自定义接口及其实现。每次向存储库接口添加接口时，都通过添加片段来增强组合。每个Spring Data模块都提供了基础存储库和存储库方面的实现。</p>
<p>以下示例显示了自定义接口及其实现：</p>
<p>例子32.片段及其实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">anotherContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">anotherContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示了扩展CrudRepository的自定义存储库的接口：</p>
<p>例子33.对您的存储库界面的更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">HumanRepository</span>, <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储库可能由多个自定义实现组成，这些自定义实现按其声明顺序导入。定制实现比基础实现和存储库方面的优先级更高。通过此排序，可以覆盖基本存储库和方面方法，并在两个片段贡献相同方法签名的情况下解决歧义。存储库片段不限于在单个存储库界面中使用。多个存储库可以使用片段接口，使您可以跨不同的存储库重用自定义项。</p>
<p>以下示例显示了存储库片段及其实现：</p>
<p>例子34.覆盖<code>save(...)</code>的片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedSaveImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示了使用上述存储库片段的存储库：</p>
<p>例子35.定制的仓库接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置</strong><br>如果使用名称空间配置，则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段。这些类需要遵循将命名空间元素的<code>repository-impl-postfix</code>属性附加到片段接口名称的命名约定。此后缀默认为<code>Impl</code>。以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库：</p>
<p>例子36.配置例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> <span class="attr">repository-impl-postfix</span>=<span class="string">&quot;MyPostfix&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上一示例中的第一个配置尝试查找一个名为<code>com.acme.repository.CustomizedUserRepositoryImpl</code>的类，以用作自定义存储库实现。 第二个示例尝试查找<code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>。</p>
<p><strong>解决歧义</strong><br>如果在不同的包中找到具有匹配类名的多个实现，Spring Data将使用Bean名称来标识要使用的那个。</p>
<p>给定前面显示的<code>CustomizedUserRepository</code>的以下两个自定义实现，将使用第一个实现。 它的bean名称是<code>customizedUserRepositoryImpl</code>，它与片段接口（<code>CustomizedUserRepository</code>）加上后缀<code>Impl</code>的名称匹配。</p>
<p>例子37.歧义实现的解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme.impl.one;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme.impl.two;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;specialCustomImpl&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>@Component(&quot;specialCustom&quot;)</code>注解<code>UserRepository</code>接口，则Bean名称加<code>Impl</code>会与<code>com.acme.impl.two</code>中为存储库实现定义的一个匹配，并使用它代替第一个。</p>
<p><span id="repositories.manual-wiring"></span></p>
<p><strong>手动接线</strong><br>如果您的自定义实现仅使用基于注解的配置和自动装配，则上述显示的方法可以很好地工作，因为它被视为其他任何Spring bean。 如果您的实现片段bean需要特殊的接线，则可以声明bean并根据上一节中描述的约定对其进行命名。 然后，基础结构通过名称引用手动定义的bean定义，而不是自己创建一个。 以下示例显示如何手动连接自定义实现：</p>
<p>例子38.手工连接定制实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-<span class="keyword">package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans:bean id=<span class="string">&quot;userRepositoryImpl&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;…&quot;</span>&gt;</span><br><span class="line">  &lt;!-- further configuration --&gt;</span><br><span class="line">&lt;/beans:bean&gt;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.customize-base-repository"></span></p>
<h3 id="自定义基础存储库"><a href="#自定义基础存储库" class="headerlink" title="自定义基础存储库"></a>自定义基础存储库</h3><p>当您要自定义基本存储库行为时，<a href="#repositories.manual-wiring">上一节</a>中描述的方法需要自定义每个存储库接口，以使所有存储库均受到影响。 要改为更改所有存储库的行为，您可以创建一个实现，以扩展特定于持久性技术的存储库基类。 然后，该类充当存储库代理的自定义基类，如以下示例所示：</p>
<p>例子39.定制存储库基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  MyRepositoryImpl(JpaEntityInformation entityInformation,</span><br><span class="line">                          EntityManager entityManager) &#123;</span><br><span class="line">    <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该类需要具有特定于存储库的存储库工厂实现使用的超类的构造函数。如果存储库基类具有多个构造函数，则覆盖一个采用<code>EntityInformation</code>加上存储特定基础结构对象（例如<code>EntityManager</code>或模板类）的构造函数。</p>
</blockquote>
<p>最后一步是使Spring Data基础结构了解定制的存储库基类。在Java配置中，可以使用<code>@Enable$&#123;store&#125;Repositories</code>注解的<code>repositoryBaseClass</code>属性来实现，如以下示例所示：</p>
<p>例子40.使用JavaConfig配置一个定制的仓库基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>XML名称空间中提供了相应的属性，如以下示例所示：</p>
<p>例子41.使用XML配置一个定制的存储库基类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">base-class</span>=<span class="string">&quot;….MyRepositoryImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="core.domain-events"></span></p>
<h2 id="从Aggregate-Roots发布事件"><a href="#从Aggregate-Roots发布事件" class="headerlink" title="从Aggregate Roots发布事件"></a>从Aggregate Roots发布事件</h2><p>由存储库管理的实体是聚合根。在域驱动的设计应用程序中，这些聚合根通常发布域事件。 Spring Data提供了一个称为<code>@DomainEvents</code>的注解，您可以在聚合根的方法上使用该注解，以使该发布尽可能容易，如以下示例所示：</p>
<p>例子42.从聚合根公开域事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnAggregateRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DomainEvents</span> <span class="number">1</span></span><br><span class="line">    <span class="function">Collection&lt;Object&gt; <span class="title">domainEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// … return events you want to get published here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterDomainEventPublication</span> <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// … potentially clean up domain events list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用@DomainEvents的方法可以返回单个事件实例或事件集合。它不能接受任何参数。</li>
<li>在发布所有事件之后，我们有一个用<code>@AfterDomainEventPublication</code>注解的方法。它可以用来潜在地清除要发布的事件列表（以及其他用途）。</li>
</ol>
<p>每当调用Spring Data存储库的<code>save(...)</code>方法之一时，就会调用这些方法。</p>
<p><span id="core.extensions"></span></p>
<h2 id="Spring-Data扩展"><a href="#Spring-Data扩展" class="headerlink" title="Spring Data扩展"></a>Spring Data扩展</h2><p>本节记录了一组Spring Data扩展，这些扩展允许在各种上下文中使用Spring Data。 当前，大多数集成都针对Spring MVC。</p>
<p><span id="core.extensions.querydsl"></span></p>
<h3 id="Querydsl扩展"><a href="#Querydsl扩展" class="headerlink" title="Querydsl扩展"></a>Querydsl扩展</h3><p><a target="_blank" rel="noopener" href="http://www.querydsl.com/">Querydsl</a>是一个框架，可通过其流畅的API来构造静态类型的类似SQL的查询。</p>
<p>几个Spring Data模块通过<code>QuerydslPredicateExecutor</code>提供了与Querydsl的集成，如以下示例所示：</p>
<p>例子43. QuerydslPredicateExecutor接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(Predicate predicate)</span></span>;  </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Predicate predicate)</span></span>;            </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Predicate predicate)</span></span>;        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>查找并返回与<code>Predicate</code>匹配的单个实体。</li>
<li>查找并返回与<code>Predicate</code>匹配的所有实体。</li>
<li>返回与<code>Predicate</code>匹配的实体数。</li>
<li>返回与<code>Predicate</code>匹配的实体是否存在。</li>
</ol>
<p>要使用Querydsl支持，请在存储库界面上扩展<code>QuerydslPredicateExecutor</code>，如以下示例所示</p>
<p>例子44.存储库上的Querydsl集成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的示例使您可以使用Querydsl<code>Predicate</code>实例编写类型安全查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = user.firstname.equalsIgnoreCase(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">    .and(user.lastname.startsWithIgnoreCase(<span class="string">&quot;mathews&quot;</span>));</span><br><span class="line"></span><br><span class="line">userRepository.findAll(predicate);</span><br></pre></td></tr></table></figure>
<p><span id="core.web"></span></p>
<h3 id="Web支持"><a href="#Web支持" class="headerlink" title="Web支持"></a>Web支持</h3><blockquote>
<p>本部分包含Spring Data Web支持的文档，该文档在Spring Data Commons的当前（和更高版本）中实现。随着新引入的支持发生了很多变化，我们将以前行为的文档保存在[web.legacy]中。</p>
</blockquote>
<p>支持存储库编程模型的Spring Data模块附带各种Web支持。与Web相关的组件要求Spring MVC JAR位于类路径上。其中一些甚至提供与<a target="_blank" rel="noopener" href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a>的集成。通常，通过在JavaConfig配置类中使用<code>@EnableSpringDataWebSupport</code>注解来启用集成支持，如以下示例所示：</p>
<p>例子45.启用Spring Data Web支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableSpringDataWebSupport</code>注解注册了一些我们稍后将讨论的组件。它还将在类路径上检测Spring HATEOAS，并为其注册集成组件（如果存在）。</p>
<p>另外，如果您使用XML配置，则将<code>SpringDataWebConfiguration</code>或<code>HateoasAwareSpringDataWebConfiguration</code>注册为Spring Bean，如以下示例所示（对于SpringDataWebConfiguration）：</p>
<p>例子46.在XML中启用Spring Data Web支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.SpringDataWebConfiguration&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="core.web.basic"></span></p>
<h4 id="基本Web支持"><a href="#基本Web支持" class="headerlink" title="基本Web支持"></a>基本Web支持</h4><p><a href="#core.web">上一节</a>中显示的配置注册了一些基本组件：</p>
<ul>
<li><p>一个<a href="#core.web.basic.domain-class-converter">DomainClassConverter</a>，可让Spring MVC从请求参数或路径变量解析存储库管理的域类的实例。</p>
</li>
<li><p><a href="#core.web.basic.paging-and-sorting">HandlerMethodArgumentResolver</a>实现，可让Spring MVC从请求参数中解析<code>Pageable</code>和<code>Sort</code>实例。</p>
</li>
</ul>
<p><span id="core.web.basic.domain-class-converter"></span></p>
<p><code>DomainClassConverter</code><br><code>DomainClassConverter</code>允许您在Spring MVC控制器方法签名中直接使用域类型，因此您无需通过存储库手动查找实例，如以下示例所示：</p>
<p>例子47.一个在方法签名中使用域类型的Spring MVC控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">showUserForm</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> User user, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;userForm&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，该方法直接接收<code>User</code>实例，不需要进一步的查找。可以通过让Spring MVC首先将路径变量转换为域类的id类型并最终通过在为该域类型注册的存储库实例上调用<code>findById(...)</code>来访问该实例来解析该实例。</p>
<blockquote>
<p>当前，该存储库必须实现<code>CrudRepository</code>才有资格被发现以进行转换。</p>
</blockquote>
<p><span id=""></span></p>
<p><strong>用于分页和排序的HandlerMethodArgumentResolvers</strong></p>
<p><a href="#core.web.basic.domain-class-converter">上一节</a>中显示的配置代码段还注册了<code>PageableHandlerMethodArgumentResolver</code>以及<code>SortHandlerMethodArgumentResolver</code>的实例。该注册启用了<code>Pageable</code>和<code>Sort</code>作为有效的控制器方法参数，如以下示例所示：</p>
<p>例子48.使用Pageable作为控制器方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">  UserController(UserRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="function">String <span class="title">showUsers</span><span class="params">(Model model, Pageable pageable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, repository.findAll(pageable));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的方法签名使Spring MVC尝试使用以下默认配置从请求参数派生<code>Pageable</code>实例：</p>
<p>表1.为可分页实例评估的请求参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>page</code></th>
<th>Page you want to retrieve. 0-indexed and defaults to 0.</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size</code></td>
<td>Size of the page you want to retrieve. Defaults to 20.</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>应该以格式属性property(ASC\</td>
<td>DESC)(,IgnoreCase)进行排序的属性。默认排序方向区分大小写。 如果要切换方向或区分大小写，请使用多个排序参数。例如，？sort = firstname＆sort = lastname，asc＆sort = city，ignorecase。</td>
</tr>
</tbody>
</table>
</div>
<p>要自定义此行为，请注册一个分别实现<code>PageableHandlerMethodArgumentResolverCustomizer</code>接口或<code>SortHandlerMethodArgumentResolverCustomizer</code>接口的bean。它的<code>customize()</code>方法被调用，让您更改设置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="function">SortHandlerMethodArgumentResolverCustomizer <span class="title">sortCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s -&gt; s.setPropertyDelimiter(<span class="string">&quot;&lt;--&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置现有<code>MethodArgumentResolver</code>的属性不足以满足您的目的，请扩展<code>SpringDataWebConfiguration</code>或启用HATEOAS的等效项，重写<code>pageableResolver()</code>或<code>sortResolver()</code>方法，然后导入自定义的配置文件，而不使用<code>@Enable</code>注解。</p>
<p>如果您需要从请求中解析多个<code>Pageable</code>或<code>Sort</code>实例（例如，对于多个表），则可以使用Spring的<code>@Qualifier</code>注解将一个实例与另一个实例区分开。然后，请求参数必须以<code>$&#123;qualifier&#125;_</code>为前缀。以下示例显示了生成的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">showUsers</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing1&quot;)</span> Pageable first,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing2&quot;)</span> Pageable second)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>您必须填充<code>thing1_page</code>和<code>thing2_page</code>，依此类推。</p>
<p>传递给该方法的默认<code>Pageable</code>等效于<code>PageRequest.of（0，20）</code>，但可以通过使用<code>Pageable</code>参数上的<code>@PageableDefault</code>注解进行自定义。</p>
<p><span id="core.web.pageables"></span></p>
<h4 id="超媒体对分页的支持"><a href="#超媒体对分页的支持" class="headerlink" title="超媒体对分页的支持"></a>超媒体对分页的支持</h4><p>Spring HATEOAS附带一个表示模型类（<code>PagedResources</code>），该类允许使用必要的页面元数据以及链接来丰富<code>Page</code>实例的内容，并使客户端可以轻松浏览页面。 <code>Page</code>到<code>PagedResources</code>的转换是通过Spring HATEOAS <code>ResourceAssembler</code>接口（称为<code>PagedResourcesAssembler</code>）的实现完成的。下面的示例演示如何将<code>PagedResourcesAssembler</code>用作控制器方法参数：</p>
<p>例子49.使用PagedResourcesAssembler作为控制器方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/persons&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,</span><br><span class="line">    PagedResourcesAssembler assembler) &#123;</span><br><span class="line"></span><br><span class="line">    Page&lt;Person&gt; persons = repository.findAll(pageable);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例中所示启用配置，可以将<code>PagedResourcesAssembler</code>用作控制器方法参数。对其调用<code>toResources(...)</code>具有以下效果：</p>
<ul>
<li><p>Page的内容成为<code>PagedResources</code>实例的内容。</p>
</li>
<li><p><code>PagedResources</code>对象获取附加的<code>PageMetadata</code>实例，并使用<code>Page</code>和基础<code>PageRequest</code>的信息填充该实例。</p>
</li>
<li><code>PagedResources</code>可能会附加上一个和下一个链接，具体取决于页面的状态。链接指向方法映射到的URI。添加到该方法的分页参数与<code>PageableHandlerMethodArgumentResolver</code>的设置匹配，以确保以后可以解析链接。</li>
</ul>
<p>假设数据库中有30个Person实例。现在，您可以触发请求（GET http:// localhost:8080/persons）并查看类似于以下内容的输出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">&quot;links&quot;</span> : [ &#123; <span class="string">&quot;rel&quot;</span> : <span class="string">&quot;next&quot;</span>,</span><br><span class="line">                <span class="string">&quot;href&quot;</span> : <span class="string">&quot;http://localhost:8080/persons?page=1&amp;size=20 &#125;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;</span>content<span class="string">&quot; : [</span></span><br><span class="line"><span class="string">     … // 20 Person instances rendered here</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;</span>pageMetadata<span class="string">&quot; : &#123;</span></span><br><span class="line"><span class="string">    &quot;</span>size<span class="string">&quot; : 20,</span></span><br><span class="line"><span class="string">    &quot;</span>totalElements<span class="string">&quot; : 30,</span></span><br><span class="line"><span class="string">    &quot;</span>totalPages<span class="string">&quot; : 2,</span></span><br><span class="line"><span class="string">    &quot;</span>number<span class="string">&quot; : 0</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>您会看到汇编器生成了正确的URI，并且还选择了默认配置以将参数解析为即将到来的请求的<code>Pageable</code>。这意味着，如果您更改该配置，则链接将自动遵循更改。默认情况下，汇编器指向调用它的控制器方法，但是可以通过传递自定义链接（用作构建分页链接的基础）进行自定义，这会使<code>PagedResourcesAssembler.toResource(...)</code>方法过载。</p>
<p><span id="core.web.binding"></span></p>
<h4 id="Web数据绑定支持"><a href="#Web数据绑定支持" class="headerlink" title="Web数据绑定支持"></a>Web数据绑定支持</h4><p>通过使用<a target="_blank" rel="noopener" href="https://goessner.net/articles/JsonPath/">JSONPath</a>表达式（需要<a target="_blank" rel="noopener" href="https://github.com/json-path/JsonPath">Jayway JsonPath</a>或<a target="_blank" rel="noopener" href="https://www.w3.org/TR/xpath-31/">XPath</a>表达式（需要<a target="_blank" rel="noopener" href="https://xmlbeam.org/">XmlBeam</a>）），可以使用Spring Data投影（在<a href="#projections">Projections</a>中描述）来绑定传入的请求有效负载，如以下示例所示：</p>
<p>例子50.使用JSONPath或XPath表达式的HTTP有效负载绑定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ProjectedPayload</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserPayload</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XBRead(&quot;//firstname&quot;)</span></span><br><span class="line">  <span class="meta">@JsonPath(&quot;$..firstname&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@XBRead(&quot;/lastname&quot;)</span></span><br><span class="line">  <span class="meta">@JsonPath(&#123; &quot;$.lastname&quot;, &quot;$.user.lastname&quot; &#125;)</span></span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面示例中显示的类型可以用作Spring MVC处理程序方法参数，也可以通过在<code>RestTemplate</code>的方法之一上使用<code>ParameterizedTypeReference</code>来使用。前面的方法声明将尝试在给定文档中的任何位置查找<code>firstname</code>。<code>lastname</code>XML查找是在传入文档的顶层执行的。的JSON变体首先尝试使用顶级<code>lastname</code>，但是如果前者未返回值，则还会尝试嵌套在用户子文档中的<code>lastname</code>。这样，可以轻松缓解源文档结构的更改，而无需客户端调用公开的方法（通常是基于类的有效负载绑定的缺点）。</p>
<p>如<a href="#projections">投影</a>中所述，支持嵌套投影。如果该方法返回复杂的非接口类型，则使用Jackson <code>ObjectMapper</code>映射最终值。</p>
<p>对于Spring MVC，<code>@EnableSpringDataWebSupport</code>处于活动状态并且所需的依赖项在类路径上可用后，会自动自动注册必需的转换器。要与<code>RestTemplate</code>一起使用，请手动注册<code>ProjectingJackson2HttpMessageConverter</code>（JSON）或<code>XmlBeamHttpMessageConverter</code>。</p>
<p>有关更多信息，请参见规范的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples存储库</a>中的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">Web投影示例</a>。</p>
<p><span id="core.web.type-safe"></span></p>
<h4 id="Querydsl-Web支持"><a href="#Querydsl-Web支持" class="headerlink" title="Querydsl Web支持"></a>Querydsl Web支持</h4><p>对于那些具有<a target="_blank" rel="noopener" href="http://www.querydsl.com/">QueryDSL</a>集成的商店，可以从<code>Request</code>查询字符串中包含的属性派生查询。</p>
<p>考虑以下查询字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?firstname&#x3D;Dave&amp;lastname&#x3D;Matthews</span><br></pre></td></tr></table></figure>
<p>给定前面示例中的<code>User</code>对象，可以使用<code>QuerydslPredicateArgumentResolver</code>将查询字符串解析为以下值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QUser.user.firstname.eq(&quot;Dave&quot;).and(QUser.user.lastname.eq(&quot;Matthews&quot;))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当在类路径上找到Querydsl时，将自动启用该功能以及<code>@EnableSpringDataWebSupport</code>。</p>
</blockquote>
<p>将<code>@QuerydslPredicate</code>添加到方法签名中可提供一个现成的<code>Predicate</code>，可以使用<code>QuerydslPredicateExecutor</code>来运行它。</p>
<blockquote>
<p>类型信息通常从方法的返回类型中解析。由于该信息不一定与域类型匹配，因此使用<code>QuerydslPredicate</code>的根属性可能是一个好主意。</p>
</blockquote>
<p>以下示例显示了如何在方法签名中使用<code>@QuerydslPredicate</code>：</p>
<p>@Controller</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)</span></span><br><span class="line">  <span class="function">String <span class="title">index</span><span class="params">(Model model, <span class="meta">@QuerydslPredicate(root = User.class)</span> Predicate predicate,    <span class="number">1</span></span></span></span><br><span class="line"><span class="function"><span class="params">          Pageable pageable, <span class="meta">@RequestParam</span> MultiValueMap&lt;String, String&gt; parameters)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, repository.findAll(predicate, pageable));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将查询字符串参数解析为<code>User</code>匹配<code>Predicate</code>。</p>
<p>默认绑定如下：</p>
<ul>
<li><p>简单属性上的<code>Object</code>如<code>eq</code>。</p>
</li>
<li><p>集合上的<code>Object</code>，如<code>Contains</code>属性。</p>
</li>
<li><p>关于简单属性<code>in</code>的<code>Collection</code>。</p>
</li>
</ul>
<p>可以通过<code>@QuerydslPredicate</code>的<code>bindings</code>属性或通过使用Java 8默认方法并将<code>QuerydslBinderCustomizer</code>方法添加到存储库接口来自定义这些绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class">                                 <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt;,                </span></span><br><span class="line"><span class="class">                                 <span class="title">QuerydslBinderCustomizer</span>&lt;<span class="title">QUser</span>&gt; </span>&#123;               </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(QuerydslBindings bindings, QUser user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    </span><br><span class="line">    bindings.bind(String.class)</span><br><span class="line">      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); </span><br><span class="line">    bindings.excluding(user.password);                                           </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>QuerydslPredicateExecutor</code>提供对<code>Predicate</code>的特定查找器方法的访问。</li>
<li>在存储库界面上定义的<code>QuerydslBinderCustomizer</code>会自动被选中，并提供快捷方式<code>@QuerydslPredicate(bindings=...)</code></li>
<li>将<code>username</code>属性的绑定定义为简单的<code>contains</code>绑定。</li>
<li>将<code>String</code>属性的默认绑定定义为不区分大小写的<code>contains</code>匹配项。</li>
<li>从<code>Predicate</code>解析中排除<code>password</code>属性。</li>
</ol>
<p><span id="core.repository-populators"></span></p>
<h4 id="存储库填充器"><a href="#存储库填充器" class="headerlink" title="存储库填充器"></a>存储库填充器</h4><p>如果您使用Spring JDBC模块，则可能熟悉使用SQL脚本填充<code>DataSource</code>的支持。尽管它不使用SQL作为数据定义语言，因为它必须独立于存储，因此在存储库级别上可以使用类似的抽象。因此，填充器支持XML（通过Spring的OXM抽象）和JSON（通过Jackson）来定义用于填充存储库的数据。</p>
<p>假设您有一个包含以下内容的<code>data.json</code>文件：</p>
<p>例子51.用JSON定义的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ &#123; <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;com.acme.Person&quot;</span>,</span><br><span class="line"> <span class="string">&quot;firstname&quot;</span> : <span class="string">&quot;Dave&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastname&quot;</span> : <span class="string">&quot;Matthews&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="string">&quot;_class&quot;</span> : <span class="string">&quot;com.acme.Person&quot;</span>,</span><br><span class="line"> <span class="string">&quot;firstname&quot;</span> : <span class="string">&quot;Carter&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastname&quot;</span> : <span class="string">&quot;Beauford&quot;</span> &#125; ]</span><br></pre></td></tr></table></figure>
<p>您可以使用Spring Data Commons中提供的存储库名称空间的populator元素来填充存储库。要将前面的数据填充到您的PersonRepository中，请声明一个类似于以下内容的填充器：</p>
<p>例子52.声明一个Jackson存储库填充器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:repository</span>=<span class="string">&quot;http://www.springframework.org/schema/data/repository&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/repository</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/repository/spring-repository.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository:jackson2-populator</span> <span class="attr">locations</span>=<span class="string">&quot;classpath:data.json&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>前面的声明使Jackson <code>ObjectMapper</code>读取并反序列化<code>data.json</code>文件。</p>
<p>通过检查JSON文档的<code>_class</code>属性来确定将JSON对象解组到的类型。基础结构最终选择适当的存储库来处理反序列化的对象。</p>
<p>要改为使用XML定义应使用存储库填充的数据，可以使用<code>unmarshaller-populator</code>元素。您可以将其配置为使用Spring OXM中可用的XML marshaller选项之一。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/#使用Object-XML映射器编组XML">Spring参考文档</a>。以下示例显示如何使用JAXB解组存储库填充器：</p>
<p>例子53.声明一个解组存储库填充器（使用JAXB）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:repository</span>=<span class="string">&quot;http://www.springframework.org/schema/data/repository&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:oxm</span>=<span class="string">&quot;http://www.springframework.org/schema/oxm&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/repository</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/repository/spring-repository.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/oxm</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/oxm/spring-oxm.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository:unmarshaller-populator</span> <span class="attr">locations</span>=<span class="string">&quot;classpath:data.json&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">unmarshaller-ref</span>=<span class="string">&quot;unmarshaller&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">oxm:jaxb2-marshaller</span> <span class="attr">contextPath</span>=<span class="string">&quot;com.acme&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="jpa.repositories"></span></p>
<h1 id="JPA-Repositories"><a href="#JPA-Repositories" class="headerlink" title="JPA Repositories"></a>JPA Repositories</h1><p>本章指出了JPA信息库支持的特长。 这基于“使用Spring数据存储库”中解释的核心存储库支持。 确保您对此处介绍的基本概念有很好的理解。</p>
<p><span id="jpa.introduction"></span></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本节介绍通过以下两种方式配置Spring Data JPA的基础知识：</p>
<p><a href="#jpa.namespace">“ Spring命名空间”</a>（XML配置）</p>
<p><a href="#jpa.java-config">“基于注解的配置”</a>（Java配置）</p>
<p><span id="jpa.namespace"></span></p>
<h3 id="Spring命名空间"><a href="#Spring命名空间" class="headerlink" title="Spring命名空间"></a>Spring命名空间</h3><p>Spring Data的JPA模块包含一个允许定义存储库bean的自定义名称空间。 它还包含JPA特有的某些功能和元素属性。 通常，可以通过使用repositories元素来设置JPA存储库，如以下示例所示：</p>
<p>例子54.使用命名空间设置JPA存储库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>repositories</code>元素可按<a href="#repositories.create-instances">“创建存储库实例”</a>中所述查找Spring Data存储库。 除此之外，它还为所有使用<code>@Repository</code>注解的bean激活持久性异常转换，以使JPA持久性提供程序引发的异常转换为Spring的<code>DataAccessException</code>层次结构。</p>
<p><strong>自定义命名空间属性</strong><br>除了<code>repositories</code>元素的默认属性，JPA命名空间还提供了其他属性，使您可以更详细地控制存储库的设置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>entity-manager-factory-ref</code></th>
<th>明确地将<code>EntityManagerFactory</code>与要使用的<code>repositories</code>元素检测到的存储库关联。 通常在应用程序中使用多个<code>EntityManagerFactory</code> bean时使用。 如果未配置，Spring Data会在<code>ApplicationContext</code>中自动查找名称为<code>EntityManagerFactory</code>的<code>EntityManagerFactory</code> bean。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transaction-manager-ref</code></td>
<td>明确地将<code>PlatformTransactionManager</code>与要使用的<code>repositories</code>元素所检测到的存储库进行连线。 通常仅在配置了多个事务管理器或<code>EntityManagerFactory</code> bean时才需要。 默认为当前<code>ApplicationContext</code>中单个定义的<code>PlatformTransactionManager</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note</p>
<p>如果未定义显式的<code>transaction-manager-ref</code>，Spring Data JPA要求提供一个名为<code>transactionManager</code>的<code>PlatformTransactionManager</code> bean。</p>
</blockquote>
<p><span id="jpa.java-config"></span></p>
<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>Spring Data JPA存储库支持不仅可以通过XML名称空间来激活，还可以通过JavaConfig使用注解来激活，如以下示例所示：</p>
<p>例子55.使用JavaConfig的Spring Data JPA存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EmbeddedDatabaseBuilder builder = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    <span class="keyword">return</span> builder.setType(EmbeddedDatabaseType.HSQL).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HibernateJpaVendorAdapter vendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    vendorAdapter.setGenerateDdl(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    LocalContainerEntityManagerFactoryBean factory = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    factory.setJpaVendorAdapter(vendorAdapter);</span><br><span class="line">    factory.setPackagesToScan(<span class="string">&quot;com.acme.domain&quot;</span>);</span><br><span class="line">    factory.setDataSource(dataSource());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    JpaTransactionManager txManager = <span class="keyword">new</span> JpaTransactionManager();</span><br><span class="line">    txManager.setEntityManagerFactory(entityManagerFactory);</span><br><span class="line">    <span class="keyword">return</span> txManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>您必须直接创建<code>LocalContainerEntityManagerFactoryBean</code>而不是<code>EntityManagerFactory</code>，因为前者除了创建<code>EntityManagerFactory</code>之外，还参与异常转换机制。</p>
</blockquote>
<p>前面的配置类通过使用<code>spring-jdbc</code>的<code>EmbeddedDatabaseBuilder</code> API来设置嵌入式HSQL数据库。然后，Spring Data会建立一个<code>EntityManagerFactory</code>并将<code>Hibernate</code>用作示例持久性提供程序。在此声明的最后一个基础结构组件是JpaTransactionManager。最后，该示例通过使用`@EnableJpaRepositories注解来激活Spring Data JPA仓库，该批注实质上具有与XML名称空间相同的属性。如果未配置任何基本程序包，它将使用配置类所在的程序包。</p>
<p><span id="jpa.bootstrap-mode"></span></p>
<h3 id="引导模式"><a href="#引导模式" class="headerlink" title="引导模式"></a>引导模式</h3><p>默认情况下，Spring Data JPA存储库是默认的Spring Bean。它们是单例作用域的，并且急切地初始化。在启动期间，它们已经与JPA <code>EntityManager</code>进行交互，以进行验证和元数据分析。 Spring框架在后台线程中支持JPA <code>EntityManagerFactory</code>的初始化，因为该过程通常在Spring应用程序中占用大量启动时间。为了有效地利用该后台初始化，我们需要确保JPA存储库尽可能早地初始化。</p>
<p>从Spring Data JPA 2.1开始，您现在可以配置<code>BootstrapMode</code>（通过<code>@EnableJpaRepositories</code>注解或XML名称空间），它采用以下值：</p>
<ul>
<li><code>DEFAULT</code>（默认值）-急切地实例化存储库，除非使用<code>@Lazy</code>显式注解。仅当没有客户机Bean需要存储库实例时，lazification才有效，因为这将需要初始化存储库bean。</li>
<li><code>LAZY</code>-隐式地将所有存储库bean声明为lazy，并且还导致创建懒惰的初始化代理以将其注入到客户端bean中。这意味着，如果客户端bean仅将实例存储在字段中并且在初始化期间不使用存储库，则不会实例化存储库。首次与存储库交互时，将初始化和验证存储库实例。</li>
<li><code>DEFERRED</code> —与<code>LAZY</code>基本相同的操作模式，但是响应<code>ContextRefreshedEvent</code>触发存储库初始化，以便在应用程序完全启动之前验证存储库。</li>
</ul>
<p><strong>推荐建议</strong><br>如果您不使用默认引导模式的异步JPA引导棒。</p>
<p>如果您以异步方式引导JPA，则<code>DEFERRED</code>是一个合理的默认值，因为它可以确保Spring Data JPA引导仅在其花费比初始化所有其他应用程序组件更长的时间时才等待<code>EntityManagerFactory</code>安装。 尽管如此，它仍可以确保在应用程序发出信号之前，对存储库进行了正确的初始化和验证。</p>
<p><code>LAZY</code>是测试方案和本地开发的不错选择。 一旦确定了存储库将正确引导后，或者在测试应用程序的其他部分的情况下，对所有存储库执行验证可能只会不必要地增加启动时间。 这同样适用于本地开发，在本地开发中，您仅访问应用程序的某些部分，而这些部分可能只需要初始化一个存储库即可。</p>
<p><span id="jpa.entity-persistence"></span></p>
<h2 id="持久化实体"><a href="#持久化实体" class="headerlink" title="持久化实体"></a>持久化实体</h2><p>本节描述了如何使用Spring Data JPA持久化（保存）实体。</p>
<p><span id="jpa.entity-persistence.saving-entites"></span></p>
<h3 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h3><p>可以使用<code>CrudRepository.save(...)</code>方法执行保存实体。 它使用基础JPA <code>EntityManager</code>持久化或合并给定实体。 如果该实体尚未持久化，Spring Data JPA会通过调用<code>entityManager.persist(...)</code>方法来保存该实体。 否则，它将调用<code>entityManager.merge(...)</code>方法。</p>
<p><span id="jpa.entity-persistence.saving-entites.strategies"></span></p>
<h4 id="实体状态检测策略"><a href="#实体状态检测策略" class="headerlink" title="实体状态检测策略"></a>实体状态检测策略</h4><p>Spring Data JPA提供以下策略来检测实体是否为新实体：</p>
<ol>
<li><p>Version-Property和Id-Property检查（default）：默认情况下，Spring Data JPA首先检查是否存在非基本类型的Version-property。如果存在，则将该实体视为新实体（如果该值为null）。没有这样的版本属性，Spring Data JPA会检查给定实体的标识符属性。如果标识符属性为<code>null</code>，则假定该实体为新实体。否则，假定它不是新的。</p>
</li>
<li><p>实现<code>Persistable</code>：如果实体实现<code>Persistable</code>，则Spring Data JPA将新检测委托给该实体的<code>isNew(...)</code>方法。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a>。</p>
</li>
<li><p>实现<code>EntityInformation</code>：通过创建<code>JpaRepositoryFactory</code>的子类并相应地重写<code>getEntityInformation(...)</code>方法，可以自定义<code>SimpleJpaRepository</code>实现中使用的<code>EntityInformation</code>抽象。然后，您必须将<code>JpaRepositoryFactory</code>的自定义实现注册为Spring bean。请注意，这几乎没有必要。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a>。</p>
</li>
</ol>
<p>对于使用手动分配的标识符的实体，选项1不是选项，因为标识符将始终为非<code>null</code>。在这种情况下，一种常见的模式是使用一个公共基类，该基类的过渡标志默认表示一个新实例，并使用JPA生命周期回调在持久性操作上翻转该标志：</p>
<p>例子56.具有手动分配的标识符的实体的基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEntity</span>&lt;<span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">Persistable</span>&lt;<span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isNew = <span class="keyword">true</span>; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isNew; <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PrePersist</span> <span class="number">3</span></span><br><span class="line">  <span class="meta">@PostLoad</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">markNotNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isNew = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// More code…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>声明一个标志以保持新状态。 暂时的，因此它不会持久化到数据库中。</li>
<li>在<code>Persistable.isNew()</code>的实现中返回标志，以便Spring Data存储库知道是调用<code>EntityManager.persist()</code>还是<code>….merge()</code>。</li>
<li>声明使用JPA实体回调的方法，以便在存储库调用<code>save(...)</code>或持久性提供程序创建实例之后，将标志切换为指示现有实体。</li>
</ol>
<p><span id="jpa.query-methods"></span></p>
<h2 id="查询方法-1"><a href="#查询方法-1" class="headerlink" title="查询方法"></a>查询方法</h2><p>本节描述了使用Spring Data JPA创建查询的各种方法。</p>
<p><span id="jpa.sample-app.finders.strategies"></span></p>
<h3 id="查询查找策略-1"><a href="#查询查找策略-1" class="headerlink" title="查询查找策略"></a>查询查找策略</h3><p>JPA模块支持手动将查询定义为String或从方法名称派生查询。</p>
<p>谓词为<code>IsStartingWith</code>，<code>StartingWith</code>，<code>StartsWith</code>，<code>IsEndingWith</code>，<code>EndingWith</code>，<code>EndsWith</code>，<code>IsNotContaining</code>，NotContaining，<code>NotContains</code>，<code>IsContaining</code>，<code>Containing</code>的派生查询将包含这些查询的各自参数。这意味着，如果参数实际上包含LIKE识别为通配符的字符，则这些字符将被转义，因此它们仅作为文字匹配。可以通过设置<code>@EnableJpaRepositories</code>注解的<code>escapeCharacter</code>来配置使用的转义字符。与<a href="#jpa.query.spel-expressions">使用SpEL表达式</a>进行比较。</p>
<p><strong>声明查询</strong><br>尽管从方法名派生一个查询很方便，但可能会遇到这样一种情况，即方法名解析器不支持一个人想使用的关键字，或者方法名不必要地变得丑陋。因此，您可以通过命名约定使用JPA命名查询（有关更多信息，请参见<a href="#jpa.query-methods.named-queries">使用JPA命名查询</a>），或者通过<code>@Query</code>注解您的查询方法（有关详细信息，请参阅<a href="#jpa.query-methods.at-query">使用@Query</a>）。</p>
<p><span id="jpa.query-methods.query-creation"></span></p>
<h3 id="查询创建-1"><a href="#查询创建-1" class="headerlink" title="查询创建"></a>查询创建</h3><p>通常，JPA的查询创建机制按<a href="#repositories.query-methods">“查询方法”</a>中所述运行。 以下示例显示了JPA查询方法转换为的内容：</p>
<p>例子57.从方法名查询创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(String emailAddress, String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从中使用JPA标准API创建查询，但是从本质上讲，这将转换为以下查询：<code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code> 如<a href="#repositories.query-methods.query-property-expressions">“属性表达式”</a>中所述，Spring Data JPA进行属性检查并遍历嵌套的属性。</p>
<p>下表描述了JPA支持的关键字以及包含该关键字的方法所转换的含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Keyword</th>
<th style="text-align:left">Sample</th>
<th style="text-align:left">JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>And</code></td>
<td style="text-align:left"><code>findByLastnameAndFirstname</code></td>
<td style="text-align:left"><code>… where x.lastname = ?1 and x.firstname = ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Or</code></td>
<td style="text-align:left"><code>findByLastnameOrFirstname</code></td>
<td style="text-align:left"><code>… where x.lastname = ?1 or x.firstname = ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Is</code>, <code>Equals</code></td>
<td style="text-align:left"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td>
<td style="text-align:left"><code>… where x.firstname = ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Between</code></td>
<td style="text-align:left"><code>findByStartDateBetween</code></td>
<td style="text-align:left"><code>… where x.startDate between ?1 and ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LessThan</code></td>
<td style="text-align:left"><code>findByAgeLessThan</code></td>
<td style="text-align:left"><code>… where x.age &lt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LessThanEqual</code></td>
<td style="text-align:left"><code>findByAgeLessThanEqual</code></td>
<td style="text-align:left"><code>… where x.age &lt;= ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GreaterThan</code></td>
<td style="text-align:left"><code>findByAgeGreaterThan</code></td>
<td style="text-align:left"><code>… where x.age &gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GreaterThanEqual</code></td>
<td style="text-align:left"><code>findByAgeGreaterThanEqual</code></td>
<td style="text-align:left"><code>… where x.age &gt;= ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>After</code></td>
<td style="text-align:left"><code>findByStartDateAfter</code></td>
<td style="text-align:left"><code>… where x.startDate &gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Before</code></td>
<td style="text-align:left"><code>findByStartDateBefore</code></td>
<td style="text-align:left"><code>… where x.startDate &lt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IsNull</code>, <code>Null</code></td>
<td style="text-align:left"><code>findByAge(Is)Null</code></td>
<td style="text-align:left"><code>… where x.age is null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IsNotNull</code>, <code>NotNull</code></td>
<td style="text-align:left"><code>findByAge(Is)NotNull</code></td>
<td style="text-align:left"><code>… where x.age not null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Like</code></td>
<td style="text-align:left"><code>findByFirstnameLike</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NotLike</code></td>
<td style="text-align:left"><code>findByFirstnameNotLike</code></td>
<td style="text-align:left"><code>… where x.firstname not like ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>StartingWith</code></td>
<td style="text-align:left"><code>findByFirstnameStartingWith</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>EndingWith</code></td>
<td style="text-align:left"><code>findByFirstnameEndingWith</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>Containing</code></td>
<td style="text-align:left"><code>findByFirstnameContaining</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>OrderBy</code></td>
<td style="text-align:left"><code>findByAgeOrderByLastnameDesc</code></td>
<td style="text-align:left"><code>… where x.age = ?1 order by x.lastname desc</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Not</code></td>
<td style="text-align:left"><code>findByLastnameNot</code></td>
<td style="text-align:left"><code>… where x.lastname &lt;&gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>In</code></td>
<td style="text-align:left"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td>
<td style="text-align:left"><code>… where x.age in ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NotIn</code></td>
<td style="text-align:left"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td>
<td style="text-align:left"><code>… where x.age not in ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>True</code></td>
<td style="text-align:left"><code>findByActiveTrue()</code></td>
<td style="text-align:left"><code>… where x.active = true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>False</code></td>
<td style="text-align:left"><code>findByActiveFalse()</code></td>
<td style="text-align:left"><code>… where x.active = false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IgnoreCase</code></td>
<td style="text-align:left"><code>findByFirstnameIgnoreCase</code></td>
<td style="text-align:left"><code>… where UPPER(x.firstame) = UPPER(?1)</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note</p>
<p><code>In</code>和<code>NotIn</code>也将<code>Collection</code>的任何子类作为参数以及varargs的数组。 对于同一逻辑运算符的其他语法版本，请选中<a href="#repository-query-keywords">“存储库查询关键字”</a>。</p>
</blockquote>
<p><span id="jpa.query-methods.named-queries"></span></p>
<h3 id="使用JPA命名查询"><a href="#使用JPA命名查询" class="headerlink" title="使用JPA命名查询"></a>使用JPA命名查询</h3><blockquote>
<p>Note</p>
<p>这些示例使用<code>&lt;named-query/&gt;</code>元素和<code>@NamedQuery</code>注解。 这些配置元素的查询必须用JPA查询语言定义。 当然，您也可以使用<code>&lt;named-native-query /&gt;</code>或<code>@NamedNativeQuery</code>。 这些元素使您可以通过失去数据库平台独立性来在本机SQL中定义查询。</p>
</blockquote>
<p><strong>XML命名查询定义</strong><br>要使用XML配置，请将必要的<named-query />元素添加到位于类路径的META-INF文件夹中的orm.xml JPA配置文件中。 通过使用一些定义的命名约定，可以自动调用命名查询。 有关更多详细信息，请参见下文。</p>
<p>例子58. XML命名查询配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">named-query</span> <span class="attr">name</span>=<span class="string">&quot;User.findByLastname&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">query</span>&gt;</span>select u from User u where u.lastname = ?1<span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-query</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该查询具有一个特殊名称，该名称用于在运行时解析它。</p>
<p><strong>基于注解的配置</strong><br>基于注解的配置的优点是不需要编辑另一个配置文件，从而减少了维护工作。 您需要为每个新的查询声明重新编译域类，从而为此付出了代价。</p>
<p>例子59.基于注释的命名查询配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery(name = &quot;User.findByEmailAddress&quot;,</span></span><br><span class="line"><span class="meta">  query = &quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明接口</strong><br>要允许执行这些命名查询，请按以下方式指定<code>UserRepository</code>：</p>
<p>例子60. UserRepository中的查询方法声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data尝试将对这些方法的调用解析为对命名查询的调用，从已配置的域类的简单名称开始，然后是由句点分隔的方法名称。 因此，前面的示例将使用在示例中定义的命名查询，而不是尝试从方法名称创建查询。</p>
<p><span id="jpa.query-methods.at-query"></span></p>
<h3 id="使用-Query"><a href="#使用-Query" class="headerlink" title="使用@Query"></a>使用@Query</h3><p>使用命名查询声明对实体的查询是一种有效的方法，并且对于少量查询也可以正常工作。 由于查询本身与执行它们的Java方法相关联，因此您实际上可以通过使用Spring Data JPA <code>@Query</code>注解直接绑定它们，而不是将它们注解到域类。 这样可以将域类从持久性特定的信息中释放出来，并将查询放置在存储库接口中。</p>
<p>注解查询方法的查询优先于使用<code>@NamedQuery</code>定义的查询或在<code>orm.xml</code>中声明的命名查询。</p>
<p>以下示例显示使用<code>@Query</code>注解创建的查询：</p>
<p>例子61.使用<code>@Query</code>在查询方法中声明查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用高级<code>LIKE</code>表达式</strong><br>使用<code>@Query</code>创建的手动定义查询的查询执行机制允许在查询定义中定义高级<code>LIKE</code>表达式，如以下示例所示：</p>
<p>例子62. <code>@Query</code>中的高级<code>like</code>表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname like %?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByFirstnameEndsWith</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，识别了<code>LIKE</code>分隔符（<code>％</code>），并将查询转换为有效的JPQL查询（删除了<code>％</code>）。 查询执行后，传递给方法调用的参数将使用先前识别的<code>LIKE</code>模式进行扩充。</p>
<p><strong>本地查询</strong><br><code>@Query</code>注解允许通过将nativeQuery标志设置为true来运行本地查询，如以下示例所示：</p>
<p>例子63.使用@Query在查询方法中声明一个本地查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA当前不支持对本机查询进行动态排序，因为它必须操纵声明的实际查询，而这对于本机SQL无法可靠地完成。 但是，您可以通过自己指定count查询来使用本机查询进行分页，如以下示例所示：<br>例子64.使用@Query在查询方法中声明本地计数查询的分页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE LASTNAME = ?1&quot;,</span></span><br><span class="line"><span class="meta">    countQuery = &quot;SELECT count(*) FROM USERS WHERE LASTNAME = ?1&quot;,</span></span><br><span class="line"><span class="meta">    nativeQuery = true)</span></span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将<code>.count</code>后缀添加到查询的副本中，类似的方法也可用于命名本机查询。 不过，您可能需要为计数查询注册结果集映射。</p>
<p><span id="jpa.query-methods.sorting"></span></p>
<h3 id="使用Sort"><a href="#使用Sort" class="headerlink" title="使用Sort"></a>使用Sort</h3><p>可以通过提供<code>PageRequest</code>或直接使用<code>Sort</code>来完成排序。 在<code>Sort</code>的<code>Order</code>实例中实际使用的属性需要与您的域模型匹配，这意味着它们需要解析为查询中使用的属性或别名。 JPQL将此定义为状态字段路径表达式。</p>
<blockquote>
<p>Note</p>
<p>使用任何不可引用的路径表达式都会导致<code>Exception</code>。</p>
</blockquote>
<p>但是，将<code>Sort</code>与<a href="#jpa.query-methods.at-query">@Query</a>一起使用，可以让您潜入包含<code>ORDER BY</code>子句中的函数的未经路径检查的Order实例。 这是可能的，因为<code>Order</code>附加到给定的查询字符串中。 默认情况下，Spring Data JPA拒绝任何包含函数调用的<code>Order</code>实例，但是您可以使用<code>JpaSort.unsafe</code>添加可能不安全的排序。</p>
<p>以下示例使用<code>Sort</code>和<code>JpaSort</code>，在JpaSort上包括一个不安全的选项：</p>
<p>例子65.使用排序和JpaSort</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByAndSort</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repo.findByAndSort(<span class="string">&quot;lannister&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;firstname&quot;</span>));     <span class="number">1</span>          </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;stark&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;LENGTH(firstname)&quot;</span>));        <span class="number">2</span>   </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;targaryen&quot;</span>, JpaSort.unsafe(<span class="string">&quot;LENGTH(firstname)&quot;</span>)); <span class="number">3</span></span><br><span class="line">repo.findByAsArrayAndSort(<span class="string">&quot;bolton&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;fn_len&quot;</span>));         <span class="number">4</span>     </span><br></pre></td></tr></table></figure>
<ol>
<li>指向域模型中属性的有效Sort表达式。</li>
<li>包含函数调用的无效排序。 Thows异常。</li>
<li>有效排序包含明显不安全的订单。</li>
<li>指向别名函数的有效Sort表达式。</li>
</ol>
<p><span id="jpa.named-parameters"></span></p>
<h3 id="使用命名参数"><a href="#使用命名参数" class="headerlink" title="使用命名参数"></a>使用命名参数</h3><p>默认情况下，Spring Data JPA使用基于位置的参数绑定，如前面所有示例中所述。 当重构有关参数位置的查询时，这会使查询方法容易出错。 要解决此问题，可以使用<code>@Param</code>注解为方法参数指定一个具体名称，然后在查询中绑定该名称，如以下示例所示：</p>
<p>例子66.使用命名参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByLastnameOrFirstname</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Param(&quot;firstname&quot;)</span> String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>方法参数根据它们在定义的查询中的顺序进行切换。</p>
<p>从版本4开始，Spring完全支持基于<code>-parameters</code>编译器标志的Java 8参数名称发现。 通过在构建中使用此标志作为调试信息的替代方法，可以省略<code>@Param</code>注解的命名参数。</p>
</blockquote>
<p><span id="jpa.query.spel-expressions"></span></p>
<h3 id="使用SpEL表达式"><a href="#使用SpEL表达式" class="headerlink" title="使用SpEL表达式"></a>使用SpEL表达式</h3><p>从Spring Data JPA 1.4版开始，我们支持在使用<code>@Query</code>定义的手动定义的查询中使用受限的SpEL模板表达式。 查询执行后，将根据一组预定义的变量对这些表达式进行求值。 Spring Data JPA支持一个名为<code>entityName</code>的变量。 它的用法是<code>select x from #&#123;#entityName&#125; x</code>。 它插入与给定存储库关联的域类型的<code>entityName</code>。 实体名称的解析如下：如果域类型已在<code>@Entity</code>注解上设置了名称属性，则将其使用。 否则，将使用域类型的简单类名。</p>
<p>以下示例演示了查询字符串中<code>＃&#123;＃entityName&#125;</code>表达式的一种用例，您想在其中使用查询方法和手动定义的查询来定义存储库接口：</p>
<p>例67.在存储库查询方法中使用SpEL表达式-entityName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  Long id;</span><br><span class="line"></span><br><span class="line">  String lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from #&#123;#entityName&#125; u where u.lastname = ?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免在<code>@Query</code>注解的查询字符串中声明实际的实体名称，可以使用＃{＃entityName}变量。</p>
<p>可以使用<code>@Entity</code>注解来自定义<code>entityName</code>。 SpEL表达式不支持orm.xml中的自定义。<br>当然，您可能只是在查询声明中直接使用了User，但这也需要您更改查询。对<code>#entityName</code>的引用将User类将来可能的重新映射选择为另一个实体名称（例如，通过使用<code>@Entity（name =“ MyUser”）</code>）。</p>
<p>查询字符串中<code>＃&#123;＃entityName&#125;</code>表达式的另一个用例是，是否要为特定域类型定义带有专用存储库接口的通用存储库接口。要不在具体接口上重复定义自定义查询方法，可以在通用存储库接口的<code>@Query</code>注解的查询字符串中使用实体名称表达式，如以下示例所示：</p>
<p>例子68.在仓库查询方法中使用SpEL表达式-具有继承的entityName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMappedType</span> </span>&#123;</span><br><span class="line">  …</span><br><span class="line">  String attribute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteType</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span> </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select t from #&#123;#entityName&#125; t where t.attribute = ?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;T&gt; <span class="title">findAllByAttribute</span><span class="params">(String attribute)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcreteRepository</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">ConcreteType</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，<code>MappedTypeRepository</code>接口是扩展<code>AbstractMappedType</code>的一些域类型的公共父接口。 它还定义了通用的<code>findAllByAttribute（…）</code>方法，该方法可用于专用存储库接口的实例。 如果现在在<code>ConcreteRepository</code>上调用<code>findByAllAttribute（…）</code>，则查询<code>select t from ConcreteType t where t.attribute = ?1</code>。</p>
<p>SpEL表达式用于操作参数，也可以用于操作方法参数。 在这些SpEL表达式中，实体名称不可用，但自变量可用。 可以通过名称或索引访问它们，如以下示例所示。</p>
<p>示例69.在存储库查询方法中使用SpEL表达式-访问参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.firstname = ?1 and u.firstname=?#&#123;[0]&#125; and u.emailAddress = ?#&#123;principal.emailAddress&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByFirstnameAndCurrentUserWithCustomQuery</span><span class="params">(String firstname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于<code>LIKE</code>条件，通常需要将<code>％</code>附加到String值参数的开头或结尾。 这可以通过将绑定参数标记或SpEL表达式附加或前缀为<code>％</code>来完成。 以下示例再次说明了这一点。</p>
<p>例子70.在仓库查询方法中使用SpEL表达式-通配符快捷方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.lastname like %:#&#123;[0]&#125;% and u.lastname like %:lastname%&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastnameWithSpelExpression</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果使用类似条件的值来自不安全来源，则应清除这些值，以使它们不能包含任何通配符，从而使攻击者可以选择比其应有的能力更多的数据。 为此，在SpEL上下文中可以使用<code>escape（String）</code>方法。 它在第一个参数中的<code>_</code>和<code>％</code>的所有实例之前加上第二个参数中的单个字符。 与JPQL中提供的<code>like</code>表达式的<code>escape</code>子句和标准SQL结合使用，可以轻松清除绑定参数。</p>
<p>示例71.在存储库查询方法中使用SpEL表达式-清理输入值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.firstname like %?#&#123;escape([0])&#125;% escape ?#&#123;escapeCharacter()&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findContainingEscaped</span><span class="params">(String namePart)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在存储库接口中给定此方法声明后，<code>findContainingEscaped（“ Peter_”）</code>“将找到’Peter_Parker而不是Peter Parker。可以通过设置<code>@EnableJpaRepositories</code>注解的<code>escapeCharacter</code>来配置使用的转义字符。请注意，该方法<code>escape（String）</code>可用 在SpEL上下文中，仅将转义SQL和JPQL标准通配符<code>_</code>和<code>％</code>，如果基础数据库或JPA实现支持其他通配符，则将不会转义这些通配符。</p>
<p><span id="jpa.modifying-queries"></span></p>
<h3 id="修改查询"><a href="#修改查询" class="headerlink" title="修改查询"></a>修改查询</h3><p>前面所有部分均描述了如何声明查询以访问给定实体或实体集合。 您可以使用“ Spring数据存储库的自定义实现”中介绍的功能来添加自定义修改行为。 由于此方法对于全面的定制功能是可行的，因此可以通过使用<code>@Modifying</code>注解查询方法来修改仅需要参数绑定的查询，如以下示例所示：</p>
<p>例子72.声明操作查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;update User u set u.firstname = ?1 where u.lastname = ?2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setFixedFirstnameFor</span><span class="params">(String firstname, String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样做将触发注解该方法的查询作为更新查询，而不是选择查询。 由于执行修改查询后<code>EntityManager</code>可能包含过时的实体，因此我们不会自动清除它（有关详细信息，请参阅<code>EntityManager.clear()</code>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html">JavaDoc</a>），因为这会有效地将所有尚未刷新的更改丢弃在<code>EntityManager</code>中。 如果您希望自动清除<code>EntityManager</code>，可以将<code>@Modifying</code>注解的<code>clearAutomatically</code>属性设置为<code>true</code>。</p>
<p><code>@Modifying</code>注解仅与<code>@Query</code>注解结合使用。 派生的查询方法或自定义方法不需要此注解。</p>
<p><span id="jpa.modifying-queries.derived-delete"></span></p>
<h4 id="派生删除查询"><a href="#派生删除查询" class="headerlink" title="派生删除查询"></a>派生删除查询</h4><p>Spring Data JPA还支持派生的删除查询，使您避免显式声明JPQL查询，如以下示例所示：</p>
<p>例子73.使用派生的删除查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Modifying</span></span><br><span class="line">  <span class="meta">@Query(&quot;delete from User u where u.role.id = ?1&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteInBulkByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>deleteByRoleId(...)</code>方法看起来基本上与<code>deleteInBulkByRoleId(...)</code>产生相同的结果，但是在执行方法方面，这两个方法声明之间存在重要区别。 顾名思义，后一种方法针对数据库发出单个JPQL查询（在注解中定义的查询）。 这意味着即使当前加载的<code>User</code>实例也看不到已调用的生命周期回调。</p>
<p>为了确保生命周期查询被实际调用，调用<code>deleteByRoleId(...)</code>会执行一个查询，然后逐个删除返回的实例，以便持久性提供程序实际上可以在这些实体上调用<code>@PreRemove</code>回调。</p>
<p>实际上，派生的删除查询是执行查询然后在结果上调用<code>CrudRepository.delete(Iterable&lt;User&gt; users)</code>并使行为与<code>CrudRepository</code>中其他<code>delete(...)</code>方法的实现保持同步的快捷方式。</p>
<p><span id="jpa.query-hints"></span></p>
<h3 id="应用查询提示"><a href="#应用查询提示" class="headerlink" title="应用查询提示"></a>应用查询提示</h3><p>要将JPA查询提示应用于在存储库接口中声明的查询，可以使用<code>@QueryHints</code>注解。 它需要一个JPA <code>@QueryHint</code>注解加上一个布尔标志，以潜在地禁用应用于应用分页时触发的附加计数查询的提示，如以下示例所示：</p>
<p>例子74.将QueryHints与存储库方法一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@QueryHints(value = &#123; @QueryHint(name = &quot;name&quot;, value = &quot;value&quot;)&#125;,</span></span><br><span class="line"><span class="meta">              forCounting = false)</span></span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的声明将为该实际查询应用已配置的<code>@QueryHint</code>，但是省略了将其应用于为计算总页数而触发的计数查询。</p>
<p><span id="jpa.entity-graph"></span></p>
<h3 id="配置Fetch-和LoadGraphs"><a href="#配置Fetch-和LoadGraphs" class="headerlink" title="配置Fetch-和LoadGraphs"></a>配置Fetch-和LoadGraphs</h3><p>JPA 2.1规范引入了对指定Fetch-和LoadGraphs的支持，我们也支持@EntityGraph注解，该批注使您可以引用@NamedEntityGraph定义。 您可以在实体上使用该注解来配置结果查询的获取计划。 可以通过使用@EntityGraph注解上的type属性来配置获取的类型（获取或加载）。 有关更多参考，请参见JPA 2.1 Spec 3.7.4。</p>
<p>以下示例显示如何在实体上定义命名实体图：</p>
<p>例子75.在一个实体上定义一个命名实体图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;GroupInfo.detail&quot;,</span></span><br><span class="line"><span class="meta">  attributeNodes = @NamedAttributeNode(&quot;members&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default fetch mode is lazy.</span></span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  List&lt;GroupMember&gt; members = <span class="keyword">new</span> ArrayList&lt;GroupMember&gt;();</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示如何在存储库查询方法上引用命名实体图：</p>
<p>示例76.在存储库查询方法上引用命名实体图定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">GroupInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EntityGraph(value = &quot;GroupInfo.detail&quot;, type = EntityGraphType.LOAD)</span></span><br><span class="line">  <span class="function">GroupInfo <span class="title">getByGroupName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用@EntityGraph定义临时实体图。 所提供的attributePaths转换为相应的EntityGraph，而无需将@NamedEntityGraph显式添加到您的域类型，如以下示例所示：</p>
<p>示例77.在存储库查询方法上使用AD-HOC实体图定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">GroupInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EntityGraph(attributePaths = &#123; &quot;members&quot; &#125;)</span></span><br><span class="line">  <span class="function">GroupInfo <span class="title">getByGroupName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="projections"></span></p>
<h3 id="Projections"><a href="#Projections" class="headerlink" title="Projections"></a>Projections</h3><p>Spring Data查询方法通常返回存储库管理的聚合根的一个或多个实例。 但是，有时可能需要根据这些类型的某些属性创建投影。 Spring Data允许对专用返回类型进行建模，以更选择性地检索托管聚合的部分视图。</p>
<p>想象一下一个存储库和聚合根类型，例如以下示例：</p>
<p>例子78.一个样本集合和存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> UUID id;</span><br><span class="line">  String firstname, lastname;</span><br><span class="line">  Address address;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String zipCode, city, street;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，假设我们只想检索此人的姓名属性。 Spring Data提供什么手段来实现这一目标？ 本章其余部分将回答该问题。</p>
<p><span id="projections.interfaces"></span></p>
<h4 id="基于接口的Projections"><a href="#基于接口的Projections" class="headerlink" title="基于接口的Projections"></a>基于接口的Projections</h4><p>将查询结果限制为仅名称属性的最简单方法是声明一个接口，该接口公开要读取的属性的访问器方法，如以下示例所示：</p>
<p>例子79.一个投影界面来检索属性的子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重要的一点是，此处定义的属性与聚合根中的属性完全匹配。 这样做可以使查询方法添加如下：</p>
<p>例子80.使用基于接口的投影和查询方法的存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;NamesOnly&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例，并将对公开方法的调用转发给目标对象。</p>
<p>可以递归使用投影。 如果还希望包括一些Address信息，请为此创建一个投影接口，并从getAddress（）的声明返回该接口，如以下示例所示：</p>
<p>例子81.一个投影界面来检索属性的子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonSummary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">AddressSummary <span class="title">getAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">AddressSummary</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCity</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法调用时，将获取目标实例的地址属性，并将其包装到投影代理中。</p>
<h5 id="封闭式Projections"><a href="#封闭式Projections" class="headerlink" title="封闭式Projections"></a>封闭式Projections</h5><p>其访问者方法均与目标集合的属性完全匹配的投影接口被视为封闭投影。 下面的示例（也在本章前面使用过）是一个封闭的投影：</p>
<p>例子82.一个封闭的投影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您使用封闭式投影，Spring Data可以优化查询执行，因为我们知道支持投影代理所需的所有属性。 有关更多信息，请参见参考文档中特定于模块的部分。</p>
<h5 id="开放式Projections"><a href="#开放式Projections" class="headerlink" title="开放式Projections"></a>开放式Projections</h5><p>投影接口中的访问器方法也可以通过使用@Value注解来计算新值，如以下示例所示：</p>
<p>例子83.一个开放的投影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;target.firstname + &#x27; &#x27; + target.lastname&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">()</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在目标变量中提供了支持投影的合计根。 使用@Value的投影接口是开放式投影。 在这种情况下，Spring Data无法应用查询执行优化，因为SpEL表达式可以使用聚合根的任何属性。</p>
<p>@Value中使用的表达式应该不太复杂-您要避免在String变量中进行编程。 对于非常简单的表达式，一种选择可能是求助于默认方法（在Java 8中引入），如以下示例所示：</p>
<p>例子84.使用默认方法自定义逻辑的投影接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getFullName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirstname().concat(<span class="string">&quot; &quot;</span>).concat(getLastname());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法要求您能够完全基于投影接口上公开的其他访问器方法来实现逻辑。 第二个更灵活的选择是在Spring bean中实现自定义逻辑，然后从SpEL表达式中调用该自定义逻辑，如以下示例所示：</p>
<p>例子85.采样人对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;@myBean.getFullName(target)&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">()</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意SpEL表达式如何引用myBean并调用getFullName（…）方法，并将投影目标作为方法参数转发。 SpEL表达式评估支持的方法也可以使用方法参数，然后可以从表达式中引用这些参数。 方法参数可通过名为args的对象数组获得。 下面的示例演示如何从args数组获取方法参数：</p>
<p>例子86. Sample Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;args[0] + &#x27; &#x27; + target.firstname + &#x27;!&#x27;&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getSalutation</span><span class="params">(String prefix)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对于更复杂的表达式，您应该使用Spring bean并让该表达式调用方法，<a href="#projections.interfaces.open.bean-reference">如前所述</a>。</p>
<p><span id="projections.dtos"></span></p>
<h4 id="基于类的Projections-DTOs"><a href="#基于类的Projections-DTOs" class="headerlink" title="基于类的Projections (DTOs)"></a>基于类的Projections (DTOs)</h4><p>定义投影的另一种方法是使用值类型DTO（数据传输对象），这些DTO拥有应该被检索的字段的属性。这些DTO类型可以以与使用投影接口完全相同的方式使用，除了不会发生代理和无法应用嵌套的投影。</p>
<p>如果商店通过限制要加载的字段来优化查询执行，则要加载的字段由公开的构造函数的参数名称确定。</p>
<p>以下示例显示了一个预计的DTO：</p>
<p>例子87.一个投影的DTO</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String firstname, lastname;</span><br><span class="line"></span><br><span class="line">  NamesOnly(String firstname, String lastname) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.firstname = firstname;</span><br><span class="line">    <span class="keyword">this</span>.lastname = lastname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.firstname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.lastname;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// equals(…) and hashCode() implementations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>避免使用投影DTO的样板代码</strong><br>您可以使用Project Lombok大大简化DTO的代码，该项目提供了<code>@Value</code>注解（不要与前面的界面示例中显示的Spring的<code>@Value</code>注解混淆）。如果您使用Project Lombok的<code>@Value</code>注解，则前面显示的示例DTO将变为以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line">    String firstname, lastname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，字段是<code>private final</code>，并且该类公开了一个构造函数，该构造函数接受所有字段并自动获取实现的<code>equals()</code>和<code>hashCode()</code>方法。</p>
</blockquote>
<p><span id="projection.dynamic"></span></p>
<h4 id="动态Projections"><a href="#动态Projections" class="headerlink" title="动态Projections"></a>动态Projections</h4><p>到目前为止，我们已经将投影类型用作集合的返回类型或元素类型。 但是，您可能希望选择调用时要使用的类型（这使它成为动态的）。 要应用动态投影，请使用查询方法，如以下示例中所示：</p>
<p>例子88.使用动态投影参数的存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Class&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，该方法可用于按原样或应用投影来获取聚合，如以下示例所示：</p>
<p>例子89.使用带有动态投影的存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">someMethod</span><span class="params">(PersonRepository people)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Collection&lt;Person&gt; aggregates =</span><br><span class="line">    people.findByLastname(<span class="string">&quot;Matthews&quot;</span>, Person.class);</span><br><span class="line"></span><br><span class="line">  Collection&lt;NamesOnly&gt; aggregates =</span><br><span class="line">    people.findByLastname(<span class="string">&quot;Matthews&quot;</span>, NamesOnly.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="jpa.stored-procedures"></span></p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>JPA 2.1规范引入了对使用JPA标准查询API调用存储过程的支持。我们引入了<code>@Procedure</code>注解，用于在存储库方法上声明存储过程元数据。</p>
<p>下面的示例使用以下存储过程：</p>
<p>示例90. HSQL DB中<code>plus1inout</code>过程的定义。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">procedure</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> plus1inout</span><br><span class="line">/;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">procedure</span> plus1inout (<span class="keyword">IN</span> arg <span class="built_in">int</span>, <span class="keyword">OUT</span> res <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span> ATOMIC</span><br><span class="line"> <span class="keyword">set</span> res = arg + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">/;</span><br></pre></td></tr></table></figure>
<p>可以通过在实体类型上使用<code>NamedStoredProcedureQuery</code>注解来配置存储过程的元数据。</p>
<p>例子91.实体上的StoredProcedure元数据定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedStoredProcedureQuery(name = &quot;User.plus1&quot;, procedureName = &quot;plus1inout&quot;, parameters = &#123;</span></span><br><span class="line"><span class="meta">  @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;arg&quot;, type = Integer.class),</span></span><br><span class="line"><span class="meta">  @StoredProcedureParameter(mode = ParameterMode.OUT, name = &quot;res&quot;, type = Integer.class) &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>@NamedStoredProcedureQuery</code>具有两个不同的存储过程名称。名称是JPA使用的名称。 <code>procedureName</code>是存储过程在数据库中具有的名称。</p>
<p>您可以通过多种方法从存储库方法引用存储过程。可以使用<code>@Procedure</code>注解的value或procedureName属性直接定义要调用的存储过程。这直接引用数据库中的存储过程，并忽略通过<code>@NamedStoredProcedureQuery</code>进行的任何配置。</p>
<p>或者，您可以将<code>@NamedStoredProcedureQuery.name</code>属性指定为<code>@Procedure.name</code>属性。如果未配置<code>value</code>，<code>procedureName</code>或<code>name</code>，则将存储库方法的名称用作<code>name</code>属性。</p>
<p>下面的示例演示如何引用显式映射的过程：</p>
<p>示例92.在数据库中引用名称为“ plus1inout”的显式映射过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Procedure(&quot;plus1inout&quot;)</span></span><br><span class="line"><span class="function">Integer <span class="title">explicitlyNamedPlus1inout</span><span class="params">(Integer arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以下示例与上一个示例等效，但是使用了<code>procedureName</code>别名：</p>
<p>例子93.通过<code>procedureName</code>别名在数据库中引用名称为“ plus1inout”的隐式映射过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Procedure(procedureName = &quot;plus1inout&quot;)</span></span><br><span class="line"><span class="function">Integer <span class="title">callPlus1InOut</span><span class="params">(Integer arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面再次与前两个等效，只是使用方法名称而不是显式注解属性。</p>
<p>例子94.使用方法名称在<code>EntityManager</code>中引用隐式映射的命名存储过程“ User.plus1”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Procedure</span></span><br><span class="line"><span class="function">Integer <span class="title">plus1inout</span><span class="params">(<span class="meta">@Param(&quot;arg&quot;)</span> Integer arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面的示例显示如何通过引用<code>@NamedStoredProcedureQuery.name</code>属性来引用存储过程。</p>
<p>示例95.在EntityManager中引用显式映射的命名存储过程“ User.plus1IO”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Procedure(name = &quot;User.plus1IO&quot;)</span></span><br><span class="line"><span class="function">Integer <span class="title">entityAnnotatedCustomNamedProcedurePlus1IO</span><span class="params">(<span class="meta">@Param(&quot;arg&quot;)</span> Integer arg)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果要调用的存储过程具有单个out参数，则该参数可以作为方法的返回值返回。如果在<code>@NamedStoredProcedureQuery</code>注解中指定了多个输出参数，则可以将这些参数作为<code>Map</code>返回，其键为<code>@NamedStoredProcedureQuery</code>中给出的参数名称。</p>
<p><span id="specifications"></span></p>
<h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p>JPA 2引入了一个标准API，您可以使用它来以编程方式构建查询。通过编写<code>criteria</code>，可以定义域类查询的where子句。再往前一步，这些标准可以视为JPA标准API约束所描述的实体的谓词。</p>
<p>Spring Data JPA采用了Eric Evans的书“域驱动设计”中的规范概念，遵循相同的语义，并提供了使用JPA标准API定义此类规范的API。为了支持规范，可以使用<code>JpaSpecificationExecutor</code>接口扩展存储库接口，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt;, <span class="title">JpaSpecificationExecutor</span> </span>&#123;</span><br><span class="line"> …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附加接口具有使您能够以各种方式执行规范的方法。例如，<code>findAll</code>方法返回与规范匹配的所有实体，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Specification&lt;T&gt; spec)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>Specification</code>接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Specification</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,</span></span></span><br><span class="line"><span class="function"><span class="params">            CriteriaBuilder builder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规范可以轻松地用于在实体之上构建可扩展的谓词集，然后可以将其组合并与<code>JpaRepository</code>一起使用，而无需为每个所需的组合声明查询（方法），如以下示例所示：</p>
<p>例子96.客户规范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerSpecs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;Customer&gt; <span class="title">isLongTermCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query,</span></span></span><br><span class="line"><span class="function"><span class="params">            CriteriaBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         LocalDate date = <span class="keyword">new</span> LocalDate().minusYears(<span class="number">2</span>);</span><br><span class="line">         <span class="keyword">return</span> builder.lessThan(root.get(Customer_.createdAt), date);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Specification&lt;Customer&gt; <span class="title">hasSalesOfMoreThan</span><span class="params">(MonetaryAmount value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,</span></span></span><br><span class="line"><span class="function"><span class="params">            CriteriaBuilder builder)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// build query here</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诚然，样板文件的数量尚有待改进（最终可能会因Java 8闭包而减少），但客户端会变得更好，正如您将在本节后面看到的那样。 <code>Customer_</code>类型是使用JPA元模型生成器生成的元模型类型（有关示例，请参见<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">Hibernate实现的文档</a>）。因此，表达式<code>Customer_.createdAt</code>假定客户具有类型为<code>Date</code>的<code>createdAt</code>属性。除此之外，我们在业务需求抽象级别上表达了一些标准，并创建了可执行的规范。因此，客户端可以使用以下规范：</p>
<p>例子97.使用一个简单的规范</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());</span><br></pre></td></tr></table></figure>
<p>为什么不为这种数据访问创建查询？与普通查询声明相比，使用单个<code>Specification</code>不会带来很多好处。将规范组合在一起以创建新的<code>Specification</code>对象时，规范的力量真正发挥了作用。您可以通过我们提供的用于构建类似于以下内容的表达式的默认<code>Specification</code>方法来实现此目的：</p>
<p>例子98.组合规格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MonetaryAmount amount = <span class="keyword">new</span> MonetaryAmount(<span class="number">200.0</span>, Currencies.DOLLAR);</span><br><span class="line">List&lt;Customer&gt; customers = customerRepository.findAll(</span><br><span class="line">  isLongTermCustomer().or(hasSalesOfMoreThan(amount)));</span><br></pre></td></tr></table></figure>
<p><code>Specification</code>提供了一些“胶水代码”默认方法来链接和组合<code>Specification</code>实例。这些方法使您可以通过创建新的<code>Specification</code>实现并将它们与现有的实现组合来扩展数据访问层。</p>
<p><span id="query-by-example"></span></p>
<h2 id="实例查询"><a href="#实例查询" class="headerlink" title="实例查询"></a>实例查询</h2><p><span id="query-by-example.introduction"></span></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>本章对“示例查询”进行了介绍，并说明了如何使用它。</p>
<p>示例查询（QBE）是一种具有简单界面的用户友好查询技术。 它允许动态查询创建，并且不需要您编写包含字段名称的查询。 实际上，“示例查询”根本不需要您使用商店特定的查询语言编写查询。</p>
<p><span id="query-by-example.usage"></span></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>按示例查询API包含三部分：</p>
<ul>
<li><p>Probe：带有填充字段的域对象的实际示例。</p>
</li>
<li><p><code>ExampleMatcher</code>：<code>ExampleMatcher</code>包含有关如何匹配特定字段的详细信息。可以在多个示例中重复使用它。</p>
</li>
<li><code>Example</code>：示例包括探针和<code>ExampleMatcher</code>。它用于创建查询。</li>
</ul>
<p>按示例查询非常适合几种用例：</p>
<ul>
<li><p>使用一组静态或动态约束来查询数据存储。</p>
</li>
<li><p>频繁重构域对象，而不必担心破坏现有查询。</p>
</li>
<li><p>独立于基础数据存储区API进行工作。</p>
</li>
</ul>
<p>按示例查询也有一些限制：</p>
<ul>
<li><p>不支持嵌套或分组属性约束，例如firstname =？0或（firstname =？1和lastname =？2）。</p>
</li>
<li><p>仅支持字符串的开始/包含/结束/正则表达式匹配，以及其他属性类型的完全匹配。</p>
</li>
</ul>
<p>在开始使用“示例查询”之前，您需要具有一个域对象。首先，为您的存储库创建一个接口，如以下示例所示：</p>
<p>例子99. Sample Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line">  <span class="keyword">private</span> String firstname;</span><br><span class="line">  <span class="keyword">private</span> String lastname;</span><br><span class="line">  <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … getters and setters omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的示例显示了一个简单的域对象。您可以使用它来创建一个示例。默认情况下，具有空值的字段将被忽略，并且使用商店特定的默认值来匹配字符串。可以使用工厂方法或使用<a href="#query-by-example.matchers">ExampleMatcher</a>构建示例。<code>Example</code>是一成不变的。以下清单显示了一个简单的示例：</p>
<p>例子100.简单的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();                         </span><br><span class="line">person.setFirstname(<span class="string">&quot;Dave&quot;</span>);                          </span><br><span class="line"></span><br><span class="line">Example&lt;Person&gt; example = Example.of(person); </span><br></pre></td></tr></table></figure>
<ol>
<li>创建域对象的新实例。</li>
<li>设置要查询的属性。</li>
<li>创建示例。</li>
</ol>
<p>可以使用存储库执行示例查询。为此，请让您的存储库接口扩展<code>QueryByExampleExecutor&lt;T&gt;</code>。以下清单显示了<code>QueryByExampleExecutor</code>接口的摘录：</p>
<p>例子101. <code>QueryByExampleExecutor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QueryByExampleExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">findOne</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">Iterable&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; example)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="query-by-example.matchers"></span></p>
<h3 id="示例匹配器"><a href="#示例匹配器" class="headerlink" title="示例匹配器"></a>示例匹配器</h3><p>示例不限于默认设置。您可以使用<code>ExampleMatcher</code>为字符串匹配，空值处理和特定于属性的设置指定自己的默认值，如以下示例所示：</p>
<p>例子102.具有定制匹配的例子匹配器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();                          </span><br><span class="line">person.setFirstname(<span class="string">&quot;Dave&quot;</span>);                           </span><br><span class="line"></span><br><span class="line">ExampleMatcher matcher = ExampleMatcher.matching()     </span><br><span class="line">  .withIgnorePaths(<span class="string">&quot;lastname&quot;</span>)                         </span><br><span class="line">  .withIncludeNullValues()                             </span><br><span class="line">  .withStringMatcherEnding();                          </span><br><span class="line"></span><br><span class="line">Example&lt;Person&gt; example = Example.of(person, matcher); </span><br></pre></td></tr></table></figure>
<ol>
<li>创建域对象的新实例。</li>
<li>设置属性。</li>
<li>创建一个<code>ExampleMatcher</code>以期望所有值都匹配。即使没有进一步的配置，它也可以在此阶段使用。</li>
<li>构造一个新的<code>ExampleMatcher</code>以忽略<code>lastname</code>属性路径。</li>
<li>构造一个新的<code>ExampleMatcher</code>以忽略<code>lastname</code>属性路径并包含空值。</li>
<li>构造一个新的<code>ExampleMatcher</code>来忽略<code>lastname</code>属性路径，包括空值，并执行后缀字符串匹配。</li>
<li>基于域对象和配置的<code>ExampleMatcher</code>创建一个新的<code>Example</code>。</li>
</ol>
<p>默认情况下，<code>ExampleMatcher</code>期望探针上设置的所有值都匹配。如果要获得与隐式定义的任何谓词匹配的结果，请使用<code>ExampleMatcher.matchingAny()</code>。</p>
<p>您可以为单个属性（例如“名字”和“姓氏”，或者对于嵌套属性，“ address.city”）指定行为。您可以使用匹配选项和区分大小写对其进行调整，如以下示例所示：</p>
<p>例子103.配置匹配器选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExampleMatcher matcher = ExampleMatcher.matching()</span><br><span class="line">  .withMatcher(<span class="string">&quot;firstname&quot;</span>, endsWith())</span><br><span class="line">  .withMatcher(<span class="string">&quot;lastname&quot;</span>, startsWith().ignoreCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置匹配器选项的另一种方法是使用lambda（在Java 8中引入）。此方法创建一个回调，要求实现者修改匹配器。您不需要返回匹配器，因为配置选项保存在匹配器实例中。以下示例显示了使用lambda的匹配器：</p>
<p>例子104.用lambdas配置匹配器选项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ExampleMatcher matcher = ExampleMatcher.matching()</span><br><span class="line">  .withMatcher(<span class="string">&quot;firstname&quot;</span>, match -&gt; match.endsWith())</span><br><span class="line">  .withMatcher(<span class="string">&quot;firstname&quot;</span>, match -&gt; match.startsWith());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>Example</code>创建的查询使用配置的合并视图。可以在<code>ExampleMatcher</code>级别上设置默认的匹配设置，而可以将个别设置应用于特定的属性路径。除非明确定义，否则<code>ExampleMatcher</code>上设置的设置将由属性路径设置继承。属性修补程序上的设置优先于默认设置。下表描述了各种<code>ExampleMatcher</code>设置的范围：</p>
<p>表4. <code>ExampleMatcher</code>设置的范围</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Setting</th>
<th style="text-align:left">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Null-handling</td>
<td style="text-align:left"><code>ExampleMatcher</code></td>
</tr>
<tr>
<td style="text-align:left">String matching</td>
<td style="text-align:left"><code>ExampleMatcher</code> and property path</td>
</tr>
<tr>
<td style="text-align:left">Ignoring properties</td>
<td style="text-align:left">Property path</td>
</tr>
<tr>
<td style="text-align:left">Case sensitivity</td>
<td style="text-align:left"><code>ExampleMatcher</code> and property path</td>
</tr>
<tr>
<td style="text-align:left">Value transformation</td>
<td style="text-align:left">Property path</td>
</tr>
</tbody>
</table>
</div>
<p><span id="query-by-example.execution"></span></p>
<h3 id="查询案例"><a href="#查询案例" class="headerlink" title="查询案例"></a>查询案例</h3><p>在Spring Data JPA中，您可以对存储库使用按示例查询，如以下示例所示：</p>
<p>示例105.使用存储库按示例查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>, <span class="title">String</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span> PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">findPeople</span><span class="params">(Person probe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> personRepository.findAll(Example.of(probe));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前，只有<code>SingularAttribute</code>属性可以用于属性匹配。</p>
</blockquote>
<p>属性说明符接受属性名称（例如<code>firstname</code>和<code>lastname</code>）。 您可以通过将属性与点（<code>address.city</code>）链接在一起来进行导航。 您还可以使用匹配选项和区分大小写对其进行调整。</p>
<p>下表显示了可以使用的各种<code>StringMatcher</code>选项，以及在名为<code>firstname</code>的字段上使用它们的结果：</p>
<p>表5. StringMatcher选项</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Matching</th>
<th style="text-align:left">Logical result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>DEFAULT</code> (case-sensitive)</td>
<td style="text-align:left"><code>firstname = ?0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>DEFAULT</code> (case-insensitive)</td>
<td style="text-align:left"><code>LOWER(firstname) = LOWER(?0)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EXACT</code> (case-sensitive)</td>
<td style="text-align:left"><code>firstname = ?0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EXACT</code> (case-insensitive)</td>
<td style="text-align:left"><code>LOWER(firstname) = LOWER(?0)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>STARTING</code> (case-sensitive)</td>
<td style="text-align:left"><code>firstname like ?0 + &#39;%&#39;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>STARTING</code> (case-insensitive)</td>
<td style="text-align:left"><code>LOWER(firstname) like LOWER(?0) + &#39;%&#39;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ENDING</code> (case-sensitive)</td>
<td style="text-align:left"><code>firstname like &#39;%&#39; + ?0</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ENDING</code> (case-insensitive)</td>
<td style="text-align:left"><code>LOWER(firstname) like &#39;%&#39; + LOWER(?0)</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONTAINING</code> (case-sensitive)</td>
<td style="text-align:left"><code>firstname like &#39;%&#39; + ?0 + &#39;%&#39;</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONTAINING</code> (case-insensitive)</td>
<td style="text-align:left"><code>LOWER(firstname) like &#39;%&#39; + LOWER(?0) + &#39;%&#39;</code></td>
</tr>
</tbody>
</table>
</div>
<p><span id="transactions"></span></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>默认情况下，存储库实例上的CRUD方法是事务性的。 对于读取操作，事务配置readOnly标志设置为true。 所有其他文件都配置有简单的@Transactional，以便应用默认事务配置。 有关详细信息，请参见SimpleJpaRepository的JavaDoc。 如果需要调整在存储库中声明的方法之一的事务配置，请在存储库接口中重新声明该方法，如下所示：</p>
<p>例子106. CRUD的自定义事务配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional(timeout = 10)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Further query method declarations</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做会使<code>findAll()</code>方法以10秒的超时运行，并且没有<code>readOnly</code>标志。</p>
<p>更改事务行为的另一种方法是使用外观或服务实现（通常）覆盖多个存储库。其目的是为非CRUD操作定义事务边界。以下示例显示了如何将这样的外观用于多个存储库：</p>
<p>例子107.使用外观定义多个存储库调用的事务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserManagementImpl</span> <span class="keyword">implements</span> <span class="title">UserManagement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository userRepository;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RoleRepository roleRepository;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserManagementImpl</span><span class="params">(UserRepository userRepository,</span></span></span><br><span class="line"><span class="function"><span class="params">    RoleRepository roleRepository)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepository = userRepository;</span><br><span class="line">    <span class="keyword">this</span>.roleRepository = roleRepository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addRoleToAllUsers</span><span class="params">(String roleName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Role role = roleRepository.findByName(roleName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (User user : userRepository.findAll()) &#123;</span><br><span class="line">      user.addRole(role);</span><br><span class="line">      userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例导致对<code>addRoleToAllUsers(...)</code>的调用在事务内运行（参与现有事务或在没有事务的情况下创建新事务）。然后忽略存储库中的事务配置，因为外部事务配置确定了实际使用的事务配置。请注意，必须激活<code>&lt;tx：annotation-driven /&gt;</code>或显式使用@EnableTransactionManagement才能使基于立面的基于外观的配置生效。本示例假定您使用组件扫描。</p>
<p>请注意，从JPA的角度来看，<code>save</code>调用并不是严格必需的，但为了与Spring Data提供的存储库抽象保持一致，调用保存仍应存在。</p>
<p><span id="transactional-query-methods"></span></p>
<h3 id="带事务的查询方法"><a href="#带事务的查询方法" class="headerlink" title="带事务的查询方法"></a>带事务的查询方法</h3><p>要使查询方法具有事务性，请在您定义的存储库接口上使用<code>@Transactional</code>，如以下示例所示：</p>
<p>例子108.在查询方法上使用<code>@Transactional</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Modifying</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="meta">@Query(&quot;delete from User u where u.active = false&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteInactiveUsers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通常，您希望将<code>readOnly</code>标志设置为<code>true</code>，因为大多数查询方法仅读取数据。与此相反，<code>deleteInactiveUsers()</code>使用<code>@Modifying</code>注解并覆盖事务配置。因此，该方法在<code>readOnly</code>标志设置为<code>false</code>的情况下运行。</p>
<blockquote>
<p>您可以将事务用于只读查询，并通过设置<code>readOnly</code>标志将其标记为事务。但是，这样做并不表示您不会触发操作查询（尽管某些数据库拒绝只读事务中的<code>INSERT</code>和<code>UPDATE</code>语句）。相反，将<code>readOnly</code>标志作为提示传播到底层JDBC驱动程序，以进行性能优化。此外，Spring在基础JPA提供程序上执行了一些优化。例如，当与Hibernate一起使用时，将事务配置为<code>readOnly</code>时，刷新模式将设置为<code>NEVER</code>，这将导致Hibernate跳过脏检查（对大型对象树的显着改进）。</p>
</blockquote>
<p><span id="locking"></span></p>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>要指定要使用的锁定模式，可以在查询方法上使用<code>@Lock</code>注解，如以下示例所示：</p>
<p>例子109.在查询方法上定义锁元数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Plain query method</span></span><br><span class="line">  <span class="meta">@Lock(LockModeType.READ)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法声明使触发的查询配备有READ的<code>LockModeType</code>。 您还可以通过在存储库界面中重新声明CRUD方法的锁来定义锁定，并添加@Lock注解，如以下示例所示：</p>
<p>例子110.在CRUD方法上定义锁元数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redeclaration of a CRUD method</span></span><br><span class="line">  <span class="meta">@Lock(LockModeType.READ)</span>;</span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="auditing"></span></p>
<h2 id="Auditing"><a href="#Auditing" class="headerlink" title="Auditing"></a>Auditing</h2><p><span id="auditing.basics"></span></p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p>Spring Data提供了复杂的支持，可以透明地跟踪创建或更改实体的人员以及更改发生的时间。 要利用该功能，您必须为实体类配备审核元数据，该审核元数据可以使用批注或通过实现接口来定义。</p>
<p><span id="auditing.annotations"></span></p>
<h4 id="基于注解的审核元数据"><a href="#基于注解的审核元数据" class="headerlink" title="基于注解的审核元数据"></a>基于注解的审核元数据</h4><p>我们提供<code>@CreatedBy</code>和@<code>LastModifiedBy</code>来捕获创建或修改实体的用户，并提供<code>@CreatedDate</code>和<code>@LastModifiedDate</code>来捕获更改发生的时间。</p>
<p>例子111.被审计实体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CreatedBy</span></span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CreatedDate</span></span><br><span class="line">  <span class="keyword">private</span> DateTime createdDate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// … further properties omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，可以根据要捕获的信息有选择地应用注解。 捕获更改时捕获的注解可以用于Joda-Time，<code>DateTime</code>，旧版Java <code>Date</code>和<code>Calendar</code>，JDK8日期和时间类型以及<code>long</code>或<code>Long</code>类型的属性。</p>
<p><span id="auditing.interfaces"></span></p>
<h4 id="基于接口的审核元数据"><a href="#基于接口的审核元数据" class="headerlink" title="基于接口的审核元数据"></a>基于接口的审核元数据</h4><p>如果您不想使用注解来定义审核元数据，则可以让您的域类实现Auditable接口。 它公开了所有审核属性的设置器方法。</p>
<p>还有一个便利的基类AbstractAuditable，可以对其进行扩展，以避免需要手动实现接口方法。 这样做会增加您的域类与Spring Data的耦合，这可能是您要避免的事情。 通常，首选基于注释的方式来定义审计元数据，因为它侵入性较小且更灵活。</p>
<p><span id="auditing.auditor-aware"></span></p>
<h4 id="AuditorAware"><a href="#AuditorAware" class="headerlink" title="AuditorAware"></a><code>AuditorAware</code></h4><p>如果您使用<code>@CreatedBy</code>或<code>@LastModifiedBy</code>，则审计基础结构需要以某种方式了解当前主体。为此，我们提供了<code>AuditorAware &lt;T&gt;</code> SPI接口，您必须实现该接口以告知基础结构与应用程序交互的当前用户或系统是谁。通用类型T定义必须使用<code>@CreatedBy</code>或@LastModifiedBy注解的属性的类型。</p>
<p>以下示例显示了使用Spring Security的<code>Authentication</code>对象的接口的实现：</p>
<p>例子112.基于Spring Security的AuditorAware的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpringSecurityAuditorAware</span> <span class="keyword">implements</span> <span class="title">AuditorAware</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;User&gt; <span class="title">getCurrentAuditor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(SecurityContextHolder.getContext())</span><br><span class="line">              .map(SecurityContext::getAuthentication)</span><br><span class="line">              .filter(Authentication::isAuthenticated)</span><br><span class="line">              .map(Authentication::getPrincipal)</span><br><span class="line">              .map(User.class::cast);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该实现访问Spring Security提供的<code>Authentication</code>对象，并查找您在<code>UserDetailsService</code>实现中创建的自定义<code>UserDetails</code>实例。我们在这里假设您通过<code>UserDetails</code>实现公开域用户，但是根据找到的身份验证，您还可以从任何地方查找它。 ：leveloffset：-1</p>
<p><span id="jpa.auditing"></span></p>
<h3 id="JPA-Auditing"><a href="#JPA-Auditing" class="headerlink" title="JPA Auditing"></a>JPA Auditing</h3><p><span id="jpa.auditing.configuration"></span></p>
<h4 id="常规审核配置"><a href="#常规审核配置" class="headerlink" title="常规审核配置"></a>常规审核配置</h4><p>Spring Data JPA附带一个实体侦听器，可用于触发捕获审计信息。首先，必须在orm.xml文件内的持久性上下文中注册要用于所有实体的AuditingEntityListener，如以下示例所示：</p>
<p>例子113.审计配置orm.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistence-unit-metadata</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">persistence-unit-defaults</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">entity-listeners</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">entity-listener</span> <span class="attr">class</span>=<span class="string">&quot;….data.jpa.domain.support.AuditingEntityListener&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">entity-listeners</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">persistence-unit-defaults</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence-unit-metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>您还可以使用<code>@EntityListeners</code>注解按每个实体启用<code>AuditingEntityListener</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@EntityListeners(AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>审核功能要求spring-aspects.jar位于类路径中。</p>
</blockquote>
<p>适当修改<code>orm.xml</code>并在类路径上使用<code>spring-aspects.jar</code>，激活审核功能只需将Spring Data JPA审核名称空间元素添加到您的配置中，如下所示：</p>
<p>例子114.使用XML配置激活审计</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jpa:auditing</span> <span class="attr">auditor-aware-ref</span>=<span class="string">&quot;yourAuditorAwareBean&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>从Spring Data JPA 1.5开始，您可以通过使用<code>@EnableJpaAuditing</code>注解对配置类进行注解来启用审核。您仍然必须修改orm.xml文件，并在类路径上具有<code>spring-aspects.jar</code>。以下示例显示了如何使用<code>@EnableJpaAuditing</code>注解：</p>
<p>例子115.用Java配置激活审计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaAuditing</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AuditorAware&lt;AuditableUser&gt; <span class="title">auditorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AuditorAwareImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将类型<code>AuditorAware</code>的bean公开给<code>ApplicationContext</code>，则审计基础结构会自动选择它并使用它来确定要在域类型上设置的当前用户。如果您在<code>ApplicationContext</code>中注册了多个实现，则可以通过显式设置<code>@EnableJpaAuditing</code>的<code>auditAwareRef</code>属性来选择要使用的实现。</p>
<p><span id="jpa.misc"></span></p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p><span id="jpa.misc.jpa-context"></span></p>
<h3 id="在自定义实现中使用JpaContext"><a href="#在自定义实现中使用JpaContext" class="headerlink" title="在自定义实现中使用JpaContext"></a>在自定义实现中使用<code>JpaContext</code></h3><p>当使用多个<code>EntityManager</code>实例和<a href="#repositories.custom-implementations">自定义存储库实现</a>时，您需要将正确的<code>EntityManager</code>连接到存储库实现类中。您可以通过在<code>@PersistenceContext</code>注解中显式命名EntityManager来实现，或者，如果<code>EntityManager</code>是<code>@Autowired</code>，则可以使用<code>@Qualifier</code>来实现。</p>
<p>从Spring Data JPA 1.9开始，Spring Data JPA包含一个名为<code>JpaContext</code>的类，假定您仅由应用程序中的<code>EntityManager</code>实例之一进行管理，则可以通过托管域类获取<code>EntityManager</code>。以下示例显示如何在自定义存储库中使用<code>JpaContext</code>：</p>
<p>例子116.在自定义存储库实现中使用JpaContext</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">UserRepositoryCustom</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager em;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserRepositoryImpl</span><span class="params">(JpaContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.em = context.getEntityManagerByManagedType(User.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的优点是，如果将域类型分配给其他持久性单元，则无需触摸存储库即可更改对持久性单元的引用。</p>
<p><span id="jpa.misc.merging-persistence-units"></span></p>
<h3 id="合并持久性单元"><a href="#合并持久性单元" class="headerlink" title="合并持久性单元"></a>合并持久性单元</h3><p>Spring支持具有多个持久性单元。 但是，有时您可能希望对应用程序进行模块化，但仍要确保所有这些模块都在单个持久性单元中运行。 为了实现该行为，Spring Data JPA提供了一个PersistenceUnitManager实现，该实现会根据其名称自动合并持久性单元，如以下示例所示：</p>
<p>例子117.使用MergingPersistenceUnitmanager</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;….LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;persistenceUnitManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;….MergingPersistenceUnitManager&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="jpa.misc.entity-scanning"></span></p>
<h4 id="Entity类和JPA映射文件的类路径扫描"><a href="#Entity类和JPA映射文件的类路径扫描" class="headerlink" title="@Entity类和JPA映射文件的类路径扫描"></a>@Entity类和JPA映射文件的类路径扫描</h4><p>普通的JPA设置要求所有注解映射的实体类在<code>orm.xml</code>中列出。 XML映射文件也是如此。 Spring Data JPA提供了一个<code>ClasspathScanningPersistenceUnitPostProcessor</code>，它配置了一个基本包，并可以选择采用映射文件名模式。然后，它在给定的软件包中扫描以<code>@Entity</code>或<code>@MappedSuperclass</code>注解的类，加载与文件名模式匹配的配置文件，并将其交给JPA配置。后处理器必须配置如下：</p>
<p>例子118.使用<code>ClasspathScanningPersistenceUnitPostProcessor</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;….LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;persistenceUnitPostProcessors&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;com.acme.domain&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mappingFileNamePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;**/*Mapping.xml&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从Spring 3.1开始，可以直接在<code>LocalContainerEntityManagerFactoryBean</code>上配置要扫描的程序包，以对实体类启用类路径扫描。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...">JavaDoc</a>)。</p>
</blockquote>
<p><span id="jpd.misc.cdi-integration"></span></p>
<h3 id="CDI整合"><a href="#CDI整合" class="headerlink" title="CDI整合"></a>CDI整合</h3><p>存储库接口的实例通常由容器创建，在使用Spring Data时，Spring是最自然的选择。如<a href="#repositories.create-instances">创建存储库实例</a>中所述，Spring为创建bean实例提供了复杂的支持。从1.1.0版开始，Spring Data JPA附带了一个自定义CDI扩展，该扩展允许在CDI环境中使用存储库抽象。该扩展是JAR的一部分。要激活它，请将Spring Data JPA JAR包含在类路径中。</p>
<p>现在，您可以通过为<code>EntityManagerFactory</code>和<code>EntityManager</code>实现CDI生产者来设置基础结构，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntityManagerFactoryProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Produces</span></span><br><span class="line">  <span class="meta">@ApplicationScoped</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EntityManagerFactory <span class="title">createEntityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Persistence.createEntityManagerFactory(<span class="string">&quot;my-presistence-unit&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="meta">@Disposes</span> EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    entityManagerFactory.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Produces</span></span><br><span class="line">  <span class="meta">@RequestScoped</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> EntityManager <span class="title">createEntityManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> entityManagerFactory.createEntityManager();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="meta">@Disposes</span> EntityManager entityManager)</span> </span>&#123;</span><br><span class="line">    entityManager.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必要的设置可能会因JavaEE环境而异。您可能需要做的只是将<code>EntityManager</code>重新声明为CDI bean，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CdiConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Produces</span></span><br><span class="line">  <span class="meta">@RequestScoped</span></span><br><span class="line">  <span class="meta">@PersistenceContext</span></span><br><span class="line">  <span class="keyword">public</span> EntityManager entityManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，容器必须能够创建JPA <code>EntityManagers</code>本身。所有配置所做的就是将JPA <code>EntityManager</code>重新导出为CDI bean。</p>
<p>每当容器请求存储库类型的bean时，Spring Data JPA CDI扩展都会将所有可用的<code>EntityManager</code>实例作为CDI Bean接收，并为Spring Data存储库创建代理。因此，获取Spring Data存储库的实例只需声明一个<code>@Injected</code>属性即可，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RepositoryClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; people = repository.findAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="appendix"></span></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><span id="repositories.namespace-reference"></span></p>
<h2 id="命名空间参考"><a href="#命名空间参考" class="headerlink" title="命名空间参考"></a>命名空间参考</h2><p><span id="populator.namespace-dao-config"></span></p>
<h3 id="The-lt-repositories-gt-Element"><a href="#The-lt-repositories-gt-Element" class="headerlink" title="The &lt;repositories /&gt; Element"></a>The <code>&lt;repositories /&gt;</code> Element</h3><p><code>&lt;repositories /&gt;</code>元素触发Spring Data存储库基础结构的设置。 最重要的属性是<code>base-package</code>，它定义了要扫描Spring Data仓库接口的软件包。 请参阅<a href="#repositories.create-instances.spring">“ XML配置”</a>。 下表描述了<code>&lt;repositories /&gt;</code>元素的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>base-package</code></td>
<td style="text-align:left">定义要扫描的包，以查找在自动检测模式下扩展<code>* Repository</code>（实际接口由特定的Spring Data模块确定）的存储库接口。 配置包下面的所有包也将被扫描。 允许使用通配符。</td>
</tr>
<tr>
<td style="text-align:left"><code>repository-impl-postfix</code></td>
<td style="text-align:left">定义后缀以自动检测自定义存储库实现。 名称以配置的后缀结尾的类被视为候选。 默认为<code>Impl</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>query-lookup-strategy</code></td>
<td style="text-align:left">确定用于创建查找器查询的策略。 有关详细信息，请参见<a href="#repositories.query-methods.query-lookup-strategies">“查询查找策略”</a>。 默认为创建未找到。</td>
</tr>
<tr>
<td style="text-align:left"><code>named-queries-location</code></td>
<td style="text-align:left">定义搜索包含外部定义查询的属性文件的位置。</td>
</tr>
<tr>
<td style="text-align:left"><code>consider-nested-repositories</code></td>
<td style="text-align:left">是否应考虑嵌套的存储库接口定义。 默认为<code>false</code>。</td>
</tr>
</tbody>
</table>
</div>
<p><span id="populator.namespace-reference"></span></p>
<h2 id="Populators-namespace-reference"><a href="#Populators-namespace-reference" class="headerlink" title="Populators namespace reference"></a>Populators namespace reference</h2><p><span id="namespace-dao-config"></span></p>
<h3 id="The-element"><a href="#The-element" class="headerlink" title="The  element"></a>The <populator/> element</h3><p><code>&lt;populator /&gt;</code>元素允许通过Spring数据存储库基础结构填充数据存储。[1]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>locations</code></td>
<td style="text-align:left">应该在哪里找到文件以从存储库中读取对象。</td>
</tr>
</tbody>
</table>
</div>
<p><span id="repository-query-keywords"></span></p>
<h2 id="Repository查询关键字"><a href="#Repository查询关键字" class="headerlink" title="Repository查询关键字"></a>Repository查询关键字</h2><p><span id=""></span></p>
<h3 id="支持的查询关键字"><a href="#支持的查询关键字" class="headerlink" title="支持的查询关键字"></a>支持的查询关键字</h3><p>下表列出了Spring Data存储库查询派生机制通常支持的关键字。 但是，请参阅商店特定的文档以获取受支持关键字的确切列表，因为特定商店可能不支持此处列出的某些关键字。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Logical keyword</th>
<th style="text-align:left">Keyword expressions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>AND</code></td>
<td style="text-align:left"><code>And</code></td>
</tr>
<tr>
<td style="text-align:left"><code>OR</code></td>
<td style="text-align:left"><code>Or</code></td>
</tr>
<tr>
<td style="text-align:left"><code>AFTER</code></td>
<td style="text-align:left"><code>After</code>, <code>IsAfter</code></td>
</tr>
<tr>
<td style="text-align:left"><code>BEFORE</code></td>
<td style="text-align:left"><code>Before</code>, <code>IsBefore</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONTAINING</code></td>
<td style="text-align:left"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></td>
</tr>
<tr>
<td style="text-align:left"><code>BETWEEN</code></td>
<td style="text-align:left"><code>Between</code>, <code>IsBetween</code></td>
</tr>
<tr>
<td style="text-align:left"><code>ENDING_WITH</code></td>
<td style="text-align:left"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></td>
</tr>
<tr>
<td style="text-align:left"><code>EXISTS</code></td>
<td style="text-align:left"><code>Exists</code></td>
</tr>
<tr>
<td style="text-align:left"><code>FALSE</code></td>
<td style="text-align:left"><code>False</code>, <code>IsFalse</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GREATER_THAN</code></td>
<td style="text-align:left"><code>GreaterThan</code>, <code>IsGreaterThan</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GREATER_THAN_EQUALS</code></td>
<td style="text-align:left"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IN</code></td>
<td style="text-align:left"><code>In</code>, <code>IsIn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS</code></td>
<td style="text-align:left"><code>Is</code>, <code>Equals</code>, (or no keyword)</td>
</tr>
<tr>
<td style="text-align:left"><code>IS_EMPTY</code></td>
<td style="text-align:left"><code>IsEmpty</code>, <code>Empty</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS_NOT_EMPTY</code></td>
<td style="text-align:left"><code>IsNotEmpty</code>, <code>NotEmpty</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS_NOT_NULL</code></td>
<td style="text-align:left"><code>NotNull</code>, <code>IsNotNull</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IS_NULL</code></td>
<td style="text-align:left"><code>Null</code>, <code>IsNull</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LESS_THAN</code></td>
<td style="text-align:left"><code>LessThan</code>, <code>IsLessThan</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LESS_THAN_EQUAL</code></td>
<td style="text-align:left"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LIKE</code></td>
<td style="text-align:left"><code>Like</code>, <code>IsLike</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NEAR</code></td>
<td style="text-align:left"><code>Near</code>, <code>IsNear</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NOT</code></td>
<td style="text-align:left"><code>Not</code>, <code>IsNot</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NOT_IN</code></td>
<td style="text-align:left"><code>NotIn</code>, <code>IsNotIn</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NOT_LIKE</code></td>
<td style="text-align:left"><code>NotLike</code>, <code>IsNotLike</code></td>
</tr>
<tr>
<td style="text-align:left"><code>REGEX</code></td>
<td style="text-align:left"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></td>
</tr>
<tr>
<td style="text-align:left"><code>STARTING_WITH</code></td>
<td style="text-align:left"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></td>
</tr>
<tr>
<td style="text-align:left"><code>TRUE</code></td>
<td style="text-align:left"><code>True</code>, <code>IsTrue</code></td>
</tr>
<tr>
<td style="text-align:left"><code>WITHIN</code></td>
<td style="text-align:left"><code>Within</code>, <code>IsWithin</code></td>
</tr>
</tbody>
</table>
</div>
<p><span id="repository-query-return-types"></span></p>
<h2 id="Repository查询返回类型"><a href="#Repository查询返回类型" class="headerlink" title="Repository查询返回类型"></a>Repository查询返回类型</h2><h3 id="支持的查询返回类型"><a href="#支持的查询返回类型" class="headerlink" title="支持的查询返回类型"></a>支持的查询返回类型</h3><p>下表列出了Spring Data存储库通常支持的返回类型。 但是，请参阅存储特定的文档以获取受支持的返回类型的确切列表，因为特定商店可能不支持此处列出的某些类型。</p>
<blockquote>
<p>地理空间类型（例如<code>GeoResult</code>，<code>GeoResults</code>和<code>GeoPage</code>）仅适用于支持地理空间查询的数据存储。</p>
</blockquote>
<p>表9.查询返回类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Return type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>void</code></td>
<td style="text-align:left">表示没有返回值。</td>
</tr>
<tr>
<td style="text-align:left">Primitives</td>
<td style="text-align:left">Java primitives.</td>
</tr>
<tr>
<td style="text-align:left">Wrapper types</td>
<td style="text-align:left">Java wrapper types.</td>
</tr>
<tr>
<td style="text-align:left"><code>T</code></td>
<td style="text-align:left">唯一实体。 期望查询方法最多返回一个结果。 如果未找到结果，则返回<code>null</code>。 一个以上的结果触发一个<code>IncorrectResultSizeDataAccessException</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>Iterator&lt;T&gt;</code></td>
<td style="text-align:left">An <code>Iterator</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Collection&lt;T&gt;</code></td>
<td style="text-align:left">A <code>Collection</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>List&lt;T&gt;</code></td>
<td style="text-align:left">A <code>List</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Optional&lt;T&gt;</code></td>
<td style="text-align:left">A Java 8 or Guava <code>Optional</code>. Expects the query method to return one result at most. If no result is found, <code>Optional.empty()</code> or <code>Optional.absent()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Option&lt;T&gt;</code></td>
<td style="text-align:left">Either a Scala or Vavr <code>Option</code> type. Semantically the same behavior as Java 8’s <code>Optional</code>, described earlier.</td>
</tr>
<tr>
<td style="text-align:left"><code>Stream&lt;T&gt;</code></td>
<td style="text-align:left">A Java 8 <code>Stream</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Streamable&lt;T&gt;</code></td>
<td style="text-align:left">A convenience extension of <code>Iterable</code> that directy exposes methods to stream, map and filter results, concatenate them etc.</td>
</tr>
<tr>
<td style="text-align:left">Types that implement <code>Streamable</code> and take a <code>Streamable</code> constructor or factory method argument</td>
<td style="text-align:left">Types that expose a constructor or <code>….of(…)</code>/<code>….valueOf(…)</code> factory method taking a <code>Streamable</code> as argument. See <a href="#repositories.collections-and-iterables.streamable-wrapper">Returning Custom Streamable Wrapper Types</a> for details.</td>
</tr>
<tr>
<td style="text-align:left">Vavr <code>Seq</code>, <code>List</code>, <code>Map</code>, <code>Set</code></td>
<td style="text-align:left">Vavr collection types. See <a href="#repositories.collections-and-iterables.vavr">Support for Vavr Collections</a> for details.</td>
</tr>
<tr>
<td style="text-align:left"><code>Future&lt;T&gt;</code></td>
<td style="text-align:left">A <code>Future</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td style="text-align:left"><code>CompletableFuture&lt;T&gt;</code></td>
<td style="text-align:left">A Java 8 <code>CompletableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td style="text-align:left"><code>ListenableFuture</code></td>
<td style="text-align:left">A <code>org.springframework.util.concurrent.ListenableFuture</code>. Expects a method to be annotated with <code>@Async</code> and requires Spring’s asynchronous method execution capability to be enabled.</td>
</tr>
<tr>
<td style="text-align:left"><code>Slice</code></td>
<td style="text-align:left">A sized chunk of data with an indication of whether there is more data available. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td style="text-align:left"><code>Page&lt;T&gt;</code></td>
<td style="text-align:left">A <code>Slice</code> with additional information, such as the total number of results. Requires a <code>Pageable</code> method parameter.</td>
</tr>
<tr>
<td style="text-align:left"><code>GeoResult&lt;T&gt;</code></td>
<td style="text-align:left">A result entry with additional information, such as the distance to a reference location.</td>
</tr>
<tr>
<td style="text-align:left"><code>GeoResults&lt;T&gt;</code></td>
<td style="text-align:left">A list of <code>GeoResult&lt;T&gt;</code> with additional information, such as the average distance to a reference location.</td>
</tr>
<tr>
<td style="text-align:left"><code>GeoPage&lt;T&gt;</code></td>
<td style="text-align:left">A <code>Page</code> with <code>GeoResult&lt;T&gt;</code>, such as the average distance to a reference location.</td>
</tr>
<tr>
<td style="text-align:left"><code>Mono&lt;T&gt;</code></td>
<td style="text-align:left">A Project Reactor <code>Mono</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Flux&lt;T&gt;</code></td>
<td style="text-align:left">A Project Reactor <code>Flux</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flux</code> can emit also an infinite number of elements.</td>
</tr>
<tr>
<td style="text-align:left"><code>Single&lt;T&gt;</code></td>
<td style="text-align:left">A RxJava <code>Single</code> emitting a single element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Maybe&lt;T&gt;</code></td>
<td style="text-align:left">A RxJava <code>Maybe</code> emitting zero or one element using reactive repositories. Expects the query method to return one result at most. If no result is found, <code>Mono.empty()</code> is returned. More than one result triggers an <code>IncorrectResultSizeDataAccessException</code>.</td>
</tr>
<tr>
<td style="text-align:left"><code>Flowable&lt;T&gt;</code></td>
<td style="text-align:left">A RxJava <code>Flowable</code> emitting zero, one, or many elements using reactive repositories. Queries returning <code>Flowable</code> can emit also an infinite number of elements.</td>
</tr>
</tbody>
</table>
</div>
<p><span id="faq"></span></p>
<h2 id="经常问的问题"><a href="#经常问的问题" class="headerlink" title="经常问的问题"></a>经常问的问题</h2><h3 id="Common"><a href="#Common" class="headerlink" title="Common"></a>Common</h3><p>我想获得有关例如<code>JpaRepository</code>内部调用哪些方法的更详细的日志记录信息。我如何获得他们？</p>
<p>您可以使用Spring提供的<code>CustomizableTraceInterceptor</code>，如以下示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;customizableTraceInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">  org.springframework.aop.interceptor.CustomizableTraceInterceptor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enterMessage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Entering $[methodName]($[arguments])&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exitMessage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Leaving $[methodName](): $[returnValue]&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;customizableTraceInterceptor&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">pointcut</span>=<span class="string">&quot;execution(public * org.springframework.data.jpa.repository.JpaRepository+.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Infrastructure"><a href="#Infrastructure" class="headerlink" title="Infrastructure"></a>Infrastructure</h3><p>目前，我已经基于<code>HibernateDaoSupport</code>实现了一个存储库层。我使用Spring的<code>AnnotationSessionFactoryBean</code>创建一个<code>SessionFactory</code>。如何使Spring Data仓库在这种环境下工作？</p>
<p>您必须使用<code>HibernateJpaSessionFactoryBean</code>替换<code>AnnotationSessionFactoryBean</code>，如下所示：</p>
<p>例子119.从一个HibernateEntityManagerFactory查找一个SessionFactory</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;entityManagerFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Auditing-1"><a href="#Auditing-1" class="headerlink" title="Auditing"></a>Auditing</h3><p>我想使用Spring Data JPA审计功能，但是已经将我的数据库配置为在实体上设置修改和创建日期。如何防止Spring Data以编程方式设置日期？</p>
<p>将审核名称空间元素的<code>set-dates</code>属性设置为<code>false</code>。</p>
<p><span id="glossary"></span></p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><p>AOP</p>
<p>Aspect oriented programming</p>
<p>Commons DBCP</p>
<p>Commons DataBase Connection Pools - a library from the Apache foundation that offers pooling implementations of the DataSource interface.</p>
<p>CRUD</p>
<p>Create, Read, Update, Delete - Basic persistence operations.</p>
<p>DAO</p>
<p>Data Access Object - Pattern to separate persisting logic from the object to be persisted</p>
<p>Dependency Injection</p>
<p>Pattern to hand a component’s dependency to the component from outside, freeing the component to lookup the dependent itself. For more information, see <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dependency_Injection">https://en.wikipedia.org/wiki/Dependency_Injection</a>.</p>
<p>EclipseLink</p>
<p>Object relational mapper implementing JPA - <a target="_blank" rel="noopener" href="https://www.eclipse.org/eclipselink/">https://www.eclipse.org/eclipselink/</a></p>
<p>Hibernate</p>
<p>Object relational mapper implementing JPA - <a target="_blank" rel="noopener" href="https://hibernate.org/">https://hibernate.org/</a></p>
<p>JPA</p>
<p>Java Persistence API</p>
<p>Spring</p>
<p>Java application framework - <a target="_blank" rel="noopener" href="https://projects.spring.io/spring-framework">https://projects.spring.io/spring-framework</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring-Data/" rel="tag"># Spring-Data</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/24/Java-Tutorials/" rel="prev" title="Java-Tutorials">
      <i class="fa fa-chevron-left"></i> Java-Tutorials
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/10/%E9%AB%98%E4%B8%AD%E8%8B%B1%E8%AF%AD%E6%B7%B1%E5%BA%A6%E8%BF%9B%E9%98%B6%E8%AF%8D%E6%B1%87/" rel="next" title="高中英语深度进阶词汇">
      高中英语深度进阶词汇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text">项目元数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%92%8C%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">新的和值得注意的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">3.</span> <span class="nav-text">依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring-Boot%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">使用Spring Boot进行依赖管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Framework"><span class="nav-number">3.2.</span> <span class="nav-text">Spring Framework</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">使用Spring数据存储库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">查询方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Repository%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.</span> <span class="nav-text">定义Repository接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E8%B0%83%E5%AD%98%E5%82%A8%E5%BA%93%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.1.</span> <span class="nav-text">微调存储库定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%8E%E5%A4%9A%E4%B8%AASpring%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">将存储库与多个Spring数据模块一起使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">定义查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5"><span class="nav-number">4.4.1.</span> <span class="nav-text">查询查找策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%9B%E5%BB%BA"><span class="nav-number">4.4.2.</span> <span class="nav-text">查询创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.3.</span> <span class="nav-text">属性表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-number">4.4.4.</span> <span class="nav-text">特殊参数处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">分页和排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.5.</span> <span class="nav-text">限制查询结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BA%93%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E6%88%96%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.6.</span> <span class="nav-text">存储库方法返回集合或可迭代对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Streamable%E4%BD%9C%E4%B8%BA%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.6.1.</span> <span class="nav-text">使用Streamable作为查询方法返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%81%E5%BC%8F%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.6.2.</span> <span class="nav-text">返回自定义流式包装器类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81Vavr%E9%9B%86%E5%90%88"><span class="nav-number">4.4.6.3.</span> <span class="nav-text">支持Vavr集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nullability-Annotations"><span class="nav-number">4.4.6.4.</span> <span class="nav-text">Nullability Annotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nullability-in-Kotlin-based-Repositories"><span class="nav-number">4.4.6.5.</span> <span class="nav-text">Nullability in Kotlin-based Repositories</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.7.</span> <span class="nav-text">流查询结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.8.</span> <span class="nav-text">异步查询结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BARepository%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.5.</span> <span class="nav-text">创建Repository实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="nav-number">4.5.1.</span> <span class="nav-text">XML配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%85%8D%E7%BD%AE"><span class="nav-number">4.5.2.</span> <span class="nav-text">Java配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">4.5.3.</span> <span class="nav-text">独立使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Data-Repositories%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.6.</span> <span class="nav-text">Spring Data Repositories的自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E4%B8%AA%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.6.1.</span> <span class="nav-text">自定义单个存储库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.6.2.</span> <span class="nav-text">自定义基础存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8EAggregate-Roots%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.7.</span> <span class="nav-text">从Aggregate Roots发布事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Data%E6%89%A9%E5%B1%95"><span class="nav-number">4.8.</span> <span class="nav-text">Spring Data扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Querydsl%E6%89%A9%E5%B1%95"><span class="nav-number">4.8.1.</span> <span class="nav-text">Querydsl扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.</span> <span class="nav-text">Web支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACWeb%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.1.</span> <span class="nav-text">基本Web支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E5%AA%92%E4%BD%93%E5%AF%B9%E5%88%86%E9%A1%B5%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.2.</span> <span class="nav-text">超媒体对分页的支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Web%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.3.</span> <span class="nav-text">Web数据绑定支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Querydsl-Web%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.4.</span> <span class="nav-text">Querydsl Web支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BA%93%E5%A1%AB%E5%85%85%E5%99%A8"><span class="nav-number">4.8.2.5.</span> <span class="nav-text">存储库填充器</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JPA-Repositories"><span class="nav-number">5.</span> <span class="nav-text">JPA Repositories</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">5.1.1.</span> <span class="nav-text">Spring命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">5.1.2.</span> <span class="nav-text">基于注解的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.3.</span> <span class="nav-text">引导模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E4%BD%93"><span class="nav-number">5.2.</span> <span class="nav-text">持久化实体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%AE%9E%E4%BD%93"><span class="nav-number">5.2.1.</span> <span class="nav-text">保存实体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">实体状态检测策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95-1"><span class="nav-number">5.3.</span> <span class="nav-text">查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">查询查找策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%9B%E5%BB%BA-1"><span class="nav-number">5.3.2.</span> <span class="nav-text">查询创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JPA%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.3.</span> <span class="nav-text">使用JPA命名查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Query"><span class="nav-number">5.3.4.</span> <span class="nav-text">使用@Query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Sort"><span class="nav-number">5.3.5.</span> <span class="nav-text">使用Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-number">5.3.6.</span> <span class="nav-text">使用命名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.3.7.</span> <span class="nav-text">使用SpEL表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.8.</span> <span class="nav-text">修改查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E5%88%A0%E9%99%A4%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.8.1.</span> <span class="nav-text">派生删除查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%8F%90%E7%A4%BA"><span class="nav-number">5.3.9.</span> <span class="nav-text">应用查询提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEFetch-%E5%92%8CLoadGraphs"><span class="nav-number">5.3.10.</span> <span class="nav-text">配置Fetch-和LoadGraphs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Projections"><span class="nav-number">5.3.11.</span> <span class="nav-text">Projections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84Projections"><span class="nav-number">5.3.11.1.</span> <span class="nav-text">基于接口的Projections</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%81%E9%97%AD%E5%BC%8FProjections"><span class="nav-number">5.3.11.1.1.</span> <span class="nav-text">封闭式Projections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%BC%8FProjections"><span class="nav-number">5.3.11.1.2.</span> <span class="nav-text">开放式Projections</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84Projections-DTOs"><span class="nav-number">5.3.11.2.</span> <span class="nav-text">基于类的Projections (DTOs)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81Projections"><span class="nav-number">5.3.11.3.</span> <span class="nav-text">动态Projections</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="nav-number">5.5.</span> <span class="nav-text">技术指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.6.</span> <span class="nav-text">实例查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">5.6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">5.6.2.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="nav-number">5.6.3.</span> <span class="nav-text">示例匹配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B"><span class="nav-number">5.6.4.</span> <span class="nav-text">查询案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.7.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">5.7.1.</span> <span class="nav-text">带事务的查询方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locking"><span class="nav-number">5.8.</span> <span class="nav-text">Locking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Auditing"><span class="nav-number">5.9.</span> <span class="nav-text">Auditing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC"><span class="nav-number">5.9.1.</span> <span class="nav-text">基本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%A1%E6%A0%B8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">5.9.1.1.</span> <span class="nav-text">基于注解的审核元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%A1%E6%A0%B8%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">5.9.1.2.</span> <span class="nav-text">基于接口的审核元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AuditorAware"><span class="nav-number">5.9.1.3.</span> <span class="nav-text">AuditorAware</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA-Auditing"><span class="nav-number">5.9.2.</span> <span class="nav-text">JPA Auditing</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E5%AE%A1%E6%A0%B8%E9%85%8D%E7%BD%AE"><span class="nav-number">5.9.2.1.</span> <span class="nav-text">常规审核配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.10.</span> <span class="nav-text">其他注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E4%B8%AD%E4%BD%BF%E7%94%A8JpaContext"><span class="nav-number">5.10.1.</span> <span class="nav-text">在自定义实现中使用JpaContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E6%8C%81%E4%B9%85%E6%80%A7%E5%8D%95%E5%85%83"><span class="nav-number">5.10.2.</span> <span class="nav-text">合并持久性单元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Entity%E7%B1%BB%E5%92%8CJPA%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F"><span class="nav-number">5.10.2.1.</span> <span class="nav-text">@Entity类和JPA映射文件的类路径扫描</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDI%E6%95%B4%E5%90%88"><span class="nav-number">5.10.3.</span> <span class="nav-text">CDI整合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%82%E8%80%83"><span class="nav-number">6.1.</span> <span class="nav-text">命名空间参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-lt-repositories-gt-Element"><span class="nav-number">6.1.1.</span> <span class="nav-text">The &lt;repositories &#x2F;&gt; Element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Populators-namespace-reference"><span class="nav-number">6.2.</span> <span class="nav-text">Populators namespace reference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-element"><span class="nav-number">6.2.1.</span> <span class="nav-text">The  element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Repository%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.3.</span> <span class="nav-text">Repository查询关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.3.1.</span> <span class="nav-text">支持的查询关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Repository%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">Repository查询返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.1.</span> <span class="nav-text">支持的查询返回类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.</span> <span class="nav-text">经常问的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Common"><span class="nav-number">6.5.1.</span> <span class="nav-text">Common</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Infrastructure"><span class="nav-number">6.5.2.</span> <span class="nav-text">Infrastructure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Auditing-1"><span class="nav-number">6.5.3.</span> <span class="nav-text">Auditing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">6.6.</span> <span class="nav-text">词汇表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/09/28/Spring-Data-JPA/";
    this.page.identifier = "2020/09/28/Spring-Data-JPA/";
    this.page.title = "Spring-Data-JPA";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
