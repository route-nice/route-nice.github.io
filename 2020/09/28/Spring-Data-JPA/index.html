<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="version 2.3.4.RELEASE 前言Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring-Data-JPA">
<meta property="og:url" content="http://yoursite.com/2020/09/28/Spring-Data-JPA/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="version 2.3.4.RELEASE 前言Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-28T05:39:16.000Z">
<meta property="article:modified_time" content="2020-10-10T09:32:37.937Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="Spring-Data">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/09/28/Spring-Data-JPA/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring-Data-JPA | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/28/Spring-Data-JPA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring-Data-JPA
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-28 13:39:16" itemprop="dateCreated datePublished" datetime="2020-09-28T13:39:16+08:00">2020-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-10-10 17:32:37" itemprop="dateModified" datetime="2020-10-10T17:32:37+08:00">2020-10-10</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/09/28/Spring-Data-JPA/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/09/28/Spring-Data-JPA/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>version 2.3.4.RELEASE</p>
<p><strong>前言</strong><br>Spring Data JPA为Java Persistence API（JPA）提供了存储库支持。 它简化了需要访问JPA数据源的应用程序的开发。</p>
<a id="more"></a>
<p><span id="project"></span></p>
<h1 id="项目元数据"><a href="#项目元数据" class="headerlink" title="项目元数据"></a>项目元数据</h1><ul>
<li>版本控制-<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-jpa">https://github.com/spring-projects/spring-data-jpa</a></li>
<li>Bugtracker-<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/DATAJPA">https://jira.spring.io/browse/DATAJPA</a></li>
<li>发布存储库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-release">https://repo.spring.io/libs-release</a></li>
<li>里程碑资料库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-milestone">https://repo.spring.io/libs-milestone</a></li>
<li>快照存储库-<a target="_blank" rel="noopener" href="https://repo.spring.io/libs-snapshot">https://repo.spring.io/libs-snapshot</a></li>
</ul>
<p><span id="new-features"></span></p>
<h1 id="新的和值得注意的"><a href="#新的和值得注意的" class="headerlink" title="新的和值得注意的"></a>新的和值得注意的</h1><p><span id="dependencies"></span></p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>由于各个Spring Data模块的起始日期不同，因此大多数模块带有不同的主要和次要版本号。 查找兼容版本的最简单方法是依赖于我们附带定义的兼容版本的Spring Data Release Train BOM。 在Maven项目中，您可以在POM的<code>&lt;dependencyManagement /&gt;</code>部分中声明此依赖关系，如下所示：</p>
<p>例子1.使用Spring Data Release系列BOM</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>Neumann-SR4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="dependencies.train-names"></span></p>
<p>当前的发行列车版本是Neumann-SR4。 火车名称按字母顺序升序，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">此处</a>列出了当前可用的火车。 版本名称遵循以下模式：<code>$ &#123;name&#125;-$ &#123;release&#125;</code>，其中release可以是以下之一：</p>
<ul>
<li><code>BUILD-SNAPSHOT</code>：当前快照</li>
<li><code>M1，M2</code>等：里程碑</li>
<li><code>RC1，RC2</code>等：发布候选</li>
<li><code>RELEASE</code>：GA发布</li>
<li><code>SR1，SR2</code>等：服务版本</li>
</ul>
<p>在我们的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data示例存储库</a>中可以找到使用BOM的工作示例。 有了它，您可以在<code>&lt;dependencies /&gt;</code>块中声明要使用的Spring Data模块而无需版本，如下所示：</p>
<p>例子2.声明对Spring Data模块的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="dependencies.spring-boot"></span></p>
<h2 id="使用Spring-Boot进行依赖管理"><a href="#使用Spring-Boot进行依赖管理" class="headerlink" title="使用Spring Boot进行依赖管理"></a>使用Spring Boot进行依赖管理</h2><p>Spring Boot为您选择了Spring Data模块的最新版本。 如果仍要升级到较新的版本，请将属性<code>spring-data-releasetrain.version</code>配置为要使用的<a href="#dependencies.train-names">火车名称和迭代</a>。</p>
<p><span id="dependencies.spring-framework"></span></p>
<h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><p>当前版本的Spring Data模块要求使用5.2.9.RELEASE或更高版本的Spring Framework。 这些模块也可以与该次要版本的较旧错误修正版本一起使用。 但是，强烈建议使用该版本中的最新版本。</p>
<p><span id="repositories"></span></p>
<h1 id="使用Spring数据存储库"><a href="#使用Spring数据存储库" class="headerlink" title="使用Spring数据存储库"></a>使用Spring数据存储库</h1><p>Spring数据存储库抽象的目标是显着减少实现各种持久性存储的数据访问层所需的样板代码量。</p>
<blockquote>
<p>Important</p>
<p>Spring Data Repository文档和您的模块</p>
<p>本章介绍了Spring Data存储库的核心概念和接口。 本章中的信息来自Spring Data Commons模块。 它使用Java Persistence API（JPA）模块的配置和代码示例。 您应该使XML名称空间声明和类型适应于所使用的特定模块的等效项。 <a href="#repositories.namespace-reference">“命名空间参考”</a>涵盖XML配置，所有支持存储库API的Spring Data模块均支持该配置。 <a href="#repository-query-keywords">“存储库查询关键字”</a>通常涵盖存储库抽象支持的查询方法关键字。 有关模块的特定功能的详细信息，请参阅本文档中有关该模块的章节。</p>
</blockquote>
<p><span id="repositories.core-concepts"></span></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Spring Data存储库抽象中的中央接口是<code>Repository</code>。 它需要域类以及域类的ID类型作为类型参数来进行管理。 该接口主要用作标记接口，以捕获要使用的类型并帮助您发现扩展该接口的接口。 <code>CrudRepository</code>为正在管理的实体类提供复杂的CRUD功能。</p>
<p>例子3. CrudRepository接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;      </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID primaryKey)</span></span>; </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;                        </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(T entity)</span></span>;               </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">existsById</span><span class="params">(ID primaryKey)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>保存给定的实体。</li>
<li>返回由给定ID标识的实体。</li>
<li>返回所有实体。</li>
<li>返回实体数。</li>
<li>删除给定的实体。</li>
<li>指示是否存在具有给定ID的实体。</li>
</ol>
<blockquote>
<p>我们还提供特定于持久性技术的抽象，例如<code>JpaRepository</code>或<code>MongoRepository</code>。 这些接口扩展了<code>CrudRepository</code>，并除了诸如<code>CrudRepository</code>之类的与通用技术无关的通用接口之外，还公开了基础持久性技术的功能。</p>
</blockquote>
<p>在<code>CrudRepository</code>之上，有一个<code>PagingAndSortingRepository</code>抽象，它添加了其他方法来简化对实体的分页访问：</p>
<p>例子4. PagingAndSortingRepository接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Page&lt;T&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要以20页的页面大小访问<code>User</code>的第二页，您可以执行以下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PagingAndSortingRepository&lt;User, Long&gt; repository = <span class="comment">// … get access to a bean</span></span><br><span class="line">Page&lt;User&gt; users = repository.findAll(PageRequest.of(<span class="number">1</span>, <span class="number">20</span>));</span><br></pre></td></tr></table></figure>
<p>除了查询方法之外，还可以使用计数和删除查询的查询派生。 以下列表显示派生计数查询的接口定义：</p>
<p>例子5.派生计数查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">countByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下列表显示了派生的删除查询的接口定义：</p>
<p>例子6.派生的删除查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">deleteByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">removeByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.query-methods"></span></p>
<h2 id="查询方法"><a href="#查询方法" class="headerlink" title="查询方法"></a>查询方法</h2><p>标准CRUD功能存储库通常在基础数据存储上进行查询。 使用Spring Data，声明这些查询将分为四个步骤：</p>
<ol>
<li><p>声明扩展存储库的接口或其子接口之一，然后将其键入到它应处理的域类和ID类型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口上声明查询方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置Spring以使用<a href="#repositories.create-instances.java-config">JavaConfig</a>或<a href="#repositories.create-instances">XML配置</a>为这些接口创建代理实例。</p>
<ol>
<li><p>要使用Java配置，请创建类似于以下内容的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要使用XML配置，请定义类似于以下内容的bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在此示例中使用了JPA命名空间。 如果将存储库抽象用于任何其他商店，则需要将其更改为商店模块的适当名称空间声明。 换句话说，您应该将<code>jpa</code>换成<code>mongodb</code>。</p>
<p>+另外，请注意，JavaConfig变量不会显式配置程序包，因为默认情况下使用带注释的类的程序包。 要自定义要扫描的包，请使用特定于数据存储的存储库的<code>@Enable$&#123;store&#125;Repositories</code>-annotation的<code>basePackage…</code>属性之一。</p>
</li>
</ol>
</li>
<li><p>注入存储库实例并使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">  SomeClient(PersonRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; persons = repository.findByLastname(<span class="string">&quot;Matthews&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以下各节详细说明了每个步骤：</p>
<ul>
<li><a href="#repositories.definition">定义存储库接口</a></li>
<li><a href="#repositories.query-methods.details">定义查询方法</a></li>
<li><a href="#repositories.create-instances">创建存储库实例</a></li>
<li><a href="#repositories.custom-implementations">Spring数据存储库的定制实现</a></li>
</ul>
<p><span id="repositories.definition"></span></p>
<h2 id="定义Repository接口"><a href="#定义Repository接口" class="headerlink" title="定义Repository接口"></a>定义Repository接口</h2><p>首先，定义特定于域类的存储库接口。 接口必须扩展<code>Repository</code>，并且必须输入域类和ID类型。 如果要公开该域类型的CRUD方法，请扩展<code>CrudRepository</code>而不是<code>Repository</code>。</p>
<p><span id="repositories.definition-tuning"></span></p>
<h3 id="微调存储库定义"><a href="#微调存储库定义" class="headerlink" title="微调存储库定义"></a>微调存储库定义</h3><p>通常，您的存储库接口扩展了<code>Repository</code>，<code>CrudRepository</code>或<code>PagingAndSortingRepository</code>。 另外，如果您不想扩展Spring Data接口，也可以使用<code>@RepositoryDefinition</code>注解存储库接口。 扩展<code>CrudRepository</code>公开了一套完整的方法来操纵您的实体。 如果您希望对公开的方法保持选择性，请将要公开的方法从<code>CrudRepository</code>复制到域存储库中。</p>
<p>这样做可以让您在提供的Spring Data Repositories功能之上定义自己的抽象。<br>下面的示例演示如何有选择地公开CRUD方法（在这种情况下，<code>findById</code>和<code>save</code>）：</p>
<p>例子7.有选择地公开CRUD方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(ID id)</span></span>;</span><br><span class="line"></span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，您为所有域存储库定义了一个通用的基本接口，并公开了<code>findById(...)</code>和<code>save(...)</code>。这些方法被路由到Spring Data提供的所选存储的基本存储库实现中（例如，如果使用JPA，则实现为<code>SimpleJpaRepository</code>，因为它们与<code>CrudRepository</code>中的方法签名匹配。因此，<code>UserRepository</code>现在可以保存用户，按ID查找单个用户，并触发查询以按电子邮件地址查找<code>Users</code>。</p>
<blockquote>
<p>中间存储库接口使用<code>@NoRepositoryBean</code>注解。确保将注释添加到所有存储库接口，Spring Data不应在运行时为其创建实例。</p>
</blockquote>
<p><span id="repositories.multiple-modules"></span></p>
<h3 id="将存储库与多个Spring数据模块一起使用"><a href="#将存储库与多个Spring数据模块一起使用" class="headerlink" title="将存储库与多个Spring数据模块一起使用"></a>将存储库与多个Spring数据模块一起使用</h3><p>在您的应用程序中使用唯一的Spring Data模块使事情变得简单，因为已定义范围中的所有存储库接口均已绑定到Spring Data模块。有时，应用程序需要使用多个Spring Data模块。在这种情况下，存储库定义必须区分持久性技术。当它在类路径上检测到多个存储库工厂时，Spring Data进入严格的存储库配置模式。严格的配置使用存储库或域类上的详细信息来决定有关存储库定义的Spring Data模块绑定：</p>
<ol>
<li><p>如果存储库定义<a href="#repositories.multiple-modules.types">扩展了特定于模块的存储库</a>，则它是特定Spring Data模块的有效候选者。</p>
</li>
<li><p>如果域类使用模块<a href="#repositories.multiple-modules.annotations">特定的类型注解来注解</a>，则它是特定Spring Data模块的有效候选者。 Spring Data模块可以接受第三方注解（例如JPA的<code>@Entity</code>），也可以提供自己的注解（例如Spring Data MongoDB的<code>@Document</code>和Spring Data Elasticsearch）。</p>
</li>
</ol>
<p><span id="repositories.multiple-modules.types"></span></p>
<p>以下示例显示了使用模块特定接口（在这种情况下为JPA）的存储库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>MyRepository</code>和<code>UserRepository</code>在其类型层次结构中扩展了<code>JpaRepository</code>。 它们是Spring Data JPA模块的有效候选者。</p>
<p>以下示例显示了使用通用接口的存储库：</p>
<p>示例9.使用通用接口的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">AmbiguousUserRepository</span> <span class="keyword">extends</span> <span class="title">MyBaseRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>AmbiguousRepository</code>和<code>AmbiguousUserRepository</code>仅在其类型层次结构中扩展<code>Repository</code>和<code>CrudRepository</code>。 尽管在使用唯一的Spring Data模块时这很好，但是多个模块无法区分这些存储库应绑定到哪个特定的Spring Data。</p>
<p>以下示例显示了使用带注解的域类的存储库：</p>
<p><span id="repositories.multiple-modules.annotations"></span></p>
<p>例子10.使用带有注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><code>PersonRepository</code>引用使用JPA <code>@Entity</code>注解进行注解的Person，因此该存储库显然属于Spring Data JPA。 <code>UserRepository</code>引用用户，该用户使用Spring Data MongoDB的<code>@Document</code>注解进行注解。</p>
<p>以下不良示例显示了使用带有混合注解的域类的存储库：</p>
<p>例子11.使用带有混合注解的域类的存储库定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">JpaPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MongoDBPersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Document</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此示例显示了同时使用JPA和Spring Data MongoDB注解的域类。它定义了两个存储库，<code>JpaPersonRepository</code>和<code>MongoDBPersonRepository</code>。一个用于JPA，另一个用于MongoDB。 Spring Data不再能够区分存储库，这导致不确定的行为。</p>
</blockquote>
<p><a href="#repositories.multiple-modules.types">存储库类型详细信息</a>和<a href="#repositories.multiple-modules.annotations">可区分的域类注解</a>用于严格的存储库配置，以标识特定Spring Data模块的存储库候选对象。在同一个域类型上使用多个特定于持久性技术的注解是可能的，并且可以跨多种持久性技术重用域类型。但是，Spring Data无法再确定用于绑定存储库的唯一模块。</p>
<p>区分存储库的最后一种方法是确定存储库基础包的范围。基本软件包定义了扫描存储库接口定义的起点，这意味着将存储库定义放在适当的软件包中。默认情况下，注解驱动的配置使用配置类的包。<a href="#repositories.create-instances.spring">基于XML的配置</a>中的基本软件包是必需的。</p>
<p>以下示例显示了基础包的注解驱动配置：</p>
<p>例子12.基础包的注解驱动配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableJpaRepositories(basePackages = &quot;com.acme.repositories.jpa&quot;)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackages = &quot;com.acme.repositories.mongo&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.query-methods.details"></span></p>
<h2 id="定义查询方法"><a href="#定义查询方法" class="headerlink" title="定义查询方法"></a>定义查询方法</h2><p>存储库代理有两种从方法名称派生特定于商店的查询的方式：</p>
<ul>
<li><p>通过直接从方法名称派生查询。</p>
</li>
<li><p>通过使用手动定义的查询。</p>
</li>
</ul>
<p>可用选项取决于实际商店。但是，必须有一个策略来决定要创建的实际查询。下一节将介绍可用的选项。</p>
<p><span id="repositories.query-methods.query-lookup-strategies"></span></p>
<h3 id="查询查找策略"><a href="#查询查找策略" class="headerlink" title="查询查找策略"></a>查询查找策略</h3><p>以下策略可用于存储库基础结构来解决查询。使用XML配置，您可以通过<code>query-lookup-strategy</code>属性在名称空间中配置策略。对于Java配置，可以使用<code>Enable$&#123;store&#125;Repositories</code>注解的<code>queryLookupStrategy</code>属性。某些数据存储可能不支持某些策略。</p>
<ul>
<li><code>CREATE</code>尝试从查询方法名称构造特定于存储的查询。通用方法是从方法名称中删除一组给定的众所周知的前缀，然后解析该方法的其余部分。您可以在<a href="#repositories.query-methods.query-creation">“查询创建”</a>中阅读有关查询构造的更多信息。</li>
<li><code>USE_DECLARED_QUERY</code>尝试查找已声明的查询，如果找不到则抛出异常。该查询可以通过某处的注解定义，也可以通过其他方式声明。请查阅特定商店的文档以找到该商店的可用选项。如果存储库基础结构在引导时找不到该方法的声明查询，则它将失败。</li>
<li><code>CREATE_IF_NOT_FOUND</code>（默认）结合了<code>CREATE</code>和<code>USE_DECLARED_QUERY</code>。它首先查找一个声明的查询，如果找不到声明的查询，它将创建一个基于名称的自定义方法查询。这是默认的查找策略，因此，如果未显式配置任何内容，则使用该策略。它允许通过方法名称快速定义查询，还可以通过根据需要引入已声明的查询来自定义调整这些查询。</li>
</ul>
<p><span id="repositories.query-methods.query-creation"></span></p>
<h3 id="查询创建"><a href="#查询创建" class="headerlink" title="查询创建"></a>查询创建</h3><p>内置于Spring Data存储库基础结构中的查询生成器机制对于在存储库实体上构建约束查询很有用。该机制从方法中剥离前缀<code>find ... By</code>，<code>read...By</code>，<code>query ... By</code>，<code>count ... By</code>和<code>get ... By</code>，然后开始解析其余部分。 Introduction子句可以包含其他表达式，例如<code>Distinct</code>，用于在要创建的查询上设置不同的标志。但是，第一个By用作分隔符，以指示实际标准的开始。在最基本的级别上，您可以定义实体属性的条件，并将其与<code>And</code>和<code>Or</code>串联。以下示例显示了如何创建许多查询：</p>
<p>例子13.从方法名查询创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(EmailAddress emailAddress, String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enables the distinct flag for the query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findDistinctPeopleByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findPeopleDistinctByLastnameOrFirstname</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling ignoring case for an individual property</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameIgnoreCase</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="comment">// Enabling ignoring case for all suitable properties</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameAndFirstnameAllIgnoreCase</span><span class="params">(String lastname, String firstname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Enabling static ORDER BY for a query</span></span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameAsc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">  <span class="function">List&lt;Person&gt; <span class="title">findByLastnameOrderByFirstnameDesc</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析该方法的实际结果取决于您为其创建查询的持久性存储。但是，需要注意一些一般事项：</p>
<ul>
<li><p>表达式通常是属性遍历，并带有可串联的运算符。您可以将属性表达式与<code>AND</code>和<code>OR</code>结合使用。您还将获得属性表达式的支持，例如<code>between</code>，<code>LessThan</code>，<code>GreaterThan</code>和<code>Like</code>。支持的运算符可能因数据存储而异，因此请参考参考文档的相应部分。</p>
</li>
<li><p>方法解析器支持为单个属性（例如，<code>findByLastnameIgnoreCase（…）</code>）或支持忽略大小写的类型的所有属性（通常为String实例，例如，<code>findByLastnameAndFirstnameAllIgnoreCase(...)</code>）设置<code>IgnoreCase</code>标志。是否支持忽略大小写可能因商店而异，因此请参考参考文档中有关存储特定查询方法的相关部分。</p>
</li>
<li><p>您可以通过将<code>OrderBy</code>子句附加到引用属性的查询方法并提供排序方向（<code>Asc</code>或<code>Desc</code>）来应用静态排序。要创建支持动态排序的查询方法，请参见<a href="#repositories.special-parameters">“特殊参数处理”</a>。</p>
</li>
</ul>
<p><span id="repositories.query-methods.query-property-expressions"></span></p>
<h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>如上例所示，属性表达式只能引用被管实体的直接属性。在查询创建时，您已经确保已解析的属性是托管域类的属性。但是，您也可以通过遍历嵌套属性来定义约束。考虑以下方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddressZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>假设<code>Person</code>的<code>Address</code>带有<code>ZipCode</code>。在这种情况下，该方法将创建遍历属性<code>x.address.zipCode</code>。解析算法首先将整个部分（<code>AddressZipCode</code>）解释为属性，然后在域类中检查具有该名称的属性（未大写）。如果算法成功，它将使用该属性。如果不是，该算法将骆驼箱部分的源从右侧分为头和尾，并尝试找到对应的属性，在我们的示例中为<code>AddressZip</code>和<code>Code</code>。如果该算法找到了具有该头部的属性，则将其取为尾部，并继续从此处开始构建树，以刚才描述的方式将尾部向上拆分。如果第一个拆分不匹配，则算法将拆分点移到左侧（地址，邮政编码）并继续。</p>
<p>尽管这在大多数情况下应该可行，但算法可能会选择错误的属性。假设<code>Person</code>类也具有<code>addressZip</code>属性。该算法将在第一个拆分回合中匹配，选择错误的属性，然后失败（因为<code>addressZip</code>的类型可能没有代码属性）。</p>
<p>要解决这种歧义，您可以在方法名称中使用_来手动定义遍历点。因此，我们的方法名称如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Person&gt; <span class="title">findByAddress_ZipCode</span><span class="params">(ZipCode zipCode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>因为我们将下划线字符视为保留字符，所以我们强烈建议您遵循以下标准Java命名约定（即，在属性名称中不使用下划线，而使用驼峰大小写）。</p>
<p><span id="repositories.special-parameters"></span></p>
<h3 id="特殊参数处理"><a href="#特殊参数处理" class="headerlink" title="特殊参数处理"></a>特殊参数处理</h3><p>要处理查询中的参数，请定义方法参数，如前面的示例所示。除此之外，基础架构还可以识别某些特定类型，例如<code>Pageable</code>和<code>Sort</code>，以将分页和排序动态应用于您的查询。下面的示例演示了这些功能：</p>
<p>例子14.在查询方法中使用<code>Pageable</code>，<code>Slice</code>和<code>Sort</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>采用<code>Sort</code>和<code>Pageable</code>的API期望将非<code>null</code>值传递到方法中。如果您不想应用任何排序或分页，请使用<code>Sort.unsorted()</code>和<code>Pageable.unpaged()</code>。</p>
</blockquote>
<p>第一种方法使您可以将<code>org.springframework.data.domain.Pageable</code>实例传递给查询方法，以将分页动态添加到静态定义的查询中。页面了解可用元素和页面的总数。它是通过基础结构触发计数查询来计算总数来实现的。由于这可能很昂贵（取决于所使用的商店），因此您可以改为返回<code>Slice</code>。切片仅知道下一个切片是否可用，当遍历较大的结果集时这可能就足够了。</p>
<p>排序选项也通过<code>Pageable</code>实例处理。如果只需要排序，则将<code>org.springframework.data.domain.Sort</code>参数添加到您的方法中。如您所见，返回列表也是可能的。在这种情况下，将不会创建构建实际的<code>Page</code>实例所需的其他元数据（这反过来意味着不会发出本来必要的其他计数查询）。而是，它将查询限制为仅查找给定范围的实体。</p>
<blockquote>
<p>要查明整个查询可获得多少页，您必须触发另一个计数查询。默认情况下，此查询源自您实际触发的查询。</p>
</blockquote>
<p><span id="repositories.paging-and-sorting"></span></p>
<h4 id="分页和排序"><a href="#分页和排序" class="headerlink" title="分页和排序"></a>分页和排序</h4><p>可以使用属性名称定义简单的排序表达式。可以将表达式连接起来，以将多个条件收集到一个表达式中。</p>
<p>例子15.定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"></span><br><span class="line">Sort sort = person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>
<p>对于定义排序表达式的类型安全性更高的方法，请从该类型开始为定义排序表达式，然后使用方法引用来定义要进行排序的属性。</p>
<p>例子16.使用类型安全的API定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);</span><br><span class="line"></span><br><span class="line">Sort sort = person.by(Person::getFirstname).ascending()</span><br><span class="line">  .and(person.by(Person::getLastname).descending());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TypedSort.by（…）通常通过使用CGlib来使用运行时代理，当使用Graal VM Native等工具时，CGlib可能会干扰本机映像的编译。<br>如果您的商店实现支持Querydsl，则还可以使用生成的元模型类型来定义排序表达式：</p>
</blockquote>
<p>例子17.使用Querydsl API定义排序表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QSort sort = QSort.by(QPerson.firstname.asc())</span><br><span class="line">  .and(QSort.by(QPerson.lastname.desc()));</span><br></pre></td></tr></table></figure>
<p><span id="repositories.limit-query-result"></span></p>
<h3 id="限制查询结果"><a href="#限制查询结果" class="headerlink" title="限制查询结果"></a>限制查询结果</h3><p>可以通过使用<code>first</code>或<code>top</code>关键字来限制查询方法的结果，它们可以互换使用。可以将可选的数值附加到顶部或顶部，以指定要返回的最大结果大小。如果省略该数字，则假定结果大小为1。以下示例显示了如何限制查询大小：</p>
<p>例子18.用<code>Top</code>和<code>First</code>限制查询的结果大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">User <span class="title">findFirstByOrderByLastnameAsc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">findTopByOrderByAgeDesc</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Page&lt;User&gt; <span class="title">queryFirst10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice&lt;User&gt; <span class="title">findTop3ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findFirst10ByLastname</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findTop10ByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<p>限制表达式还支持<code>Distinct</code>关键字。此外，对于将结果集限制为一个实例的查询，支持使用<code>Optional</code>关键字将结果包装到其中。</p>
<p>如果将分页或切片应用于限制查询分页（以及对可用页面数的计算），则会在限制结果内应用分页或切片。</p>
<blockquote>
<p>通过使用Sort参数来限制结果与动态排序的组合，可以让您表达对最小的“ K”元素和对“ K”的最大元素的查询方法。</p>
</blockquote>
<p><span id="repositories.collections-and-iterables"></span></p>
<h3 id="存储库方法返回集合或可迭代对象"><a href="#存储库方法返回集合或可迭代对象" class="headerlink" title="存储库方法返回集合或可迭代对象"></a>存储库方法返回集合或可迭代对象</h3><p>返回多个结果的查询方法可以使用标准的Java <code>Iterable，List，Set</code>。除此之外，我们还支持返回Spring Data的<code>Streamable</code>，<code>Iterable</code>的自定义扩展以及<a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>提供的集合类型。</p>
<p><span id="repositories.collections-and-iterables.streamable"></span></p>
<h4 id="使用Streamable作为查询方法返回类型"><a href="#使用Streamable作为查询方法返回类型" class="headerlink" title="使用Streamable作为查询方法返回类型"></a>使用Streamable作为查询方法返回类型</h4><p><code>Streamable</code>可用作<code>Iterable</code>或任何集合类型的替代。它提供了方便的方法来访问非并行流（缺少Iterable），能够直接在元素上进行<code>….filter(...)</code>和<code>….map(...)</code>并将<code>Streamable</code>连接到其他元素：</p>
<p>例子19.使用Streamable合并查询方法结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByFirstnameContaining</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">  <span class="function">Streamable&lt;Person&gt; <span class="title">findByLastnameContaining</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Streamable&lt;Person&gt; result = repository.findByFirstnameContaining(<span class="string">&quot;av&quot;</span>)</span><br><span class="line">  .and(repository.findByLastnameContaining(<span class="string">&quot;ea&quot;</span>));</span><br></pre></td></tr></table></figure>
<p><span id="repositories.collections-and-iterables.streamable-wrapper"></span></p>
<h4 id="返回自定义流式包装器类型"><a href="#返回自定义流式包装器类型" class="headerlink" title="返回自定义流式包装器类型"></a>返回自定义流式包装器类型</h4><p>为集合提供专用的包装器类型是一种常用的模式，用于在返回多个元素的查询执行结果上提供API。通常，这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的。如果Spring Data允许这些包装器类型满足以下条件，则可以避免使用这些包装器类型作为查询方法返回类型：</p>
<ol>
<li><p>该类型实现<code>Streamable</code>。</p>
</li>
<li><p>该类型以<code>Streamable</code>作为参数公开构造函数或名为<code>of(...)</code>或<code>valueOf(...)</code>的静态工厂方法。</p>
</li>
</ol>
<p>示例用例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123; <span class="number">1</span></span><br><span class="line">  <span class="function">MonetaryAmount <span class="title">getPrice</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Products</span> <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">Product</span>&gt; </span>&#123; <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Streamable&lt;Product&gt; streamable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MonetaryAmount <span class="title">getTotal</span><span class="params">()</span> </span>&#123; <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> streamable.stream() <span class="comment">//</span></span><br><span class="line">      .map(Priced::getPrice)</span><br><span class="line">      .reduce(Money.of(<span class="number">0</span>), MonetaryAmount::add);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ProductRepository</span> <span class="keyword">implements</span> <span class="title">Repository</span>&lt;<span class="title">Product</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">Products <span class="title">findAllByDescriptionContaining</span><span class="params">(String text)</span></span>; <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>公开API以访问产品价格的产品实体。</li>
<li>可以通过<code>Products.of(...)</code>（通过Lombok注解创建的工厂方法）构造的<code>Streamable &lt;Product&gt;</code>的包装器类型。</li>
<li>包装器类型在<code>Streamable &lt;Product&gt;</code>上公开其他用于计算新值的API。</li>
<li>该包装器类型可以直接用作查询方法返回类型。无需返回<code>Stremable &lt;Product&gt;</code>并将其手动包装在存储库客户端中。</li>
</ol>
<p><span id="repositories.collections-and-iterables.vavr"></span></p>
<h4 id="支持Vavr集合"><a href="#支持Vavr集合" class="headerlink" title="支持Vavr集合"></a>支持Vavr集合</h4><p><a target="_blank" rel="noopener" href="https://www.vavr.io/">Vavr</a>是一个包含Java功能编程概念的库。它附带了一组自定义的收集类型，可用作查询方法返回类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Vavr collection type</th>
<th style="text-align:left">Used Vavr implementation type</th>
<th style="text-align:left">Valid Java source types</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Seq</code></td>
<td style="text-align:left"><code>io.vavr.collection.List</code></td>
<td style="text-align:left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Set</code></td>
<td style="text-align:left"><code>io.vavr.collection.LinkedHashSet</code></td>
<td style="text-align:left"><code>java.util.Iterable</code></td>
</tr>
<tr>
<td style="text-align:left"><code>io.vavr.collection.Map</code></td>
<td style="text-align:left"><code>io.vavr.collection.LinkedHashMap</code></td>
<td style="text-align:left"><code>java.util.Map</code></td>
</tr>
</tbody>
</table>
</div>
<p>第一列中的类型（或其子类型）可以用作查询方法返回类型，并将根据实际查询结果的Java类型（第三列）获取第二列中的类型作为实现类型。或者，可以声明<code>Traversable</code>（等效于Vavr <code>Iterable</code>），然后从实际返回值派生实现类，即<code>java.util.List</code>将被转换为Vavr List / Seq，而java.util.Set变为Vavr <code>LinkedHashSet</code>/<code>Set</code>等</p>
<p><span id="repositories.nullability"></span></p>
<p>从Spring Data 2.0开始，返回单个聚合实例的存储库CRUD方法使用Java 8的<code>Optional</code>来指示可能缺少值。 除此之外，Spring Data支持在查询方法上返回以下包装器类型：</p>
<ul>
<li><code>com.google.common.base.Optional</code></li>
<li><code>scala.Option</code></li>
<li><code>io.vavr.control.Option</code></li>
</ul>
<p>另外，查询方法可以选择根本不使用包装器类型。 然后，通过返回null来指示是否缺少查询结果。 保证返回集合，集合替代项，包装器和流的存储库方法永远不会返回<code>null</code>，而是会返回相应的空表示形式。 有关详细信息，请参见<a href="#repository-query-return-types">“存储库查询返回类型”</a>。</p>
<p><span id="repositories.nullability.annotations"></span></p>
<h4 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h4><p>您可以使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#Null-safety">Spring Framework的可空性注解</a>来表达存储库方法的可空性约束。它们提供了一种工具友好的方法，并且在运行时提供了选择加入的空检查，如下所示：</p>
<ul>
<li><code>@NonNullApi</code>：在包级别用于声明参数和返回值的默认行为是不接受或产生空值。</li>
<li><code>@NonNull</code>：用于不能为空的参数或返回值（<code>@NonNullApi</code>适用的参数和返回值不需要）。</li>
<li><code>@Nullable</code>：用于可以为空的参数或返回值。</li>
</ul>
<p>Spring注解使用<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>注解（休眠但分布广泛的JSR）进行元注解。 JSR 305元注解使工具供应商（例如<a target="_blank" rel="noopener" href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>，<a target="_blank" rel="noopener" href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a>和<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a>）以通用方式提供了空安全支持，而不必对Spring注解进行硬编码支持。为了对查询方法的可空性约束进行运行时检查，您需要使用package-info.java中的Spring的<code>@NonNullApi</code>在包级别激活非空性，如以下示例所示：</p>
<p>例子20.在package-info.java中声明不可为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.lang.NonNullApi</span><br><span class="line"><span class="keyword">package</span> com.acme;</span><br></pre></td></tr></table></figure>
<p>一旦设置了非null的默认值，就可以在运行时验证存储库查询方法的调用是否具有可空性约束。如果查询执行结果违反了定义的约束，则会引发异常。当该方法返回null但被声明为不可为null时（在存储库所在的包中定义了注解的默认值），就会发生这种情况。如果要再次选择接受可为空的结果，请在各个方法上有选择地使用<code>@Nullable</code>。使用本节开头提到的结果包装器类型可以按预期继续工作：将空结果转换为表示缺席的值。</p>
<p>以下示例显示了刚才描述的许多技术：</p>
<p>例子21.使用不同的可空性约束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme;             <span class="number">1</span>                                          </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">getByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>;          <span class="number">2</span>          </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(<span class="meta">@Nullable</span> EmailAddress emailAdress)</span></span>;    <span class="number">3</span>      </span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;User&gt; <span class="title">findOptionalByEmailAddress</span><span class="params">(EmailAddress emailAddress)</span></span>; <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.nullability.kotlin"></span></p>
<h4 id="Nullability-in-Kotlin-based-Repositories"><a href="#Nullability-in-Kotlin-based-Repositories" class="headerlink" title="Nullability in Kotlin-based Repositories"></a>Nullability in Kotlin-based Repositories</h4><p>Kotlin定义了语言中包含的<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">可空性约束</a>。 Kotlin代码编译为字节码，该字节码不通过方法签名来表达可空性约束，而是通过内置的元数据来表达。请确保在您的项目中包含<code>kotlin-reflect</code>的JAR，以对Kotlin的可空性约束进行自省。 Spring Data存储库使用语言机制来定义这些约束以应用相同的运行时检查，如下所示：</p>
<p>例子22.在Kotlin仓库上使用可空性约束</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> : <span class="type">Repository</span>&lt;<span class="type">User, String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByUsername</span><span class="params">(username: <span class="type">String</span>)</span></span>: User     <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">findByFirstname</span><span class="params">(firstname: <span class="type">String</span>?)</span></span>: User? <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>该方法将参数和结果都定义为不可为空（Kotlin默认值）。 Kotlin编译器拒绝将null传递给方法的方法调用。如果查询执行产生空结果，则抛出<code>EmptyResultDataAccessException</code>。</li>
<li>此方法的<code>firstname</code>参数接受<code>null</code>，如果查询执行未产生结果，则返回<code>null</code>。</li>
</ol>
<p><span id="repositories.query-streaming"></span></p>
<h3 id="流查询结果"><a href="#流查询结果" class="headerlink" title="流查询结果"></a>流查询结果</h3><p>通过使用Java 8 <code>Stream&lt;T&gt;</code>作为返回类型，可以递增地处理查询方法的结果。 并非将查询结果包装在<code>Stream</code>中，而是使用特定于数据存储的方法来执行流传输，如以下示例所示：</p>
<p>例子23.用Java 8 <code>Stream&lt;T&gt;</code>流查询的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">findAllByCustomQueryAndStream</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">readAllByFirstnameNotNull</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Query(&quot;select u from User u&quot;)</span></span><br><span class="line"><span class="function">Stream&lt;User&gt; <span class="title">streamAllPaged</span><span class="params">(Pageable pageable)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>Stream</code>可能包装了特定于底层数据存储的资源，因此必须在使用后关闭。 您可以使用<code>close()</code>方法或使用Java 7 <code>try-with-resources</code>块来手动关闭<code>Stream</code>，如以下示例所示：</p>
</blockquote>
<p>例子24.使用<code>Stream&lt;T&gt;</code>导致<code>try-with-resources</code>块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) &#123;</span><br><span class="line">  stream.forEach(…);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当前，并非所有的Spring Data模块都支持Stream <T>作为返回类型。</p>
</blockquote>
<p><span id="repositories.query-async"></span></p>
<h3 id="异步查询结果"><a href="#异步查询结果" class="headerlink" title="异步查询结果"></a>异步查询结果</h3><p>使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/#任务执行和调度">Spring的异步方法执行功能</a>，可以异步运行存储库查询。 这意味着该方法在调用时立即返回，而实际查询执行发生在已提交给Spring <code>TaskExecutor</code>的任务中。 异步查询执行与反应式查询执行不同，因此不应混为一谈。 有关响应式支持的更多详细信息，请参阅商店特定的文档。 以下示例显示了许多异步查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">Future&lt;User&gt; <span class="title">findByFirstname</span><span class="params">(String firstname)</span></span>;               </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">CompletableFuture&lt;User&gt; <span class="title">findOneByFirstname</span><span class="params">(String firstname)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function">ListenableFuture&lt;User&gt; <span class="title">findOneByLastname</span><span class="params">(String lastname)</span></span>;    </span><br></pre></td></tr></table></figure>
<ol>
<li>使用<code>java.util.concurrent.Future</code>作为返回类型。</li>
<li>使用Java 8 <code>java.util.concurrent.CompletableFuture</code>作为返回类型。</li>
<li>使用<code>org.springframework.util.concurrent.ListenableFuture</code>作为返回类型。</li>
</ol>
<p><span id="repositories.create-instances"></span></p>
<h2 id="创建Repository实例"><a href="#创建Repository实例" class="headerlink" title="创建Repository实例"></a>创建Repository实例</h2><p>在本部分中，将为已定义的存储库接口创建实例和Bean定义。 一种方法是使用支持存储库机制的每个Spring Data模块随附的Spring名称空间，尽管我们通常建议使用Java配置。</p>
<p><span id="repositories.create-instances.spring"></span></p>
<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>每个Spring Data模块都包含一个<code>repositories</code>元素，可用于定义Spring会为您扫描的基本软件包，如以下示例所示：</p>
<p>例子25.通过XML启用Spring Data仓库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans:beans</span> <span class="attr">xmlns:beans</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans:beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，指示Spring扫描<code>com.acme.repositories</code>及其所有子包，以查找扩展<code>Repository</code>的接口或其子接口之一。对于找到的每个接口，基础结构都会注册特定于持久性技术的<code>FactoryBean</code>，以创建处理查询方法调用的适当代理。每个bean都使用从接口名称派生的bean名称进行注册，因此<code>UserRepository</code>的接口将注册在<code>userRepository</code>下。 <code>base-package</code>属性允许使用通配符，以便您可以定义扫描程序包的模式。</p>
<p><span id=""></span></p>
<p><strong>使用过滤器</strong><br>默认情况下，基础架构会拾取扩展位于配置的基本包下的特定于持久性技术的<code>Repository</code>子接口的每个接口，并为其创建一个bean实例。 但是，您可能希望更精细地控制哪些接口具有为其创建的Bean实例。 为此，请在<code>&lt;repositories /&gt;</code>元素内使用<code>&lt;include-filter /&gt;</code>和<code>&lt;exclude-filter /&gt;</code>元素。 语义完全等同于Spring的上下文命名空间中的元素。 有关详细信息，请参见这些元素的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#使用过滤器自定义扫描">Spring参考文档</a>。</p>
<p>例如，要将某些接口从实例中排除为存储库Bean，可以使用以下配置：</p>
<p>例子26.使用exclude-filter元素</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;regex&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;.*SomeRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面的示例排除了实例化以<code>SomeRepository</code>结尾的所有接口。</p>
</blockquote>
<p><span id="repositories.create-instances.java-config"></span></p>
<h3 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h3><p>还可以通过在JavaConfig类上使用特定于商店的<code>@Enable$&#123;store&#125;Repositories</code>注解来触发存储库基础结构。 有关Spring容器的基于Java的配置的介绍，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A0%B8%E5%BF%83/#基于Java的容器配置">Spring参考文档中的JavaConfig</a>。</p>
<p>启用Spring数据存储库的示例配置类似于以下内容：</p>
<p>例子27.基于样本注释的存储库配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(&quot;com.acme.repositories&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function">EntityManagerFactory <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// …</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前面的示例使用特定于JPA的注解，您将根据实际使用的商店模块对其进行更改。 这同样适用于<code>EntityManagerFactory</code> bean的定义。 请参阅有关商店特定配置的部分。</p>
</blockquote>
<p><span id="repositories.create-instances.standalone"></span></p>
<h3 id="独立使用"><a href="#独立使用" class="headerlink" title="独立使用"></a>独立使用</h3><p>您还可以在Spring容器之外使用存储库基础结构，例如在CDI环境中。 您的类路径中仍然需要一些Spring库，但是，通常，您也可以通过编程方式来设置存储库。 提供存储库支持的Spring Data模块附带了特定于持久性技术的RepositoryFactory，您可以按以下方式使用它：</p>
<p>例子28.仓库工厂的独立使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RepositoryFactorySupport factory = … <span class="comment">// Instantiate factory here</span></span><br><span class="line">UserRepository repository = factory.getRepository(UserRepository.class);</span><br></pre></td></tr></table></figure>
<p><span id="repositories.custom-implementations"></span></p>
<h2 id="Spring-Data-Repositories的自定义实现"><a href="#Spring-Data-Repositories的自定义实现" class="headerlink" title="Spring Data Repositories的自定义实现"></a>Spring Data Repositories的自定义实现</h2><p>本节介绍存储库定制以及片段如何形成复合存储库。</p>
<p>当查询方法需要不同的行为或无法通过查询派生实现时，则有必要提供自定义实现。 Spring Data存储库使您可以提供自定义存储库代码，并将其与通用CRUD抽象和查询方法功能集成。</p>
<p><span id="repositories.single-repository-behavior"></span></p>
<h3 id="自定义单个存储库"><a href="#自定义单个存储库" class="headerlink" title="自定义单个存储库"></a>自定义单个存储库</h3><p>要使用自定义功能丰富存储库，必须首先定义片段接口和自定义功能的实现，如以下示例所示：</p>
<p>例子29.定制仓库功能的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子30.定制仓库功能的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someCustomMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>与片段接口相对应的类名称中最重要的部分是<code>Impl</code>后缀。</p>
</blockquote>
<p>实现本身不依赖于Spring Data，可以是常规的Spring bean。因此，您可以使用标准的依赖项注入行为来注入对其他bean（例如<code>JdbcTemplate</code>）的引用，参与各个方面，等等。</p>
<p>然后，可以让您的存储库接口扩展片段接口，如以下示例所示：</p>
<p>示例31.对您的存储库界面的更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将片段接口扩展为您的存储库接口，将CRUD和自定义功能结合在一起，并使它可用于客户端。</p>
<p>Spring Data存储库是通过使用构成存储库组成的片段来实现的。片段是基础存储库，功能方面（例如<a href="#core.extensions.querydsl">QueryDsl</a>）以及自定义接口及其实现。每次向存储库接口添加接口时，都通过添加片段来增强组合。每个Spring Data模块都提供了基础存储库和存储库方面的实现。</p>
<p>以下示例显示了自定义接口及其实现：</p>
<p>例子32.片段及其实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HumanRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">HumanRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someHumanMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">anotherContactMethod</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">anotherContactMethod</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示了扩展CrudRepository的自定义存储库的接口：</p>
<p>例子33.对您的存储库界面的更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">HumanRepository</span>, <span class="title">ContactRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Declare query methods here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储库可能由多个自定义实现组成，这些自定义实现按其声明顺序导入。定制实现比基础实现和存储库方面的优先级更高。通过此排序，可以覆盖基本存储库和方面方法，并在两个片段贡献相同方法签名的情况下解决歧义。存储库片段不限于在单个存储库界面中使用。多个存储库可以使用片段接口，使您可以跨不同的存储库重用自定义项。</p>
<p>以下示例显示了存储库片段及其实现：</p>
<p>例子34.覆盖<code>save(...)</code>的片段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedSaveImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">CustomizedSave</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your custom implementation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示了使用上述存储库片段的存储库：</p>
<p>例子35.定制的仓库接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">CustomizedSave</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>配置</strong><br>如果使用名称空间配置，则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段。这些类需要遵循将命名空间元素的<code>repository-impl-postfix</code>属性附加到片段接口名称的命名约定。此后缀默认为<code>Impl</code>。以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库：</p>
<p>例子36.配置例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span> <span class="attr">repository-impl-postfix</span>=<span class="string">&quot;MyPostfix&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>上一示例中的第一个配置尝试查找一个名为<code>com.acme.repository.CustomizedUserRepositoryImpl</code>的类，以用作自定义存储库实现。 第二个示例尝试查找<code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>。</p>
<p><strong>解决歧义</strong><br>如果在不同的包中找到具有匹配类名的多个实现，Spring Data将使用Bean名称来标识要使用的那个。</p>
<p>给定前面显示的<code>CustomizedUserRepository</code>的以下两个自定义实现，将使用第一个实现。 它的bean名称是<code>customizedUserRepositoryImpl</code>，它与片段接口（<code>CustomizedUserRepository</code>）加上后缀<code>Impl</code>的名称匹配。</p>
<p>例子37.歧义实现的解决</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme.impl.one;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.acme.impl.two;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;specialCustomImpl&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedUserRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">CustomizedUserRepository</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Your custom implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>@Component(&quot;specialCustom&quot;)</code>注解<code>UserRepository</code>接口，则Bean名称加<code>Impl</code>会与<code>com.acme.impl.two</code>中为存储库实现定义的一个匹配，并使用它代替第一个。</p>
<p><span id="repositories.manual-wiring"></span></p>
<p><strong>手动接线</strong><br>如果您的自定义实现仅使用基于注解的配置和自动装配，则上述显示的方法可以很好地工作，因为它被视为其他任何Spring bean。 如果您的实现片段bean需要特殊的接线，则可以声明bean并根据上一节中描述的约定对其进行命名。 然后，基础结构通过名称引用手动定义的bean定义，而不是自己创建一个。 以下示例显示如何手动连接自定义实现：</p>
<p>例子38.手工连接定制实现</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;repositories base-<span class="keyword">package</span>=<span class="string">&quot;com.acme.repository&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;beans:bean id=<span class="string">&quot;userRepositoryImpl&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;…&quot;</span>&gt;</span><br><span class="line">  &lt;!-- further configuration --&gt;</span><br><span class="line">&lt;/beans:bean&gt;</span><br></pre></td></tr></table></figure>
<p><span id="repositories.customize-base-repository"></span></p>
<h3 id="自定义基础存储库"><a href="#自定义基础存储库" class="headerlink" title="自定义基础存储库"></a>自定义基础存储库</h3><p>当您要自定义基本存储库行为时，<a href="#repositories.manual-wiring">上一节</a>中描述的方法需要自定义每个存储库接口，以使所有存储库均受到影响。 要改为更改所有存储库的行为，您可以创建一个实现，以扩展特定于持久性技术的存储库基类。 然后，该类充当存储库代理的自定义基类，如以下示例所示：</p>
<p>例子39.定制存储库基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRepositoryImpl</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">SimpleJpaRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">  MyRepositoryImpl(JpaEntityInformation entityInformation,</span><br><span class="line">                          EntityManager entityManager) &#123;</span><br><span class="line">    <span class="keyword">super</span>(entityInformation, entityManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep the EntityManager around to used from the newly introduced methods.</span></span><br><span class="line">    <span class="keyword">this</span>.entityManager = entityManager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> &lt;S extends T&gt; <span class="function">S <span class="title">save</span><span class="params">(S entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implementation goes here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>该类需要具有特定于存储库的存储库工厂实现使用的超类的构造函数。如果存储库基类具有多个构造函数，则覆盖一个采用<code>EntityInformation</code>加上存储特定基础结构对象（例如<code>EntityManager</code>或模板类）的构造函数。</p>
</blockquote>
<p>最后一步是使Spring Data基础结构了解定制的存储库基类。在Java配置中，可以使用<code>@Enable$&#123;store&#125;Repositories</code>注解的<code>repositoryBaseClass</code>属性来实现，如以下示例所示：</p>
<p>例子40.使用JavaConfig配置一个定制的仓库基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfiguration</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>XML名称空间中提供了相应的属性，如以下示例所示：</p>
<p>例子41.使用XML配置一个定制的存储库基类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repository&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">base-class</span>=<span class="string">&quot;….MyRepositoryImpl&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="core.domain-events"></span></p>
<h2 id="从Aggregate-Roots发布事件"><a href="#从Aggregate-Roots发布事件" class="headerlink" title="从Aggregate Roots发布事件"></a>从Aggregate Roots发布事件</h2><p>由存储库管理的实体是聚合根。在域驱动的设计应用程序中，这些聚合根通常发布域事件。 Spring Data提供了一个称为<code>@DomainEvents</code>的注解，您可以在聚合根的方法上使用该注解，以使该发布尽可能容易，如以下示例所示：</p>
<p>例子42.从聚合根公开域事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnAggregateRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DomainEvents</span> <span class="number">1</span></span><br><span class="line">    <span class="function">Collection&lt;Object&gt; <span class="title">domainEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// … return events you want to get published here</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterDomainEventPublication</span> <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callbackMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// … potentially clean up domain events list</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用@DomainEvents的方法可以返回单个事件实例或事件集合。它不能接受任何参数。</li>
<li>在发布所有事件之后，我们有一个用<code>@AfterDomainEventPublication</code>注解的方法。它可以用来潜在地清除要发布的事件列表（以及其他用途）。</li>
</ol>
<p>每当调用Spring Data存储库的<code>save(...)</code>方法之一时，就会调用这些方法。</p>
<p><span id="core.extensions"></span></p>
<h2 id="Spring-Data扩展"><a href="#Spring-Data扩展" class="headerlink" title="Spring Data扩展"></a>Spring Data扩展</h2><p>本节记录了一组Spring Data扩展，这些扩展允许在各种上下文中使用Spring Data。 当前，大多数集成都针对Spring MVC。</p>
<p><span id="core.extensions.querydsl"></span></p>
<h3 id="Querydsl扩展"><a href="#Querydsl扩展" class="headerlink" title="Querydsl扩展"></a>Querydsl扩展</h3><p><a target="_blank" rel="noopener" href="http://www.querydsl.com/">Querydsl</a>是一个框架，可通过其流畅的API来构造静态类型的类似SQL的查询。</p>
<p>几个Spring Data模块通过<code>QuerydslPredicateExecutor</code>提供了与Querydsl的集成，如以下示例所示：</p>
<p>例子43. QuerydslPredicateExecutor接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Optional&lt;T&gt; <span class="title">findById</span><span class="params">(Predicate predicate)</span></span>;  </span><br><span class="line"></span><br><span class="line">  <span class="function">Iterable&lt;T&gt; <span class="title">findAll</span><span class="params">(Predicate predicate)</span></span>;   </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">(Predicate predicate)</span></span>;            </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(Predicate predicate)</span></span>;        </span><br><span class="line"></span><br><span class="line">  <span class="comment">// … more functionality omitted.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>查找并返回与<code>Predicate</code>匹配的单个实体。</li>
<li>查找并返回与<code>Predicate</code>匹配的所有实体。</li>
<li>返回与<code>Predicate</code>匹配的实体数。</li>
<li>返回与<code>Predicate</code>匹配的实体是否存在。</li>
</ol>
<p>要使用Querydsl支持，请在存储库界面上扩展<code>QuerydslPredicateExecutor</code>，如以下示例所示</p>
<p>例子44.存储库上的Querydsl集成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt;, <span class="title">QuerydslPredicateExecutor</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的示例使您可以使用Querydsl<code>Predicate</code>实例编写类型安全查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate predicate = user.firstname.equalsIgnoreCase(<span class="string">&quot;dave&quot;</span>)</span><br><span class="line">    .and(user.lastname.startsWithIgnoreCase(<span class="string">&quot;mathews&quot;</span>));</span><br><span class="line"></span><br><span class="line">userRepository.findAll(predicate);</span><br></pre></td></tr></table></figure>
<p><span id="core.web"></span></p>
<h3 id="Web支持"><a href="#Web支持" class="headerlink" title="Web支持"></a>Web支持</h3><blockquote>
<p>本部分包含Spring Data Web支持的文档，该文档在Spring Data Commons的当前（和更高版本）中实现。随着新引入的支持发生了很多变化，我们将以前行为的文档保存在[web.legacy]中。</p>
</blockquote>
<p>支持存储库编程模型的Spring Data模块附带各种Web支持。与Web相关的组件要求Spring MVC JAR位于类路径上。其中一些甚至提供与<a target="_blank" rel="noopener" href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a>的集成。通常，通过在JavaConfig配置类中使用<code>@EnableSpringDataWebSupport</code>注解来启用集成支持，如以下示例所示：</p>
<p>例子45.启用Spring Data Web支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@EnableSpringDataWebSupport</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>@EnableSpringDataWebSupport</code>注解注册了一些我们稍后将讨论的组件。它还将在类路径上检测Spring HATEOAS，并为其注册集成组件（如果存在）。</p>
<p>另外，如果您使用XML配置，则将<code>SpringDataWebConfiguration</code>或<code>HateoasAwareSpringDataWebConfiguration</code>注册为Spring Bean，如以下示例所示（对于SpringDataWebConfiguration）：</p>
<p>例子46.在XML中启用Spring Data Web支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.SpringDataWebConfiguration&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><span id="core.web.basic"></span></p>
<h4 id="基本Web支持"><a href="#基本Web支持" class="headerlink" title="基本Web支持"></a>基本Web支持</h4><p><a href="#core.web">上一节</a>中显示的配置注册了一些基本组件：</p>
<ul>
<li><p>一个<a href="#core.web.basic.domain-class-converter">DomainClassConverter</a>，可让Spring MVC从请求参数或路径变量解析存储库管理的域类的实例。</p>
</li>
<li><p><a href="#core.web.basic.paging-and-sorting">HandlerMethodArgumentResolver</a>实现，可让Spring MVC从请求参数中解析<code>Pageable</code>和<code>Sort</code>实例。</p>
</li>
</ul>
<p><span id="core.web.basic.domain-class-converter"></span></p>
<p><code>DomainClassConverter</code><br><code>DomainClassConverter</code>允许您在Spring MVC控制器方法签名中直接使用域类型，因此您无需通过存储库手动查找实例，如以下示例所示：</p>
<p>例子47.一个在方法签名中使用域类型的Spring MVC控制器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">showUserForm</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> User user, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;userForm&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，该方法直接接收<code>User</code>实例，不需要进一步的查找。可以通过让Spring MVC首先将路径变量转换为域类的id类型并最终通过在为该域类型注册的存储库实例上调用<code>findById(...)</code>来访问该实例来解析该实例。</p>
<blockquote>
<p>当前，该存储库必须实现<code>CrudRepository</code>才有资格被发现以进行转换。</p>
</blockquote>
<p><span id=""></span></p>
<p><strong>用于分页和排序的HandlerMethodArgumentResolvers</strong></p>
<p><a href="#core.web.basic.domain-class-converter">上一节</a>中显示的配置代码段还注册了<code>PageableHandlerMethodArgumentResolver</code>以及<code>SortHandlerMethodArgumentResolver</code>的实例。该注册启用了<code>Pageable</code>和<code>Sort</code>作为有效的控制器方法参数，如以下示例所示：</p>
<p>例子48.使用Pageable作为控制器方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">  UserController(UserRepository repository) &#123;</span><br><span class="line">    <span class="keyword">this</span>.repository = repository;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span></span><br><span class="line">  <span class="function">String <span class="title">showUsers</span><span class="params">(Model model, Pageable pageable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">&quot;users&quot;</span>, repository.findAll(pageable));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的方法签名使Spring MVC尝试使用以下默认配置从请求参数派生<code>Pageable</code>实例：</p>
<p>表1.为可分页实例评估的请求参数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>page</code></th>
<th>Page you want to retrieve. 0-indexed and defaults to 0.</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size</code></td>
<td>Size of the page you want to retrieve. Defaults to 20.</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>应该以格式属性property(ASC\</td>
<td>DESC)(,IgnoreCase)进行排序的属性。默认排序方向区分大小写。 如果要切换方向或区分大小写，请使用多个排序参数。例如，？sort = firstname＆sort = lastname，asc＆sort = city，ignorecase。</td>
</tr>
</tbody>
</table>
</div>
<p>要自定义此行为，请注册一个分别实现<code>PageableHandlerMethodArgumentResolverCustomizer</code>接口或<code>SortHandlerMethodArgumentResolverCustomizer</code>接口的bean。它的<code>customize()</code>方法被调用，让您更改设置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span> <span class="function">SortHandlerMethodArgumentResolverCustomizer <span class="title">sortCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s -&gt; s.setPropertyDelimiter(<span class="string">&quot;&lt;--&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置现有<code>MethodArgumentResolver</code>的属性不足以满足您的目的，请扩展<code>SpringDataWebConfiguration</code>或启用HATEOAS的等效项，重写<code>pageableResolver()</code>或<code>sortResolver()</code>方法，然后导入自定义的配置文件，而不使用<code>@Enable</code>注解。</p>
<p>如果您需要从请求中解析多个<code>Pageable</code>或<code>Sort</code>实例（例如，对于多个表），则可以使用Spring的<code>@Qualifier</code>注解将一个实例与另一个实例区分开。然后，请求参数必须以<code>$&#123;qualifier&#125;_</code>为前缀。以下示例显示了生成的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">showUsers</span><span class="params">(Model model,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing1&quot;)</span> Pageable first,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="meta">@Qualifier(&quot;thing2&quot;)</span> Pageable second)</span> </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>您必须填充<code>thing1_page</code>和<code>thing2_page</code>，依此类推。</p>
<p>传递给该方法的默认<code>Pageable</code>等效于<code>PageRequest.of（0，20）</code>，但可以通过使用<code>Pageable</code>参数上的<code>@PageableDefault</code>注解进行自定义。</p>
<p><span id="core.repository-populators"></span></p>
<p><span id="jpa.repositories"></span></p>
<h1 id="JPA-Repositories"><a href="#JPA-Repositories" class="headerlink" title="JPA Repositories"></a>JPA Repositories</h1><p>本章指出了JPA信息库支持的特长。 这基于“使用Spring数据存储库”中解释的核心存储库支持。 确保您对此处介绍的基本概念有很好的理解。</p>
<p><span id="jpa.introduction"></span></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本节介绍通过以下两种方式配置Spring Data JPA的基础知识：</p>
<p><a href="#jpa.namespace">“ Spring命名空间”</a>（XML配置）</p>
<p><a href="#jpa.java-config">“基于注解的配置”</a>（Java配置）</p>
<p><span id="jpa.namespace"></span></p>
<h3 id="Spring命名空间"><a href="#Spring命名空间" class="headerlink" title="Spring命名空间"></a>Spring命名空间</h3><p>Spring Data的JPA模块包含一个允许定义存储库bean的自定义名称空间。 它还包含JPA特有的某些功能和元素属性。 通常，可以通过使用repositories元素来设置JPA存储库，如以下示例所示：</p>
<p>例子54.使用命名空间设置JPA存储库</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/data/jpa</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.acme.repositories&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>repositories</code>元素可按<a href="#repositories.create-instances">“创建存储库实例”</a>中所述查找Spring Data存储库。 除此之外，它还为所有使用<code>@Repository</code>注解的bean激活持久性异常转换，以使JPA持久性提供程序引发的异常转换为Spring的<code>DataAccessException</code>层次结构。</p>
<p><strong>自定义命名空间属性</strong><br>除了<code>repositories</code>元素的默认属性，JPA命名空间还提供了其他属性，使您可以更详细地控制存储库的设置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>entity-manager-factory-ref</code></th>
<th>明确地将<code>EntityManagerFactory</code>与要使用的<code>repositories</code>元素检测到的存储库关联。 通常在应用程序中使用多个<code>EntityManagerFactory</code> bean时使用。 如果未配置，Spring Data会在<code>ApplicationContext</code>中自动查找名称为<code>EntityManagerFactory</code>的<code>EntityManagerFactory</code> bean。</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transaction-manager-ref</code></td>
<td>明确地将<code>PlatformTransactionManager</code>与要使用的<code>repositories</code>元素所检测到的存储库进行连线。 通常仅在配置了多个事务管理器或<code>EntityManagerFactory</code> bean时才需要。 默认为当前<code>ApplicationContext</code>中单个定义的<code>PlatformTransactionManager</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note</p>
<p>如果未定义显式的<code>transaction-manager-ref</code>，Spring Data JPA要求提供一个名为<code>transactionManager</code>的<code>PlatformTransactionManager</code> bean。</p>
</blockquote>
<p><span id="jpa.java-config"></span></p>
<h3 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h3><p>Spring Data JPA存储库支持不仅可以通过XML名称空间来激活，还可以通过JavaConfig使用注解来激活，如以下示例所示：</p>
<p>例子55.使用JavaConfig的Spring Data JPA存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJpaRepositories</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    EmbeddedDatabaseBuilder builder = <span class="keyword">new</span> EmbeddedDatabaseBuilder();</span><br><span class="line">    <span class="keyword">return</span> builder.setType(EmbeddedDatabaseType.HSQL).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">entityManagerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HibernateJpaVendorAdapter vendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">    vendorAdapter.setGenerateDdl(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    LocalContainerEntityManagerFactoryBean factory = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">    factory.setJpaVendorAdapter(vendorAdapter);</span><br><span class="line">    factory.setPackagesToScan(<span class="string">&quot;com.acme.domain&quot;</span>);</span><br><span class="line">    factory.setDataSource(dataSource());</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">transactionManager</span><span class="params">(EntityManagerFactory entityManagerFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    JpaTransactionManager txManager = <span class="keyword">new</span> JpaTransactionManager();</span><br><span class="line">    txManager.setEntityManagerFactory(entityManagerFactory);</span><br><span class="line">    <span class="keyword">return</span> txManager;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>您必须直接创建<code>LocalContainerEntityManagerFactoryBean</code>而不是<code>EntityManagerFactory</code>，因为前者除了创建<code>EntityManagerFactory</code>之外，还参与异常转换机制。</p>
</blockquote>
<p>前面的配置类通过使用<code>spring-jdbc</code>的<code>EmbeddedDatabaseBuilder</code> API来设置嵌入式HSQL数据库。然后，Spring Data会建立一个<code>EntityManagerFactory</code>并将<code>Hibernate</code>用作示例持久性提供程序。在此声明的最后一个基础结构组件是JpaTransactionManager。最后，该示例通过使用`@EnableJpaRepositories注解来激活Spring Data JPA仓库，该批注实质上具有与XML名称空间相同的属性。如果未配置任何基本程序包，它将使用配置类所在的程序包。</p>
<p><span id="jpa.bootstrap-mode"></span></p>
<h3 id="引导模式"><a href="#引导模式" class="headerlink" title="引导模式"></a>引导模式</h3><p>默认情况下，Spring Data JPA存储库是默认的Spring Bean。它们是单例作用域的，并且急切地初始化。在启动期间，它们已经与JPA <code>EntityManager</code>进行交互，以进行验证和元数据分析。 Spring框架在后台线程中支持JPA <code>EntityManagerFactory</code>的初始化，因为该过程通常在Spring应用程序中占用大量启动时间。为了有效地利用该后台初始化，我们需要确保JPA存储库尽可能早地初始化。</p>
<p>从Spring Data JPA 2.1开始，您现在可以配置<code>BootstrapMode</code>（通过<code>@EnableJpaRepositories</code>注解或XML名称空间），它采用以下值：</p>
<ul>
<li><code>DEFAULT</code>（默认值）-急切地实例化存储库，除非使用<code>@Lazy</code>显式注解。仅当没有客户机Bean需要存储库实例时，lazification才有效，因为这将需要初始化存储库bean。</li>
<li><code>LAZY</code>-隐式地将所有存储库bean声明为lazy，并且还导致创建懒惰的初始化代理以将其注入到客户端bean中。这意味着，如果客户端bean仅将实例存储在字段中并且在初始化期间不使用存储库，则不会实例化存储库。首次与存储库交互时，将初始化和验证存储库实例。</li>
<li><code>DEFERRED</code> —与<code>LAZY</code>基本相同的操作模式，但是响应<code>ContextRefreshedEvent</code>触发存储库初始化，以便在应用程序完全启动之前验证存储库。</li>
</ul>
<p><strong>推荐建议</strong><br>如果您不使用默认引导模式的异步JPA引导棒。</p>
<p>如果您以异步方式引导JPA，则<code>DEFERRED</code>是一个合理的默认值，因为它可以确保Spring Data JPA引导仅在其花费比初始化所有其他应用程序组件更长的时间时才等待<code>EntityManagerFactory</code>安装。 尽管如此，它仍可以确保在应用程序发出信号之前，对存储库进行了正确的初始化和验证。</p>
<p><code>LAZY</code>是测试方案和本地开发的不错选择。 一旦确定了存储库将正确引导后，或者在测试应用程序的其他部分的情况下，对所有存储库执行验证可能只会不必要地增加启动时间。 这同样适用于本地开发，在本地开发中，您仅访问应用程序的某些部分，而这些部分可能只需要初始化一个存储库即可。</p>
<p><span id="jpa.entity-persistence"></span></p>
<h2 id="持久化实体"><a href="#持久化实体" class="headerlink" title="持久化实体"></a>持久化实体</h2><p>本节描述了如何使用Spring Data JPA持久化（保存）实体。</p>
<p><span id="jpa.entity-persistence.saving-entites"></span></p>
<h3 id="保存实体"><a href="#保存实体" class="headerlink" title="保存实体"></a>保存实体</h3><p>可以使用<code>CrudRepository.save(...)</code>方法执行保存实体。 它使用基础JPA <code>EntityManager</code>持久化或合并给定实体。 如果该实体尚未持久化，Spring Data JPA会通过调用<code>entityManager.persist(...)</code>方法来保存该实体。 否则，它将调用<code>entityManager.merge(...)</code>方法。</p>
<p><span id="jpa.entity-persistence.saving-entites.strategies"></span></p>
<h4 id="实体状态检测策略"><a href="#实体状态检测策略" class="headerlink" title="实体状态检测策略"></a>实体状态检测策略</h4><p>Spring Data JPA提供以下策略来检测实体是否为新实体：</p>
<ol>
<li><p>Version-Property和Id-Property检查（default）：默认情况下，Spring Data JPA首先检查是否存在非基本类型的Version-property。如果存在，则将该实体视为新实体（如果该值为null）。没有这样的版本属性，Spring Data JPA会检查给定实体的标识符属性。如果标识符属性为<code>null</code>，则假定该实体为新实体。否则，假定它不是新的。</p>
</li>
<li><p>实现<code>Persistable</code>：如果实体实现<code>Persistable</code>，则Spring Data JPA将新检测委托给该实体的<code>isNew(...)</code>方法。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a>。</p>
</li>
<li><p>实现<code>EntityInformation</code>：通过创建<code>JpaRepositoryFactory</code>的子类并相应地重写<code>getEntityInformation(...)</code>方法，可以自定义<code>SimpleJpaRepository</code>实现中使用的<code>EntityInformation</code>抽象。然后，您必须将<code>JpaRepositoryFactory</code>的自定义实现注册为Spring bean。请注意，这几乎没有必要。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a>。</p>
</li>
</ol>
<p>对于使用手动分配的标识符的实体，选项1不是选项，因为标识符将始终为非<code>null</code>。在这种情况下，一种常见的模式是使用一个公共基类，该基类的过渡标志默认表示一个新实例，并使用JPA生命周期回调在持久性操作上翻转该标志：</p>
<p>例子56.具有手动分配的标识符的实体的基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEntity</span>&lt;<span class="title">ID</span>&gt; <span class="keyword">implements</span> <span class="title">Persistable</span>&lt;<span class="title">ID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isNew = <span class="keyword">true</span>; <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isNew; <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@PrePersist</span> <span class="number">3</span></span><br><span class="line">  <span class="meta">@PostLoad</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">markNotNew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.isNew = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// More code…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>声明一个标志以保持新状态。 暂时的，因此它不会持久化到数据库中。</li>
<li>在<code>Persistable.isNew()</code>的实现中返回标志，以便Spring Data存储库知道是调用<code>EntityManager.persist()</code>还是<code>….merge()</code>。</li>
<li>声明使用JPA实体回调的方法，以便在存储库调用<code>save(...)</code>或持久性提供程序创建实例之后，将标志切换为指示现有实体。</li>
</ol>
<p><span id="jpa.query-methods"></span></p>
<h2 id="查询方法-1"><a href="#查询方法-1" class="headerlink" title="查询方法"></a>查询方法</h2><p>本节描述了使用Spring Data JPA创建查询的各种方法。</p>
<p><span id="jpa.sample-app.finders.strategies"></span></p>
<h3 id="查询查找策略-1"><a href="#查询查找策略-1" class="headerlink" title="查询查找策略"></a>查询查找策略</h3><p>JPA模块支持手动将查询定义为String或从方法名称派生查询。</p>
<p>谓词为<code>IsStartingWith</code>，<code>StartingWith</code>，<code>StartsWith</code>，<code>IsEndingWith</code>，<code>EndingWith</code>，<code>EndsWith</code>，<code>IsNotContaining</code>，NotContaining，<code>NotContains</code>，<code>IsContaining</code>，<code>Containing</code>的派生查询将包含这些查询的各自参数。这意味着，如果参数实际上包含LIKE识别为通配符的字符，则这些字符将被转义，因此它们仅作为文字匹配。可以通过设置<code>@EnableJpaRepositories</code>注解的<code>escapeCharacter</code>来配置使用的转义字符。与<a href="#jpa.query.spel-expressions">使用SpEL表达式</a>进行比较。</p>
<p><strong>声明查询</strong><br>尽管从方法名派生一个查询很方便，但可能会遇到这样一种情况，即方法名解析器不支持一个人想使用的关键字，或者方法名不必要地变得丑陋。因此，您可以通过命名约定使用JPA命名查询（有关更多信息，请参见<a href="#jpa.query-methods.named-queries">使用JPA命名查询</a>），或者通过<code>@Query</code>注解您的查询方法（有关详细信息，请参阅<a href="#jpa.query-methods.at-query">使用@Query</a>）。</p>
<p><span id="jpa.query-methods.query-creation"></span></p>
<h3 id="查询创建-1"><a href="#查询创建-1" class="headerlink" title="查询创建"></a>查询创建</h3><p>通常，JPA的查询创建机制按<a href="#repositories.query-methods">“查询方法”</a>中所述运行。 以下示例显示了JPA查询方法转换为的内容：</p>
<p>例子57.从方法名查询创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByEmailAddressAndLastname</span><span class="params">(String emailAddress, String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们从中使用JPA标准API创建查询，但是从本质上讲，这将转换为以下查询：<code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code> 如<a href="#repositories.query-methods.query-property-expressions">“属性表达式”</a>中所述，Spring Data JPA进行属性检查并遍历嵌套的属性。</p>
<p>下表描述了JPA支持的关键字以及包含该关键字的方法所转换的含义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Keyword</th>
<th style="text-align:left">Sample</th>
<th style="text-align:left">JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>And</code></td>
<td style="text-align:left"><code>findByLastnameAndFirstname</code></td>
<td style="text-align:left"><code>… where x.lastname = ?1 and x.firstname = ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Or</code></td>
<td style="text-align:left"><code>findByLastnameOrFirstname</code></td>
<td style="text-align:left"><code>… where x.lastname = ?1 or x.firstname = ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Is</code>, <code>Equals</code></td>
<td style="text-align:left"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></td>
<td style="text-align:left"><code>… where x.firstname = ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Between</code></td>
<td style="text-align:left"><code>findByStartDateBetween</code></td>
<td style="text-align:left"><code>… where x.startDate between ?1 and ?2</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LessThan</code></td>
<td style="text-align:left"><code>findByAgeLessThan</code></td>
<td style="text-align:left"><code>… where x.age &lt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>LessThanEqual</code></td>
<td style="text-align:left"><code>findByAgeLessThanEqual</code></td>
<td style="text-align:left"><code>… where x.age &lt;= ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GreaterThan</code></td>
<td style="text-align:left"><code>findByAgeGreaterThan</code></td>
<td style="text-align:left"><code>… where x.age &gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>GreaterThanEqual</code></td>
<td style="text-align:left"><code>findByAgeGreaterThanEqual</code></td>
<td style="text-align:left"><code>… where x.age &gt;= ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>After</code></td>
<td style="text-align:left"><code>findByStartDateAfter</code></td>
<td style="text-align:left"><code>… where x.startDate &gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Before</code></td>
<td style="text-align:left"><code>findByStartDateBefore</code></td>
<td style="text-align:left"><code>… where x.startDate &lt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IsNull</code>, <code>Null</code></td>
<td style="text-align:left"><code>findByAge(Is)Null</code></td>
<td style="text-align:left"><code>… where x.age is null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IsNotNull</code>, <code>NotNull</code></td>
<td style="text-align:left"><code>findByAge(Is)NotNull</code></td>
<td style="text-align:left"><code>… where x.age not null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Like</code></td>
<td style="text-align:left"><code>findByFirstnameLike</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NotLike</code></td>
<td style="text-align:left"><code>findByFirstnameNotLike</code></td>
<td style="text-align:left"><code>… where x.firstname not like ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>StartingWith</code></td>
<td style="text-align:left"><code>findByFirstnameStartingWith</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>EndingWith</code></td>
<td style="text-align:left"><code>findByFirstnameEndingWith</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>Containing</code></td>
<td style="text-align:left"><code>findByFirstnameContaining</code></td>
<td style="text-align:left"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</td>
</tr>
<tr>
<td style="text-align:left"><code>OrderBy</code></td>
<td style="text-align:left"><code>findByAgeOrderByLastnameDesc</code></td>
<td style="text-align:left"><code>… where x.age = ?1 order by x.lastname desc</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Not</code></td>
<td style="text-align:left"><code>findByLastnameNot</code></td>
<td style="text-align:left"><code>… where x.lastname &lt;&gt; ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>In</code></td>
<td style="text-align:left"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></td>
<td style="text-align:left"><code>… where x.age in ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NotIn</code></td>
<td style="text-align:left"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></td>
<td style="text-align:left"><code>… where x.age not in ?1</code></td>
</tr>
<tr>
<td style="text-align:left"><code>True</code></td>
<td style="text-align:left"><code>findByActiveTrue()</code></td>
<td style="text-align:left"><code>… where x.active = true</code></td>
</tr>
<tr>
<td style="text-align:left"><code>False</code></td>
<td style="text-align:left"><code>findByActiveFalse()</code></td>
<td style="text-align:left"><code>… where x.active = false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>IgnoreCase</code></td>
<td style="text-align:left"><code>findByFirstnameIgnoreCase</code></td>
<td style="text-align:left"><code>… where UPPER(x.firstame) = UPPER(?1)</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note</p>
<p><code>In</code>和<code>NotIn</code>也将<code>Collection</code>的任何子类作为参数以及varargs的数组。 对于同一逻辑运算符的其他语法版本，请选中<a href="#repository-query-keywords">“存储库查询关键字”</a>。</p>
</blockquote>
<p><span id="jpa.query-methods.named-queries"></span></p>
<h3 id="使用JPA命名查询"><a href="#使用JPA命名查询" class="headerlink" title="使用JPA命名查询"></a>使用JPA命名查询</h3><blockquote>
<p>Note</p>
<p>这些示例使用<code>&lt;named-query/&gt;</code>元素和<code>@NamedQuery</code>注解。 这些配置元素的查询必须用JPA查询语言定义。 当然，您也可以使用<code>&lt;named-native-query /&gt;</code>或<code>@NamedNativeQuery</code>。 这些元素使您可以通过失去数据库平台独立性来在本机SQL中定义查询。</p>
</blockquote>
<p><strong>XML命名查询定义</strong><br>要使用XML配置，请将必要的<named-query />元素添加到位于类路径的META-INF文件夹中的orm.xml JPA配置文件中。 通过使用一些定义的命名约定，可以自动调用命名查询。 有关更多详细信息，请参见下文。</p>
<p>例子58. XML命名查询配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">named-query</span> <span class="attr">name</span>=<span class="string">&quot;User.findByLastname&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">query</span>&gt;</span>select u from User u where u.lastname = ?1<span class="tag">&lt;/<span class="name">query</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-query</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该查询具有一个特殊名称，该名称用于在运行时解析它。</p>
<p><strong>基于注解的配置</strong><br>基于注解的配置的优点是不需要编辑另一个配置文件，从而减少了维护工作。 您需要为每个新的查询声明重新编译域类，从而为此付出了代价。</p>
<p>例子59.基于注释的命名查询配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedQuery(name = &quot;User.findByEmailAddress&quot;,</span></span><br><span class="line"><span class="meta">  query = &quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明接口</strong><br>要允许执行这些命名查询，请按以下方式指定<code>UserRepository</code>：</p>
<p>例子60. UserRepository中的查询方法声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data尝试将对这些方法的调用解析为对命名查询的调用，从已配置的域类的简单名称开始，然后是由句点分隔的方法名称。 因此，前面的示例将使用在示例中定义的命名查询，而不是尝试从方法名称创建查询。</p>
<p><span id="jpa.query-methods.at-query"></span></p>
<h3 id="使用-Query"><a href="#使用-Query" class="headerlink" title="使用@Query"></a>使用@Query</h3><p>使用命名查询声明对实体的查询是一种有效的方法，并且对于少量查询也可以正常工作。 由于查询本身与执行它们的Java方法相关联，因此您实际上可以通过使用Spring Data JPA <code>@Query</code>注解直接绑定它们，而不是将它们注解到域类。 这样可以将域类从持久性特定的信息中释放出来，并将查询放置在存储库接口中。</p>
<p>注解查询方法的查询优先于使用<code>@NamedQuery</code>定义的查询或在<code>orm.xml</code>中声明的命名查询。</p>
<p>以下示例显示使用<code>@Query</code>注解创建的查询：</p>
<p>例子61.使用<code>@Query</code>在查询方法中声明查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.emailAddress = ?1&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用高级<code>LIKE</code>表达式</strong><br>使用<code>@Query</code>创建的手动定义查询的查询执行机制允许在查询定义中定义高级<code>LIKE</code>表达式，如以下示例所示：</p>
<p>例子62. <code>@Query</code>中的高级<code>like</code>表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname like %?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByFirstnameEndsWith</span><span class="params">(String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，识别了<code>LIKE</code>分隔符（<code>％</code>），并将查询转换为有效的JPQL查询（删除了<code>％</code>）。 查询执行后，传递给方法调用的参数将使用先前识别的<code>LIKE</code>模式进行扩充。</p>
<p><strong>本地查询</strong><br><code>@Query</code>注解允许通过将nativeQuery标志设置为true来运行本地查询，如以下示例所示：</p>
<p>例子63.使用@Query在查询方法中声明一个本地查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1&quot;, nativeQuery = true)</span></span><br><span class="line">  <span class="function">User <span class="title">findByEmailAddress</span><span class="params">(String emailAddress)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA当前不支持对本机查询进行动态排序，因为它必须操纵声明的实际查询，而这对于本机SQL无法可靠地完成。 但是，您可以通过自己指定count查询来使用本机查询进行分页，如以下示例所示：<br>例子64.使用@Query在查询方法中声明本地计数查询的分页</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(value = &quot;SELECT * FROM USERS WHERE LASTNAME = ?1&quot;,</span></span><br><span class="line"><span class="meta">    countQuery = &quot;SELECT count(*) FROM USERS WHERE LASTNAME = ?1&quot;,</span></span><br><span class="line"><span class="meta">    nativeQuery = true)</span></span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过将<code>.count</code>后缀添加到查询的副本中，类似的方法也可用于命名本机查询。 不过，您可能需要为计数查询注册结果集映射。</p>
<p><span id="jpa.query-methods.sorting"></span></p>
<h3 id="使用Sort"><a href="#使用Sort" class="headerlink" title="使用Sort"></a>使用Sort</h3><p>可以通过提供<code>PageRequest</code>或直接使用<code>Sort</code>来完成排序。 在<code>Sort</code>的<code>Order</code>实例中实际使用的属性需要与您的域模型匹配，这意味着它们需要解析为查询中使用的属性或别名。 JPQL将此定义为状态字段路径表达式。</p>
<blockquote>
<p>Note</p>
<p>使用任何不可引用的路径表达式都会导致<code>Exception</code>。</p>
</blockquote>
<p>但是，将<code>Sort</code>与<a href="#jpa.query-methods.at-query">@Query</a>一起使用，可以让您潜入包含<code>ORDER BY</code>子句中的函数的未经路径检查的Order实例。 这是可能的，因为<code>Order</code>附加到给定的查询字符串中。 默认情况下，Spring Data JPA拒绝任何包含函数调用的<code>Order</code>实例，但是您可以使用<code>JpaSort.unsafe</code>添加可能不安全的排序。</p>
<p>以下示例使用<code>Sort</code>和<code>JpaSort</code>，在JpaSort上包括一个不安全的选项：</p>
<p>例子65.使用排序和JpaSort</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByAndSort</span><span class="params">(String lastname, Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%&quot;)</span></span><br><span class="line">  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repo.findByAndSort(<span class="string">&quot;lannister&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;firstname&quot;</span>));     <span class="number">1</span>          </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;stark&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;LENGTH(firstname)&quot;</span>));        <span class="number">2</span>   </span><br><span class="line">repo.findByAndSort(<span class="string">&quot;targaryen&quot;</span>, JpaSort.unsafe(<span class="string">&quot;LENGTH(firstname)&quot;</span>)); <span class="number">3</span></span><br><span class="line">repo.findByAsArrayAndSort(<span class="string">&quot;bolton&quot;</span>, <span class="keyword">new</span> Sort(<span class="string">&quot;fn_len&quot;</span>));         <span class="number">4</span>     </span><br></pre></td></tr></table></figure>
<ol>
<li>指向域模型中属性的有效Sort表达式。</li>
<li>包含函数调用的无效排序。 Thows异常。</li>
<li>有效排序包含明显不安全的订单。</li>
<li>指向别名函数的有效Sort表达式。</li>
</ol>
<p><span id="jpa.named-parameters"></span></p>
<h3 id="使用命名参数"><a href="#使用命名参数" class="headerlink" title="使用命名参数"></a>使用命名参数</h3><p>默认情况下，Spring Data JPA使用基于位置的参数绑定，如前面所有示例中所述。 当重构有关参数位置的查询时，这会使查询方法容易出错。 要解决此问题，可以使用<code>@Param</code>注解为方法参数指定一个具体名称，然后在查询中绑定该名称，如以下示例所示：</p>
<p>例子66.使用命名参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from User u where u.firstname = :firstname or u.lastname = :lastname&quot;)</span></span><br><span class="line">  <span class="function">User <span class="title">findByLastnameOrFirstname</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="meta">@Param(&quot;firstname&quot;)</span> String firstname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>方法参数根据它们在定义的查询中的顺序进行切换。</p>
<p>从版本4开始，Spring完全支持基于<code>-parameters</code>编译器标志的Java 8参数名称发现。 通过在构建中使用此标志作为调试信息的替代方法，可以省略<code>@Param</code>注解的命名参数。</p>
</blockquote>
<p><span id="jpa.query.spel-expressions"></span></p>
<h3 id="使用SpEL表达式"><a href="#使用SpEL表达式" class="headerlink" title="使用SpEL表达式"></a>使用SpEL表达式</h3><p>从Spring Data JPA 1.4版开始，我们支持在使用<code>@Query</code>定义的手动定义的查询中使用受限的SpEL模板表达式。 查询执行后，将根据一组预定义的变量对这些表达式进行求值。 Spring Data JPA支持一个名为<code>entityName</code>的变量。 它的用法是<code>select x from #&#123;#entityName&#125; x</code>。 它插入与给定存储库关联的域类型的<code>entityName</code>。 实体名称的解析如下：如果域类型已在<code>@Entity</code>注解上设置了名称属性，则将其使用。 否则，将使用域类型的简单类名。</p>
<p>以下示例演示了查询字符串中<code>＃&#123;＃entityName&#125;</code>表达式的一种用例，您想在其中使用查询方法和手动定义的查询来定义存储库接口：</p>
<p>例67.在存储库查询方法中使用SpEL表达式-entityName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  Long id;</span><br><span class="line"></span><br><span class="line">  String lastname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select u from #&#123;#entityName&#125; u where u.lastname = ?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免在<code>@Query</code>注解的查询字符串中声明实际的实体名称，可以使用＃{＃entityName}变量。</p>
<p>可以使用<code>@Entity</code>注解来自定义<code>entityName</code>。 SpEL表达式不支持orm.xml中的自定义。<br>当然，您可能只是在查询声明中直接使用了User，但这也需要您更改查询。对<code>#entityName</code>的引用将User类将来可能的重新映射选择为另一个实体名称（例如，通过使用<code>@Entity（name =“ MyUser”）</code>）。</p>
<p>查询字符串中<code>＃&#123;＃entityName&#125;</code>表达式的另一个用例是，是否要为特定域类型定义带有专用存储库接口的通用存储库接口。要不在具体接口上重复定义自定义查询方法，可以在通用存储库接口的<code>@Query</code>注解的查询字符串中使用实体名称表达式，如以下示例所示：</p>
<p>例子68.在仓库查询方法中使用SpEL表达式-具有继承的entityName</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMappedType</span> </span>&#123;</span><br><span class="line">  …</span><br><span class="line">  String attribute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteType</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span> </span>&#123; … &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">AbstractMappedType</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">T</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Query(&quot;select t from #&#123;#entityName&#125; t where t.attribute = ?1&quot;)</span></span><br><span class="line">  <span class="function">List&lt;T&gt; <span class="title">findAllByAttribute</span><span class="params">(String attribute)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcreteRepository</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">MappedTypeRepository</span>&lt;<span class="title">ConcreteType</span>&gt; </span>&#123; … &#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，<code>MappedTypeRepository</code>接口是扩展<code>AbstractMappedType</code>的一些域类型的公共父接口。 它还定义了通用的<code>findAllByAttribute（…）</code>方法，该方法可用于专用存储库接口的实例。 如果现在在<code>ConcreteRepository</code>上调用<code>findByAllAttribute（…）</code>，则查询<code>select t from ConcreteType t where t.attribute = ?1</code>。</p>
<p>SpEL表达式用于操作参数，也可以用于操作方法参数。 在这些SpEL表达式中，实体名称不可用，但自变量可用。 可以通过名称或索引访问它们，如以下示例所示。</p>
<p>示例69.在存储库查询方法中使用SpEL表达式-访问参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.firstname = ?1 and u.firstname=?#&#123;[0]&#125; and u.emailAddress = ?#&#123;principal.emailAddress&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByFirstnameAndCurrentUserWithCustomQuery</span><span class="params">(String firstname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于<code>LIKE</code>条件，通常需要将<code>％</code>附加到String值参数的开头或结尾。 这可以通过将绑定参数标记或SpEL表达式附加或前缀为<code>％</code>来完成。 以下示例再次说明了这一点。</p>
<p>例子70.在仓库查询方法中使用SpEL表达式-通配符快捷方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.lastname like %:#&#123;[0]&#125;% and u.lastname like %:lastname%&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findByLastnameWithSpelExpression</span><span class="params">(<span class="meta">@Param(&quot;lastname&quot;)</span> String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果使用类似条件的值来自不安全来源，则应清除这些值，以使它们不能包含任何通配符，从而使攻击者可以选择比其应有的能力更多的数据。 为此，在SpEL上下文中可以使用<code>escape（String）</code>方法。 它在第一个参数中的<code>_</code>和<code>％</code>的所有实例之前加上第二个参数中的单个字符。 与JPQL中提供的<code>like</code>表达式的<code>escape</code>子句和标准SQL结合使用，可以轻松清除绑定参数。</p>
<p>示例71.在存储库查询方法中使用SpEL表达式-清理输入值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query(&quot;select u from User u where u.firstname like %?#&#123;escape([0])&#125;% escape ?#&#123;escapeCharacter()&#125;&quot;)</span></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">findContainingEscaped</span><span class="params">(String namePart)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在存储库接口中给定此方法声明后，<code>findContainingEscaped（“ Peter_”）</code>“将找到’Peter_Parker而不是Peter Parker。可以通过设置<code>@EnableJpaRepositories</code>注解的<code>escapeCharacter</code>来配置使用的转义字符。请注意，该方法<code>escape（String）</code>可用 在SpEL上下文中，仅将转义SQL和JPQL标准通配符<code>_</code>和<code>％</code>，如果基础数据库或JPA实现支持其他通配符，则将不会转义这些通配符。</p>
<p><span id="jpa.modifying-queries"></span></p>
<h3 id="修改查询"><a href="#修改查询" class="headerlink" title="修改查询"></a>修改查询</h3><p>前面所有部分均描述了如何声明查询以访问给定实体或实体集合。 您可以使用“ Spring数据存储库的自定义实现”中介绍的功能来添加自定义修改行为。 由于此方法对于全面的定制功能是可行的，因此可以通过使用<code>@Modifying</code>注解查询方法来修改仅需要参数绑定的查询，如以下示例所示：</p>
<p>例子72.声明操作查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Modifying</span></span><br><span class="line"><span class="meta">@Query(&quot;update User u set u.firstname = ?1 where u.lastname = ?2&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setFixedFirstnameFor</span><span class="params">(String firstname, String lastname)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样做将触发注解该方法的查询作为更新查询，而不是选择查询。 由于执行修改查询后<code>EntityManager</code>可能包含过时的实体，因此我们不会自动清除它（有关详细信息，请参阅<code>EntityManager.clear()</code>的<a target="_blank" rel="noopener" href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html">JavaDoc</a>），因为这会有效地将所有尚未刷新的更改丢弃在<code>EntityManager</code>中。 如果您希望自动清除<code>EntityManager</code>，可以将<code>@Modifying</code>注解的<code>clearAutomatically</code>属性设置为<code>true</code>。</p>
<p><code>@Modifying</code>注解仅与<code>@Query</code>注解结合使用。 派生的查询方法或自定义方法不需要此注解。</p>
<p><span id="jpa.modifying-queries.derived-delete"></span></p>
<h4 id="派生删除查询"><a href="#派生删除查询" class="headerlink" title="派生删除查询"></a>派生删除查询</h4><p>Spring Data JPA还支持派生的删除查询，使您避免显式声明JPQL查询，如以下示例所示：</p>
<p>例子73.使用派生的删除查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Modifying</span></span><br><span class="line">  <span class="meta">@Query(&quot;delete from User u where u.role.id = ?1&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deleteInBulkByRoleId</span><span class="params">(<span class="keyword">long</span> roleId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管<code>deleteByRoleId(...)</code>方法看起来基本上与<code>deleteInBulkByRoleId(...)</code>产生相同的结果，但是在执行方法方面，这两个方法声明之间存在重要区别。 顾名思义，后一种方法针对数据库发出单个JPQL查询（在注解中定义的查询）。 这意味着即使当前加载的<code>User</code>实例也看不到已调用的生命周期回调。</p>
<p>为了确保生命周期查询被实际调用，调用<code>deleteByRoleId(...)</code>会执行一个查询，然后逐个删除返回的实例，以便持久性提供程序实际上可以在这些实体上调用<code>@PreRemove</code>回调。</p>
<p>实际上，派生的删除查询是执行查询然后在结果上调用<code>CrudRepository.delete(Iterable&lt;User&gt; users)</code>并使行为与<code>CrudRepository</code>中其他<code>delete(...)</code>方法的实现保持同步的快捷方式。</p>
<p><span id="jpa.query-hints"></span></p>
<h3 id="应用查询提示"><a href="#应用查询提示" class="headerlink" title="应用查询提示"></a>应用查询提示</h3><p>要将JPA查询提示应用于在存储库接口中声明的查询，可以使用<code>@QueryHints</code>注解。 它需要一个JPA <code>@QueryHint</code>注解加上一个布尔标志，以潜在地禁用应用于应用分页时触发的附加计数查询的提示，如以下示例所示：</p>
<p>例子74.将QueryHints与存储库方法一起使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@QueryHints(value = &#123; @QueryHint(name = &quot;name&quot;, value = &quot;value&quot;)&#125;,</span></span><br><span class="line"><span class="meta">              forCounting = false)</span></span><br><span class="line">  <span class="function">Page&lt;User&gt; <span class="title">findByLastname</span><span class="params">(String lastname, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的声明将为该实际查询应用已配置的<code>@QueryHint</code>，但是省略了将其应用于为计算总页数而触发的计数查询。</p>
<p><span id="jpa.entity-graph"></span></p>
<h3 id="配置Fetch-和LoadGraphs"><a href="#配置Fetch-和LoadGraphs" class="headerlink" title="配置Fetch-和LoadGraphs"></a>配置Fetch-和LoadGraphs</h3><p>JPA 2.1规范引入了对指定Fetch-和LoadGraphs的支持，我们也支持@EntityGraph注解，该批注使您可以引用@NamedEntityGraph定义。 您可以在实体上使用该注解来配置结果查询的获取计划。 可以通过使用@EntityGraph注解上的type属性来配置获取的类型（获取或加载）。 有关更多参考，请参见JPA 2.1 Spec 3.7.4。</p>
<p>以下示例显示如何在实体上定义命名实体图：</p>
<p>例子75.在一个实体上定义一个命名实体图。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@NamedEntityGraph(name = &quot;GroupInfo.detail&quot;,</span></span><br><span class="line"><span class="meta">  attributeNodes = @NamedAttributeNode(&quot;members&quot;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// default fetch mode is lazy.</span></span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  List&lt;GroupMember&gt; members = <span class="keyword">new</span> ArrayList&lt;GroupMember&gt;();</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下示例显示如何在存储库查询方法上引用命名实体图：</p>
<p>示例76.在存储库查询方法上引用命名实体图定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">GroupInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EntityGraph(value = &quot;GroupInfo.detail&quot;, type = EntityGraphType.LOAD)</span></span><br><span class="line">  <span class="function">GroupInfo <span class="title">getByGroupName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用@EntityGraph定义临时实体图。 所提供的attributePaths转换为相应的EntityGraph，而无需将@NamedEntityGraph显式添加到您的域类型，如以下示例所示：</p>
<p>示例77.在存储库查询方法上使用AD-HOC实体图定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GroupRepository</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">GroupInfo</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@EntityGraph(attributePaths = &#123; &quot;members&quot; &#125;)</span></span><br><span class="line">  <span class="function">GroupInfo <span class="title">getByGroupName</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="projections"></span></p>
<h3 id="Projections"><a href="#Projections" class="headerlink" title="Projections"></a>Projections</h3><p>Spring Data查询方法通常返回存储库管理的聚合根的一个或多个实例。 但是，有时可能需要根据这些类型的某些属性创建投影。 Spring Data允许对专用返回类型进行建模，以更选择性地检索托管聚合的部分视图。</p>
<p>想象一下一个存储库和聚合根类型，例如以下示例：</p>
<p>例子78.一个样本集合和存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Id</span> UUID id;</span><br><span class="line">  String firstname, lastname;</span><br><span class="line">  Address address;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    String zipCode, city, street;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;Person&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，假设我们只想检索此人的姓名属性。 Spring Data提供什么手段来实现这一目标？ 本章其余部分将回答该问题。</p>
<p><span id="projections.interfaces"></span></p>
<h4 id="基于接口的Projections"><a href="#基于接口的Projections" class="headerlink" title="基于接口的Projections"></a>基于接口的Projections</h4><p>将查询结果限制为仅名称属性的最简单方法是声明一个接口，该接口公开要读取的属性的访问器方法，如以下示例所示：</p>
<p>例子79.一个投影界面来检索属性的子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里重要的一点是，此处定义的属性与聚合根中的属性完全匹配。 这样做可以使查询方法添加如下：</p>
<p>例子80.使用基于接口的投影和查询方法的存储库</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">Person</span>, <span class="title">UUID</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">Collection&lt;NamesOnly&gt; <span class="title">findByLastname</span><span class="params">(String lastname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例，并将对公开方法的调用转发给目标对象。</p>
<p>可以递归使用投影。 如果还希望包括一些Address信息，请为此创建一个投影接口，并从getAddress（）的声明返回该接口，如以下示例所示：</p>
<p>例子81.一个投影界面来检索属性的子集</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonSummary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">AddressSummary <span class="title">getAddress</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">AddressSummary</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getCity</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法调用时，将获取目标实例的地址属性，并将其包装到投影代理中。</p>
<h5 id="封闭式Projections"><a href="#封闭式Projections" class="headerlink" title="封闭式Projections"></a>封闭式Projections</h5><p>其访问者方法均与目标集合的属性完全匹配的投影接口被视为封闭投影。 下面的示例（也在本章前面使用过）是一个封闭的投影：</p>
<p>例子82.一个封闭的投影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您使用封闭式投影，Spring Data可以优化查询执行，因为我们知道支持投影代理所需的所有属性。 有关更多信息，请参见参考文档中特定于模块的部分。</p>
<h5 id="开放式Projections"><a href="#开放式Projections" class="headerlink" title="开放式Projections"></a>开放式Projections</h5><p>投影接口中的访问器方法也可以通过使用@Value注解来计算新值，如以下示例所示：</p>
<p>例子83.一个开放的投影</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;target.firstname + &#x27; &#x27; + target.lastname&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">()</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在目标变量中提供了支持投影的合计根。 使用@Value的投影接口是开放式投影。 在这种情况下，Spring Data无法应用查询执行优化，因为SpEL表达式可以使用聚合根的任何属性。</p>
<p>@Value中使用的表达式应该不太复杂-您要避免在String变量中进行编程。 对于非常简单的表达式，一种选择可能是求助于默认方法（在Java 8中引入），如以下示例所示：</p>
<p>例子84.使用默认方法自定义逻辑的投影接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFirstname</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">String <span class="title">getLastname</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> String <span class="title">getFullName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirstname().concat(<span class="string">&quot; &quot;</span>).concat(getLastname());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法要求您能够完全基于投影接口上公开的其他访问器方法来实现逻辑。 第二个更灵活的选择是在Spring bean中实现自定义逻辑，然后从SpEL表达式中调用该自定义逻辑，如以下示例所示：</p>
<p>例子85.采样人对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">    …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;@myBean.getFullName(target)&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getFullName</span><span class="params">()</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意SpEL表达式如何引用myBean并调用getFullName（…）方法，并将投影目标作为方法参数转发。 SpEL表达式评估支持的方法也可以使用方法参数，然后可以从表达式中引用这些参数。 方法参数可通过名为args的对象数组获得。 下面的示例演示如何从args数组获取方法参数：</p>
<p>例子86. Sample Person对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NamesOnly</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;args[0] + &#x27; &#x27; + target.firstname + &#x27;!&#x27;&#125;&quot;)</span></span><br><span class="line">  <span class="function">String <span class="title">getSalutation</span><span class="params">(String prefix)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对于更复杂的表达式，您应该使用Spring bean并让该表达式调用方法，<a href="#projections.interfaces.open.bean-reference">如前所述</a>。</p>
<p><span id="projections.dtos"></span></p>
<h4 id="基于类的Projections-DTOs"><a href="#基于类的Projections-DTOs" class="headerlink" title="基于类的Projections (DTOs)"></a>基于类的Projections (DTOs)</h4><p><span id="projection.dynamic"></span></p>
<h4 id="动态Projections"><a href="#动态Projections" class="headerlink" title="动态Projections"></a>动态Projections</h4><p><span id="jpa.stored-procedures"></span></p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p><span id="specifications"></span></p>
<h2 id="技术指标"><a href="#技术指标" class="headerlink" title="技术指标"></a>技术指标</h2><p><span id="query-by-example"></span></p>
<h2 id="实例查询"><a href="#实例查询" class="headerlink" title="实例查询"></a>实例查询</h2><p><span id="query-by-example.introduction"></span></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><span id="query-by-example.usage"></span></p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><span id="query-by-example.matchers"></span></p>
<h3 id="示例匹配器"><a href="#示例匹配器" class="headerlink" title="示例匹配器"></a>示例匹配器</h3><p><span id="query-by-example.execution"></span></p>
<h3 id="查询案例"><a href="#查询案例" class="headerlink" title="查询案例"></a>查询案例</h3><p><span id="transactions"></span></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>默认情况下，存储库实例上的CRUD方法是事务性的。 对于读取操作，事务配置readOnly标志设置为true。 所有其他文件都配置有简单的@Transactional，以便应用默认事务配置。 有关详细信息，请参见SimpleJpaRepository的JavaDoc。 如果需要调整在存储库中声明的方法之一的事务配置，请在存储库接口中重新声明该方法，如下所示：</p>
<p>例子106. CRUD的自定义事务配置</p>
<p><span id="transactional-query-methods"></span></p>
<h3 id="带事务的查询方法"><a href="#带事务的查询方法" class="headerlink" title="带事务的查询方法"></a>带事务的查询方法</h3><p><span id="locking"></span></p>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p><span id="auditing"></span></p>
<h2 id="Auditing"><a href="#Auditing" class="headerlink" title="Auditing"></a>Auditing</h2><p><span id="auditing.basics"></span></p>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><p><span id="jpa.auditing"></span></p>
<h3 id="JPA-Auditing"><a href="#JPA-Auditing" class="headerlink" title="JPA Auditing"></a>JPA Auditing</h3><p><span id="jpa.misc"></span></p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p><span id="appendix"></span></p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><span id="repositories.namespace-reference"></span></p>
<h2 id="命名空间参考"><a href="#命名空间参考" class="headerlink" title="命名空间参考"></a>命名空间参考</h2><p><span id="populator.namespace-dao-config"></span></p>
<h3 id="The-lt-repositories-gt-Element"><a href="#The-lt-repositories-gt-Element" class="headerlink" title="The &lt;repositories /&gt; Element"></a>The <code>&lt;repositories /&gt;</code> Element</h3><p><span id="populator.namespace-reference"></span></p>
<h2 id="Populators-namespace-reference"><a href="#Populators-namespace-reference" class="headerlink" title="Populators namespace reference"></a>Populators namespace reference</h2><p><span id="namespace-dao-config"></span></p>
<h3 id="The-element"><a href="#The-element" class="headerlink" title="The  element"></a>The <populator/> element</h3><p><span id="repository-query-keywords"></span></p>
<h2 id="Repository查询关键字"><a href="#Repository查询关键字" class="headerlink" title="Repository查询关键字"></a>Repository查询关键字</h2><p><span id="repository-query-return-types"></span></p>
<h2 id="Repository查询返回类型"><a href="#Repository查询返回类型" class="headerlink" title="Repository查询返回类型"></a>Repository查询返回类型</h2><p><span id="faq"></span></p>
<h2 id="经常问的问题"><a href="#经常问的问题" class="headerlink" title="经常问的问题"></a>经常问的问题</h2><p><span id="glossary"></span></p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring-Data/" rel="tag"># Spring-Data</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/24/Java-Tutorials/" rel="prev" title="Java-Tutorials">
      <i class="fa fa-chevron-left"></i> Java-Tutorials
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/10/%E9%AB%98%E4%B8%AD%E8%8B%B1%E8%AF%AD%E6%B7%B1%E5%BA%A6%E8%BF%9B%E9%98%B6%E8%AF%8D%E6%B1%87/" rel="next" title="高中英语深度进阶词汇">
      高中英语深度进阶词汇 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text">项目元数据</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%B0%E7%9A%84%E5%92%8C%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">新的和值得注意的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">3.</span> <span class="nav-text">依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring-Boot%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86"><span class="nav-number">3.1.</span> <span class="nav-text">使用Spring Boot进行依赖管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Framework"><span class="nav-number">3.2.</span> <span class="nav-text">Spring Framework</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">使用Spring数据存储库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">查询方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89Repository%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.3.</span> <span class="nav-text">定义Repository接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AE%E8%B0%83%E5%AD%98%E5%82%A8%E5%BA%93%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.1.</span> <span class="nav-text">微调存储库定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%8E%E5%A4%9A%E4%B8%AASpring%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9D%97%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">将存储库与多个Spring数据模块一起使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">定义查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5"><span class="nav-number">4.4.1.</span> <span class="nav-text">查询查找策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%9B%E5%BB%BA"><span class="nav-number">4.4.2.</span> <span class="nav-text">查询创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.3.</span> <span class="nav-text">属性表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-number">4.4.4.</span> <span class="nav-text">特殊参数处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%92%8C%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">分页和排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.5.</span> <span class="nav-text">限制查询结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BA%93%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E9%9B%86%E5%90%88%E6%88%96%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.4.6.</span> <span class="nav-text">存储库方法返回集合或可迭代对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Streamable%E4%BD%9C%E4%B8%BA%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.6.1.</span> <span class="nav-text">使用Streamable作为查询方法返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%81%E5%BC%8F%E5%8C%85%E8%A3%85%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.4.6.2.</span> <span class="nav-text">返回自定义流式包装器类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81Vavr%E9%9B%86%E5%90%88"><span class="nav-number">4.4.6.3.</span> <span class="nav-text">支持Vavr集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nullability-Annotations"><span class="nav-number">4.4.6.4.</span> <span class="nav-text">Nullability Annotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Nullability-in-Kotlin-based-Repositories"><span class="nav-number">4.4.6.5.</span> <span class="nav-text">Nullability in Kotlin-based Repositories</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.7.</span> <span class="nav-text">流查询结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="nav-number">4.4.8.</span> <span class="nav-text">异步查询结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BARepository%E5%AE%9E%E4%BE%8B"><span class="nav-number">4.5.</span> <span class="nav-text">创建Repository实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="nav-number">4.5.1.</span> <span class="nav-text">XML配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E9%85%8D%E7%BD%AE"><span class="nav-number">4.5.2.</span> <span class="nav-text">Java配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E4%BD%BF%E7%94%A8"><span class="nav-number">4.5.3.</span> <span class="nav-text">独立使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Data-Repositories%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.6.</span> <span class="nav-text">Spring Data Repositories的自定义实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E4%B8%AA%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.6.1.</span> <span class="nav-text">自定义单个存储库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%A1%80%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">4.6.2.</span> <span class="nav-text">自定义基础存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8EAggregate-Roots%E5%8F%91%E5%B8%83%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.7.</span> <span class="nav-text">从Aggregate Roots发布事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Data%E6%89%A9%E5%B1%95"><span class="nav-number">4.8.</span> <span class="nav-text">Spring Data扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Querydsl%E6%89%A9%E5%B1%95"><span class="nav-number">4.8.1.</span> <span class="nav-text">Querydsl扩展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.</span> <span class="nav-text">Web支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACWeb%E6%94%AF%E6%8C%81"><span class="nav-number">4.8.2.1.</span> <span class="nav-text">基本Web支持</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JPA-Repositories"><span class="nav-number">5.</span> <span class="nav-text">JPA Repositories</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">5.1.1.</span> <span class="nav-text">Spring命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">5.1.2.</span> <span class="nav-text">基于注解的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.3.</span> <span class="nav-text">引导模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E4%BD%93"><span class="nav-number">5.2.</span> <span class="nav-text">持久化实体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E5%AE%9E%E4%BD%93"><span class="nav-number">5.2.1.</span> <span class="nav-text">保存实体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E7%8A%B6%E6%80%81%E6%A3%80%E6%B5%8B%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">实体状态检测策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95-1"><span class="nav-number">5.3.</span> <span class="nav-text">查询方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%9F%A5%E6%89%BE%E7%AD%96%E7%95%A5-1"><span class="nav-number">5.3.1.</span> <span class="nav-text">查询查找策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E5%88%9B%E5%BB%BA-1"><span class="nav-number">5.3.2.</span> <span class="nav-text">查询创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JPA%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.3.</span> <span class="nav-text">使用JPA命名查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Query"><span class="nav-number">5.3.4.</span> <span class="nav-text">使用@Query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Sort"><span class="nav-number">5.3.5.</span> <span class="nav-text">使用Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="nav-number">5.3.6.</span> <span class="nav-text">使用命名参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">5.3.7.</span> <span class="nav-text">使用SpEL表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.8.</span> <span class="nav-text">修改查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E5%88%A0%E9%99%A4%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.3.8.1.</span> <span class="nav-text">派生删除查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%9F%A5%E8%AF%A2%E6%8F%90%E7%A4%BA"><span class="nav-number">5.3.9.</span> <span class="nav-text">应用查询提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AEFetch-%E5%92%8CLoadGraphs"><span class="nav-number">5.3.10.</span> <span class="nav-text">配置Fetch-和LoadGraphs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Projections"><span class="nav-number">5.3.11.</span> <span class="nav-text">Projections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E7%9A%84Projections"><span class="nav-number">5.3.11.1.</span> <span class="nav-text">基于接口的Projections</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%81%E9%97%AD%E5%BC%8FProjections"><span class="nav-number">5.3.11.1.1.</span> <span class="nav-text">封闭式Projections</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E6%94%BE%E5%BC%8FProjections"><span class="nav-number">5.3.11.1.2.</span> <span class="nav-text">开放式Projections</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84Projections-DTOs"><span class="nav-number">5.3.11.2.</span> <span class="nav-text">基于类的Projections (DTOs)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81Projections"><span class="nav-number">5.3.11.3.</span> <span class="nav-text">动态Projections</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">5.4.</span> <span class="nav-text">存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E6%8C%87%E6%A0%87"><span class="nav-number">5.5.</span> <span class="nav-text">技术指标</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E6%9F%A5%E8%AF%A2"><span class="nav-number">5.6.</span> <span class="nav-text">实例查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">5.6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">5.6.2.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E5%8C%B9%E9%85%8D%E5%99%A8"><span class="nav-number">5.6.3.</span> <span class="nav-text">示例匹配器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E6%A1%88%E4%BE%8B"><span class="nav-number">5.6.4.</span> <span class="nav-text">查询案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.7.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95"><span class="nav-number">5.7.1.</span> <span class="nav-text">带事务的查询方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locking"><span class="nav-number">5.8.</span> <span class="nav-text">Locking</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Auditing"><span class="nav-number">5.9.</span> <span class="nav-text">Auditing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC"><span class="nav-number">5.9.1.</span> <span class="nav-text">基本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA-Auditing"><span class="nav-number">5.9.2.</span> <span class="nav-text">JPA Auditing</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">5.10.</span> <span class="nav-text">其他注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%82%E8%80%83"><span class="nav-number">6.1.</span> <span class="nav-text">命名空间参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-lt-repositories-gt-Element"><span class="nav-number">6.1.1.</span> <span class="nav-text">The &lt;repositories &#x2F;&gt; Element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Populators-namespace-reference"><span class="nav-number">6.2.</span> <span class="nav-text">Populators namespace reference</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-element"><span class="nav-number">6.2.1.</span> <span class="nav-text">The  element</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Repository%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.3.</span> <span class="nav-text">Repository查询关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Repository%E6%9F%A5%E8%AF%A2%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.</span> <span class="nav-text">Repository查询返回类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.5.</span> <span class="nav-text">经常问的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">6.6.</span> <span class="nav-text">词汇表</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/09/28/Spring-Data-JPA/";
    this.page.identifier = "2020/09/28/Spring-Data-JPA/";
    this.page.title = "Spring-Data-JPA";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
