<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spring Framework 概述1. “Spring” 的含义术语“Spring”在不同的环境中意味着不同的东西。它可用于引用 Spring Framework 项目本身，这是它开始的地方。随着时间推移，其他 Spring 项目已经构建在 Spring Framework 之上。大多数情况下，当人们说“Spring”时，他们指的是整个项目系列。这个参考文档侧重于基础：Spring Frame">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring Framework官方文档翻译">
<meta property="og:url" content="http://yoursite.com/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Spring Framework 概述1. “Spring” 的含义术语“Spring”在不同的环境中意味着不同的东西。它可用于引用 Spring Framework 项目本身，这是它开始的地方。随着时间推移，其他 Spring 项目已经构建在 Spring Framework 之上。大多数情况下，当人们说“Spring”时，他们指的是整个项目系列。这个参考文档侧重于基础：Spring Frame">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg">
<meta property="article:published_time" content="2020-08-24T06:34:27.000Z">
<meta property="article:modified_time" content="2020-08-24T07:41:51.460Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Spring Framework官方文档翻译 | Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring Framework官方文档翻译
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-24 14:34:27 / 修改时间：15:41:51" itemprop="dateCreated datePublished" datetime="2020-08-24T14:34:27+08:00">2020-08-24</time>
            </span>

          
            <span id="/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/" class="post-meta-item leancloud_visitors" data-flag-title="Spring Framework官方文档翻译" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/24/Spring-Framework官方文档翻译/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Spring-Framework-概述"><a href="#Spring-Framework-概述" class="headerlink" title="Spring Framework 概述"></a>Spring Framework 概述</h1><h2 id="1-“Spring”-的含义"><a href="#1-“Spring”-的含义" class="headerlink" title="1. “Spring” 的含义"></a>1. “Spring” 的含义</h2><p>术语“Spring”在不同的环境中意味着不同的东西。它可用于引用 Spring Framework 项目本身，这是它开始的地方。随着时间推移，其他 Spring 项目已经构建在 Spring Framework 之上。大多数情况下，当人们说“Spring”时，他们指的是整个项目系列。这个参考文档侧重于基础：Spring Framework 本身。</p>
<p>Spring Framework 分离成多个模块。 Applications 可以选择他们所需要的模块。容器的核心模块包括 配置模型和依赖注入机制。除此之外，Spring Framework 为不同的应用程序架构提供了基础支持，包括消息传递，事务数据和持久性以及 web。它还包括 Servlet-based Spring MVC web framework，以及 Spring WebFlux reactive web framework。</p>
<p>关于模块的说明：Spring 的 framework jars 允许部署到 JDK 9 的模块路径(“Jigsaw”)。为了在 Jigsaw-enabled applications 中使用，Spring Framework 5 jars 带有“Automatic-Module-Name”清单条目，它们定义了独立于 jar artifact 名称的稳定 language-level 模块名称(“spring.core”，“spring.context”等)(jars 遵循相同的命名规则“ - “而不是”.“，例如 ”spring-core“和”spring-context“)。当然，Spring 的 framework jars 在 JDK 8 和 9 上都能正常工作。</p>
<a id="more"></a>

<h1 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h1><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><h3 id="介绍spring-ioc容器和Beans"><a href="#介绍spring-ioc容器和Beans" class="headerlink" title="介绍spring ioc容器和Beans"></a>介绍spring ioc容器和Beans</h3><p>本章介绍了控制反转(IoC)原理的 Spring Framework implementation。 (参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/overview.html#background-ioc">控制反转</a> .) IoC 也称为依赖注入(DI)。它是一个 process，其中 objects 仅通过构造函数 arguments，工厂方法的 arguments 或者属性的 properties 来定义它们的依赖项(即，它们使用的其他 objects)。在构造或从工厂方法返回后，在 object 实例上设置。然后容器在创建 bean 时注入这些依赖项。这个 process 基本上是 bean 本身控制实例化的逆(故名，控制反转)或者通过使用 classes 的直接构造或诸如 Service Locator pattern 之类的机制来确定其依赖关系的位置。</p>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是 Spring Framework 的 IoC 容器的基础。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html">BeanFactory</a>接口提供了一种高级 configuration 机制，能够管理任何类型的 object。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html">ApplicationContext</a>是<code>BeanFactory</code>的 sub-interface。它补充说：</p>
<ul>
<li>使用 Spring 的 AOP features 更容易整合</li>
<li>消息资源处理(用于国际化)</li>
<li>事件发布</li>
<li>Application-layer 特定的上下文，例如用于 web applications。</li>
</ul>
<p>简而言之，<code>BeanFactory</code>提供 configuration framework 和基本功能，<code>ApplicationContext</code>添加更多 enterprise-specific 功能。 <code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集，在本章中专门用于 Spring 的 IoC 容器的描述。有关使用<code>BeanFactory</code>而不是<code>ApplicationContext</code>的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanfactory">BeanFactory</a>。</p>
<p>在 Spring 中，构成 application 主干并由 Spring IoC 容器管理的 objects 称为 beans。 _ bean 是一个 object，它由 Spring IoC 容器实例化，组装和管理。否则，bean 只是 application 中许多 object 之一。 Beans 及其之间的依赖关系反映在容器使用的 configuration 元数据中。</p>
<h3 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h3><p><code>org.springframework.context.ApplicationContext</code>接口表示 Spring IoC 容器，负责实例化，配置和组装 beans。容器通过读取 configuration 元数据获取有关 objects 实例化，配置和汇编的指令。 configuration 元数据以 XML，Java annotations 或 Java code 表示。它允许您表达组成您的 application 的 objects 以及这些 objects 之间丰富的相互依赖关系。</p>
<p>Spring 提供了<code>ApplicationContext</code>接口的几个 implementation。在 stand-alone applications 中，通常创建 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html">ClassPathXmlApplicationContext</a> 或 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html">FileSystemXmlApplicationContext</a> 实例。虽然 XML 是定义配置元数据的传统格式，但您可以通过提供少量 XML 配置来声明性地启用对 Java 注解或者代码这些其他元数据格式的支持。</p>
<p>在大多数 application 场景中，不需要用户显示的实例化 Spring IoC 容器的一个或多个实例。例如，在 web application 场景中，application 的<code>web.xml</code>文件中的简单八行(或左右)的样板代码通常就足够了(参见 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>)。如果使用<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>(STS, Eclipse-powered 开发环境)，只需单击几下鼠标或按键即可轻松创建此样板配置文件。</p>
<p>下图显示了 Spring 如何工作的 high-level 视图。您的 application classes 与 configuration 元数据结合使用，以便在创建和初始化<code>ApplicationContext</code>之后，您拥有一个完全配置且可执行的系统或应用。</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/container-magic.jpg" alt="容器魔术"></p>
<p>图 1. Spring IoC 容器</p>
<h4 id="Configuration-元数据"><a href="#Configuration-元数据" class="headerlink" title="Configuration 元数据"></a>Configuration 元数据</h4><p>如上图所示，Spring IoC 容器使用一种 configuration 元数据。此 configuration 元数据表示作为 application 开发人员如何告诉 Spring 容器在 application 中实例化，配置和组装 objects。</p>
<p>Configuration 元数据传统上以简单直观的 XML 格式提供，本章大部分内容用于传达 Spring IoC 容器的 key 概念和 features。</p>
<blockquote>
<p>基于 XML 的元数据不是唯一允许的配置元数据形式。 Spring IoC 容器本身与实际编写此 configuration 元数据的格式完全分离。现在，许多开发人员选择 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-java">基于Java的配置</a> 作为他们开发的 Spring 应用。</p>
</blockquote>
<p>有关在 Spring 容器中使用其他形式的元数据的信息，请参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-annotation-config">基于注解的配置</a>：Spring 2.5 引入了对 annotation-based configuration 元数据的支持。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans-java">基于Java的配置</a>：从 Spring 3.0 开始，Spring JavaConfig 项目提供的许多 features 成为 Spring Framework 核心的一部分。因此，您可以使用 Java 而不是 XML 文件定义 application classes 外部的 beans。要使用这些新的 features，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html">@Import</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html">@DependsOn</a> 注释。</li>
</ul>
<p>Spring 配置方式至少包含一种并且通常容器必须管理多个 bean 定义。 基于 XML 配置的元数据将 beans 配置为 top-level <code>&lt;beans/&gt;</code>元素内的<code>&lt;bean/&gt;</code>元素。 Java 配置通常在<code>@Configuration</code> 标记的类中使用<code>@Bean</code> 注释的方法。</p>
<p>这些 bean 定义对应于构成应用的实际对象。通常，您定义服务层对象，数据访问对象(DAO)，表示对象(如 Struts <code>Action</code>实例)，基础结构对象(如 Hibernate <code>SessionFactories</code>，JMS <code>Queues</code>等)。通常，不会在容器中配置 fine-grained domain objects，因为它通常是 DAO 和业务逻辑负责创建和加载 domain objects。但是，您可以通过 Spring 与 AspectJ 整合来配置在 IoC 容器控制之外创建的 objects。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable">使用 AspectJ 与 Spring 注入 domain objects</a>。</p>
<p>以下示例展示了基于 XML 配置的元数据的基本结构：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span>  (1) (2)</span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>id</code>属性是一个 string，用于标识单个 bean 定义。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>class</code>属性定义 bean 的类型并需要使用完全限定的类名。</td>
</tr>
</tbody></table>
<p><code>id</code>属性的 value 指的是协作 objects。用于引用协作 objects 的 XML 未在此示例中显示。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-dependencies">依赖</a>。</p>
<h4 id="实例化容器"><a href="#实例化容器" class="headerlink" title="实例化容器"></a>实例化容器</h4><p>提供给<code>ApplicationContext</code>构造函数的一个或多个字符串类型的位置路径，它允许容器从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载 configuration 元数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在了解 Spring 的 IoC 容器之后，您可能想要了解更多关于 Spring 的<code>Resource</code>抽象(如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources">资源</a>中所述)，它提供了一种从 URI 语法中定义的位置读取 InputStream 的便捷机制。特别是，<code>Resource</code> 路径用于构造 applications 上下文，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources-app-ctx">Application Contexts 和 Resource Paths</a>中所述。</p>
</blockquote>
<p>以下示例显示了服务层对象 <code>(services.xml)</code> 配置文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- services --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;petStore&quot; class&#x3D;&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDao&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;itemDao&quot; ref&#x3D;&quot;itemDao&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions for services go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>以下示例显示了数据访问对象(DAO) <code>daos.xml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;accountDao&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;itemDao&quot; class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;</span><br><span class="line">        &lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- more bean definitions for data access objects go here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>在前面的示例中，服务层由<code>PetStoreServiceImpl</code> class 和两个类型<code>JpaAccountDao</code>和<code>JpaItemDao</code>的数据访问对象(DAO)组成(基于 JPA Object-Relational Mapping 标准)。 <code>property name</code>元素引用 JavaBean property 的 name，<code>ref</code>元素引用另一个 bean 定义的 name。 <code>id</code>和<code>ref</code>元素之间的这种联系表达了协作 objects 之间的依赖关系。有关配置 object 依赖项的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-dependencies">依赖</a>。</p>
<h5 id="撰写基于-XML-配置的元数据"><a href="#撰写基于-XML-配置的元数据" class="headerlink" title="撰写基于 XML 配置的元数据"></a>撰写基于 XML 配置的元数据</h5><p>使 bean 定义在多个 XML 文件中非常有用。通常，每个单独的 XML 配置文件代表应用架构中的逻辑层或模块。</p>
<p>您可以使用 application context 构造函数从所有这些 XML 片段加载 bean 定义。此构造函数传递多个<code>Resource</code>路径，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-instantiation">上一节</a>中所示。或者，使用一个或多个<code>&lt;import/&gt;</code>元素来从一个文件或多个文件加载 bean 定义。以下示例显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;services.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;resources&#x2F;messageSource.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;import resource&#x3D;&quot;&#x2F;resources&#x2F;themeSource.xml&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;bean1&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;bean2&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>在前面的 example 中，外部 bean 定义从三个 files 加载：<code>services.xml</code>，<code>messageSource.xml</code>和<code>themeSource.xml</code>。所有位置路径都与执行 importing 的定义文件相关，因此 <code>services.xml</code> 必须与执行 importing 的文件位于同一目录或 classpath 位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于 importing 文件位置下方的<code>resources</code>位置。如您所见，忽略前导斜杠。但是，鉴于这些_path 是相对的，最好不要使用斜杠。根据 Spring Schema，导入的 files 的内容(包括 top level <code>&lt;beans/&gt;</code>元素)必须是有效的 XML bean 定义。</p>
<blockquote>
<p>使用相对“../”路径在 parent 目录中 reference files 是可行的，但不建议这样做。这样做会对当前 application 之外的文件创建依赖关系。特别是，不建议对<code>classpath:</code> URL(对于 example，<code>classpath:../services.xml</code>)使用该方式，其中运行时解析 process 选择“最近的”classpath 根，然后查看其 parent 目录。 Classpath configuration 更改可能导致选择不同的，不正确的目录。</p>
</blockquote>
<p>您始终可以使用完全限定的资源位置而不是相对路径：例如，<code>file:C:/config/services.xml</code>或<code>classpath:/config/services.xml</code>。但是，请注意您的 application 的配置文件将与特定的绝对位置耦合。通常最好为这样的绝对位置保持间接 - 例如，通过在运行时针对 JVM 系统 properties 解析的“$ {}”占位符。</p>
<p>命名空间本身提供 import 指令功能。 Spring 提供的一系列 XML 命名空间（例如，context 和 util 名称空间）中提供了普通 bean 定义之外的其他配置功能。</p>
<h5 id="Groovy-Bean-定义-DSL"><a href="#Groovy-Bean-定义-DSL" class="headerlink" title="Groovy Bean 定义 DSL"></a>Groovy Bean 定义 DSL</h5><p>作为外部化配置元数据的进一步示例，bean 定义也可以在 Spring 的 Groovy Bean Definition DSL 中表示，如 Grails framework 中所知。通常，此类 configuration 存在于“.groovy”文件中，其结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">beans &#123;</span><br><span class="line">    dataSource(BasicDataSource) &#123;</span><br><span class="line">        driverClassName &#x3D; &quot;org.hsqldb.jdbcDriver&quot;</span><br><span class="line">        url &#x3D; &quot;jdbc:hsqldb:mem:grailsDB&quot;</span><br><span class="line">        username &#x3D; &quot;sa&quot;</span><br><span class="line">        password &#x3D; &quot;&quot;</span><br><span class="line">        settings &#x3D; [mynew:&quot;setting&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">    sessionFactory(SessionFactory) &#123;</span><br><span class="line">        dataSource &#x3D; dataSource</span><br><span class="line">    &#125;</span><br><span class="line">    myService(MyService) &#123;</span><br><span class="line">        nestedBean &#x3D; &#123; AnotherBean bean -&gt;</span><br><span class="line">            dataSource &#x3D; dataSource</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种 configuration 样式在很大程度上等同于 XML bean 定义，甚至支持 Spring 的 XML configuration 命名空间。它还允许通过<code>importBeans</code>指令 importing XML bean definition files。</p>
<h4 id="使用容器"><a href="#使用容器" class="headerlink" title="使用容器"></a>使用容器</h4><p><code>ApplicationContext</code>是高级工厂的接口，能够维护不同 beans 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，您可以检索 beans 的实例。</p>
<p><code>ApplicationContext</code>允许您读取 bean 定义并访问它们，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; create and configure beans</span><br><span class="line">ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; retrieve configured instance</span><br><span class="line">PetStoreService service &#x3D; context.getBean(&quot;petStore&quot;, PetStoreService.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use configured instance</span><br><span class="line">List&lt;String&gt; userList &#x3D; service.getUsernameList();</span><br></pre></td></tr></table></figure>

<p>使用 Groovy configuration，bootstrapping 看起来非常相似。它有一个不同的 context implementation class，它是 Groovy-aware(但也理解 XML bean 定义)。以下 example 显示了 Groovy configuration：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>最灵活的变体是<code>GenericApplicationContext</code>与 reader 委托相结合 - 例如，表示 XML files，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>您还可以使用<code>GroovyBeanDefinitionReader</code> for Groovy files，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span><br><span class="line"><span class="keyword">new</span> GroovyBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">&quot;services.groovy&quot;</span>, <span class="string">&quot;daos.groovy&quot;</span>);</span><br><span class="line">context.refresh();</span><br></pre></td></tr></table></figure>

<p>您可以在同一个<code>ApplicationContext</code>上混合和 match 这样的 reader 委托，从不同的 configuration 源读取 bean 定义。</p>
<p>然后，您可以使用<code>getBean</code>来检索 beans 的实例。 <code>ApplicationContext</code>接口还有一些其他方法可以检索 beans，但理想情况下，application code 应该永远不会使用它们。实际上，你的 application code 根本不应该对<code>getBean()</code>方法有 calls，因此根本不依赖于 Spring API。例如，Spring 与 web 框架的 integration 为各种 web framework 组件(如控制器和 JSF-managed beans)提供依赖注入，让您通过元数据(例如自动装配 annotation)声明对特定 bean 的依赖。</p>
<h3 id="Bean-概述"><a href="#Bean-概述" class="headerlink" title="Bean 概述"></a>Bean 概述</h3><p>Spring IoC 容器管理一个或多个 beans。这些 beans 是使用您提供给容器的 configuration 元数据创建的(对于 example，以 XML <code>&lt;bean/&gt;</code>定义的形式)。</p>
<p>在容器本身中，这些 bean 定义表示为<code>BeanDefinition</code> objects，其中包含(以及其他信息)以下元数据：</p>
<ul>
<li>package-qualified class name：通常是bean 被定义的实际实现类。</li>
<li>Bean 行为 configuration 元素，它们 state bean 应该如何在容器中运行(范围，生命周期回调等)。</li>
<li>引用 bean 执行其工作所需的其他 beans。这些 references 也称为协作者或依赖项。</li>
<li>要在新创建的 object 中设置的其他 configuration 设置 - 用于 example，池的大小限制或在管理连接池的 bean 中使用的连接数。</li>
</ul>
<p>此元数据转换为构成每个 bean 定义的一组 properties。以下 table 描述了这些 properties：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释在……</th>
</tr>
</thead>
<tbody><tr>
<td>Class</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class">实例化 Beans</a></td>
</tr>
<tr>
<td>Name</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname">命名 Beans</a></td>
</tr>
<tr>
<td>Scope</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean的作用域</a></td>
</tr>
<tr>
<td>Constructor arguments</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators=">依赖注入</a></td>
</tr>
<tr>
<td>Properties</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">依赖注入</a></td>
</tr>
<tr>
<td>Autowiring mode</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动化协作者</a></td>
</tr>
<tr>
<td>Lazy initialization mode</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init">Lazy-initialized Beans</a></td>
</tr>
<tr>
<td>Initialization method</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">初始化回调</a></td>
</tr>
<tr>
<td>Destruction method</td>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean">毁灭回调</a></td>
</tr>
</tbody></table>
<p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code> implementations 还允许注册在容器外部(由用户)创建的现有 objects。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code> implementation。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的 applications 只能使用通过常规 bean 定义元数据定义的 beans。</p>
<blockquote>
<p>Bean 元数据和手动提供的 singleton 实例需要尽早注册，以便容器在自动装配和其他内省步骤中正确推理它们。虽然在某种程度上支持覆盖现有元数据和现有 singleton 实例，但是在运行时注册新的 beans(与对工厂的实时访问同时)并未得到官方支持，并且可能导致并发访问 exceptions，bean 容器中的 state 不一致，或者都。</p>
</blockquote>
<h4 id="命名-Beans"><a href="#命名-Beans" class="headerlink" title="命名 Beans"></a>命名 Beans</h4><p>每个 bean 都有一个或多个标识符。这些标识符在承载 bean 的容器中必须是唯一的。 bean 通常只有一个标识符。但是，如果它需要多个，则额外的可以被视为别名。</p>
<p>在 XML-based configuration 元数据中，使用<code>id</code>属性，<code>name</code>属性或两者来指定 bean 标识符。 <code>id</code>属性允许您指定一个 id。通常，这些名称是字母数字(‘myBean’，’someService’，etc.)，但它们也可以包含特殊字符。如果要为 bean 引入其他别名，您还可以在<code>name</code>属性中指定它们，由 a 分隔逗号(<code>,</code>)，分号(<code>;</code>)或空格。作为历史记录，在 Spring 3.1 之前的版本中，<code>id</code>属性被定义为<code>xsd:ID</code>类型，它约束了可能的字符。从 3.1 开始，它被定义为<code>xsd:string</code> type。请注意，bean <code>id</code> uniqueness 仍由容器强制执行，但不再由 XML 解析器强制执行。</p>
<p>您不需要为 bean 提供<code>name</code>或<code>id</code>。如果您没有显式提供<code>name</code>或<code>id</code>，则容器会为该 bean 生成唯一的 name。但是，如果要通过 name 引用 bean，通过使用<code>ref</code>元素或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-servicelocator">服务定位器</a>样式查找，则必须提供 name。不提供 name 的动机与使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-inner-beans">内豆</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire">自动装配合作者</a>有关。</p>
<p>Bean 命名约定</p>
<p>约定是在命名 beans 时使用标准 Java 约定作为实例字段名称。也就是说，bean 名称以小写字母开头，并且从那里开始 camel-cased。此类名称的示例包括<code>accountManager</code>，<code>accountService</code>，<code>userDao</code>，<code>loginController</code>等。</p>
<p>命名 beans 始终使您的 configuration 更容易阅读和理解。此外，如果您使用 Spring AOP，则在将建议应用于 name 相关的一组 beans 时会有很大帮助。</p>
<blockquote>
<p>使用 classpath 中的 component 扫描，Spring 按照前面描述的规则为未命名的组件生成 bean 名称：基本上，使用简单的 class name 并将其初始字符转换为 lower-case。但是，在(不常见的)特殊情况下，当有多个字符且第一个和第二个字符都是大写字母时，原始外壳将被保留。这些规则与<code>java.beans.Introspector.decapitalize</code>(Spring 在此处使用)中定义的规则相同。</p>
</blockquote>
<h5 id="在-Bean-定义之外别名-Bean"><a href="#在-Bean-定义之外别名-Bean" class="headerlink" title="在 Bean 定义之外别名 Bean"></a>在 Bean 定义之外别名 Bean</h5><p>在 bean 定义本身中，通过使用<code>id</code>属性指定的最多一个 name 和<code>name</code>属性中的任意数量的其他名称，可以为 bean 提供多个 name。这些名称可以是同一 bean 的等效别名，并且在某些情况下很有用，例如让 application 中的每个 component 通过使用特定于该 component 本身的 bean name 来引用 common 依赖项。</p>
<p>但是，指定实际定义 bean 的所有别名并不总是足够的。有时需要为其他地方定义的 bean 引入别名。在大型系统中通常就是这种情况，其中 configuration 在每个子系统之间分配，每个子系统都有自己的 object 定义集。在 XML-based configuration 元数据中，您可以使用<code>&lt;alias/&gt;</code>元素来完成此操作。以下 example 显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;fromName&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;toName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，在使用此别名定义之后，名为<code>fromName</code>的 bean(在同一容器中)也可以称为<code>toName</code>。</p>
<p>例如，子系统 A 的 configuration 元数据可以通过<code>subsystemA-dataSource</code>的 name 引用 DataSource。子系统 B 的 configuration 元数据可以通过<code>subsystemB-dataSource</code>的 name 引用 DataSource。在编写使用这两个子系统的主 application 时，main application 通过<code>myApp-dataSource</code>的 name 引用 DataSource。要使所有三个名称引用相同的 object，可以将以下别名定义添加到 configuration 元数据中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemA-dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;myApp-dataSource&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;subsystemB-dataSource&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在每个 component 和 main application 都可以通过 name 来引用 dataSource，该 name 是唯一的，并且保证不与任何其他定义冲突(有效地创建命名空间)，但它们引用相同的 bean。</p>
<p>Java-configuration</p>
<p>如果使用 Javaconfiguration，则<code>@Bean</code> annotation 可用于提供别名。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-java-bean-annotation">使用 @Bean Annotation</a>。</p>
<h4 id="实例化-Beans"><a href="#实例化-Beans" class="headerlink" title="实例化 Beans"></a>实例化 Beans</h4><p>bean 定义本质上是 creating 一个或多个 objects 的配方。容器在询问时查看命名 bean 的配方，并使用由 bean 定义封装的 configuration 元数据来创建(或获取)实际的 object。</p>
<p>如果使用 XML-based configuration 元数据，则指定要在<code>&lt;bean/&gt;</code>元素的<code>class</code>属性中实例化的 object 的类型(或 class)。这个<code>class</code>属性(内部是<code>BeanDefinition</code>实例上的<code>Class</code> property)通常是强制性的。 (对于 exceptions，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-instance-factory-method">使用实例工厂方法实例化</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">Bean 定义继承</a> .)您可以通过以下两种方式之一使用<code>Class</code> property：</p>
<ul>
<li>通常，要指定在容器本身通过反射调用其构造函数直接创建 bean 的情况下构造的 bean class，有点等同于运算符的 Java code。</li>
<li>要指定包含工厂方法的实际 class，该方法被调用以创建 object，在较少 common 的情况下，容器在 class 上调用<code>static</code>工厂方法来创建 bean。从<code>static</code>工厂方法的调用返回的 object 类型可能完全是相同的 class 或另一个 class。</li>
</ul>
<p>内部 class 名称</p>
<p>如果要为<code>static</code>嵌套 class 配置 bean 定义，则必须使用嵌套 class 的二进制 name。</p>
<p>例如，如果在<code>com.example</code>包中有一个名为<code>SomeThing</code>的 class，并且<code>SomeThing</code> class 有一个<code>static</code>嵌套 class，名为<code>OtherThing</code>，则 bean</p>
<p>注意在 name 中使用<code>$</code>字符将嵌套的 class name 与外部 class name 分开。</p>
<h5 id="使用构造函数实例化"><a href="#使用构造函数实例化" class="headerlink" title="使用构造函数实例化"></a>使用构造函数实例化</h5><p>当您通过构造方法创建 bean 时，所有正常的 classes 都可以使用 Spring 并与之兼容。也就是说，正在开发的 class 不需要实现任何特定接口或以特定方式编码。只需指定 bean class 就足够了。但是，根据您为特定 bean 使用的 IoC 类型，您可能需要一个默认(空)构造函数。</p>
<p>Spring IoC 容器几乎可以管理您希望它管理的任何 class。它不仅限于管理 true JavaBeans。大多数 Spring 用户更喜欢实际的 JavaBeans，只有一个默认的(no-argument)构造函数，并且在容器中的 properties 之后建模了适当的 setter 和 getter。您还可以在容器中拥有更多异域 non-bean-style classes。例如，对于 example，您需要使用绝对不符合 JavaBean 规范的 legacy 连接池，Spring 也可以对其进行管理。</p>
<p>使用 XML-based configuration 元数据，您可以指定 bean class，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exampleBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBean&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;anotherExample&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.ExampleBeanTwo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关在构造 object 之后向构造函数提供 arguments(如果需要)和设置 object instance properties 的机制的详细信息，请参阅<a href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">注入依赖关系</a>。</p>
<h5 id="使用静态工厂方法实例化"><a href="#使用静态工厂方法实例化" class="headerlink" title="使用静态工厂方法实例化"></a>使用静态工厂方法实例化</h5><p>定义使用静态工厂方法创建的 bean 时，请使用<code>class</code>属性指定包含<code>static</code>工厂方法的 class 和名为<code>factory-method</code>的属性，以指定工厂方法本身的 name。您应该能够调用此方法(使用可选的 arguments，如稍后所述)并 return live object，后来被视为通过构造函数创建。这种 bean 定义的一个用途是在 legacy code 中调用<code>static</code>工厂。</p>
<p>以下 bean 定义指定通过调用工厂方法来创建 bean。该定义未指定返回的 object 的类型(class)，仅指定包含工厂方法的 class。在此 example 中，<code>createInstance()</code>方法必须是静态方法。以下 example 显示了如何指定工厂方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;examples.ClientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下 example 显示了一个可以使用前面的 bean 定义的 class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关在工厂返回 object 之后向工厂方法提供(可选)arguments 并设置 object instance properties 的机制的详细信息，请参阅[详细信息中的依赖关系和 Configuration](#详细信息中的依赖关系和 Configuration)。</p>
<h5 id="使用实例工厂方法实例化"><a href="#使用实例工厂方法实例化" class="headerlink" title="使用实例工厂方法实例化"></a>使用实例工厂方法实例化</h5><p>与通过<a href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96">静态工厂方法</a>进行实例化类似，使用实例工厂方法进行实例化会从容器中调用现有 bean 的 non-static 方法来创建新的 bean。要使用此机制，请将<code>class</code>属性保留为空，并在<code>factory-bean</code>属性中，在当前(或 parent 或 ancestor)容器中指定 bean 的 name，该容器包含要调用以创建 object 的实例方法。使用<code>factory-method</code>属性设置工厂方法本身的 name。以下 example 显示了如何配置这样的 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下 example 显示了相应的 Java class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个工厂 class 也可以包含多个工厂方法，如下面的示例所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;serviceLocator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.DefaultServiceLocator&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;clientService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createClientServiceInstance&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">&quot;serviceLocator&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">&quot;createAccountServiceInstance&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>以下 example 显示了相应的 Java class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法表明工厂 bean 本身可以通过依赖注入(DI)进行管理和配置。见[详细信息中的依赖关系和 Configuration](#详细信息中的依赖关系和 Configuration)。</p>
<blockquote>
<p>在 Spring 文档中，“factory bean”指的是 Spring 容器中配置的 bean，它通过<a href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96">例</a>或<a href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96">静态</a>工厂方法创建 objects。相比之下，<code>FactoryBean</code>(注意大写)指的是 Spring-specific [FactoryBean](#使用 FactoryBean 自定义实例化逻辑)。</p>
</blockquote>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>典型的企业应用程序不包含单个 object(或 Spring 用语中的 bean)。即使是最简单的 application 也有一些 objects 可以协同工作来呈现 end-user 所看到的连贯应用程序。下一节将介绍如何定义一些独立的 bean 定义到完全实现的 application，其中 objects 协作实现目标。</p>
<h4 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h4><p>依赖注入(DI)是一个 process，其中 objects 仅通过构造函数 arguments，工厂方法的 arguments 或 object 实例在构造之后设置的 properties 定义它们的依赖项(即，它们工作的其他 objects)或者从工厂方法返回。然后容器在创建 bean 时注入这些依赖项。这个 process 基本上是 bean 本身的逆(因此 name，控制反转)，它通过使用 classes 或 Service Locator pattern 的直接构造来控制其依赖项的实例化或位置。</p>
<p>使用 DI 原理，Code 更干净，当 objects 具有依赖关系时，解耦更有效。 object 不查找其依赖项，也不知道依赖项的位置或 class。因此，您的 classes 变得更容易测试，特别是当依赖关系在接口或 abstract base classes 上时，它们允许在单元测试中使用 stub 或 mock implementations。</p>
<p>DI 存在两种主要变体：[Constructor-based 依赖注入](#Constructor-based 依赖注入)和[Setter-based 依赖注入](#Setter-based 依赖注入)。</p>
<h5 id="Constructor-based-依赖注入"><a href="#Constructor-based-依赖注入" class="headerlink" title="Constructor-based 依赖注入"></a>Constructor-based 依赖注入</h5><p>Constructor-based DI 由容器调用具有多个 arguments 的构造函数完成，每个 arguments 表示一个依赖项。调用具有特定 arguments 的<code>static</code>工厂方法来构造 bean 几乎是等效的，本讨论同样将 arguments 视为构造函数和<code>static</code>工厂方法。以下 example 显示了一个只能使用构造函数注入 dependency-injected 的 class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这个 class 没有什么特别之处。它是一个 POJO，它不依赖于容器特定的接口，base classes 或 annotations。</p>
<h6 id="构造函数参数解析"><a href="#构造函数参数解析" class="headerlink" title="构造函数参数解析"></a>构造函数参数解析</h6><p>通过使用参数的类型进行构造函数参数解析匹配。如果 bean 定义的构造函数 arguments 中不存在潜在的歧义，则在 bean 定义中定义构造函数 arguments 的 order 是 order，其中在实例化 bean 时将这些 arguments 提供给适当的构造函数。考虑以下 class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThingOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThingOne</span><span class="params">(ThingTwo thingTwo, ThingThree thingThree)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设<code>ThingTwo</code>和<code>ThingThree</code> classes 与继承无关，则不存在潜在的歧义。因此，以下 configuration 工作正常，您不需要在<code>&lt;constructor-arg/&gt;</code>元素中显式指定构造函数参数索引或类型。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingOne&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingOne&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingTwo&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;thingThree&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingTwo&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingTwo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;thingThree&quot;</span> <span class="attr">class</span>=<span class="string">&quot;x.y.ThingThree&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当引用另一个 bean 时，类型是已知的，并且可以进行匹配(与前面的 example 的情况一样)。当使用简单类型(例如<code>&lt;value&gt;true&lt;/value&gt;</code>)时，Spring 无法确定 value 的类型，因此无法在没有帮助的情况下按类型匹配。考虑以下 class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of years to calculate the Ultimate Answer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> years;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Answer to Life, the Universe, and Everything</span></span><br><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.years = years;</span><br><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数参数类型匹配</p>
<p>在前面的场景中，如果使用<code>type</code>属性显式指定构造函数参数的类型，则容器可以使用与简单类型匹配的类型。如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>构造函数参数索引</p>
<p>您可以使用<code>index</code>属性显式指定构造函数 arguments 的索引，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg index&#x3D;&quot;1&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>除了解决多个简单值的歧义之外，指定索引还可以解决构造函数具有两个相同类型的 arguments 的歧义。</p>
<blockquote>
<p>索引是 0-based。</p>
</blockquote>
<p>构造函数参数 name</p>
<p>您还可以使用构造函数参数 name 进行 value 消歧，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;years&quot; value&#x3D;&quot;7500000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg name&#x3D;&quot;ultimateAnswer&quot; value&#x3D;&quot;42&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>请记住，要使这项工作开箱即用，必须在启用 debug flag 的情况下编译 code，以便 Spring 可以从构造函数中查找参数 name。如果您不能或不想使用 debug flag 编译 code，则可以使用<a target="_blank" rel="noopener" href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a> JDK annotation 显式 name 构造函数 arguments。然后 sample class 必须如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package examples;</span><br><span class="line"></span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Fields omitted</span><br><span class="line"></span><br><span class="line">    @ConstructorProperties(&#123;&quot;years&quot;, &quot;ultimateAnswer&quot;&#125;)</span><br><span class="line">    public ExampleBean(int years, String ultimateAnswer) &#123;</span><br><span class="line">        this.years &#x3D; years;</span><br><span class="line">        this.ultimateAnswer &#x3D; ultimateAnswer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Setter-based-依赖注入"><a href="#Setter-based-依赖注入" class="headerlink" title="Setter-based 依赖注入"></a>Setter-based 依赖注入</h5><p>Setter-based DI 是在调用 no-argument 构造函数或 no-argument <code>static</code>工厂方法来实例化 bean 之后，在 beans 上调用 setter 方法的容器来完成的。</p>
<p>以下 example 显示了一个 class，它只能通过使用纯 setter 注入来 dependency-injected。这个 class 是传统的 Java。它是一个 POJO，它不依赖于容器特定的接口，base classes 或 annotations。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleMovieLister &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; the SimpleMovieLister has a dependency on the MovieFinder</span><br><span class="line">    private MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a setter method so that the Spring container can inject a MovieFinder</span><br><span class="line">    public void setMovieFinder(MovieFinder movieFinder) &#123;</span><br><span class="line">        this.movieFinder &#x3D; movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; business logic that actually uses the injected MovieFinder is omitted...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ApplicationContext</code>支持它管理的 beans 的 constructor-based 和 setter-based DI。在通过构造函数方法注入了一些依赖项之后，它还支持 setter-based DI。您可以以<code>BeanDefinition</code>的形式配置依赖项，并将其与<code>PropertyEditor</code>实例结合使用，以将 properties 从一种格式转换为另一种格式。但是，大多数 Spring 用户不直接使用这些 classes(即以编程方式)，而是使用 XML <code>bean</code>定义，带注释的组件(即用，<code>@Controller</code>等注释的 classes)，或 Java-based <code>@Configuration</code> classes 中的<code>@Bean</code>方法。然后，这些源在内部转换为<code>BeanDefinition</code>的实例，并用于加载整个 Spring IoC 容器实例。</p>
<p>Constructor-based 或 setter-based DI？</p>
<p>由于您可以混合使用 constructor-based 和 setter-based DI，因此将构造函数用于强制依赖项和 setter 方法或使用 configuration 方法作为可选依赖项是一个很好的经验法则。请注意，在 setter 方法上使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation">@Required</a> annotation 可用于使 property 成为必需的依赖项。</p>
<p>Spring 团队通常提倡构造函数注入，因为它允许您将 application 组件实现为不可变 objects 并确保所需的依赖项不是<code>null</code>。此外，constructor-injected 组件始终返回到完全初始化的 state 中的 client(调用)code。作为旁注，大量的构造函数 arguments 是一个糟糕的 code 气味，暗示 class 可能有太多的责任，应该重构以更好地解决关注点的正确分离。</p>
<p>Setter 注入应主要仅用于可在 class 中指定合理默认值的可选依赖项。否则，必须在 code 使用依赖项的任何位置执行 not-null 检查。 setter 注入的一个好处是 setter 方法使 class 的 objects 适合重新配置或 re-injection 以后。 因此，通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx">JMX MBeans</a>管理是一个引人注目的用于二传手注射的用例。</p>
<p>使用对特定 class 最有意义的 DI 样式。有时，在处理没有源的 third-party classes 时，会选择您。例如，如果 third-party class 没有公开任何 setter 方法，那么构造函数注入可能是唯一可用的 DI 形式。</p>
<h5 id="依赖性解决-Process"><a href="#依赖性解决-Process" class="headerlink" title="依赖性解决 Process"></a>依赖性解决 Process</h5><p>容器执行 bean 依赖项解析，如下所示：</p>
<ul>
<li>使用描述所有 beans 的 configuration 元数据创建和初始化<code>ApplicationContext</code>。 Configuration 元数据可以由 XML，Java code 或 annotations 指定。</li>
<li>对于每个 bean，其依赖关系以 properties，constructor arguments 或_ar_ments 的形式表示(如果使用它而不是普通的构造函数)。当实际创建 bean 时，这些依赖项将提供给 bean。</li>
<li>每个 property 或构造函数参数都是要设置的 value 的实际定义，或者是容器中另一个 bean 的 reference。</li>
<li>作为 value 的每个 property 或构造函数参数都从其指定的格式转换为该 property 或 constructor 参数的实际类型。默认情况下，Spring 可以将 string 格式提供的 value 转换为所有 built-in 类型，例如<code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>等。</li>
</ul>
<p>Spring 容器在创建容器时验证每个 bean 的 configuration。但是，在实际创建 bean 之前，不会设置 bean properties 本身。创建容器时会创建 singleton-scoped 并设置为 pre-instantiated(默认值)的 Beans。范围在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">Bean 范围</a>中定义。否则，只有在请求时才会创建 bean。创建 bean 可能会导致创建 beans 图，因为 bean 的依赖项及其依赖项的依赖项(依此类推)会被创建和分配。请注意，这些依赖项之间的解决方案不匹配可能会显示较晚 - 也就是说，首次创建受影响的 bean 时。</p>
<p>循环依赖</p>
<p>如果您主要使用构造函数注入，则可以创建无法解析的循环依赖关系场景。</p>
<p>对于 example：Class A 需要通过构造函数注入实现 class B，而 class B 需要通过构造函数注入实现 class A.如果为 classes A 和 B 配置 beans 以相互注入，则 Spring IoC 容器会在运行时检测到此循环 reference，并抛出<code>BeanCurrentlyInCreationException</code>。</p>
<p>一种可能的解决方案是编辑某些 classes 的 source code，以便由 setter 而不是构造函数配置。或者，避免构造函数注入并仅使用 setter 注入。换句话说，尽管不推荐使用，但您可以使用 setter 注入配置循环依赖项。</p>
<p>与典型情况(没有循环依赖)不同，bean A 和 bean B 之间的循环依赖强制其中一个 beans 在完全初始化之前被注入另一个(经典的 chicken-and-egg 场景)。</p>
<p>您通常可以信任 Spring 做正确的事情。它在容器 load-time 处检测 configuration 问题，例如 reference to non-existent beans 和循环依赖项。 Spring sets properties 并在实际创建 bean 时尽可能晚地解析依赖项。这意味着正确加载的 Spring 容器以后可以在请求 object 时生成 exception，如果有问题创建 object 或其中一个依赖项 - 对于 example，bean 因缺少或无效而抛出 exception 属性。这可能会延迟一些 configuration 问题的可见性，这就是为什么<code>ApplicationContext</code> implementations 默认为 pre-instantiate singleton beans。以某些前期 time 和 memory 为代价，在实际需要之前创建这些 beans，您会在创建<code>ApplicationContext</code>时发现 configuration 问题，而不是以后。您仍然可以覆盖此默认行为，以便 singleton beans 懒惰地初始化，而不是 pre-instantiated。</p>
<p>如果不存在循环依赖关系，则当一个或多个协作 beans 被注入依赖 bean 时，每个协作 bean 在被注入依赖 bean 之前完全配置。这意味着，如果 bean A 依赖于 bean B，Spring IoC 容器在 bean A 上调用 setter 方法之前完全配置 bean B.换句话说，bean 被实例化(如果它不是 pre-instantiated singleton)，设置其依赖项，并调用相关的生命周期方法(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">配置的 init 方法</a>或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean">InitializingBean 回调方法</a>)。</p>
<h5 id="依赖注入的示例"><a href="#依赖注入的示例" class="headerlink" title="依赖注入的示例"></a>依赖注入的示例</h5><p>以下 example 使用 setter-based 配置元数据用于 setter-based DI。 Spring XML configuration 文件的一小部分指定了一些 bean 定义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;!-- setter injection using the nested ref element --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;beanOne&quot;&gt;</span><br><span class="line">        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- setter injection using the neater ref attribute --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;beanTwo&quot; ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;integerProperty&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    private AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    private YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public void setBeanOne(AnotherBean beanOne) &#123;</span><br><span class="line">        this.beanOne &#x3D; beanOne;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBeanTwo(YetAnotherBean beanTwo) &#123;</span><br><span class="line">        this.beanTwo &#x3D; beanTwo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIntegerProperty(int i) &#123;</span><br><span class="line">        this.i &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的 example 中，setter 被声明为与 XML 文件中指定的 properties 进行 match。以下示例使用 constructor-based DI：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;</span><br><span class="line">    &lt;!-- constructor injection using the nested ref element --&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;constructor-arg&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- constructor injection using the neater ref attribute --&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    private AnotherBean beanOne;</span><br><span class="line"></span><br><span class="line">    private YetAnotherBean beanTwo;</span><br><span class="line"></span><br><span class="line">    private int i;</span><br><span class="line"></span><br><span class="line">    public ExampleBean(</span><br><span class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;</span><br><span class="line">        this.beanOne &#x3D; anotherBean;</span><br><span class="line">        this.beanTwo &#x3D; yetAnotherBean;</span><br><span class="line">        this.i &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bean 定义中指定的构造函数 arguments 用作<code>ExampleBean</code>的构造函数的 arguments。</p>
<p>现在考虑这个 example 的变体，其中，不是使用构造函数，而是告诉 Spring 调用<code>static</code>工厂方法来 return object 的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot; factory-method&#x3D;&quot;createInstance&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;constructor-arg value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了相应的<code>ExampleBean</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBean &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a private constructor</span><br><span class="line">    private ExampleBean(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a static factory method; the arguments to this method can be</span><br><span class="line">    &#x2F;&#x2F; considered the dependencies of the bean that is returned,</span><br><span class="line">    &#x2F;&#x2F; regardless of how those arguments are actually used.</span><br><span class="line">    public static ExampleBean createInstance (</span><br><span class="line">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;</span><br><span class="line"></span><br><span class="line">        ExampleBean eb &#x3D; new ExampleBean (...);</span><br><span class="line">        &#x2F;&#x2F; some other operations...</span><br><span class="line">        return eb;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂方法的 Arguments 由<code>&lt;constructor-arg/&gt;</code>元素提供，与实际使用构造函数的方式完全相同。工厂方法返回的 class 的类型不必与包含<code>static</code>工厂方法的 class 的类型相同(尽管，在此 example 中，它是)。实例(non-static)工厂方法可以以基本相同的方式使用(除了使用<code>factory-bean</code>属性而不是<code>class</code>属性)，因此我们不在此讨论这些细节。</p>
<h4 id="详细信息中的依赖关系和-Configuration"><a href="#详细信息中的依赖关系和-Configuration" class="headerlink" title="详细信息中的依赖关系和 Configuration"></a>详细信息中的依赖关系和 Configuration</h4><p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">上一节</a>中所述，您可以将 bean properties 和 constructor arguments 定义为对其他托管 beans(协作者)的 references 或作为内联定义的值。为此，Spring 的 XML-based configuration 元数据在其<code>&lt;property/&gt;</code>和<code>&lt;constructor-arg/&gt;</code>元素中支持 sub-element 类型。</p>
<h5 id="直线值-Primitives，Strings-等"><a href="#直线值-Primitives，Strings-等" class="headerlink" title="直线值(Primitives，Strings 等)"></a>直线值(Primitives，Strings 等)</h5><p><code>&lt;property/&gt;</code>元素的<code>value</code>属性将 property 或构造函数参数指定为 human-readable string 表示。 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#core-convert-ConversionService-API">转换服务</a>用于将这些值从<code>String</code>转换为 property 或参数的实际类型。以下 example 显示了设置的各种值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myDataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setDriverClassName(String) call --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;masterkaoli&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>以下 example 使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-p-namespace">p-namespace</a>进行更简洁的 XML configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">    http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myDataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span><br><span class="line">        destroy-method&#x3D;&quot;close&quot;</span><br><span class="line">        p:driverClassName&#x3D;&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">        p:url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb&quot;</span><br><span class="line">        p:username&#x3D;&quot;root&quot;</span><br><span class="line">        p:password&#x3D;&quot;masterkaoli&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 XML 更简洁。但是，在运行时发现拼写错误而不是设计 time，除非您在创建 bean 定义时使用支持自动 property 完成的 IDE(例如<a target="_blank" rel="noopener" href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a>或<a target="_blank" rel="noopener" href="https://spring.io/tools/sts">Spring 工具套件</a>)。强烈建议使用此类 IDE 帮助。</p>
<p>您还可以配置<code>java.util.Properties</code>实例，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;mappings&quot;</span><br><span class="line">    class&#x3D;&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- typed as a java.util.Properties --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;properties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            jdbc.driver.className&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">            jdbc.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb</span><br><span class="line">        &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>Spring 容器通过使用 JavaBeans <code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素内的文本转换为<code>java.util.Properties</code>实例。这是一个很好的快捷方式，是 Spring 团队支持在<code>value</code>属性样式上使用嵌套<code>&lt;value/&gt;</code>元素的少数几个地方之一。</p>
<h6 id="idref-元素"><a href="#idref-元素" class="headerlink" title="idref 元素"></a>idref 元素</h6><p><code>idref</code>元素只是一种 error-proof 方式，用于将容器中另一个 bean 的<code>id</code>(string value - 而不是 reference)传递给<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>元素。以下 example 显示了如何使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;theTargetBean&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;theClientBean&quot; class&#x3D;&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetName&quot;&gt;</span><br><span class="line">        &lt;idref bean&#x3D;&quot;theTargetBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 bean 定义代码段与以下代码段完全等效(在运行时)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;theTargetBean&quot; class&#x3D;&quot;...&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;client&quot; class&#x3D;&quot;...&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetName&quot; value&#x3D;&quot;theTargetBean&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>第一种形式优于第二种形式，因为使用<code>idref</code>标记允许容器在部署 time 时验证引用的名为 bean 的实际存在。在第二个变体中，不会对传递给<code>client</code> bean 的<code>targetName</code> property 的 value 执行验证。当<code>client</code> bean 实际被实例化时，才会发现错别字(最有可能致命的结果)。如果<code>client</code> bean 是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes">原型</a> bean，则只能在部署容器后 long 发现此错误和结果 exception。</p>
<blockquote>
<p>4.0 beans XSD 不再支持<code>idref</code>元素上的<code>local</code>属性，因为它不再提供常规<code>bean</code> reference 的 value。升级到 4.0 schema 时，将现有的<code>idref local</code> references 更改为<code>idref bean</code>。</p>
</blockquote>
<p><code>&lt;idref/&gt;</code>元素带来 value 的 common 位置(至少在 Spring 2.0 之前的版本中)位于<code>ProxyFactoryBean</code> bean 定义的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-pfb-1">AOP 拦截器</a>的 configuration 中。指定拦截器名称时使用<code>&lt;idref/&gt;</code>元素可防止拼写错误的拦截器 ID。</p>
<h5 id="References-to-Other-Beans-Collaborators"><a href="#References-to-Other-Beans-Collaborators" class="headerlink" title="References to Other Beans(Collaborators)"></a>References to Other Beans(Collaborators)</h5><p><code>ref</code>元素是<code>&lt;constructor-arg/&gt;</code>或<code>&lt;property/&gt;</code>定义元素中的最后一个元素。在这里，您将 bean 的指定 property 的 value 设置为由容器管理的另一个 bean(协作者)的 reference。引用的 bean 是要设置 property 的 bean 的依赖项，并且在设置 property 之前根据需要初始化它。 (如果协作者是 singleton bean，它可能已经被 container.)初始化所有 references 最终都是 reference 给另一个 object。作用域和验证取决于你是否通过<code>bean</code>，<code>local,</code>或<code>parent</code>指定另一个 object 的 ID 或 name 属性。</p>
<p>通过<code>&lt;ref/&gt;</code>标记的<code>bean</code>属性指定目标 bean 是最常用的形式，并允许在同一容器或 parent 容器中创建 reference 给任何 bean，无论它是否在同一 XML 文件中。 <code>bean</code>属性的 value 可以与 target bean 的<code>id</code>属性相同，也可以与 target bean 的<code>name</code>属性中的一个值相同。以下 example 显示了如何使用<code>ref</code>元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;ref bean&#x3D;&quot;someBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>通过<code>parent</code>属性指定目标 bean 会创建一个 reference 给位于当前容器的 parent 容器中的 bean。 <code>parent</code>属性的 value 可以与 target bean 的<code>id</code>属性相同，也可以与 target bean 的<code>name</code>属性中的一个值相同。目标 bean 必须位于当前容器的 parent 容器中。您应该使用此 bean reference 变体，主要是当您有容器层次结构并且希望将现有 bean 包装在 parent 容器中时，该容器具有与 parent bean 具有相同 name 的代理。以下一对列表显示了如何使用<code>parent</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- in the parent context --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.SimpleAccountService&quot;&gt;</span><br><span class="line">    &lt;!-- insert dependencies as required as here --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;!-- in the child (descendant) context --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; &lt;!-- bean name is the same as the parent bean --&gt;</span><br><span class="line">    class&#x3D;&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;target&quot;&gt;</span><br><span class="line">        &lt;ref parent&#x3D;&quot;accountService&quot;&#x2F;&gt; &lt;!-- notice how we refer to the parent bean --&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- insert other configuration and dependencies as required here --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.0 beans XSD 不再支持<code>ref</code>元素上的<code>local</code>属性，因为它不再提供常规<code>bean</code> reference 的 value。升级到 4.0 schema 时，将现有的<code>ref local</code> references 更改为<code>ref bean</code>。</p>
</blockquote>
<h5 id="内部-Beans"><a href="#内部-Beans" class="headerlink" title="内部 Beans"></a>内部 Beans</h5><p><code>&lt;property/&gt;</code>或<code>&lt;constructor-arg/&gt;</code>元素中的<code>&lt;bean/&gt;</code>元素定义内部 bean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;outer&quot; class&#x3D;&quot;...&quot;&gt;</span><br><span class="line">    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;target&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Fiona Apple&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>内部 bean 定义不需要定义的 ID 或 name。如果指定，则容器不使用这样的 value 作为标识符。容器也会在创建时忽略<code>scope</code> flag，因为内部 beans 始终是匿名的，并且始终使用外部 bean 创建。不可能独立访问内部 beans 或者将它们注入到协作 beans 而不是封闭的 bean 中。</p>
<p>作为一个极端情况，可以从自定义范围接收销毁回调 - 对于 example，包含在 singleton bean 中的 request-scoped inner bean。内部 bean 实例的创建与其包含 bean 相关联，但是销毁回调允许它参与请求范围的生命周期。这不是一个常见的场景。内部 beans 通常只是共享其包含 bean 的范围。</p>
<h5 id="收藏"><a href="#收藏" class="headerlink" title="收藏"></a>收藏</h5><p><code>&lt;list/&gt;</code>，<code>&lt;set/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;props/&gt;</code>元素分别设置 Java <code>Collection</code>类型<code>List</code>，<code>Set</code>，<code>Map</code>和<code>Properties</code>的 properties 和 arguments。以下 example 显示了如何使用它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;moreComplexObject&quot; class&#x3D;&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;adminEmails&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;administrator&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;support&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;development&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">        &lt;&#x2F;props&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeList(java.util.List) call --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;someList&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;a list element followed by a reference&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;myDataSource&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;someMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;an entry&quot; value&#x3D;&quot;just some string&quot;&#x2F;&gt;</span><br><span class="line">            &lt;entry key &#x3D;&quot;a ref&quot; value-ref&#x3D;&quot;myDataSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;someSet&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;just some string&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;myDataSource&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>map key 或 value 或 set value 的 value 也可以是以下任何元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span><br></pre></td></tr></table></figure>

<h6 id="收集合并"><a href="#收集合并" class="headerlink" title="收集合并"></a>收集合并</h6><p>Spring 容器还支持合并集合。 application 开发人员可以定义 parent <list/>，<map/>，<set/>或<props/>元素，并使 child <list/>，<map/>，<set/>或<props/>元素继承并覆盖 parent 集合中的值。也就是说，child 集合的值是合并 parent 和 child 集合的元素的结果，其中 child 的集合元素覆盖 parent 集合中指定的值。</p>
<p>关于合并的这一部分讨论了 parent-child bean 机制。 不熟悉 parent 和 child bean 定义的读者可能希望在继续之前阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">相关部分</a>。</p>
<p>以下 example 演示了集合合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;parent&quot; abstract&#x3D;&quot;true&quot; class&#x3D;&quot;example.ComplexObject&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;adminEmails&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;administrator&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;support&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;child&quot; parent&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;adminEmails&quot;&gt;</span><br><span class="line">            &lt;!-- the merge is specified on the child collection definition --&gt;</span><br><span class="line">            &lt;props merge&#x3D;&quot;true&quot;&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;sales&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;support&quot;&gt;[emailprotected]&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;beans&gt;</span><br></pre></td></tr></table></figure>

<p>注意在<code>child</code> bean 定义的<code>adminEmails</code> property 的<code>&lt;props/&gt;</code>元素上使用<code>merge=true</code>属性。当<code>child</code> bean 由容器解析并实例化时，生成的实例有一个<code>adminEmails</code> <code>Properties</code>集合，其中包含将 child 的<code>adminEmails</code>集合与 parent 的<code>adminEmails</code>集合合并的结果。以下清单显示了结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[emailprotected]</span><br><span class="line">[emailprotected]</span><br><span class="line">[emailprotected]</span><br></pre></td></tr></table></figure>

<p>child <code>Properties</code>集合的 value 集合从 parent <code>&lt;props/&gt;</code>继承所有 property 元素，child _ value 的 child 的 value 覆盖 parent 集合中的 value。</p>
<p>此合并行为同样适用于<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型。在<code>&lt;list/&gt;</code>元素的特定情况下，保持与<code>List</code>集合类型相关联的语义(即，<code>ordered</code>值集合的概念)。 parent 的值在所有 child 列表的值之前。对于<code>Map</code>，<code>Set</code>和<code>Properties</code>集合类型，不存在 ordering。因此，没有 ordering 语义对集合类型有效，这些集合类型是容器在内部使用的关联<code>Map</code>，<code>Set</code>和<code>Properties</code> implementation 类型的基础。</p>
<h6 id="收集合并的限制"><a href="#收集合并的限制" class="headerlink" title="收集合并的限制"></a>收集合并的限制</h6><p>您无法合并不同的集合类型(例如<code>Map</code>和<code>List</code>)。如果您尝试这样做，则会抛出适当的<code>Exception</code>。必须在较低的，继承的 child 定义上指定<code>merge</code>属性。在 parent 集合定义上指定<code>merge</code>属性是多余的，并且不会导致所需的合并。</p>
<h6 id="Strongly-typed-集合"><a href="#Strongly-typed-集合" class="headerlink" title="Strongly-typed 集合"></a>Strongly-typed 集合</h6><p>通过在 Java 5 中引入泛型类型，您可以使用强类型集合。也就是说，可以声明<code>Collection</code>类型，使其只能包含(对于 example)<code>String</code>元素。如果使用 Spring dependency-inject strongly-typed <code>Collection</code>进入 bean，则可以利用 Spring 的 type-conversion 支持，以便在添加到<code>Collection</code>之前将 strongly-typed <code>Collection</code>实例的元素转换为适当的类型。以下 Java class 和 bean 定义显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class SomeClass &#123;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Float&gt; accounts;</span><br><span class="line"></span><br><span class="line">    public void setAccounts(Map&lt;String, Float&gt; accounts) &#123;</span><br><span class="line">        this.accounts &#x3D; accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;something&quot; class&#x3D;&quot;x.y.SomeClass&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;accounts&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;one&quot; value&#x3D;&quot;9.99&quot;&#x2F;&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;two&quot; value&#x3D;&quot;2.75&quot;&#x2F;&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;six&quot; value&#x3D;&quot;3.99&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>当<code>something</code> bean 的<code>accounts</code> property 准备好进行注入时，可以通过反射获得有关 strongly-typed <code>Map&lt;String, Float&gt;</code>的元素类型的泛型信息。因此，Spring 的类型转换基础结构将各种 value 元素识别为<code>Float</code>类型，并将 string 值(<code>9.99, 2.75</code>和<code>3.99</code>)转换为实际的<code>Float</code>类型。</p>
<h5 id="Null-和-Empty-String-值"><a href="#Null-和-Empty-String-值" class="headerlink" title="Null 和 Empty String 值"></a>Null 和 Empty String 值</h5><p>Spring 将 properties 等的空 arguments 视为空<code>Strings</code>。以下 XML-based configuration 元数据片段_set <code>email</code> property 为空<code>String</code> value(“”)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;ExampleBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 example 等效于以下 Java code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(&quot;&quot;);</span><br></pre></td></tr></table></figure>

<p><code>&lt;null/&gt;</code>元素处理<code>null</code>值。以下清单显示了一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;ExampleBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;email&quot;&gt;</span><br><span class="line">        &lt;null&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>前面的 configuration 相当于以下 Java code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(null);</span><br></pre></td></tr></table></figure>

<h5 id="带-p-namespace-的-XML-快捷方式"><a href="#带-p-namespace-的-XML-快捷方式" class="headerlink" title="带 p-namespace 的 XML 快捷方式"></a>带 p-namespace 的 XML 快捷方式</h5><p>p-namespace 允许您使用<code>bean</code>元素的属性(而不是嵌套的<code>&lt;property/&gt;</code>元素)来描述 property 值协作 beans，或两者。</p>
<p>Spring 支持可扩展的 configuration 格式<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">使用命名空间</a>，它们基于 XML Schema 定义。本章中讨论的<code>beans</code> configuration 格式在 XML Schema 文档中定义。但是，p-namespace 未在 XSD 文件中定义，仅存在于 Spring 的核心中。</p>
<p>以下 example 显示了两个 XML 片段(第一个使用标准 XML 格式，第二个使用 p-namespace)解析为相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name&#x3D;&quot;classic&quot; class&#x3D;&quot;com.example.ExampleBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;email&quot; value&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name&#x3D;&quot;p-namespace&quot; class&#x3D;&quot;com.example.ExampleBean&quot;</span><br><span class="line">        p:email&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>example 在 bean中显示了一个名为<code>email</code>的属性，该属性在 bean 定义中。这告诉 Spring 包含 property 声明。如前所述，p-namespace 没有 schema 定义，因此您可以将属性的 name 设置为 property name。</p>
<p>下一个 example 包含两个 bean 定义，它们都有一个 reference 给另一个 bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name&#x3D;&quot;john-classic&quot; class&#x3D;&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;John Doe&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;spouse&quot; ref&#x3D;&quot;jane&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name&#x3D;&quot;john-modern&quot;</span><br><span class="line">        class&#x3D;&quot;com.example.Person&quot;</span><br><span class="line">        p:name&#x3D;&quot;John Doe&quot;</span><br><span class="line">        p:spouse-ref&#x3D;&quot;jane&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name&#x3D;&quot;jane&quot; class&#x3D;&quot;com.example.Person&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Jane Doe&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p>此 example 不仅包含使用 p-namespace 的 property value，还使用特殊格式声明 property references。第一个 bean 定义使用<code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code>从 bean <code>john</code>到 bean <code>jane</code>创建 reference，而第二个 bean 定义使用<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来完成同样的事情。在这种情况下，<code>spouse</code>是 property name，而<code>-ref</code>部分表示这不是一个直的 value 而是 reference 给另一个 bean。</p>
<blockquote>
<p>p-namespace 不如标准 XML 格式灵活。例如，声明 property references 的格式与以<code>Ref</code>结尾的 properties 冲突，而标准 XML 格式则不然。我们建议您仔细选择您的方法并将其传达给您的团队成员，以避免产生在同一时间使用所有三种方法的 XML 文档。</p>
</blockquote>
<h5 id="带-c-namespace-的-XML-快捷方式"><a href="#带-c-namespace-的-XML-快捷方式" class="headerlink" title="带 c-namespace 的 XML 快捷方式"></a>带 c-namespace 的 XML 快捷方式</h5><p>与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-p-namespace">p-namespace 的 XML 快捷方式</a>类似，Spring 3.1 中引入的 c-namespace 允许内联属性来配置构造函数 arguments 而不是嵌套的<code>constructor-arg</code>元素。</p>
<p>以下 example 使用<code>c:</code>名称空间来执行与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-constructor-injection">Constructor-based 依赖注入</a>相同的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;thingOne&quot; class&#x3D;&quot;x.y.ThingTwo&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;thingTwo&quot; class&#x3D;&quot;x.y.ThingThree&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- traditional declaration --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;thingOne&quot; class&#x3D;&quot;x.y.ThingOne&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref&#x3D;&quot;thingTwo&quot;&#x2F;&gt;</span><br><span class="line">        &lt;constructor-arg ref&#x3D;&quot;thingThree&quot;&#x2F;&gt;</span><br><span class="line">        &lt;constructor-arg value&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- c-namespace declaration --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;thingOne&quot; class&#x3D;&quot;x.y.ThingOne&quot; c:thingTwo-ref&#x3D;&quot;thingTwo&quot; c:thingThree-ref&#x3D;&quot;thingThree&quot; c:email&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<p><code>c:</code>名称空间使用与<code>p:</code>一样的约定(bean references 的尾随<code>-ref</code>)，用于按名称设置构造函数 arguments。同样，它需要声明，即使它没有在 XSD schema 中定义(它存在于 Spring 核心内)。</p>
<p>对于构造函数参数名称不可用的罕见情况(通常在没有调试信息的情况下编译字节码)，您可以使用回退到参数索引，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- c-namespace index declaration --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;thingOne&quot; class&#x3D;&quot;x.y.ThingOne&quot; c:_0-ref&#x3D;&quot;thingTwo&quot; c:_1-ref&#x3D;&quot;thingThree&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于 XML 语法，索引表示法需要存在前导<code>_</code>，因为 XML 属性名称不能以数字开头(即使某些 IDE 允许它)。</p>
</blockquote>
<p>实际上，构造函数分辨率<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-ctor-arguments-resolution">机制</a>在匹配 arguments 方面非常有效，所以除非你真的需要，否则我们建议使用 name 表示法 through-out your configuration。</p>
<h5 id="化合物属性名称"><a href="#化合物属性名称" class="headerlink" title="化合物属性名称"></a>化合物属性名称</h5><p>将 bean properties 设置为 long 时，可以使用复合或嵌套 property 名称，因为除最终 property name 之外的路径的所有组件都不是<code>null</code>。考虑以下 bean 定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;something&quot; class&#x3D;&quot;things.ThingOne&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;fred.bob.sammy&quot; value&#x3D;&quot;123&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p><code>something</code> bean 有一个<code>fred</code> property，它有一个<code>bob</code> property，它有<code>sammy</code> property，最后<code>sammy</code> property 被设置为<code>123</code>的 value。为了使这个工作，的<code>fred</code> property 和<code>fred</code>的<code>bob</code> property 在构造 bean 之后不能是<code>null</code>。否则，抛出<code>NullPointerException</code>。</p>
<h4 id="使用-depends-on"><a href="#使用-depends-on" class="headerlink" title="使用 depends-on"></a>使用 depends-on</h4><p>如果 bean 是另一个 bean 的依赖项，那通常意味着一个 bean 被设置为另一个 bean 的 property。通常，您可以使用 XML-based XML-based configuration 元数据完成此操作。但是，有时 beans 之间的依赖关系不那么直接。 示例是需要触发 class 中的静态初始化程序时，例如数据库驱动程序注册。在使用此元素的 bean 初始化之前，<code>depends-on</code>属性可以显式强制初始化一个或多个 beans。以下 example 使用<code>depends-on</code>属性表示对单个 bean 的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;beanOne&quot; class&#x3D;&quot;ExampleBean&quot; depends-on&#x3D;&quot;manager&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;manager&quot; class&#x3D;&quot;ManagerBean&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>要表示对多个 beans 的依赖，请提供 bean 名称列表作为<code>depends-on</code>属性的 value(逗号，空格和分号是有效的分隔符)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;beanOne&quot; class&#x3D;&quot;ExampleBean&quot; depends-on&#x3D;&quot;manager,accountDao&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;manager&quot; ref&#x3D;&quot;manager&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;manager&quot; class&#x3D;&quot;ManagerBean&quot; &#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountDao&quot; class&#x3D;&quot;x.y.jdbc.JdbcAccountDao&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>depends-on</code>属性既可以指定 initialization-time 依赖项，也可以指定<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-ref-element">singleton</a> beans，相应的 destruction-time 依赖项。在给定 bean 本身被销毁之前，首先销毁与给定 bean 定义<code>depends-on</code>关系的依赖 beans。因此，<code>depends-on</code>也可以控制 shutdown order。</p>
</blockquote>
<h4 id="Lazy-initialized-Beans"><a href="#Lazy-initialized-Beans" class="headerlink" title="Lazy-initialized Beans"></a>Lazy-initialized Beans</h4><p>默认情况下，<code>ApplicationContext</code> implementations 急切地创建和配置所有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">singleton</a> beans 作为初始化 process 的一部分。通常，这个 pre-instantiation 是可取的，因为 configuration 或周围环境中的错误会立即被发现，而不是几小时甚至几天。如果不希望出现这种情况，可以通过将 bean 定义标记为 lazy-initialized 来阻止 singleton bean 的 pre-instantiation。 lazy-initialized bean 告诉 IoC 容器在第一次请求时创建 bean 实例，而不是在启动时创建 bean 实例。</p>
<p>在 XML 中，此行为由<code>&lt;bean/&gt;</code>元素上的<code>lazy-init</code>属性控制，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.ExpensiveToCreateBean&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;not.lazy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AnotherBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当前面的 configuration 被<code>ApplicationContext</code>消耗时，<code>ApplicationContext</code> bean 在<code>ApplicationContext</code>启动时并不急切 pre-instantiated，而<code>not.lazy</code> bean 则急切地 pre-instantiated。</p>
<p>但是，当 lazy-initialized bean 是 singleton bean 的依赖关系而不是 lazy-initialized 时，<code>ApplicationContext</code>会在启动时创建 lazy-initialized bean，因为它必须满足 singleton 的依赖关系。 lazy-initialized bean 被注入 singleton bean，而不是 lazy-initialized。</p>
<p>您还可以使用<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性控制容器 level 上的 lazy-initialization，以下 example 显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans default-lazy-init&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;!-- no beans will be pre-instantiated... --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h4 id="自动化协作者"><a href="#自动化协作者" class="headerlink" title="自动化协作者"></a>自动化协作者</h4><p>Spring 容器可以自动配合协作 beans 之间的关系。您可以通过检查<code>ApplicationContext</code>的内容让 Spring 自动为您的 bean 解析协作者(其他 beans)。自动装配具有以下优点：</p>
<ul>
<li>自动装配可以显着减少指定 properties 或构造函数 arguments 的需要。 (其他机制，如 bean 模板<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">在本章的其他地方讨论过</a>在此 regard.)也很有价值</li>
<li>随着 objects 的发展，自动装配可以更新 configuration。例如，如果需要向 class 添加依赖项，则可以自动满足该依赖项，而无需修改 configuration。因此，自动装配在开发期间尤其有用，而不会在 code base 变得更稳定时否定切换到显式布线的选项。</li>
</ul>
<p>使用 XML-based configuration 元数据(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-child-bean-definitions">依赖注入</a>)时，可以使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性为 bean 定义指定 autowire 模式。自动装配功能有四种模式。您为每个 bean 指定自动装配，因此可以选择要自动装配的那些。以下 table 描述了四种自动装配模式：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>no</code></td>
<td>(默认)无自动装配。 Bean references 必须由<code>ref</code>元素定义。不建议对较大的部署更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。</td>
</tr>
<tr>
<td><code>byName</code></td>
<td>property name 自动装配。 Spring 查找 bean，其 name 与需要自动装配的 property 相同。例如，如果 bean 定义由 name 设置为 autowire 并且它包含<code>master</code> property(即，它具有<code>setMaster(..)</code>方法)，则 Spring 将查找名为<code>master</code>的 bean 定义并使用它来设置 property。</td>
</tr>
<tr>
<td><code>byType</code></td>
<td>如果容器中只存在 property 类型的一个 bean，则允许 property 自动装配。如果存在多个，则抛出致命的 exception，这表示您不能对该 bean 使用<code>byType</code>自动装配。如果没有匹配的 beans，则不会发生任何事情(property 未设置)。</td>
</tr>
<tr>
<td><code>constructor</code></td>
<td>类似于<code>byType</code>但适用于构造函数 arguments。如果容器中没有构造函数参数类型的一个 bean，则会引发致命错误。</td>
</tr>
</tbody></table>
<p>使用<code>byType</code>或<code>constructor</code>自动装配模式，您可以连接数组和类型集合。在这种情况下，提供容器中与预期类型匹配的所有 autowire 候选者以满足依赖性。如果预期的 key 类型为<code>String</code>，则可以自动装配 strongly-typed <code>Map</code>实例。自动装配的<code>Map</code>实例的值由 match 预期类型的所有 bean 实例组成，<code>Map</code>实例的键包含相应的 bean 名称。</p>
<h5 id="自动装配的限制和缺点"><a href="#自动装配的限制和缺点" class="headerlink" title="自动装配的限制和缺点"></a>自动装配的限制和缺点</h5><p>当在整个项目中一致地使用自动装配时，自动装配效果最佳。如果一般不使用自动装配，那么开发人员使用它来连接一个或两个 bean 定义可能会让人感到困惑。</p>
<p>考虑自动装配的局限和缺点：</p>
<ul>
<li><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终覆盖自动装配。您无法自动装配简单的 properties，例如 primitives，<code>Strings</code>和<code>Classes</code>(以及此类简单 properties 的数组)。这个限制是 by-design。</li>
<li>自动装配不如显式布线精确。虽然如前面的 table 所述，Spring 谨慎避免在可能产生意外结果的模糊性的情况下进行猜测。您的 Spring-managed object 之间的关系不再明确记录。</li>
<li>可能无法为可能从 Spring 容器生成文档的工具提供接线信息。</li>
<li>容器中的多个 bean 定义可以 match 由 setter 方法或构造函数参数指定的类型以进行自动装配。对于数组，集合或<code>Map</code>实例，这不一定是个问题。但是，对于期望单个 value 的依赖关系，这种歧义不是任意解决的。如果没有唯一的 bean 定义，则抛出 exception。</li>
</ul>
<p>在后一种情况下，您有几种选择：</p>
<ul>
<li>放弃自动装配，支持显式布线。</li>
<li>通过将属性设置为<code>false</code>，避免为 bean 定义自动装配，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators">下一节</a>中所述。</li>
<li>通过将元素的<code>primary</code>属性设置为<code>true</code>，将单个 bean 定义指定为主要候选者。</li>
<li>使用 annotation-based configuration 实现更多 fine-grained 控件，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire-candidate">Annotation-based Container Configuration</a>中所述。</li>
</ul>
<h5 id="从自动装配中排除-Bean"><a href="#从自动装配中排除-Bean" class="headerlink" title="从自动装配中排除 Bean"></a>从自动装配中排除 Bean</h5><p>在 per-bean 的基础上，您可以从自动装配中排除 bean。在 Spring 的 XML 格式中，将<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性设置为<code>false</code>。容器使特定的 bean 定义对自动装配基础结构不可用(包括 annotation 样式配置，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config">@Autowired</a>)。</p>
<blockquote>
<p><code>autowire-candidate</code>属性旨在仅影响 type-based 自动装配。它不会影响 name 的显式 references，即使指定的 bean 未标记为 autowire 候选，它也会得到解析。因此，如果 name 匹配，name 的自动装配仍会注入 bean。</p>
</blockquote>
<p>您还可以根据 pattern-matching 对 bean 名称限制 autowire 候选者。 top-level <code>&lt;beans/&gt;</code>元素在其<code>default-autowire-candidates</code>属性中接受一个或多个模式。对于 example，要将 autowire 候选状态限制为 name ends with <code>Repository</code>的任何 bean，请提供的 value。要提供多个模式，请在 comma-separated 列表中定义它们。对于 bean 定义的<code>autowire-candidate</code>属性，<code>true</code>或<code>false</code>的显式 value 始终优先。对于此类 beans，pattern 匹配规则不适用。</p>
<p>这些技术对 beans 很有用，你永远不想通过自动装配注入其他 beans。这并不意味着排除的 bean 本身不能通过使用自动装配进行配置。相反，bean 本身不是自动装配其他 beans 的候选者。</p>
<h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><p>在大多数 application 场景中，容器中的大多数 beans 都是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation">单身</a>。当 singleton bean 需要与另一个 singleton bean 协作或 non-singleton bean 需要与另一个 non-singleton bean 协作时，通常通过将一个 bean 定义为另一个的 property 来处理依赖关系。当 bean 生命周期不同时会出现问题。假设 singleton bean A 需要使用 non-singleton(原型)bean B，可能在 A 上的每个方法调用上。容器只创建 singleton bean A 一次，因此只有一次机会来设置 properties。容器不能为 bean A 提供 bean B 的新实例，每个 time B 都需要一个。</p>
<p>解决方案是放弃一些控制反转。您可以<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">make bean 了解容器</a>实现<code>ApplicationContextAware</code>接口，并通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware">对容器进行 getBean(“B”)调用</a>请求(一个通常是新的)bean B 实例每 time bean A 需要它。以下 example 显示了这种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a class that uses a stateful Command-style class to perform some processing</span><br><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Spring-API imports</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line"></span><br><span class="line">public class CommandManager implements ApplicationContextAware &#123;</span><br><span class="line"></span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public Object process(Map commandState) &#123;</span><br><span class="line">        &#x2F;&#x2F; grab a new instance of the appropriate Command</span><br><span class="line">        Command command &#x3D; createCommand();</span><br><span class="line">        &#x2F;&#x2F; set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Command createCommand() &#123;</span><br><span class="line">        &#x2F;&#x2F; notice the Spring API dependency!</span><br><span class="line">        return this.applicationContext.getBean(&quot;command&quot;, Command.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setApplicationContext(</span><br><span class="line">            ApplicationContext applicationContext) throws BeansException &#123;</span><br><span class="line">        this.applicationContext &#x3D; applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的内容是不可取的，因为 business code 知道并耦合到 Spring Framework。方法注入，Spring IoC 容器的一些先进的 feature，让您可以干净地处理这个用例。</p>
<p>您可以在<a target="_blank" rel="noopener" href="https://spring.io/blog/2004/08/06/method-injection/">这篇博客文章</a>中阅读有关方法注入动机的更多信息。</p>
<h5 id="查找方法注入"><a href="#查找方法注入" class="headerlink" title="查找方法注入"></a>查找方法注入</h5><p>Lookup 方法注入是容器覆盖 container-managed beans 方法的能力，_return 查找容器中另一个名为 bean 的查找结果。查找通常涉及原型 bean，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-client">上一节</a>中描述的场景。 Spring Framework 通过使用 CGLIB library 中的字节码生成来动态生成覆盖该方法的子类来实现此方法注入。</p>
<blockquote>
<ul>
<li>为了使这个动态子类工作，Spring bean 容器子类的 class 不能是<code>final</code>，要覆盖的方法也不能是<code>final</code>。</li>
</ul>
</blockquote>
<ul>
<li>Unit-testing 具有<code>abstract</code>方法的 class 要求您自己子类化 class 并提供<code>abstract</code>方法的 stub implementation。</li>
<li>component 扫描也需要具体的方法，这需要具体的 classes 来获取。</li>
<li>另一个 key 限制是查找方法不能与工厂方法一起使用，特别是在 configuration classes 中不能使用<code>@Bean</code>方法，因为在这种情况下，容器不负责 creating 实例，因此无法创建 runtime-generated 子类。飞。</li>
</ul>
<p>对于前一个 code 片段中的<code>CommandManager</code> class，Spring 容器会动态覆盖<code>createCommand()</code>方法的 implementation。 <code>CommandManager</code> class 没有任何 Spring 依赖项，因为重写的 example 显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package fiona.apple;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; no more Spring imports!</span><br><span class="line"></span><br><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        &#x2F;&#x2F; grab a new instance of the appropriate Command interface</span><br><span class="line">        Command command &#x3D; createCommand();</span><br><span class="line">        &#x2F;&#x2F; set the state on the (hopefully brand new) Command instance</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; okay... but where is the implementation of this method?</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在包含要注入的方法的 client class 中(在本例中为<code>CommandManager</code>)，要注入的方法需要以下形式的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</span><br></pre></td></tr></table></figure>

<p>如果方法是<code>abstract</code>，则 dynamically-generated 子类实现该方法。否则，dynamically-generated 子类将覆盖原始 class 中定义的具体方法。考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;myCommand&quot; class&#x3D;&quot;fiona.apple.AsyncCommand&quot; scope&#x3D;&quot;prototype&quot;&gt;</span><br><span class="line">    &lt;!-- inject dependencies here as required --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;commandManager&quot; class&#x3D;&quot;fiona.apple.CommandManager&quot;&gt;</span><br><span class="line">    &lt;lookup-method name&#x3D;&quot;createCommand&quot; bean&#x3D;&quot;myCommand&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>bean 标识为<code>commandManager</code> calls 它自己的<code>createCommand()</code>方法，只要它需要一个<code>myCommand</code> bean 的新实例。您必须小心部署<code>myCommand</code> bean 作为原型，如果这实际上是需要的话。如果它是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">singleton</a>，则每 time 返回相同的<code>myCommand</code> bean 实例。</p>
<p>或者，在 annotation-based component model 中，您可以通过<code>@Lookup</code> annotation 声明查找方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        Command command &#x3D; createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup(&quot;myCommand&quot;)</span><br><span class="line">    protected abstract Command createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，更具惯用性，您可以依赖于查找方法的声明的 return 类型来解析目标 bean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CommandManager &#123;</span><br><span class="line"></span><br><span class="line">    public Object process(Object commandState) &#123;</span><br><span class="line">        MyCommand command &#x3D; createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        return command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Lookup</span><br><span class="line">    protected abstract MyCommand createCommand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，您通常应该在 order 中使用具体的 stub implementation 声明这样带注释的查找方法，以使它们与 Spring 的 component 扫描规则兼容，其中 abstract classes 默认被忽略。此限制不适用于显式注册或显式导入的 bean classes。</p>
<blockquote>
<p>访问不同范围的目标 beans 的另一种方法是<code>ObjectFactory</code>/<code>Provider</code>注入点。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton">将 Beans 视为依赖关系</a>。</p>
</blockquote>
<p>您可能还会发现<code>ServiceLocatorFactoryBean</code>(在<code>org.springframework.beans.factory.config</code>包中)很有用。</p>
<h5 id="任意方法替换"><a href="#任意方法替换" class="headerlink" title="任意方法替换"></a>任意方法替换</h5><p>与查找方法注入相比，一种不太有用的方法注入形式是能够使用另一种方法 implementation 替换托管 bean 中的任意方法。您可以安全地跳过本节的 rest，直到您真正需要此功能。</p>
<p>使用 XML-based configuration 元数据，您可以使用<code>replaced-method</code>元素将已存在的方法 implementation 替换为另一个，用于已部署的 bean。考虑以下 class，它有一个我们想要覆盖的名为<code>computeValue</code>的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyValueCalculator &#123;</span><br><span class="line"></span><br><span class="line">    public String computeValue(String input) &#123;</span><br><span class="line">        &#x2F;&#x2F; some real code...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; some other methods...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>org.springframework.beans.factory.support.MethodReplacer</code>接口的 class 提供了新的方法定义，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * meant to be used to override the existing computeValue(String)</span><br><span class="line"> * implementation in MyValueCalculator</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ReplacementComputeValue implements MethodReplacer &#123;</span><br><span class="line"></span><br><span class="line">    public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123;</span><br><span class="line">        &#x2F;&#x2F; get the input value, work with it, and return a computed result</span><br><span class="line">        String input &#x3D; (String) args[0];</span><br><span class="line">        ...</span><br><span class="line">        return ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部署原始 class 并指定方法覆盖的 bean 定义类似于以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myValueCalculator&quot; class&#x3D;&quot;x.y.z.MyValueCalculator&quot;&gt;</span><br><span class="line">    &lt;!-- arbitrary method replacement --&gt;</span><br><span class="line">    &lt;replaced-method name&#x3D;&quot;computeValue&quot; replacer&#x3D;&quot;replacementComputeValue&quot;&gt;</span><br><span class="line">        &lt;arg-type&gt;String&lt;&#x2F;arg-type&gt;</span><br><span class="line">    &lt;&#x2F;replaced-method&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;replacementComputeValue&quot; class&#x3D;&quot;a.b.c.ReplacementComputeValue&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在<code>&lt;replaced-method/&gt;</code>元素中使用一个或多个<code>&lt;arg-type/&gt;</code>元素来指示被覆盖的方法的方法签名。仅当方法重载且 class 中存在多个变体时，arguments 的签名才是必需的。为方便起见，参数的类型 string 可以是完全限定类型 name 的子字符串。对于 example，以下所有 match <code>java.lang.String</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.String</span><br><span class="line">String</span><br><span class="line">Str</span><br></pre></td></tr></table></figure>

<p>因为 arguments 的数量通常足以区分每个可能的选择，所以通过允许您只键入与参数类型匹配的最短 string，此快捷方式可以节省大量 typing。</p>
<h3 id="Bean-范围"><a href="#Bean-范围" class="headerlink" title="Bean 范围"></a>Bean 范围</h3><p>创建 bean 定义时，将创建一个配方，用于创建由 bean 定义定义的 class 的实际实例。 bean 定义是配方的 idea 很重要，因为它意味着，与 class 一样，您可以从单个配方创建许多 object 实例。</p>
<p>您不仅可以控制要插入到从特定 bean 定义创建的 object 的各种依赖项和 configuration 值，还可以控制从特定 bean 定义创建的 objects 的范围。这种方法功能强大且灵活，因为您可以选择通过 configuration 创建的 objects 的范围，而不必在 Java class level 的 object 范围内进行烘焙。 Beans 可以定义为部署在多个范围之一中。 Spring Framework 支持六个范围，其中四个范围仅在您使用 web-aware <code>ApplicationContext</code>时可用。你也可以创建<a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4">自定义范围。</a></p>
<p>以下 table 描述了支持的范围：</p>
<table>
<thead>
<tr>
<th>范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4">singleton</a></td>
<td>(默认)为每个 Spring IoC 容器的单个 object 实例定义单个 bean 定义。</td>
</tr>
<tr>
<td>[原型](#Singleton 范围)</td>
<td>为任意数量的 object 实例定义单个 bean 定义。</td>
</tr>
<tr>
<td><a href="#%E5%8E%9F%E5%9E%8B%E8%8C%83%E5%9B%B4">请求</a></td>
<td>将单个 bean 定义范围限定为单个 HTTP 请求的生命周期。也就是说，每个 HTTP 请求都有自己的 bean 实例，该实例是在单个 bean 定义的后面创建的。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td><a href="#%E8%AF%B7%E6%B1%82%E8%8C%83%E5%9B%B4">session</a></td>
<td>将单个 bean 定义范围限定为 HTTP <code>Session</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td>[应用](#Session 范围)</td>
<td>将单个 bean 定义范围限定为<code>ServletContext</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
<tr>
<td>[WebSocket](#Servlet Stack 上的 Web)</td>
<td>将单个 bean 定义范围限定为<code>WebSocket</code>的生命周期。仅在 web-aware Spring <code>ApplicationContext</code>的 context 中有效。</td>
</tr>
</tbody></table>
<blockquote>
<p>从 Spring 3.0 开始，线程范围可用，但默认情况下未注册。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html">SimpleThreadScope</a>的文档。有关如何注册此范围或任何其他自定义范围的说明，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#websocket-stomp-websocket-scope">使用自定义范围</a>。</p>
</blockquote>
<h4 id="Singleton-范围"><a href="#Singleton-范围" class="headerlink" title="Singleton 范围"></a>Singleton 范围</h4><p>只管理 singleton bean 的一个共享实例，并且 beans 的所有请求都带有一个或多个 match bean 定义的 ID 导致 Spring 容器返回的一个特定 bean 实例。</p>
<p>换句话说，当您定义 bean 定义并将其范围限定为 singleton 时，Spring IoC 容器只创建该 bean 定义定义的 object 的一个实例。此单个实例存储在此类 singleton beans 的缓存中，并且所有后续请求和 references 都指向 bean return 缓存的 object。下图显示了 singleton 范围的工作原理：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/singleton.jpg" alt="singleton"></p>
<p>Spring 的 singleton bean 概念与 singleton pattern 的概念不同，如四人帮(GoF)模式书中所定义的那样。 GoF singleton hard-codes object 的范围，使得每个 ClassLoader 创建一个且只有一个特定 class 的实例。 Spring singleton 的范围最好描述为 per-container 和 per-bean。这意味着，如果在单个 Spring 容器中为特定 class 定义一个 bean，则 Spring 容器将创建该_ bean 定义所定义的 class 的一个且仅一个实例。 singleton 范围是 Spring 中的默认范围。要在中将 bean 定义为 singleton，您可以定义 bean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.something.DefaultAccountService&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="原型范围"><a href="#原型范围" class="headerlink" title="原型范围"></a>原型范围</h4><p>bean 部署的 non-singleton 原型范围导致每次都会创建一个新的 bean 实例，并对该特定 bean 发出请求。也就是说，bean 被注入到另一个 bean 中，或者通过容器上的<code>getBean()</code>方法调用来请求它。通常，您应该为所有有状态 beans 使用原型范围，为 stateless beans 使用 singleton 范围。</p>
<p>下图说明了 Spring 原型范围：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/prototype.jpg" alt="原型"></p>
<p>(数据访问 object(DAO)通常不配置为原型，因为典型的 DAO 不包含任何会话 state。我们更容易重用 singleton diagram.)的核心</p>
<p>以下 example 将 bean 定义为 XML 中的原型：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.DefaultAccountService&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>与其他范围相比，Spring 不管理原型 bean 的完整生命周期。容器实例化，配置和组装原型 object 并将其交给 client，没有该原型实例的进一步 record。因此，尽管无论范围如何都在所有 object 上调用初始化生命周期回调方法，但在原型的情况下，不会调用已配置的销毁生命周期回调。 client code 必须清理 prototype-scoped object 并释放原型 beans 所拥有的昂贵资源。要让 Spring 容器释放 prototype-scoped beans 所拥有的资源，请尝试使用自定义<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-custom-using">bean post-processor</a>，它包含需要清理的 beans 的 reference。</p>
<p>在某些方面，Spring 容器关于 prototype-scoped bean 的角色是 Java <code>new</code> operator 的替代品。超过该点的所有生命周期管理必须由 client 处理。 (有关 Spring 容器中 bean 生命周期的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp">生命周期回调</a> .)</p>
<h4 id="Singleton-Beans-with-Prototype-bean-Dependencies"><a href="#Singleton-Beans-with-Prototype-bean-Dependencies" class="headerlink" title="Singleton Beans with Prototype-bean Dependencies"></a>Singleton Beans with Prototype-bean Dependencies</h4><p>当您对原型 beans 使用带有依赖关系的 singleton-scoped beans 时，请注意在实例化 time 时解析依赖关系。因此，如果原型实例是提供给 singleton-scoped bean 的唯一实例。</p>
<p>但是，假设您希望 singleton-scoped bean 在运行时重复获取 prototype-scoped bean 的新实例。你不能@ 如果您需要在运行时多次使用原型 bean 的新实例，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle">方法注入</a></p>
<h4 id="Request，Session，Application-和-WebSocket-Scopes"><a href="#Request，Session，Application-和-WebSocket-Scopes" class="headerlink" title="Request，Session，Application 和 WebSocket Scopes"></a>Request，Session，Application 和 WebSocket Scopes</h4><p>仅当您使用 web-aware Spring <code>ApplicationContext</code> implementation(例如<code>XmlWebApplicationContext</code>)时，<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围才可用。如果将这些范围与常规 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会抛出抱怨未知 bean 范围的<code>IllegalStateException</code>。</p>
<h5 id="初始-Web-Configuration"><a href="#初始-Web-Configuration" class="headerlink" title="初始 Web Configuration"></a>初始 Web Configuration</h5><p>要在<code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>级别(web-scoped beans)支持 beans 的范围设定，在定义 beans 之前需要一些小的初始 configuration。 (标准范围不需要此初始设置：<code>singleton</code>和<code>prototype</code> .)</p>
<p>如何完成此初始设置取决于您的特定 Servlet 环境。</p>
<p>如果在 Spring Web MVC 中访问范围 beans，实际上是在 Spring <code>DispatcherServlet</code>处理的请求中，则无需进行特殊设置。 <code>DispatcherServlet</code>已经暴露了所有相关的 state。</p>
<p>如果使用 Servlet 2.5 web 容器，并且在 Spring 的<code>DispatcherServlet</code>之外处理请求(对于 example，当使用 JSF 或 Struts 时)，则需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。或者，或者对于旧容器，将以下声明添加到 web application 的<code>web.xml</code>文件中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.request.RequestContextListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或者，如果 listener 设置存在问题，请考虑使用 Spring 的<code>RequestContextFilter</code>。过滤器映射取决于周围的 web application configuration，因此您必须根据需要进行更改。以下清单显示了 web application 的过滤器部分：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>DispatcherServlet</code>，<code>RequestContextListener</code>和<code>RequestContextFilter</code>都完全相同，即将 HTTP 请求 object 绑定到为该请求提供服务的<code>Thread</code>。这使 beans 在请求和 session-scoped 可进一步在调用链中可用。</p>
<h5 id="请求范围"><a href="#请求范围" class="headerlink" title="请求范围"></a>请求范围</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.LoginAction&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器通过对每个 HTTP 请求使用<code>loginAction</code> bean 定义来创建<code>LoginAction</code> bean 的新实例。也就是说，<code>loginAction</code> bean 的作用域是 HTTP 请求 level。您可以根据需要更改创建的实例的内部 state，因为从同一<code>loginAction</code> bean 定义创建的其他实例在 state 中看不到这些更改。它们特别针对个人要求。当请求完成处理时，将放弃作用于请求的 bean。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，<code>@RequestScope</code> annotation 可用于将 component 分配给<code>request</code>范围。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Session-范围"><a href="#Session-范围" class="headerlink" title="Session 范围"></a>Session 范围</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器通过在单个 HTTP <code>Session</code>的生命周期中使用<code>userPreferences</code> bean 定义来创建<code>UserPreferences</code> bean 的新实例。换句话说，<code>userPreferences</code> bean 有效地限定在 HTTP <code>Session</code> level。与 request-scoped beans 一样，您可以根据需要更改创建的实例的内部 state，因为知道同样使用从同一<code>userPreferences</code> bean 定义创建的实例的其他 HTTP <code>Session</code>实例在 state 中看不到这些更改，因为它们特定于单个 HTTP <code>Session</code>。当最终丢弃 HTTP <code>Session</code>时，也将丢弃作用于该特定 HTTP <code>Session</code>的 bean。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，可以使用<code>@SessionScope</code> annotation 将 component 分配给<code>session</code>范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Application-Scope"><a href="#Application-Scope" class="headerlink" title="Application Scope"></a>Application Scope</h5><p>考虑以下针对 bean 定义的 XML configuration：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;appPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.AppPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;application&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 容器通过对整个 web application 使用<code>appPreferences</code> bean 定义一次来创建<code>AppPreferences</code> bean 的新实例。也就是说，<code>appPreferences</code> bean 的作用域为<code>ServletContext</code> level 并存储为常规<code>ServletContext</code>属性。这有点类似于 Spring singleton bean 但在两个重要方面有所不同：它是 singleton 每<code>ServletContext</code>，而不是 Spring’ApplicationContext’(在任何给定的 web application 中可能有几个)，它实际上是暴露的，因此作为<code>ServletContext</code>属性可见。</p>
<p>使用 annotation-driven 组件或 Java configuration 时，可以使用<code>@ApplicationScope</code> annotation 将 component 分配给<code>application</code>范围。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Scoped-Beans-as-Dependencies"><a href="#Scoped-Beans-as-Dependencies" class="headerlink" title="Scoped Beans as Dependencies"></a>Scoped Beans as Dependencies</h5><p>Spring IoC 容器不仅管理 objects(beans)的实例化，还管理协作者(或依赖项)的连接。如果要将 HTTP request-scoped bean 注入(对于 example)到 longer-lived 范围的另一个 bean，您可以选择 inject AOP 代理来代替作用域 bean。也就是说，您需要 inject 一个代理 object，它暴露与作用域 object 相同的公共接口，但也可以从相关范围(例如 HTTP 请求)中检索真实目标 object，并将方法 calls 委托给真实的 object。</p>
<blockquote>
<p>您也可以在作为<code>singleton</code>的 beans 之间使用<code>&lt;aop:scoped-proxy/&gt;</code>，然后 reference 将通过可序列化的中间代理，因此能够在反序列化时 re-obtain 目标 singleton bean。</p>
</blockquote>
<p>当针对范围<code>prototype</code>的 bean 声明<code>&lt;aop:scoped-proxy/&gt;</code>时，共享代理上的每个方法调用都会导致创建一个新的目标实例，然后将该呼叫转发到该目标实例。</p>
<p>此外，范围代理不是以 lifecycle-safe 方式从较短范围访问 beans 的唯一方法。您还可以将注入点(即构造函数或 setter 参数或自动装配字段)声明为<code>ObjectFactory&lt;MyTargetBean&gt;</code>，允许<code>getObject()</code>调用在每次需要时按需检索当前实例 - 无需保留实例或存储它分别。</p>
<p>作为扩展变体，您可以声明<code>ObjectProvider&lt;MyTargetBean&gt;</code>，它提供了几个额外的访问变体，包括<code>getIfAvailable</code>和<code>getIfUnique</code>。</p>
<p>这个的 JSR-330 变体称为<code>Provider</code>，并且每次检索尝试都会使用<code>Provider&lt;MyTargetBean&gt;</code>声明和相应的<code>get()</code>调用。有关 JSR-330 整体的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-method-injection">这里</a>。</p>
<p>以下 example 中的 configuration 只有一个 line，但了解“为什么”以及它背后的“如何”非常重要：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- instructs the container to proxy the surrounding bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span> (1)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.something.SimpleUserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- a reference to the proxied userPreferences bean --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userPreferences&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>定义代理的 line。</td>
</tr>
</tbody></table>
<p>要创建这样的代理，请将 child <code>&lt;aop:scoped-proxy/&gt;</code>元素插入到作用域 bean 定义中(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-standard-annotations">选择要创建的代理类型</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection-proxies">XML Schema-based configuration</a>)。为什么在<code>request</code>，<code>session</code>和 custom-scope 级别定义 beans 的定义需要<code>&lt;aop:scoped-proxy/&gt;</code>元素？考虑以下 singleton bean 定义，并将其与您需要为上述范围定义的内容进行对比(请注意，以下<code>userPreferences</code> bean 定义不完整)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.something.UserPreferences&quot; scope&#x3D;&quot;session&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userManager&quot; class&#x3D;&quot;com.something.UserManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userPreferences&quot; ref&#x3D;&quot;userPreferences&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>在前面的 example 中，singleton bean(<code>userManager</code>)注入一个 reference 到 HTTP <code>Session</code> -scoped bean(<code>userPreferences</code>)。这里的重点是<code>userManager</code> bean 是 singleton：它每个容器只实例化一次，它的依赖项(在这种情况下只有一个，<code>userPreferences</code> bean)也只注入一次。这意味着<code>userManager</code> bean 仅在完全相同的<code>userPreferences</code> object(即最初注入它的那个)上运行。</p>
<p>这不是将 shorter-lived 作用域 bean 注入 longer-lived 作用域 bean 时所需的行为(对于 example，将-scoped 协作 bean 作为依赖项注入 singleton bean)。相反，您需要一个<code>userManager</code> object，并且，对于 HTTP <code>Session</code>的生命周期，您需要一个特定于 HTTP <code>Session</code>的<code>userPreferences</code> object。因此，容器创建一个 object，它公开与<code>UserPreferences</code> class 完全相同的公共接口(理想情况下是一个<code>UserPreferences</code>实例的 object)，它可以从作用域机制中获取真正的<code>UserPreferences</code> object(HTTP 请求，<code>Session</code>等) 。容器将此代理 object 注入<code>userManager</code> bean，它不知道此<code>UserPreferences</code> reference 是代理。在此 example 中，当<code>UserManager</code>实例在 dependency-injected <code>UserPreferences</code> object 上调用方法时，它实际上是在代理上调用方法。然后代理从(在这种情况下)HTTP <code>Session</code>中获取真实<code>UserPreferences</code> object，并将方法调用委托给检索到的真实<code>UserPreferences</code> object。</p>
<p>因此，在将<code>request-</code>和<code>session-scoped</code> beans 注入协作 objects 时，需要以下(正确和完整)configuration，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.something.UserPreferences&quot; scope&#x3D;&quot;session&quot;&gt;</span><br><span class="line">    &lt;aop:scoped-proxy&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userManager&quot; class&#x3D;&quot;com.something.UserManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userPreferences&quot; ref&#x3D;&quot;userPreferences&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<h6 id="选择要创建的代理类型"><a href="#选择要创建的代理类型" class="headerlink" title="选择要创建的代理类型"></a>选择要创建的代理类型</h6><p>默认情况下，当 Spring 容器为使用<code>&lt;aop:scoped-proxy/&gt;</code>元素标记的 bean 创建代理时，会创建 CGLIB-based class 代理。</p>
<blockquote>
<p>CGLIB 代理只拦截公共方法 calls！不要在这样的代理上调用 non-public 方法。它们不会委托给实际作用域的目标 object。</p>
</blockquote>
<p>或者，您可以通过为<code>&lt;aop:scoped-proxy/&gt;</code>元素的<code>proxy-target-class</code>属性的 value 指定<code>false</code>来配置 Spring 容器以为此类作用域 beans 创建标准 JDK interface-based 代理。使用 JDK interface-based 代理意味着您不需要 application classpath 中的其他 libraries 来影响此类代理。但是，它还意味着作用域 bean 的 class 必须至少实现一个接口，并且注入了作用域 bean 的所有协作者必须通过其中一个接口引用 bean。以下 example 显示了基于接口的代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userPreferences&quot; class&#x3D;&quot;com.stuff.DefaultUserPreferences&quot; scope&#x3D;&quot;session&quot;&gt;</span><br><span class="line">    &lt;aop:scoped-proxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userManager&quot; class&#x3D;&quot;com.stuff.UserManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userPreferences&quot; ref&#x3D;&quot;userPreferences&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>

<p>有关选择 class-based 或 interface-based 代理的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas">代理机制</a>。</p>
<h4 id="自定义范围"><a href="#自定义范围" class="headerlink" title="自定义范围"></a>自定义范围</h4><p>bean 作用域机制是可扩展的。您可以定义自己的范围，甚至可以重新定义现有范围，但后者被认为是不好的做法，您无法覆盖 built-in <code>singleton</code>和<code>prototype</code>范围。</p>
<h5 id="创建自定义范围"><a href="#创建自定义范围" class="headerlink" title="创建自定义范围"></a>创建自定义范围</h5><p>要将自定义作用域集成到 Spring 容器中，需要实现<code>org.springframework.beans.factory.config.Scope</code>接口，本节将对此进行介绍。有关如何实现自己的范围的 idea，请参阅 Spring Framework 本身和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html">范围</a> javadoc 提供的<code>Scope</code> implementations，它们解释了您需要更详细地实现的方法。</p>
<p><code>Scope</code>接口有四种方法可以从作用域中获取 objects，将它们从作用域中删除，然后将它们销毁。</p>
<p>session 范围 implementation，对于 example，返回 session-scoped bean(如果它不存在，则该方法在将__ssion 绑定到 session 以用于将来 reference 之后返回 bean 的新实例)。以下方法从基础范围返回 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object get(String name, ObjectFactory objectFactory)</span><br></pre></td></tr></table></figure>

<p>session 范围 implementation，对于 example，从基础 session 中删除 session-scoped bean。应返回 object，但如果找不到具有指定 name 的 object，则可以 return null。以下方法从基础范围中删除 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object remove(String name)</span><br></pre></td></tr></table></figure>

<p>以下方法记录范围在销毁时或范围中指定的 object 被销毁时应执行的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void registerDestructionCallback(String name, Runnable destructionCallback)</span><br></pre></td></tr></table></figure>

<p>有关销毁回调的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/Scope.html#aop-proxying">javadoc</a>或 Spring 范围 implementation。</p>
<p>以下方法获取基础范围的对话标识符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String getConversationId()</span><br></pre></td></tr></table></figure>

<p>每个范围的标识符都不同。对于 session 范围的 implementation，此标识符可以是 session 标识符。</p>
<h5 id="使用自定义范围"><a href="#使用自定义范围" class="headerlink" title="使用自定义范围"></a>使用自定义范围</h5><p>在编写并测试一个或多个自定义<code>Scope</code> __mplement 之后，您需要让 Spring 容器知道您的新范围。以下方法是使用 Spring 容器注册新<code>Scope</code>的核心方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void registerScope(String scopeName, Scope scope);</span><br></pre></td></tr></table></figure>

<p>此方法在<code>ConfigurableBeanFactory</code>接口上声明，在 Spring 附带的大多数具体<code>ApplicationContext</code> implementations 上可通过<code>BeanFactory</code> property 获得。</p>
<p><code>registerScope(..)</code>方法的第一个参数是与范围关联的唯一 name。 Spring 容器本身中此类名称的示例是<code>singleton</code>和<code>prototype</code>。 <code>registerScope(..)</code>方法的第二个参数是您希望注册和使用的自定义<code>Scope</code> implementation 的实际实例。</p>
<p>假设您编写自定义<code>Scope</code> implementation，然后按照下一个 example 中的说明进行注册。</p>
<blockquote>
<p>下一个 example 使用<code>SimpleThreadScope</code>，它包含在 Spring 中，但默认情况下未注册。对于您自己的自定义<code>Scope</code> __mplement，说明将是相同的。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Scope threadScope &#x3D; new SimpleThreadScope();</span><br><span class="line">beanFactory.registerScope(&quot;thread&quot;, threadScope);</span><br></pre></td></tr></table></figure>

<p>然后，您可以创建符合自定义<code>Scope</code>的作用域规则的 bean 定义，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;...&quot; class&#x3D;&quot;...&quot; scope&#x3D;&quot;thread&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>使用自定义<code>Scope</code> implementation，您不仅限于范围的编程注册。您还可以使用<code>CustomScopeConfigurer</code> class 以声明方式执行<code>Scope</code>注册，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;scopes&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;thread&quot;&gt;</span><br><span class="line">                    &lt;bean class&#x3D;&quot;org.springframework.context.support.SimpleThreadScope&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;thing2&quot; class&#x3D;&quot;x.y.Thing2&quot; scope&#x3D;&quot;thread&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Rick&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:scoped-proxy&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;thing1&quot; class&#x3D;&quot;x.y.Thing1&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;thing2&quot; ref&#x3D;&quot;thing2&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当<code>&lt;aop:scoped-proxy/&gt;</code>放在<code>FactoryBean</code> implementation 中时，工厂 bean 本身是作用域的，而不是从<code>getObject()</code>返回的 object。</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/19/%E5%AD%A6%E4%B9%A0%E6%B8%85%E5%8D%951/" rel="prev" title="学习清单1">
      <i class="fa fa-chevron-left"></i> 学习清单1
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Framework-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Spring Framework 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E2%80%9CSpring%E2%80%9D-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">1. “Spring” 的含义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">核心技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">IOC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8Dspring-ioc%E5%AE%B9%E5%99%A8%E5%92%8CBeans"><span class="nav-number">2.1.1.</span> <span class="nav-text">介绍spring ioc容器和Beans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Configuration-%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">Configuration 元数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">实例化容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%92%B0%E5%86%99%E5%9F%BA%E4%BA%8E-XML-%E9%85%8D%E7%BD%AE%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.2.2.1.</span> <span class="nav-text">撰写基于 XML 配置的元数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Groovy-Bean-%E5%AE%9A%E4%B9%89-DSL"><span class="nav-number">2.1.2.2.2.</span> <span class="nav-text">Groovy Bean 定义 DSL</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">使用容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.3.</span> <span class="nav-text">Bean 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D-Beans"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">命名 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8-Bean-%E5%AE%9A%E4%B9%89%E4%B9%8B%E5%A4%96%E5%88%AB%E5%90%8D-Bean"><span class="nav-number">2.1.3.1.1.</span> <span class="nav-text">在 Bean 定义之外别名 Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-Beans"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">实例化 Beans</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.1.3.2.1.</span> <span class="nav-text">使用构造函数实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.1.3.2.2.</span> <span class="nav-text">使用静态工厂方法实例化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">2.1.3.2.3.</span> <span class="nav-text">使用实例工厂方法实例化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96"><span class="nav-number">2.1.4.</span> <span class="nav-text">依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructor-based-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.1.1.</span> <span class="nav-text">Constructor-based 依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">2.1.4.1.1.1.</span> <span class="nav-text">构造函数参数解析</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Setter-based-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.1.2.</span> <span class="nav-text">Setter-based 依赖注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%80%A7%E8%A7%A3%E5%86%B3-Process"><span class="nav-number">2.1.4.1.3.</span> <span class="nav-text">依赖性解决 Process</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.4.1.4.</span> <span class="nav-text">依赖注入的示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF%E4%B8%AD%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E5%92%8C-Configuration"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">详细信息中的依赖关系和 Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E7%BA%BF%E5%80%BC-Primitives%EF%BC%8CStrings-%E7%AD%89"><span class="nav-number">2.1.4.2.1.</span> <span class="nav-text">直线值(Primitives，Strings 等)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#idref-%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.4.2.1.1.</span> <span class="nav-text">idref 元素</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#References-to-Other-Beans-Collaborators"><span class="nav-number">2.1.4.2.2.</span> <span class="nav-text">References to Other Beans(Collaborators)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8-Beans"><span class="nav-number">2.1.4.2.3.</span> <span class="nav-text">内部 Beans</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B6%E8%97%8F"><span class="nav-number">2.1.4.2.4.</span> <span class="nav-text">收藏</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%90%88%E5%B9%B6"><span class="nav-number">2.1.4.2.4.1.</span> <span class="nav-text">收集合并</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%B6%E9%9B%86%E5%90%88%E5%B9%B6%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">2.1.4.2.4.2.</span> <span class="nav-text">收集合并的限制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Strongly-typed-%E9%9B%86%E5%90%88"><span class="nav-number">2.1.4.2.4.3.</span> <span class="nav-text">Strongly-typed 集合</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Null-%E5%92%8C-Empty-String-%E5%80%BC"><span class="nav-number">2.1.4.2.5.</span> <span class="nav-text">Null 和 Empty String 值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6-p-namespace-%E7%9A%84-XML-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.4.2.6.</span> <span class="nav-text">带 p-namespace 的 XML 快捷方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A6-c-namespace-%E7%9A%84-XML-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F"><span class="nav-number">2.1.4.2.7.</span> <span class="nav-text">带 c-namespace 的 XML 快捷方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%96%E5%90%88%E7%89%A9%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0"><span class="nav-number">2.1.4.2.8.</span> <span class="nav-text">化合物属性名称</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-depends-on"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">使用 depends-on</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lazy-initialized-Beans"><span class="nav-number">2.1.4.4.</span> <span class="nav-text">Lazy-initialized Beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8D%8F%E4%BD%9C%E8%80%85"><span class="nav-number">2.1.4.5.</span> <span class="nav-text">自动化协作者</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.4.5.1.</span> <span class="nav-text">自动装配的限制和缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%AD%E6%8E%92%E9%99%A4-Bean"><span class="nav-number">2.1.4.5.2.</span> <span class="nav-text">从自动装配中排除 Bean</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.6.</span> <span class="nav-text">方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">2.1.4.6.1.</span> <span class="nav-text">查找方法注入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.1.4.6.2.</span> <span class="nav-text">任意方法替换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean-%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.</span> <span class="nav-text">Bean 范围</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Singleton-%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">Singleton 范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">原型范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Singleton-Beans-with-Prototype-bean-Dependencies"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">Singleton Beans with Prototype-bean Dependencies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Request%EF%BC%8CSession%EF%BC%8CApplication-%E5%92%8C-WebSocket-Scopes"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">Request，Session，Application 和 WebSocket Scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B-Web-Configuration"><span class="nav-number">2.1.5.4.1.</span> <span class="nav-text">初始 Web Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.4.2.</span> <span class="nav-text">请求范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session-%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.4.3.</span> <span class="nav-text">Session 范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Application-Scope"><span class="nav-number">2.1.5.4.4.</span> <span class="nav-text">Application Scope</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scoped-Beans-as-Dependencies"><span class="nav-number">2.1.5.4.5.</span> <span class="nav-text">Scoped Beans as Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E8%A6%81%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.5.4.5.1.</span> <span class="nav-text">选择要创建的代理类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.5.</span> <span class="nav-text">自定义范围</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.5.1.</span> <span class="nav-text">创建自定义范围</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-number">2.1.5.5.2.</span> <span class="nav-text">使用自定义范围</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"2VnxHgjEtfnE32vEU7kSwp7u-gzGzoHsz","app_key":"C31JOMiTW1vAVoeT7ece3Gts","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/24/Spring-Framework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/";
    this.page.identifier = "2020/08/24/Spring-Framework官方文档翻译/";
    this.page.title = "Spring Framework官方文档翻译";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
