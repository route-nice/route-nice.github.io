<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="数据访问事务管理对于事务的全面支持是使用 Spring Framework 的最主要原因之一。Spring Framework 为事务管理提供了统一的抽象，这带来了如下好处：  跨越不同 transaction API 的一致编程模型，例如 Java Transaction API(JTA)，JDBC，Hibernate 和 Java Persistence API(JPA)。 对声明式事务管理的">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-数据访问">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="数据访问事务管理对于事务的全面支持是使用 Spring Framework 的最主要原因之一。Spring Framework 为事务管理提供了统一的抽象，这带来了如下好处：  跨越不同 transaction API 的一致编程模型，例如 Java Transaction API(JTA)，JDBC，Hibernate 和 Java Persistence API(JPA)。 对声明式事务管理的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx_prop_required.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx_prop_requires_new.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/DataAccessException.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/oxm-exceptions.jpg">
<meta property="article:published_time" content="2020-08-25T00:30:19.000Z">
<meta property="article:modified_time" content="2020-09-11T07:11:42.676Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-数据访问 | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-数据访问
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 08:30:19" itemprop="dateCreated datePublished" datetime="2020-08-25T08:30:19+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-11 15:11:42" itemprop="dateModified" datetime="2020-09-11T15:11:42+08:00">2020-09-11</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-数据访问/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h1><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p>对于事务的全面支持是使用 Spring Framework 的最主要原因之一。Spring Framework 为事务管理提供了统一的抽象，这带来了如下好处：</p>
<ul>
<li>跨越不同 transaction API 的一致编程模型，例如 Java Transaction API(JTA)，JDBC，Hibernate 和 Java Persistence API(JPA)。</li>
<li>对<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative">声明式事务管理</a>的支持。</li>
<li>一种相比于复杂事务API（例如JTA）要更简单的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-programmatic">编程式</a>事务管理。</li>
<li>与 Spring 的数据访问抽象的完美整合。</li>
</ul>
<p>以下部分描述了 Spring Framework 的事务特性和术语：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-motivation">Spring Framework 的 transaction 支持 model 的优点</a>描述了为什么要使用 Spring Framework 的 transaction 抽象而不是 EJB Container-Managed Transactions(CMT)或选择通过专有 API 驱动本地 transactions，例如 Hibernate。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-strategies">理解 Spring Framework transaction 抽象</a>概述了核心 classes，并介绍了如何从各种来源配置和获取<code>DataSource</code>实例。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-resource-synchronization">使用 transactions 同步资源</a>描述了 application code 如何确保正确创建，重用和清理资源。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative">声明式 transaction management</a>描述了对声明性 transaction management 的支持。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-programmatic">程序化 transaction management</a>涵盖对程序化(即明确编码)transaction management 的支持。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-event">Transaction bound event</a>描述了如何在 transaction 中使用 application events。</li>
</ul>
<p>(该章还包括对最佳实践的讨论，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-application-server-integration">application server integration</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-solutions-to-common-problems">常见问题的解决方案</a> .)</p>
<a id="more"></a>
<h3 id="SpringFramework事务模型的优点"><a href="#SpringFramework事务模型的优点" class="headerlink" title="SpringFramework事务模型的优点"></a>SpringFramework事务模型的优点</h3><p>传统上，Java EE 开发人员对 transaction management 有两种选择：global 或 local transactions，这两种选择都有很大的局限性。 Global 和 local transaction management 将在接下来的两节中进行回顾，然后讨论 Spring Framework 的 transaction management 支持如何解决 global 和 local transaction 模型的局限性。</p>
<h4 id="全局事务"><a href="#全局事务" class="headerlink" title="全局事务"></a>全局事务</h4><p>Global transactions 允许您使用多个 transactional 资源，通常是关系数据库和消息队列。 application 服务器通过 JTA 管理 global transactions，这是一个繁琐的 API(部分原因是它的 exception model)。此外，JTA <code>UserTransaction</code>通常需要从 JNDI 获取，这意味着您还需要在 order 中使用 JNDI 来使用 JTA。 global transactions 的使用限制了 application code 的任何潜在重用，因为 JTA 通常仅在 application 服务器环境中可用。</p>
<p>以前，使用 global transactions 的首选方法是通过 EJB CMT(Container Managed Transaction)。 CMT 是声明性 transaction management 的一种形式(与程序性 transaction management 不同)。 EJB CMT 消除了对 transaction-related JNDI 查找的需要，尽管使用 EJB 本身需要使用 JNDI。它删除了大多数但不是全部需要编写 Java code 来控制 transactions。显着的缺点是 CMT 与 JTA 和应用程序服务器环境相关联。此外，只有在选择在 EJB 中实现业务逻辑(或至少在 transactional EJB 外观后面)时，它才可用。一般来说，EJB 的负面影响是如此之大，以至于这不是一个有吸引力的主张，特别是在面对声明性交易管理的令人信服的替代方案时。</p>
<h4 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h4><p>本地事务与资源挂钩，例如与 JDBC 关联的事务。本地事务可能更容易使用但有一个显著的缺点：不能跨多个事务资源。例如使用 JDBC 连接管理事务的代码不能在 JTA 事务中运行。对于 example，使用 JDBC 连接管理 transactions 的 code 不能在 global JTA transaction 中运行。由于 application 服务器不参与 transaction management，因此无法确保跨多个资源的正确性。 (值得注意的是，大多数 applications 使用单个 transaction resource.)另一个缺点是本地 transactions 对编程 model 是侵入性的。</p>
<h4 id="SpringFramework的一致编程模型"><a href="#SpringFramework的一致编程模型" class="headerlink" title="SpringFramework的一致编程模型"></a>SpringFramework的一致编程模型</h4><p>Spring 解决了全局和本地事务的缺点。应用开发者能在任何环境中使用一致的编程模型。只需要编写一次代码，就能适用于不同环境中的各种事务管理策略。Spring Framework 同时提供了声明式和编程式的事务管理。大多是用户更喜欢声明式事务管理，这也是在大多数情况下我们推荐使用的。 通过程序化的 transaction management，开发人员可以使用 Spring Framework transaction 抽象，它可以运行任何底层的 transaction 基础架构。使用首选的声明性 model，开发人员通常只编写与 transaction management 相关的很少或没有 code，因此，不依赖于 Spring Framework transaction API 或任何其他 transaction API。</p>
<blockquote>
<p>transaction management 是否需要 application 服务器？</p>
<p>Spring Framework 的 transaction management 支持改变了传统规则，即企业 Java application 何时需要 application 服务器。</p>
<p>特别是，您不需要纯粹用于通过 EJB 的声明性 transactions 的 application 服务器。实际上，即使您的 application 服务器具有强大的 JTA 功能，您也可以认为 Spring Framework 的声明性 transactions 提供了比 EJB CMT 更强大的功能和更高效的编程 model。</p>
<p>通常，只有当 application 需要跨多个资源处理 transactions 时才需要 application 服务器的 JTA 功能，这对于许多 applications 来说并不是必需的。许多 high-end applications 使用单个高度可伸缩的数据库(例如 Oracle RAC)。 Stand-alone transaction managers(例如<a target="_blank" rel="noopener" href="http://www.atomikos.com/">Atomikos Transactions</a>和<a target="_blank" rel="noopener" href="http://jotm.objectweb.org/">JOTM</a>)是其他选项。当然，您可能需要其他 application Server 功能，例如 Java Message Service(JMS)和 Java EE Connector Architecture(JCA)。</p>
<p>Spring Framework 让您可以选择何时将 application 扩展为完全加载的 application 服务器。使用 EJB CMT 或 JTA 的唯一替代方法是使用本地 transactions(例如 JDBC 连接上的那些)编写 code，并且如果在 global，container-managed transactions 中需要 code 到 run，则会面临大量的返工。使用 Spring Framework，只需要更改 configuration 文件中的某些 bean 定义(而不是您的 code)。</p>
</blockquote>
<h3 id="理解SpringFramework事务抽象"><a href="#理解SpringFramework事务抽象" class="headerlink" title="理解SpringFramework事务抽象"></a>理解SpringFramework事务抽象</h3><p>Spring 事务抽象的关键在于事务策略的概念。<code>org.springframework.transaction.PlatformTransactionManager</code>定义了事务策略，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface PlatformTransactionManager &#123;</span><br><span class="line"></span><br><span class="line">    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void commit(TransactionStatus status) throws TransactionException;</span><br><span class="line"></span><br><span class="line">    void rollback(TransactionStatus status) throws TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管可以在应用代码中以<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-programmatic-ptm">编程方式</a>使用它，但它主要是服务提供者接口（SPI）。因为<code>PlatformTransactionManager</code>是一个接口，所以可以根据需要轻松地模拟或存根。它与查找策略无关，例如 JNDI。 <code>PlatformTransactionManager</code> implementations 的定义与 Spring Framework IoC 容器中的任何其他 object(或 bean)相同。即使你使用 JTA，只有这个好处使 Spring Framework transactions 成为一个有价值的抽象。与直接使用 JTA 相比，您可以更轻松地测试 transactional code。</p>
<p>同样，为了与 Spring 的哲学保持一致，<code>PlatformTransactionManager</code>接口的所有方法都能抛出的<code>TransactionException</code>是非受检异常（也就是说它继承<code>java.lang.RuntimeException</code>）。事务基础设施故障几乎总是很严重的，只有极少数情况应用代码可以真正从事务失败中恢复，但应用开发者也可选择捕获并处理异常。。重点是开发人员不会被迫这样做。</p>
<p><code>getTransaction(..)</code>方法根据<code>TransactionDefinition</code>参数返回<code>TransactionStatus</code>对象。如果当前调用栈中有匹配的事务，则返回的<code>TransactionStatus</code>代表已存在的事务，否则代表新的事务。后一种情况的含义是，与 Java EE transaction 上下文一样，<code>TransactionStatus</code>与执行线程相关联。</p>
<p><code>TransactionDefinition</code>接口指定：</p>
<ul>
<li>传播：通常，transaction 范围内执行的所有 code 都在 transaction 中运行。但是，如果 transaction context 已存在，则执行 transactional 方法时，可以指定行为。例如，运行在已经存在的事务中（这是通常情况），或暂停已存在的事务并创建新事务。 Spring 提供 EJB CMT 中熟悉的所有 transaction 传播选项。要阅读 Spring 中 transaction 传播的语义，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-propagation">Transaction 传播</a>。</li>
<li>隔离：此 transaction 与其他 transactions 的工作隔离的程度。对于 example，这个 transaction 可以看到来自其他 transactions 的未提交的写入吗？</li>
<li>超时：transaction 如何在超时之前运行并由底层 transaction 基础架构自动回滚。</li>
<li>Read-only status：当只需要读不需要写时，可以使用只读事务。只读事务可在某些场景中用于优化，例如使用 Hibernate 时。</li>
</ul>
<p>这些设置反映了标准的 transactional 概念。如有必要，请参阅讨论 transaction 隔离级别和其他核心 transaction 概念的资源。理解这些概念对于使用 Spring Framework 或任何 transaction management 解决方案至关重要。</p>
<p><code>TransactionStatus</code>接口为编写事务代码以控制事务执行和查询事务状态提供了一种更简单的方式。这些概念应该不陌生，因为它们对于所有的事务 API 来说都是常见的。以下清单显示了<code>TransactionStatus</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager &#123;</span><br><span class="line"></span><br><span class="line">    boolean isNewTransaction();</span><br><span class="line"></span><br><span class="line">    boolean hasSavepoint();</span><br><span class="line"></span><br><span class="line">    void setRollbackOnly();</span><br><span class="line"></span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line"></span><br><span class="line">    void flush();</span><br><span class="line"></span><br><span class="line">    boolean isCompleted();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是选择声明式还是编程式事务管理，定义正确的<code>PlatformTransactionManager</code>都是绝对必要的。通常通过依赖注入定义其实现。</p>
<p><code>PlatformTransactionManager</code> implementations 通常需要了解它们工作的环境：JDBC，JTA，Hibernate 等。以下示例显示如何定义本地<code>PlatformTransactionManager</code> implementation(在本例中，使用 plain JDBC.)</p>
<p>您可以通过 creating bean 来定义 JDBC <code>DataSource</code>，类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot; &#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>然后，相关的<code>PlatformTransactionManager</code> bean 定义具有<code>DataSource</code>定义的 reference。它应该类似于以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>如果在 Java EE 容器中使用 JTA，则使用通过 JNDI 获得的容器<code>DataSource</code>和 Spring 的<code>JtaTransactionManager</code>。以下 example 显示了 JTA 和 JNDI 查找 version 的外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&#x2F;spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jee:jndi-lookup id&#x3D;&quot;dataSource&quot; jndi-name&#x3D;&quot;jdbc&#x2F;jpetstore&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean&#x2F;&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><code>JtaTransactionManager</code>不需要知道<code>DataSource</code>(或任何其他特定资源)，因为它使用容器的 global transaction management 基础结构。</p>
<blockquote>
<p>前面的<code>dataSource</code> bean 定义使用<code>jee</code>命名空间中的<code>&lt;jndi-lookup/&gt;</code>标记。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#xsd-schemas-jee">JEE Schema</a>。</p>
</blockquote>
<p>您还可以轻松使用 Hibernate local transactions，如以下示例所示。在这种情况下，您需要定义 Hibernate <code>LocalSessionFactoryBean</code>，application code 可以使用它来获取 Hibernate <code>Session</code>实例。</p>
<p><code>DataSource</code> bean 定义类似于前面显示的本地 JDBC example，因此，未在以下 example 中显示。</p>
<blockquote>
<p>如果<code>DataSource</code>(由任何 non-JTA transaction manager 使用)通过 JNDI 查找并由 Java EE 容器管理，它应该是 non-transactional，因为 Spring Framework(而不是 Java EE 容器)管理 transactions。</p>
</blockquote>
<p>在这种情况下，<code>txManager</code> bean 是<code>HibernateTransactionManager</code>类型。与<code>DataSourceTransactionManager</code>需要的<code>DataSource</code>相同，<code>HibernateTransactionManager</code>需要的 reference。以下 example 声明<code>sessionFactory</code>和<code>txManager</code> beans：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sessionFactory&quot; class&#x3D;&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mappingResources&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org&#x2F;springframework&#x2F;samples&#x2F;petclinic&#x2F;hibernate&#x2F;petclinic.hbm.xml&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;hibernateProperties&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            hibernate.dialect&#x3D;$&#123;hibernate.dialect&#125;</span><br><span class="line">        &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>如果使用 Hibernate 和 Java EE container-managed JTA transactions，则应使用与之前的 JTA example 相同的<code>JtaTransactionManager</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果使用 JTA，无论使用何种数据访问技术，无论是 JDBC，Hibernate JPA 还是任何其他支持的技术，transaction manager 定义应该看起来都一样。这是因为 JTA transactions 是 global transactions，它可以登记任何 transactional 资源。</p>
</blockquote>
<p>在所有这些情况下，application code 不需要更改。您可以仅通过更改 configuration 来更改 transactions 的管理方式，即使该更改意味着从本地移动到 global transactions，反之亦然。</p>
<h3 id="使用Transactions同步资源"><a href="#使用Transactions同步资源" class="headerlink" title="使用Transactions同步资源"></a>使用Transactions同步资源</h3><p>如何创建不同的 transaction managers 以及它们如何链接到需要同步到 transactions 的相关资源(对于 example <code>DataSourceTransactionManager</code>到 JDBC <code>DataSource</code>，<code>HibernateTransactionManager</code>到 Hibernate <code>SessionFactory</code>等等)现在应该是清楚的。本节描述了 application code(直接或间接使用诸如 JDBC，Hibernate 或 JPA 之类的持久性 API)如何确保正确创建，重用和清理这些资源。本节还讨论了如何通过相关的<code>PlatformTransactionManager</code>触发 transaction 同步(可选)。</p>
<h4 id="High-level同步方法"><a href="#High-level同步方法" class="headerlink" title="High-level同步方法"></a>High-level同步方法</h4><p>首选方法是使用基于 Spring 的 highest-level 模板的持久性 integration API，或者使用带有 transaction-aware factory beans 或代理的本机 ORM API 来管理本机资源工厂。这些 transaction-aware 解决方案在内部处理资源创建和重用，清理，资源的可选 transaction 同步和 exception 映射。因此，用户数据访问 code 不必解决这些任务，但可以完全专注于 non-boilerplate 持久性逻辑。通常，您使用本机 ORM API 或使用模板方法使用<code>JdbcTemplate</code>进行 JDBC 访问。这些解决方案将在本参考文档的后续章节中详细介绍。</p>
<h4 id="Low-level同步方法"><a href="#Low-level同步方法" class="headerlink" title="Low-level同步方法"></a>Low-level同步方法</h4><p>(用于 JDBC)，<code>EntityManagerFactoryUtils</code>(用于 JPA)，<code>SessionFactoryUtils</code>(用于 Hibernate)等类存在于较低的 level 中。如果希望 application code 直接处理本机持久性 API 的资源类型，可以使用这些 classes 来确保获得正确的 Spring Framework-managed 实例，transactions(可选)同步，并且 process 中出现的 exceptions 正确映射一致的 API。</p>
<p>例如，对于 JDBC，不是传统的 JDBC 方法在<code>DataSource</code>上调用<code>getConnection()</code>方法，而是使用 Spring 的<code>org.springframework.jdbc.datasource.DataSourceUtils</code> class，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn &#x3D; DataSourceUtils.getConnection(dataSource);</span><br></pre></td></tr></table></figure>
<p>如果现有 transaction 已经与其同步(链接)了连接，则返回该实例。否则，方法调用会触发创建新连接，该连接(可选)与任何现有的 transaction 同步，并可在后续的同一 transaction 中重用。如前所述，任何<code>SQLException</code>都包含在 Spring Framework <code>CannotGetJdbcConnectionException</code>中，这是 Spring Framework 的未经检查的<code>DataAccessException</code>类型的层次结构之一。这种方法为您提供了比从<code>SQLException</code>轻松获得的更多信息，并确保跨数据库甚至跨不同持久性技术的可移植性。</p>
<p>这种方法也可以在没有 Spring transaction management(transaction 同步是可选的)的情况下工作，因此无论是否使用 Spring 进行 transaction management 都可以使用它。</p>
<p>当然，一旦你使用了 Spring 的 JDBC 支持，JPA 支持或 Hibernate 支持，你通常不喜欢使用<code>DataSourceUtils</code>或其他帮助 classes，因为你通过 Spring 抽象而不是直接使用相关 API 更快乐。例如，如果您使用 Spring <code>JdbcTemplate</code>或<code>jdbc.object</code>包来简化 JDBC 的使用，则在幕后进行正确的连接检索，您无需编写任何特殊的 code。</p>
<h4 id="类TransactionAwareDataSourceProxy"><a href="#类TransactionAwareDataSourceProxy" class="headerlink" title="类TransactionAwareDataSourceProxy"></a>类TransactionAwareDataSourceProxy</h4><p>在最低 level 存在<code>TransactionAwareDataSourceProxy</code> class。这是目标<code>DataSource</code>的代理，它包装目标<code>DataSource</code>以添加 Spring-managed transactions 的意识。在这方面，它类似于 Java EE 服务器提供的 transactional JNDI <code>DataSource</code>。</p>
<p>您几乎从不需要或不想使用此 class，除非必须调用现有的 code 并传递标准的 JDBC <code>DataSource</code>接口 implementation。在这种情况下，此 code 可能可用但参与 Spring-managed transactions。您可以使用前面提到的 higher-level 抽象编写新的 code。</p>
<h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><blockquote>
<p>大多数 Spring Framework 用户选择声明式 transaction management。此选项对 application code 的影响最小，因此与 non-invasive 轻量级容器的理想最为一致。</p>
</blockquote>
<p>使用 Spring aspect-oriented 编程(AOP)可以实现 Spring Framework 的声明式 transaction management。但是，由于 transactional 方面 code 附带 Spring Framework 分布并且可能以样板方式使用，因此通常不必理解 AOP 概念以有效地使用此 code。</p>
<p>Spring Framework 的声明性 transaction management 类似于 EJB CMT，因为您可以将 transaction 行为(或缺少行为)指定为单个方法 level。如有必要，您可以在 transaction context 中进行<code>setRollbackOnly()</code>调用。两种 transaction management 之间的区别是：</p>
<ul>
<li>与绑定到 JTA 的 EJB CMT 不同，Spring Framework 的声明性 transaction management 可以在任何环境中使用。通过调整 configuration files，它可以使用 JDBC，JPA 或 Hibernate 与 JTA transactions 或 local transactions 一起使用。</li>
<li>您可以将 Spring Framework 声明 transaction management 应用于任何 class，而不仅仅是特殊的 classes，例如 EJB。</li>
<li>Spring Framework 提供声明性<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-rolling-back">回滚规则</a>，一个没有 EJB 等效的 feature。提供了对回滚规则的编程和声明性支持。</li>
<li>Spring Framework 允许您使用 AOP 自定义 transactional 行为。对于 example，您可以在 transaction 回滚的情况下插入自定义行为。您还可以添加任意建议以及 transactional 建议。使用 EJB CMT，除了<code>setRollbackOnly()</code>之外，您不能影响容器的 transaction management。</li>
<li>Spring Framework 不支持跨 remote calls 传播 transaction 上下文，就像 high-end application 服务器那样。如果您需要此 feature，我们建议您使用 EJB。但是，在使用这样的 feature 之前要仔细考虑，因为通常情况下，人们不希望 transactions 对 span remote calls。</li>
</ul>
<p>TransactionProxyFactoryBean 在哪里？</p>
<p>Spring 2.0 及以上版本中的声明性 transaction configuration 与以前版本的 Spring 有很大不同。主要区别在于不再需要配置<code>TransactionProxyFactoryBean</code> beans。</p>
<p>pre-Spring 2.0 configuration 样式仍然是 100％有效的 configuration。将新的<code>&lt;tx:tags/&gt;</code>视为为您定义<code>TransactionProxyFactoryBean</code> beans。</p>
<p>回滚规则的概念很重要。它们允许您指定哪些 exceptions(和 throwables)应该导致自动回滚。您可以在 configuration 中以声明方式指定，而不是在 Java code 中。因此，虽然您仍然可以在<code>TransactionStatus</code> object 上调用<code>setRollbackOnly()</code>来回滚当前的 transaction，但大多数情况下您可以指定<code>MyApplicationException</code>必须始终导致回滚的规则。此选项的显着优势是业务 objects 不依赖于 transaction 基础结构。例如，它们通常不需要 import Spring transaction API 或其他 Spring API。</p>
<p>尽管 EJB 容器默认行为会自动回滚系统 exception(通常是运行时 exception)上的 transaction，但 EJB CMT 不会在 application exception(即<code>java.rmi.RemoteException</code>以外的已检查 exception)上自动回滚 transaction。虽然声明性 transaction management 的 Spring 默认行为遵循 EJB 约定(回滚仅在未经检查的 exceptions 上自动回放)，但定制此行为通常很有用。</p>
<h4 id="理解SpringFramework的声明Transaction-Implementation"><a href="#理解SpringFramework的声明Transaction-Implementation" class="headerlink" title="理解SpringFramework的声明Transaction Implementation"></a>理解SpringFramework的声明Transaction Implementation</h4><p>仅仅告诉您使用<code>@Transactional</code> annotation 注释 classes，将<code>@EnableTransactionManagement</code>添加到 configuration 并且希望您了解它是如何工作的还不够。为了更深入地理解，本节解释了#</p>
<p>关于 Spring Framework 的声明性 transaction 支持，要掌握的最重要的概念是，这种支持是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-understanding-aop-proxies">通过 AOP 代理</a>启用的，而 transactional 建议是由元数据驱动的(目前是 XML-或 annotation-based)。 AOP 与 transactional 元数据的组合产生一个 AOP 代理，它使用<code>TransactionInterceptor</code>和适当的<code>PlatformTransactionManager</code> implementation 来驱动方法调用的 transactions。</p>
<blockquote>
<p>Spring AOP 涵盖在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">AOP 部分</a>中。</p>
</blockquote>
<p>以下图像显示了在 transactional 代理上调用方法的概念视图：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx.jpg" alt="TX"></p>
<h4 id="声明式事务实现示例"><a href="#声明式事务实现示例" class="headerlink" title="声明式事务实现示例"></a>声明式事务实现示例</h4><p>考虑以下接口及其伴随 implementation。此 example 使用<code>Foo</code>和<code>Bar</code> classes 作为占位符，以便您可以专注于 transaction 用法，而无需关注特定的域 model。出于本示例的目的，<code>DefaultFooService</code> class 在每个实现的方法的主体中抛出<code>UnsupportedOperationException</code>实例的事实是好的。通过该行为，您可以看到 transactions 被创建，然后回滚以响应<code>UnsupportedOperationException</code>实例。以下清单显示了<code>FooService</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; the service interface that we want to make transactional</span><br><span class="line"></span><br><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public interface FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面接口的 implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package x.y.service;</span><br><span class="line"></span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName, String barName) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        throw new UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设<code>FooService</code>接口的前两个方法<code>getFoo(String)</code>和<code>getFoo(String, String)</code>必须在具有 read-only 语义的 transaction 的 context 中执行，并且其他方法<code>insertFoo(Foo)</code>和<code>updateFoo(Foo)</code>必须在具有 read-write 语义的 transaction 的 context 中执行。以下 configuration 将在接下来的几段中详细解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- from the file &#39;context.xml&#39; --&gt;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the transactional advice (what &#39;happens&#39;; see the &lt;aop:advisor&#x2F;&gt; bean below) --&gt;</span><br><span class="line">    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;!-- the transactional semantics... --&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;!-- all methods starting with &#39;get&#39; are read-only --&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;!-- other methods use the default transaction settings (see below) --&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">    &lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ensure that the above transactional advice runs for any execution</span><br><span class="line">        of an operation defined by the FooService interface --&gt;</span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;fooServiceOperation&quot; expression&#x3D;&quot;execution(* x.y.service.FooService.*(..))&quot;&#x2F;&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;fooServiceOperation&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- don&#39;t forget the DataSource --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;oracle.jdbc.driver.OracleDriver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;scott&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;tiger&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- similarly, don&#39;t forget the PlatformTransactionManager --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean&#x2F;&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>检查前面的 configuration。它假定您要创建服务 object，<code>fooService</code> bean，transactional。要应用的 transaction 语义封装在<code>&lt;tx:advice/&gt;</code>定义中。 <code>&lt;tx:advice/&gt;</code>定义读作“所有方法，从<code>get</code>开始，将在 read-only transaction 的 context 中执行，所有其他方法将使用默认的 transaction 语义执行”。 <code>&lt;tx:advice/&gt;</code>标记的<code>transaction-manager</code>属性设置为<code>PlatformTransactionManager</code> bean 的 name，它将驱动 transactions(在本例中为<code>txManager</code> bean)。</p>
<blockquote>
<p>如果要连接的<code>PlatformTransactionManager</code>的 bean name 具有 name <code>transactionManager</code>，则可以省略 transactional 通知(<code>&lt;tx:advice/&gt;</code>)中的<code>transaction-manager</code>属性。如果要连接的<code>PlatformTransactionManager</code> bean 具有任何其他 name，则必须显式使用<code>transaction-manager</code>属性，如前面的 example 中所示。</p>
</blockquote>
<p><code>&lt;aop:config/&gt;</code>定义确保<code>txAdvice</code> bean 定义的 transactional 通知在程序中的适当位置执行。首先，定义一个切入点，该切入点与<code>FooService</code>接口(<code>fooServiceOperation</code>)中定义的任何操作的执行相匹配。然后使用顾问程序将切入点与<code>txAdvice</code>相关联。结果表明，在执行<code>fooServiceOperation</code>时，<code>txAdvice</code>定义的建议是 run。</p>
<p><code>&lt;aop:pointcut/&gt;</code>元素中定义的表达式是 AspectJ 切入点表达式。有关 Spring 中切入点表达式的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">AOP 部分</a>。</p>
<p>common 要求是创建整个服务层 transactional。执行此操作的最佳方法是将切入点表达式更改为 match 服务层中的任何操作。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id&#x3D;&quot;fooServiceMethods&quot; expression&#x3D;&quot;execution(* x.y.service.*.*(..))&quot;&#x2F;&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;fooServiceMethods&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在前面的示例中，假设所有服务接口都在<code>x.y.service</code>包中定义。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">AOP 部分</a>。</p>
</blockquote>
<p>现在我们已经分析了 configuration，你可能会问自己，“所有这些 configuration 实际上做了什么？”</p>
<p>前面显示的 configuration 用于围绕从<code>fooService</code> bean 定义创建的 object 创建 transactional 代理。代理配置了 transactional 通知，以便在代理上调用适当的方法时，transaction 被启动，挂起，标记为 read-only，依此类推，具体取决于与该方法关联的 transaction configuration。考虑以下测试驱动前面显示的 configuration 的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class Boot &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(final String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(&quot;context.xml&quot;, Boot.class);</span><br><span class="line">        FooService fooService &#x3D; (FooService) ctx.getBean(&quot;fooService&quot;);</span><br><span class="line">        fooService.insertFoo (new Foo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>running 前面程序的输出应类似于以下内容(Log4J 输出和 DefaultFooService class 的 insertFoo(..)方法抛出的 UnsupportedOperationException 中的堆栈跟踪已被截断，以便清楚)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the Spring container is starting up... --&gt;</span><br><span class="line">[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean &#39;fooService&#39; with 0 common interceptors and 1 specific interceptors</span><br><span class="line"></span><br><span class="line">&lt;!-- the DefaultFooService is actually proxied --&gt;</span><br><span class="line">[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]</span><br><span class="line"></span><br><span class="line">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span><br><span class="line">[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo</span><br><span class="line"></span><br><span class="line">&lt;!-- the transactional advice kicks in here... --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]</span><br><span class="line">[DataSourceTransactionManager] - Acquired Connection [[emailprotected]] for JDBC transaction</span><br><span class="line"></span><br><span class="line">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span><br><span class="line">[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException</span><br><span class="line">[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]</span><br><span class="line"></span><br><span class="line">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span><br><span class="line">[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [[emailprotected]]</span><br><span class="line">[DataSourceTransactionManager] - Releasing JDBC Connection after transaction</span><br><span class="line">[DataSourceUtils] - Returning JDBC Connection to DataSource</span><br><span class="line"></span><br><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)</span><br><span class="line">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span><br><span class="line">at $Proxy0.insertFoo(Unknown Source)</span><br><span class="line">at Boot.main(Boot.java:11)</span><br></pre></td></tr></table></figure>
<h4 id="回滚声明式-Transaction"><a href="#回滚声明式-Transaction" class="headerlink" title="回滚声明式 Transaction"></a>回滚声明式 Transaction</h4><p>上一节概述了如何在 application 中以声明方式为 classes(通常是服务层 classes)指定 transactional 设置的基础知识。本节介绍如何以简单的声明方式控制 transactions 的回滚。</p>
<p>向 Spring Framework 的 transaction 基础结构指示 transaction 的工作将被回滚的推荐方法是从当前在 transaction 的 context 中执行的 code 中抛出<code>Exception</code>。 Spring Framework 的 transaction infrastructure code 捕获任何未处理的<code>Exception</code>，因为它会使调用堆栈冒泡并确定是否标记 transaction 以进行回滚。</p>
<p>在默认的 configuration 中，Spring Framework 的 transaction infrastructure code 仅在运行时未经检查的 exceptions 的情况下标记 transaction 以进行回滚。也就是说，抛出的 exception 是<code>RuntimeException</code>的实例或子类。 (默认情况下，<code>Error</code>实例也会导致回滚)。从 transactional 方法抛出的已检查 exceptions 不会导致默认 configuration 中的回滚。</p>
<p>您可以准确配置哪些<code>Exception</code>类型标记 transaction 以进行回滚，包括已检查的 exceptions。以下 XML 代码段演示了如何为已检查的 application-specific <code>Exception</code>类型配置回滚：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;NoProductInStockException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果您不希望在抛出 exception 时回滚 transaction，您还可以指定“no rollback rules”。以下 example 告诉 Spring Framework 的 transaction 基础设施提交服务员 transaction，即使面对未处理的<code>InstrumentNotFoundException</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;updateStock&quot;</span> <span class="attr">no-rollback-for</span>=<span class="string">&quot;InstrumentNotFoundException&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当 Spring Framework 的 transaction 基础结构捕获 exception 并且它查询配置的回滚规则以确定是否标记 transaction 进行回滚时，最强匹配规则获胜。因此，在以下 configuration 的情况下，除了<code>InstrumentNotFoundException</code>之外的任何 exception 都会导致响尾符 transaction 的回滚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id&#x3D;&quot;txAdvice&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">    &lt;tx:method name&#x3D;&quot;*&quot; rollback-for&#x3D;&quot;Throwable&quot; no-rollback-for&#x3D;&quot;InstrumentNotFoundException&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">&lt;&#x2F;tx:advice&gt;</span><br></pre></td></tr></table></figure>
<p>您还可以以编程方式指示所需的回滚。虽然很简单，但这个 process 非常具有侵入性，并且会将 code 紧密地耦合到 Spring Framework 的 transaction 基础架构。以下 example 显示了如何以编程方式指示所需的回滚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void resolvePosition() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; some business logic...</span><br><span class="line">    &#125; catch (NoProductInStockException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; trigger rollback programmatically</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果可能的话，强烈建议您使用声明性方法进行回滚。如果您绝对需要程序化回滚，则可以使用程序化回滚，但它的使用方式可以实现干净的 POJO-based architecture。</p>
<h4 id="为不同的-Beans-配置不同的-Transactional-语义"><a href="#为不同的-Beans-配置不同的-Transactional-语义" class="headerlink" title="为不同的 Beans 配置不同的 Transactional 语义"></a>为不同的 Beans 配置不同的 Transactional 语义</h4><p>考虑具有多个服务层 objects 的场景，并且您希望对它们中的每一个应用完全不同的 transactional configuration。您可以通过定义具有不同<code>pointcut</code>和<code>advice-ref</code>属性值的不同<code>&lt;aop:advisor/&gt;</code>元素来实现。</p>
<p>作为比较，首先假设您的所有服务层 classes 都在根<code>x.y.service</code>包中定义。要使所有 beans 成为在该包(或子包中)中定义的 classes 实例并且名称以<code>Service</code>结尾，并且具有默认的 transactional configuration，您可以编写以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;serviceOperation&quot;</span><br><span class="line">                expression&#x3D;&quot;execution(* x.y.service..*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref&#x3D;&quot;serviceOperation&quot; advice-ref&#x3D;&quot;txAdvice&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- these two beans will be transactional... --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;barService&quot; class&#x3D;&quot;x.y.service.extras.SimpleBarService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... and these two beans won&#39;t --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;anotherService&quot; class&#x3D;&quot;org.xyz.SomeService&quot;&#x2F;&gt; &lt;!-- (not in the right package) --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;barManager&quot; class&#x3D;&quot;x.y.service.SimpleBarManager&quot;&#x2F;&gt; &lt;!-- (doesn&#39;t end in &#39;Service&#39;) --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id&#x3D;&quot;txAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">    &lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用完全不同的 transactional 设置配置两个不同的 beans：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;defaultServiceOperation&quot;</span><br><span class="line">                expression&#x3D;&quot;execution(* x.y.service.*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;noTxServiceOperation&quot;</span><br><span class="line">                expression&#x3D;&quot;execution(* x.y.service.ddl.DefaultDdlManager.*(..))&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref&#x3D;&quot;defaultServiceOperation&quot; advice-ref&#x3D;&quot;defaultTxAdvice&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor pointcut-ref&#x3D;&quot;noTxServiceOperation&quot; advice-ref&#x3D;&quot;noTxAdvice&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will be transactional (see the &#39;defaultServiceOperation&#39; pointcut) --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;anotherFooService&quot; class&#x3D;&quot;x.y.service.ddl.DefaultDdlManager&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id&#x3D;&quot;defaultTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">    &lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id&#x3D;&quot;noTxAdvice&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;NEVER&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">    &lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="lt-hh-211-h-gt-设置"><a href="#lt-hh-211-h-gt-设置" class="headerlink" title="&lt; hh:// +211+ .h &gt;设置"></a>&lt; hh:// +211+ .h &gt;设置</h4><p>本节总结了您可以使用<code>&lt;tx:advice/&gt;</code>标记指定的各种 transactional 设置。默认的<code>&lt;tx:advice/&gt;</code>设置为：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-propagation">传播设置</a>是<code>REQUIRED.</code></li>
<li>隔离 level 是<code>DEFAULT.</code></li>
<li>transaction 是 read-write。</li>
<li>transaction 超时默认为基础 transaction 系统的默认超时，如果不支持超时，则默认为 none。</li>
<li>任何<code>RuntimeException</code>触发回滚，任何已检查的<code>Exception</code>都没有。</li>
</ul>
<p>您可以更改这些默认设置。以下 table 总结了嵌套在<code>&lt;tx:advice/&gt;</code>和<code>&lt;tx:attributes/&gt;</code>标记内的<code>&lt;tx:method/&gt;</code>标记的各种属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>需要？</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>name</code></td>
<td>是</td>
<td>与 transaction 属性关联的方法名称。通配符(<em>)字符可用于将相同的 transaction 属性设置与多个方法相关联(对于 example，`get</em><code>，</code>handle<em><code>，</code>on</em>Event`等)。</td>
<td></td>
</tr>
<tr>
<td><code>propagation</code></td>
<td>没有</td>
<td><code>REQUIRED</code></td>
<td>Transaction 传播行为。</td>
</tr>
<tr>
<td><code>isolation</code></td>
<td>没有</td>
<td><code>DEFAULT</code></td>
<td>Transaction isolation level。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播设置。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>没有</td>
<td>-1</td>
<td>Transaction timeout(秒)。仅适用于传播<code>REQUIRED</code>或<code>REQUIRES_NEW</code>。</td>
</tr>
<tr>
<td><code>read-only</code></td>
<td>没有</td>
<td>假</td>
<td>Read-write 与 read-only transaction。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>。</td>
</tr>
<tr>
<td><code>rollback-for</code></td>
<td>没有</td>
<td>Comma-delimited 触发回滚的<code>Exception</code>实例列表。对于 example，<code>com.foo.MyBusinessException,ServletException.</code></td>
<td></td>
</tr>
<tr>
<td><code>no-rollback-for</code></td>
<td>没有</td>
<td>Comma-delimited 不触发回滚的<code>Exception</code>实例列表。对于 example，<code>com.foo.MyBusinessException,ServletException.</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="使用-Transactional"><a href="#使用-Transactional" class="headerlink" title="使用 @Transactional"></a>使用 @Transactional</h4><p>除_tra_action configuration 的 XML-based 声明方法之外，您还可以使用 annotation-based 方法。直接在 Java source code 中声明 transaction 语义会使声明更接近受影响的 code。没有太多的过度耦合的危险，因为无论如何，用于交易使用的 code 几乎总是以这种方式部署。</p>
<blockquote>
<p>标准<code>javax.transaction.Transactional</code> annotation 也被支持为 Spring 自己的 annotation 的 drop-in 替换。有关更多详细信息，请参阅 JTA 1.2 文档。</p>
</blockquote>
<p>使用<code>@Transactional</code> annotation 提供的 ease-of-use 最好用 example 说明，后面的文字对此进行了解释。考虑以下 class 定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; the service class that we want to make transactional</span><br><span class="line">@Transactional</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName);</span><br><span class="line"></span><br><span class="line">    Foo getFoo(String fooName, String barName);</span><br><span class="line"></span><br><span class="line">    void insertFoo(Foo foo);</span><br><span class="line"></span><br><span class="line">    void updateFoo(Foo foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上所述在 class level 中使用，annotation 指示声明 class(及其子类)的所有方法的默认值。或者，每个方法都可以单独注释。请注意，class-level annotation 不适用于 class 层次结构的祖先 classes;在这种情况下，需要在 order 中本地重新声明方法以参与 subclass-level annotation。</p>
<p>当如上所述的 POJO class 在 Spring context 中定义为 bean 时，可以通过<code>@Configuration</code> class 中的<code>@EnableTransactionManagement</code> annotation 创建 bean 实例 transactional。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/transaction/annotation/EnableTransactionManagement.html">javadoc</a>。</p>
<p>在 XML configuration 中，<code>&lt;tx:annotation-driven/&gt;</code>标签提供了类似的便利：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- from the file &#39;context.xml&#39; --&gt;</span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the service object that we want to make transactional --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span><br><span class="line">    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;txManager&quot;&#x2F;&gt;&lt;!-- a PlatformTransactionManager is still required --&gt; (1)</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;!-- (this dependency is defined somewhere else) --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean&#x2F;&gt; definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使 bean 实例 transactional 的 line。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果要连接的<code>PlatformTransactionManager</code>的 bean name 具有 name，<code>transactionManager</code>，则可以省略<code>&lt;tx:annotation-driven/&gt;</code>标记中的<code>transaction-manager</code>属性。如果要的bean 具有任何其他 name，则必须使用<code>transaction-manager</code>属性，如前面的 example 中所示。</p>
</blockquote>
<p>方法可见性和<code>@Transactional</code></p>
<p>使用代理时，应仅将<code>@Transactional</code> annotation 应用于具有公共可见性的方法。如果使用<code>@Transactional</code> annotation 注释 protected，private 或 package-visible 方法，则不会引发错误，但带注释的方法不会显示已配置的 transactional 设置。如果需要注释 non-public 方法，请考虑使用 AspectJ(稍后介绍)。</p>
<p>您可以将<code>@Transactional</code> annotation 应用于接口定义，接口上的方法，class 定义或 class 上的公共方法。但是，仅仅存在<code>@Transactional</code> annotation 不足以激活 transactional 行为。 <code>@Transactional</code> annotation 只是元数据，可以被<code>@Transactional</code> -aware 的某些运行时基础结构使用，并且可以使用元数据来配置具有 transactional 行为的相应 beans。在前面的 example 中，<code>&lt;tx:annotation-driven/&gt;</code>元素会切换 transactional 行为。</p>
<blockquote>
<p>Spring 团队建议您使用<code>@Transactional</code> annotation 仅注释具体的 classes(以及具体 classes 的方法)，而不是注释接口。您当然可以将<code>@Transactional</code> annotation 放在接口(或接口方法)上，但这只能在您使用 interface-based 代理时按预期工作。 Java annotations 不是从接口继承的事实意味着，如果使用 class-based 代理(<code>proxy-target-class=&quot;true&quot;</code>)或 weaving-based aspect(<code>mode=&quot;aspectj&quot;</code>)，代理和编织基础结构无法识别 transaction 设置，并且 object 不包含在 transactional 代理。</p>
<p>在代理模式(默认设置)下，只拦截通过代理进入的外部方法 calls。这意味着 self-invocation(实际上，目标 object 中的一个方法调用目标 object 的另一个方法)在运行时不会导致实际的 transaction，即使被调用的方法用<code>@Transactional</code>标记。此外，必须完全初始化代理以提供预期的行为，因此您不应该在初始化 code(即<code>@PostConstruct</code>)中依赖此 feature。</p>
</blockquote>
<p>如果您希望 self-invocations 也包含 transactions，请考虑使用 AspectJ 模式(请参阅以下 table 中的<code>mode</code>属性)。在这种情况下，首先没有代理。相反，目标 class 被编织(即，其字节 code 被修改)以在任何类型的方法上将<code>@Transactional</code>转换为运行时行为。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>XML 属性</th>
<th>Annotation 属性</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>transaction-manager</code></td>
<td>N/A(见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html">TransactionManagementConfigurer</a> javadoc)</td>
<td><code>transactionManager</code></td>
<td>_transaction manager 要使用的名称。仅当 transaction manager 的 name 不是<code>transactionManager</code>时才需要，如前面的 example 中所示。</td>
</tr>
<tr>
<td><code>mode</code></td>
<td><code>mode</code></td>
<td><code>proxy</code></td>
<td>默认模式(<code>proxy</code>)通过使用 Spring 的 AOP framework 处理带注释的 beans 代理(遵循代理语义，如前所述，仅适用于通过代理进入的方法 calls)。替代模式(<code>aspectj</code>)使用 Spring 的 AspectJ transaction aspect 编织受影响的 classes，修改目标 class byte code 以应用于任何类型的方法调用。 AspectJ 编织在 classpath 中需要<code>spring-aspects.jar</code>以及启用 load-time 编织(或 compile-time 编织)。 (有关如何设置 load-time weaving.)的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">Spring configuration</a></td>
</tr>
<tr>
<td><code>proxy-target-class</code></td>
<td><code>proxyTargetClass</code></td>
<td><code>false</code></td>
<td>仅适用于<code>proxy</code>模式。控制为使用<code>@Transactional</code> annotation 注释的 classes 创建的 transactional 代理类型。如果<code>proxy-target-class</code>属性设置为<code>true</code>，则会创建 class-based 个代理。如果<code>proxy-target-class</code>是<code>false</code>或者省略了该属性，则会创建标准 JDK interface-based 代理。 (有关不同代理人的详细检查，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-proxying">代理机制</a> types.)</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>order</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE</code></td>
<td>定义应用于使用<code>@Transactional</code>注释的 beans 的 transaction 建议的 order。 (有关与 AOP 建议的 ordering 相关的规则的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-ordering">建议订购</a> .)没有指定的 ordering 意味着 AOP 子系统确定建议的 order。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>处理<code>@Transactional</code> annotations 的默认建议模式是<code>proxy</code>，它允许仅通过代理拦截 calls。同一 class 中的本地 calls 不能以这种方式截获。对于更高级的拦截模式，请考虑结合 compile-time 或 load-time 编织切换到<code>aspectj</code>模式。</p>
<p><code>proxy-target-class</code>属性控制为使用<code>@Transactional</code> annotation 注释的 classes 创建的 transactional 代理类型。如果<code>proxy-target-class</code>设置为<code>true</code>，则会创建 class-based 个代理。如果<code>proxy-target-class</code>是<code>false</code>或者省略了该属性，则会创建标准 JDK interface-based 代理。 (有关不同代理的讨论，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#aop-proxying">[aop-proxying]</a> types.)</p>
<p><code>@EnableTransactionManagement</code>和<code>&lt;tx:annotation-driven/&gt;</code>仅在定义它们的同一 application context 中的 beans 上查找<code>@Transactional</code>。这意味着，如果您将 annotation-driven configuration 放在<code>WebApplicationContext</code>中<code>DispatcherServlet</code>，它只会在您的控制器而不是您的服务中检查<code>@Transactional</code> beans。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet">MVC</a>。</p>
</blockquote>
<p>在评估方法的 transactional 设置时，派生的位置优先。在以下 example 的情况下，<code>DefaultFooService</code> class 在 class level 中使用 read-only transaction 的设置进行注释，但同一 class 中<code>updateFoo(Foo)</code>方法上的<code>@Transactional</code> annotation 优先于 class level 中定义的 transactional 设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(readOnly &#x3D; true)</span><br><span class="line">public class DefaultFooService implements FooService &#123;</span><br><span class="line"></span><br><span class="line">    public Foo getFoo(String fooName) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; these settings have precedence for this method</span><br><span class="line">    @Transactional(readOnly &#x3D; false, propagation &#x3D; Propagation.REQUIRES_NEW)</span><br><span class="line">    public void updateFoo(Foo foo) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Transactional-设置"><a href="#Transactional-设置" class="headerlink" title="@Transactional 设置"></a>@Transactional 设置</h5><p><code>@Transactional</code> annotation 是元数据，指定接口，class 或方法必须具有 transactional 语义(对于 example，“在调用此方法时启动全新的 read-only transaction，暂停任何现有的 transaction”)。默认的<code>@Transactional</code>设置如下：</p>
<ul>
<li>传播设置为<code>PROPAGATION_REQUIRED.</code></li>
<li>隔离 level 是<code>ISOLATION_DEFAULT.</code></li>
<li>transaction 是 read-write。</li>
<li>transaction 超时默认为基础 transaction 系统的默认超时，如果不支持超时，则为 none。</li>
<li>任何<code>RuntimeException</code>触发回滚，任何已检查的<code>Exception</code>都没有。</li>
</ul>
<p>您可以更改这些默认设置。以下 table 总结了<code>@Transactional</code> annotation 的各种 properties：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-multiple-tx-mgrs-with-attransactional">值</a></td>
<td><code>String</code></td>
<td>可选限定符，指定要使用的 transaction manager。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-propagation">传播</a></td>
<td><code>enum</code> : <code>Propagation</code></td>
<td>可选的传播设置。</td>
</tr>
<tr>
<td><code>isolation</code></td>
<td><code>enum</code> : <code>Isolation</code></td>
<td>可选隔离 level。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播值。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td><code>int</code>(以粒度为单位)</td>
<td>可选的 transaction 超时。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的传播值。</td>
</tr>
<tr>
<td><code>readOnly</code></td>
<td><code>boolean</code></td>
<td>Read-write 与 read-only transaction。仅适用于<code>REQUIRED</code>或<code>REQUIRES_NEW</code>的值。</td>
</tr>
<tr>
<td><code>rollbackFor</code></td>
<td>_A_ray <code>Class</code> objects，必须从<code>Throwable.</code>派生</td>
<td>可选的 exception exception classes 必须导致回滚。</td>
</tr>
<tr>
<td><code>rollbackForClassName</code></td>
<td>_Alass 类的 class 名称。 classes 必须从<code>Throwable.</code>派生</td>
<td>exception classes 名称的可选 array 必须导致回滚。</td>
</tr>
<tr>
<td><code>noRollbackFor</code></td>
<td>_A_ray <code>Class</code> objects，必须从<code>Throwable.</code>派生</td>
<td>可选 array 的 exception classes，不得导致回滚。</td>
</tr>
<tr>
<td><code>noRollbackForClassName</code></td>
<td>Array 的<code>String</code> class 名称，必须从<code>Throwable.</code>派生</td>
<td>可选 array 的 exception classes 名称，不得导致回滚。</td>
</tr>
</tbody>
</table>
</div>
<p>目前，您无法明确控制 transaction 的 name，其中’name’表示 transaction 监视器中出现的 transaction name(如果适用)(对于 example，WebLogic 的 transaction 监视器)和 logging 输出。对于声明式 transactions，transaction name 始终是 fully-qualified class name <code>.</code>事务建议 class 的方法 name。例如，如果<code>BusinessService</code> class 的<code>handlePayment(..)</code>方法启动 transaction，则 transaction 的 name 将为：<code>com.example.BusinessService.handlePayment</code>。</p>
<h5 id="多个-Transaction-Managers-with-Transactional"><a href="#多个-Transaction-Managers-with-Transactional" class="headerlink" title="多个 Transaction Managers with @Transactional"></a>多个 Transaction Managers with @Transactional</h5><p>大多数 Spring applications 只需要一个 transaction manager，但是在某些 application 中你可能需要多个独立的 transaction managers。您可以使用<code>@Transactional</code> annotation 的<code>value</code>属性来选择性地指定要使用的<code>PlatformTransactionManager</code>的标识。这可以是 bean name 或 transaction manager bean 的限定符 value。对于 example，使用限定符表示法，可以将以下 Java code 与 application context 中的以下 transaction manager bean 声明组合使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalService &#123;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;order&quot;)</span><br><span class="line">    public void setSomething(String name) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(&quot;account&quot;)</span><br><span class="line">    public void doSomething() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下清单显示了 bean 声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;transactionManager1&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value&#x3D;&quot;order&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;transactionManager2&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;qualifier value&#x3D;&quot;account&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>TransactionalService</code> run 上的两个方法在单独的 transaction managers 下，由<code>order</code>和<code>account</code>限定符区分。如果未找到特定限定的<code>PlatformTransactionManager</code> bean，则仍使用默认的<code>&lt;tx:annotation-driven&gt;</code>目标 bean name，<code>transactionManager</code>。</p>
<h5 id="自定义快捷方式注释"><a href="#自定义快捷方式注释" class="headerlink" title="自定义快捷方式注释"></a>自定义快捷方式注释</h5><p>如果您发现在许多不同方法上重复使用与<code>@Transactional</code>相同的属性，则<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">Spring 的 meta-annotation 支持</a>允许您为特定用例定义自定义快捷方式注释。对于 example，请考虑以下 annotation 定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;order&quot;)</span><br><span class="line">public @interface OrderTx &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Transactional(&quot;account&quot;)</span><br><span class="line">public @interface AccountTx &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的注释允许我们编写上一节中的 example，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalService &#123;</span><br><span class="line"></span><br><span class="line">    @OrderTx</span><br><span class="line">    public void setSomething(String name) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    @AccountTx</span><br><span class="line">    public void doSomething() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，我们使用语法来定义 transaction manager 限定符，但我们也可以包含传播行为，回滚规则，超时和其他 features。</p>
<h4 id="Transaction-传播"><a href="#Transaction-传播" class="headerlink" title="Transaction 传播"></a>Transaction 传播</h4><p>本节描述了 Spring 中 transaction 传播的一些语义。请注意，本节不是 transaction 传播的简介。相反，它详细介绍了 Spring 中有关 transaction 传播的一些语义。</p>
<p>在 Spring-managed transactions 中，请注意物理和逻辑 transactions 之间的区别，以及传播设置如何应用于此差异。</p>
<h5 id="了解-PROPAGATION-REQUIRED"><a href="#了解-PROPAGATION-REQUIRED" class="headerlink" title="了解 PROPAGATION_REQUIRED"></a>了解 PROPAGATION_REQUIRED</h5><p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx_prop_required.jpg" alt="需要 tx 道具"></p>
<p>如果还没有 transaction 存在，或者参与为更大范围定义的现有“外部”transaction，则<code>PROPAGATION_REQUIRED</code>对当前作用域本地执行物理 transaction。这是同一线程中 common 调用堆栈排列的一个很好的默认值(对于 example，一个服务门面，它委托给几个 repository 方法，其中所有底层资源都必须参与 service-level transaction)。</p>
<blockquote>
<p>默认情况下，参与的 transaction 连接外部作用域的特征，静默忽略本地隔离 level，timeout value 或 read-only flag(如果有)。如果希望在参与具有不同隔离 level 的现有 transaction 时拒绝隔离 level 声明，请考虑将<code>validateExistingTransactions</code> flag 切换到 transactionmanager 上的<code>true</code>。此 non-lenient 模式也拒绝 read-only 不匹配(即，尝试参与 read-only 外部范围的内部 read-write transaction)。</p>
</blockquote>
<p>当传播设置为<code>PROPAGATION_REQUIRED</code>时，将为应用该设置的每个方法创建逻辑 transaction 范围。每个这样的逻辑 transaction 范围可以单独确定 rollback-only status，外部 transaction 范围在逻辑上独立于内部 transaction 范围。在标准<code>PROPAGATION_REQUIRED</code>行为的情况下，所有这些范围都映射到相同的物理 transaction。因此，内部 transaction 范围中的 rollback-only 标记集确实会影响外部 transaction 实际提交的机会。</p>
<p>但是，在内部 transaction 范围设置 rollback-only 标记的情况下，外部 transaction 尚未决定回滚本身，因此回滚(由内部 transaction 范围静默触发)是意外的。此时抛出相应的<code>UnexpectedRollbackException</code>。这是预期的行为，因此 transaction 的调用者永远不会被误导，假设在实际上没有执行提交。因此，如果内部 transaction(外部调用者不知道)默认将 transaction 标记为 rollback-only，则外部调用者仍然会 calls commit。外部调用者需要接收<code>UnexpectedRollbackException</code>以清楚地指示已执行回滚。</p>
<h5 id="了解-PROPAGATION-REQUIRES-NEW"><a href="#了解-PROPAGATION-REQUIRES-NEW" class="headerlink" title="了解 PROPAGATION_REQUIRES_NEW"></a>了解 PROPAGATION_REQUIRES_NEW</h5><p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/tx_prop_requires_new.jpg" alt="tx prop 需要新"></p>
<p>与<code>PROPAGATION_REQUIRED</code>相比，<code>PROPAGATION_REQUIRES_NEW</code>始终对每个受影响的 transaction 范围使用独立的物理 transaction，从不参与外部范围的现有 transaction。在这样的安排中，底层资源 transactions 是不同的，因此可以独立提交或回滚，外部 transaction 不受内部 transaction 的回滚状态的影响，并且内部 transaction 的锁在完成后立即释放。这样一个独立的内部 transaction 也可以声明它自己的隔离 level，timeout 和 read-only 设置，而不是继承外部 transaction 的特性。</p>
<h5 id="了解-PROPAGATION-NESTED"><a href="#了解-PROPAGATION-NESTED" class="headerlink" title="了解 PROPAGATION_NESTED"></a>了解 PROPAGATION_NESTED</h5><p><code>PROPAGATION_NESTED</code>使用具有多个保存点的单个物理 transaction，它可以回滚到。这样的部分回滚允许内部 transaction 范围触发其范围的回滚，外部 transaction 能够继续物理 transaction，尽管已经回滚了一些操作。此设置通常映射到 JDBC 保存点，因此它仅适用于 JDBC 资源 transactions。见 Spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jdbc/datasource/DataSourceTransactionManager.html">DataSourceTransactionManager 对象</a>。</p>
<h4 id="建议-Transactional-Operations"><a href="#建议-Transactional-Operations" class="headerlink" title="建议 Transactional Operations"></a>建议 Transactional Operations</h4><p>假设您要执行 transactional 操作和一些基本的分析建议。你如何在<code>&lt;tx:annotation-driven/&gt;</code>的 context 中实现这一点？</p>
<p>当您调用<code>updateFoo(Foo)</code>方法时，您希望看到以下操作：</p>
<ul>
<li>配置的分析 aspect 启动。</li>
<li>transactional 建议执行。</li>
<li>建议 object 上的方法执行。</li>
<li>transaction 提交。</li>
<li>分析 aspect 报告整个 transactional 方法调用的确切持续时间。</li>
</ul>
<blockquote>
<p>本章不涉及详细解释 AOP(除非适用于 transactions)。有关 AOP configuration 和 AOP 的详细介绍，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">AOP</a>。</p>
</blockquote>
<p>以下 code 显示了前面讨论过的简单分析 aspect：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package x.y;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line">import org.springframework.util.StopWatch;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line">public class SimpleProfiler implements Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private int order;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; allows us to control the ordering of advice</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return this.order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOrder(int order) &#123;</span><br><span class="line">        this.order &#x3D; order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; this method is the around advice</span><br><span class="line">    public Object profile(ProceedingJoinPoint call) throws Throwable &#123;</span><br><span class="line">        Object returnValue;</span><br><span class="line">        StopWatch clock &#x3D; new StopWatch(getClass().getName());</span><br><span class="line">        try &#123;</span><br><span class="line">            clock.start(call.toShortString());</span><br><span class="line">            returnValue &#x3D; call.proceed();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            clock.stop();</span><br><span class="line">            System.out.println(clock.prettyPrint());</span><br><span class="line">        &#125;</span><br><span class="line">        return returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议的 ordering 通过<code>Ordered</code>接口控制。有关建议 ordering 的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-ordering">建议 ordering</a>。</p>
<p>以下 configuration 创建一个<code>fooService</code> bean，在所需的 order 中应用了 profiling 和 transactional 方面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- this is the aspect --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;profiler&quot; class&#x3D;&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;order&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven transaction-manager&#x3D;&quot;txManager&quot; order&#x3D;&quot;200&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">            &lt;!-- this advice will execute around the transactional advice --&gt;</span><br><span class="line">            &lt;aop:aspect id&#x3D;&quot;profilingAspect&quot; ref&#x3D;&quot;profiler&quot;&gt;</span><br><span class="line">                &lt;aop:pointcut id&#x3D;&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                        expression&#x3D;&quot;execution(!void x.y..*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line">                &lt;aop:around method&#x3D;&quot;profile&quot; pointcut-ref&#x3D;&quot;serviceMethodWithReturnValue&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;aop:aspect&gt;</span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;oracle.jdbc.driver.OracleDriver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;scott&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;tiger&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;txManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>您可以以类似的方式配置任意数量的其他方面。</p>
<p>以下 example 创建与前两个示例相同的设置，但使用纯 XML 声明方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;fooService&quot; class&#x3D;&quot;x.y.service.DefaultFooService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- the profiling advice --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;profiler&quot; class&#x3D;&quot;x.y.SimpleProfiler&quot;&gt;</span><br><span class="line">        &lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;order&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id&#x3D;&quot;entryPointMethod&quot; expression&#x3D;&quot;execution(* x.y..*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;entryPointMethod&quot; order&#x3D;&quot;2&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- order value is higher than the profiling aspect --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;aop:aspect id&#x3D;&quot;profilingAspect&quot; ref&#x3D;&quot;profiler&quot;&gt;</span><br><span class="line">            &lt;aop:pointcut id&#x3D;&quot;serviceMethodWithReturnValue&quot;</span><br><span class="line">                    expression&#x3D;&quot;execution(!void x.y..*Service.*(..))&quot;&#x2F;&gt;</span><br><span class="line">            &lt;aop:around method&#x3D;&quot;profile&quot; pointcut-ref&#x3D;&quot;serviceMethodWithReturnValue&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;txManager&quot;&gt;</span><br><span class="line">        &lt;tx:attributes&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;tx:method name&#x3D;&quot;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;tx:attributes&gt;</span><br><span class="line">    &lt;&#x2F;tx:advice&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other &lt;bean&#x2F;&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 configuration 的结果是<code>fooService</code> bean，它在该 order 中应用了 profiling 和 transactional 方面。如果您希望在关于出路的 transactional 建议之前和之前的 transactional 建议之后执行分析建议，您可以交换分析 aspect bean 的<code>order</code> property 的 value，使其高于 transactional advice 的 order value。</p>
<p>您可以以类似的方式配置其他方面。</p>
<h4 id="在-AspectJ-中使用-Transactional"><a href="#在-AspectJ-中使用-Transactional" class="headerlink" title="在 AspectJ 中使用 @Transactional"></a>在 AspectJ 中使用 @Transactional</h4><p>您还可以通过 AspectJ aspect 在 Spring 容器外部使用 Spring Framework 的<code>@Transactional</code>支持。为此，首先使用<code>@Transactional</code> annotation 注释 classes(以及可选的 classes’方法)，然后将 application 与<code>spring-aspects.jar</code>文件中定义的<code>org.springframework.transaction.aspectj.AnnotationTransactionAspect</code>链接(编织)。您还必须使用 transaction manager 配置 aspect。您可以使用 Spring Framework 的 IoC 容器来处理 dependency-injecting aspect。配置 transaction management aspect 的最简单方法是使用<code>&lt;tx:annotation-driven/&gt;</code>元素并将<code>mode</code>属性指定为<code>aspectj</code>，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-annotations">使用 @Transactional</a>中所述。因为我们专注于在 Spring 容器之外运行的 applications，我们将向您展示如何以编程方式执行此操作。</p>
<blockquote>
<p>在继续之前，您可能需要分别阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-annotations">使用 @Transactional</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">AOP</a>。</p>
</blockquote>
<p>以下 example 显示了如何创建 transaction manager 并配置<code>AnnotationTransactionAspect</code>以使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; construct an appropriate transaction manager</span><br><span class="line">DataSourceTransactionManager txManager &#x3D; new DataSourceTransactionManager(getDataSource());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span><br><span class="line">AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用此 aspect 时，必须注释 implementation class(或该 class 中的方法或两者)，而不是 class 实现的接口(如果有)。 AspectJ 遵循 Java 的规则，即接口上的注释不会被继承。</p>
</blockquote>
<p>class 上的<code>@Transactional</code> annotation 指定了 class 中执行任何公共方法的默认 transaction 语义。</p>
<p>class 中的方法上的<code>@Transactional</code> annotation 覆盖 class annotation(如果存在)给出的默认 transaction 语义。无论可见性如何，您都可以注释任何方法。</p>
<p>要使用<code>AnnotationTransactionAspect</code>编写 applications，您必须使用 AspectJ 构建 application(请参阅<a target="_blank" rel="noopener" href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html">AspectJ 开发指南</a>)或使用 load-time 编织。有关使用 AspectJ 进行 load-time 编织的讨论，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw">Load-time 在 Spring Framework 中使用 AspectJ 进行编织</a>。</p>
<h3 id="程序化交易管理"><a href="#程序化交易管理" class="headerlink" title="程序化交易管理"></a>程序化交易管理</h3><p>Spring Framework 提供了两种程序化 transaction management 方法，使用：</p>
<ul>
<li><code>TransactionTemplate</code>。</li>
<li>直接<code>PlatformTransactionManager</code> implementation。</li>
</ul>
<p>Spring 团队通常建议使用<code>TransactionTemplate</code>进行程序化 transaction management。第二种方法类似于使用 JTA <code>UserTransaction</code> API，尽管 exception 处理不那么麻烦。</p>
<h4 id="使用-TransactionTemplate"><a href="#使用-TransactionTemplate" class="headerlink" title="使用 TransactionTemplate"></a>使用 TransactionTemplate</h4><p><code>TransactionTemplate</code>采用与其他 Spring 模板相同的方法，例如<code>JdbcTemplate</code>。它使用回调方法(免费 application code 从必须进行样板采集和释放 transactional 资源)并导致 code 被意图驱动，因为你的 code 只关注你想要做的事情。</p>
<blockquote>
<p>如下面的示例所示，使用<code>TransactionTemplate</code>绝对会将您与 Spring 的 transaction 基础结构和 API 相结合。程序化 transaction management 是否适合您的开发需求是您必须自己做出的决定。</p>
</blockquote>
<p>Application code 必须在 transactional context 中执行，并且显式使用<code>TransactionTemplate</code>类似于下一个 example。作为 application 开发人员，您可以编写<code>TransactionCallback</code> implementation(通常表示为匿名内部 class)，其中包含您需要在 transaction 的 context 中执行的 code。然后，您可以将自定义<code>TransactionCallback</code>的实例传递给<code>TransactionTemplate</code>上公开的<code>execute(..)</code>方法。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; single TransactionTemplate shared amongst all methods in this instance</span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; use constructor-injection to supply the PlatformTransactionManager</span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        this.transactionTemplate &#x3D; new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object someServiceMethod() &#123;</span><br><span class="line">        return transactionTemplate.execute(new TransactionCallback() &#123;</span><br><span class="line">            &#x2F;&#x2F; the code in this method executes in a transactional context</span><br><span class="line">            public Object doInTransaction(TransactionStatus status) &#123;</span><br><span class="line">                updateOperation1();</span><br><span class="line">                return resultOfUpdateOperation2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有 return value，则可以使用带有匿名 class 的方便的<code>TransactionCallbackWithoutResult</code> class，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        updateOperation1();</span><br><span class="line">        updateOperation2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调中的 Code 可以通过调用提供的<code>TransactionStatus</code> object 上的<code>setRollbackOnly()</code>方法来回滚 transaction，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line"></span><br><span class="line">    protected void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            updateOperation1();</span><br><span class="line">            updateOperation2();</span><br><span class="line">        &#125; catch (SomeBusinessException ex) &#123;</span><br><span class="line">            status.setRollbackOnly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="指定-Transaction-设置"><a href="#指定-Transaction-设置" class="headerlink" title="指定 Transaction 设置"></a>指定 Transaction 设置</h5><p>您可以在<code>TransactionTemplate</code>上以编程方式或在 configuration 中指定 transaction 设置(例如传播模式，隔离 level，超时等)。默认情况下，<code>TransactionTemplate</code>实例具有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-txadvice-settings">默认 transactional 设置</a>。以下 example 显示了特定<code>TransactionTemplate:</code>的 transactional 设置的编程自定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleService implements Service &#123;</span><br><span class="line"></span><br><span class="line">    private final TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    public SimpleService(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        this.transactionTemplate &#x3D; new TransactionTemplate(transactionManager);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; the transaction settings can be set here explicitly if so desired</span><br><span class="line">        this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);</span><br><span class="line">        this.transactionTemplate.setTimeout(30); &#x2F;&#x2F; 30 seconds</span><br><span class="line">        &#x2F;&#x2F; and so forth...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 通过使用 Spring XML configuration 定义带有一些自定义 transactional 设置的<code>TransactionTemplate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;sharedTransactionTemplate&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;isolationLevelName&quot; value&#x3D;&quot;ISOLATION_READ_UNCOMMITTED&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;timeout&quot; value&#x3D;&quot;30&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;&quot;</span><br></pre></td></tr></table></figure>
<p>然后，您可以_将<code>sharedTransactionTemplate</code>注入所需数量的服务。</p>
<p>最后，<code>TransactionTemplate</code> class 的实例是 thread-safe，在这种情况下不保持任何会话 state。但是，<code>TransactionTemplate</code>实例会保持 configuration state。因此，虽然许多 classes 可以共享<code>TransactionTemplate</code>的单个实例，但如果 class 需要使用具有不同设置的<code>TransactionTemplate</code>(对于 example，不同的隔离 level)，则需要创建两个不同的<code>TransactionTemplate</code>实例。</p>
<h4 id="使用-PlatformTransactionManager"><a href="#使用-PlatformTransactionManager" class="headerlink" title="使用 PlatformTransactionManager"></a>使用 PlatformTransactionManager</h4><p>您也可以直接使用<code>org.springframework.transaction.PlatformTransactionManager</code>来管理 transaction。为此，请通过 bean reference 将您使用的<code>PlatformTransactionManager</code>的_imple 实现传递给 bean。然后，通过使用<code>TransactionDefinition</code>和<code>TransactionStatus</code> objects，您可以启动 transactions，回滚和提交。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DefaultTransactionDefinition def &#x3D; new DefaultTransactionDefinition();</span><br><span class="line">&#x2F;&#x2F; explicitly setting the transaction name is something that can be done only programmatically</span><br><span class="line">def.setName(&quot;SomeTxName&quot;);</span><br><span class="line">def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line"></span><br><span class="line">TransactionStatus status &#x3D; txManager.getTransaction(def);</span><br><span class="line">try &#123;</span><br><span class="line">    &#x2F;&#x2F; execute your business logic here</span><br><span class="line">&#125;</span><br><span class="line">catch (MyException ex) &#123;</span><br><span class="line">    txManager.rollback(status);</span><br><span class="line">    throw ex;</span><br><span class="line">&#125;</span><br><span class="line">txManager.commit(status);</span><br></pre></td></tr></table></figure>
<h3 id="在-Programmatic-和-Declarative-之间选择-Transaction-Management"><a href="#在-Programmatic-和-Declarative-之间选择-Transaction-Management" class="headerlink" title="在 Programmatic 和 Declarative 之间选择 Transaction Management"></a>在 Programmatic 和 Declarative 之间选择 Transaction Management</h3><p>只有少数 transactional 操作，程序化 transaction management 通常是一个很好的 idea。例如，如果您的 web application 只需要 transactions 用于某些更新操作，您可能不希望使用 Spring 或任何其他技术设置 transactional 代理。在这种情况下，使用<code>TransactionTemplate</code>可能是一个很好的方法。能够明确地设置 transaction name 也是可以通过使用 transaction management 的编程方法来完成的。</p>
<p>另一方面，如果你的 application 有很多 transactional 操作，声明 transaction management 通常是值得的。它使 transaction management 不受业务逻辑的影响，并且不难配置。当使用 Spring Framework 而不是 EJB CMT 时，声明性 transaction management 的 configuration 成本大大降低。</p>
<h3 id="Transaction-bound-Events"><a href="#Transaction-bound-Events" class="headerlink" title="Transaction-bound Events"></a>Transaction-bound Events</h3><p>从 Spring 4.2 开始，event 的 listener 可以绑定到 transaction 的一个阶段。典型的 example 是在 transaction 成功完成后处理 event。这样做可以在当前 transaction 的结果对 listener 实际上很重要时更灵活地使用 events。</p>
<p>您可以使用<code>@EventListener</code> annotation 注册常规 event listener。如果需要将其绑定到 transaction，请使用<code>@TransactionalEventListener</code>。执行此操作时，listener 默认绑定到 transaction 的提交阶段。</p>
<p>下一个例子显示了这个概念。假设一个 component 发布一个 order-created event，并且我们想要定义一个 listener，它只应该在已经发布它的 transaction 成功提交后才处理该 event。以下 example 设置了这样一个 event listener：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyComponent &#123;</span><br><span class="line"></span><br><span class="line">    @TransactionalEventListener</span><br><span class="line">    public void handleOrderCreatedEvent(CreationEvent&lt;Order&gt; creationEvent) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@TransactionalEventListener</code> annotation 公开了一个<code>phase</code>属性，该属性允许您自定义 listener 应绑定到的 transaction 的阶段。有效阶段是<code>BEFORE_COMMIT</code>，<code>AFTER_COMMIT</code>(默认)，<code>AFTER_ROLLBACK</code>和<code>AFTER_COMPLETION</code>，它们聚合 transaction 完成(无论是提交还是回滚)。</p>
<p>如果没有 transaction running，则根本不会调用 listener，因为我们无法遵守所需的语义。但是，您可以通过将 annotation 的<code>fallbackExecution</code>属性设置为<code>true</code>来覆盖该行为。</p>
<h3 id="Application-server-specific-integration"><a href="#Application-server-specific-integration" class="headerlink" title="Application server-specific integration"></a>Application server-specific integration</h3><p>Spring 的 transaction 抽象通常是 application server-agnostic。此外，Spring 的<code>JtaTransactionManager</code> class(可以选择对 JTA <code>UserTransaction</code>和<code>TransactionManager</code>objects 执行 JNDI 查找)自动检测后者 object 的位置，该位置因 application 服务器而异。有权访问 JTA <code>TransactionManager</code>允许增强的 transaction 语义 - 特别是支持 transaction 暂停。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/transaction/jta/JtaTransactionManager.html">JtaTransactionManager</a> javadoc。</p>
<p>Spring 的<code>JtaTransactionManager</code>是 Java EE application 服务器上 run 的标准选择，并且已知适用于所有 common 服务器。高级功能，例如 transaction suspension，也适用于许多服务器(包括 GlassFish，JBoss 和 Geronimo)，无需任何特殊的 configuration 配置。但是，对于完全支持的 transaction 暂停和进一步的高级 integration，Spring 包含用于 WebLogic Server 和 WebSphere 的特殊适配器。以下各节将讨论这些适配器。</p>
<p>对于标准方案(包括 WebLogic Server 和 WebSphere)，请考虑使用方便的<code>&lt;tx:jta-transaction-manager/&gt;</code> configuration 元素。配置后，此元素会自动检测基础服务器并选择可用于平台的最佳 transaction manager。这意味着您无需显式配置 server-specific adapter classes(如以下部分所述)。相反，它们是自动选择的，标准<code>JtaTransactionManager</code>作为默认回退。</p>
<h4 id="IBM-WebSphere"><a href="#IBM-WebSphere" class="headerlink" title="IBM WebSphere"></a>IBM WebSphere</h4><p>在 WebSphere 6.1.0.9 及更高版本上，推荐使用的 Spring JTA transaction manager 是<code>WebSphereUowTransactionManager</code>。此特殊适配器使用 IBM 的<code>UOWManager</code> API，该 API 在 WebSphere Application Server 6.1.0.9 及更高版本中可用。使用此适配器，IBM 正式支持 Spring-driven transaction 暂停(由<code>PROPAGATION_REQUIRES_NEW</code>启动暂停和恢复)。</p>
<h4 id="Oracle-WebLogic-Server"><a href="#Oracle-WebLogic-Server" class="headerlink" title="Oracle WebLogic Server"></a>Oracle WebLogic Server</h4><p>在 WebLogic Server 9.0 或更高版本上，通常使用<code>WebLogicJtaTransactionManager</code>而不是 stock <code>JtaTransactionManager</code> class。正常<code>JtaTransactionManager</code>的这个特殊的 WebLogic-specific 子类支持 WebLogic-managed transaction 定义中 Spring 的 transaction 定义的全部功能，超出了标准的 JTA 语义。 Features 包括 transaction 名称，per-transaction 隔离级别，以及在所有情况下 transactions 的正确恢复。</p>
<h3 id="Common-问题的解决方案"><a href="#Common-问题的解决方案" class="headerlink" title="Common 问题的解决方案"></a>Common 问题的解决方案</h3><p>本节介绍了一些常见问题的解决方案。</p>
<h4 id="使用错误的-Transaction-Manager-用于特定数据源"><a href="#使用错误的-Transaction-Manager-用于特定数据源" class="headerlink" title="使用错误的 Transaction Manager 用于特定数据源"></a>使用错误的 Transaction Manager 用于特定数据源</h4><p>根据您选择的 transactional 技术和要求，使用正确的<code>PlatformTransactionManager</code> implementation。如果使用得当，Spring Framework 只提供简单易用的抽象。如果使用 global transactions，则必须对所有 transactional 操作使用<code>org.springframework.transaction.jta.JtaTransactionManager</code> class(或<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-application-server-integration">application server-specific subclass</a>)。否则，transaction 基础结构会尝试在容器<code>DataSource</code>实例等资源上执行本地 transactions。这样的本地 transactions 没有意义，一个好的 application 服务器将它们视为错误。</p>
<h3 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h3><p>有关 Spring Framework 的 transaction 支持的更多信息，请参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html">Spring 中的分布式 transactions，有和没有 XA</a>是一个 JavaWorld 演示文稿，其中 Spring 的 David Syer 在 Spring applications 中引导您完成分布式 transactions 的七种模式，其中三种模式使用 XA，另外四种没有。</li>
<li><a target="_blank" rel="noopener" href="http://www.infoq.com/minibooks/JTDS">Java Transaction 设计策略</a>是一本来自<a target="_blank" rel="noopener" href="http://www.infoq.com/">InfoQ 中文站</a>的书，它为 Java 中的 transactions 提供 well-paced 介绍。它还包括如何使用 Spring Framework 和 EJB3 配置和使用 transactions 的 side-by-side 示例。</li>
</ul>
<h2 id="DAO-支持"><a href="#DAO-支持" class="headerlink" title="DAO 支持"></a>DAO 支持</h2><p>Spring 中的数据访问 Object(DAO)支持旨在使以一致的方式使用数据访问技术(如 JDBC，Hibernate 或 JPA)变得容易。这使您可以相当容易地在上述持久性技术之间切换，并且它还允许您 code 而不必担心捕获特定于每种技术的 exceptions。</p>
<h3 id="一致的-Exception-层次结构"><a href="#一致的-Exception-层次结构" class="headerlink" title="一致的 Exception 层次结构"></a>一致的 Exception 层次结构</h3><p>Spring 提供了从 technology-specific exceptions(例如<code>SQLException</code>)到其自己的 exception class 层次结构的方便转换，其中<code>DataAccessException</code>作为根 exception。这些 exceptions 包装了原始的 exception，因此您可能永远不会丢失任何可能出错的信息。</p>
<p>除了 JDBC exceptions 之外，Spring 还可以包装 JPA-和 Hibernate-specific exceptions，将它们转换为一组专注的运行时 exceptions。这使您可以仅在适当的层中处理大多数 non-recoverable 持久性 exceptions，而不会在 DAO 中使用恼人的样板 catch-and-throw 块和 exception 声明。 (您仍然可以在任何需要的地方捕获和处理 exceptions though.)如上所述，JDBC exceptions(包括 database-specific 方言)也会转换为相同的层次结构，这意味着您可以在一致的编程 model 中使用 JDBC 执行某些操作。</p>
<p>前面的讨论为 Spring 支持各种 ORM 框架的各种模板 classes 保存了 true。如果使用 interceptor-based classes，则 application 必须关心处理<code>HibernateExceptions</code>和<code>PersistenceExceptions</code>本身，最好分别委托给<code>SessionFactoryUtils</code>的<code>convertHibernateAccessException(..)</code>或<code>convertJpaAccessException()</code>方法。这些方法将 exceptions 转换为与<code>org.springframework.dao</code> exception 层次结构中的 exceptions 兼容的 exceptions。由于<code>PersistenceExceptions</code>未经检查，它们也可能被抛出(尽管在 exceptions 方面牺牲了通用的 DAO 抽象)。</p>
<p>下图显示了 Spring 提供的 exception 层次结构。 (请注意，图像中详细说明的 class 层次结构仅显示整个<code>DataAccessException</code> hierarchy.)的子集</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/DataAccessException.jpg" alt="DataAccessException "></p>
<h3 id="Annotations-用于配置-DAO-或-Repository-Classes"><a href="#Annotations-用于配置-DAO-或-Repository-Classes" class="headerlink" title="Annotations 用于配置 DAO 或 Repository Classes"></a>Annotations 用于配置 DAO 或 Repository Classes</h3><p>保证数据访问 Objects(DAO)或 repositories 提供 exception 转换的最佳方法是使用<code>@Repository</code> annotation。此 annotation 还允许 component 扫描支持查找和配置您的 DAO 和 repositories，而无需为它们提供 XML configuration 条目。以下 example 显示了如何使用<code>@Repository</code> annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Repository (1)</span><br><span class="line">public class SomeMovieFinder implements MovieFinder &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>@Repository</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<p>任何 DAO 或 repository implementation 都需要访问持久性资源，具体取决于所使用的持久性技术。例如，JDBC-based repository 需要访问 JDBC <code>DataSource</code>，而 JPA-based repository 需要访问<code>EntityManager</code>。完成此操作的最简单方法是使用<code>@Autowired</code>，<code>@Inject</code>，<code>@Resource</code>或<code>@PersistenceContext</code> 注释之一注入此资源依赖项。以下 example 适用于 JPA repository：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class JpaMovieFinder implements MovieFinder &#123;</span><br><span class="line"></span><br><span class="line">    @PersistenceContext</span><br><span class="line">    private EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用经典的 Hibernate API，则可以 inject <code>SessionFactory</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class HibernateMovieFinder implements MovieFinder &#123;</span><br><span class="line"></span><br><span class="line">    private SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setSessionFactory(SessionFactory sessionFactory) &#123;</span><br><span class="line">        this.sessionFactory &#x3D; sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这里展示的最后一个例子是典型的 JDBC 支持。您可以将<code>DataSource</code>注入初始化方法，您可以使用此<code>DataSource</code>创建<code>JdbcTemplate</code>和其他数据访问支持 classes(例如<code>SimpleJdbcCall</code>和其他)。以下 example 自动装配<code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class JdbcMovieFinder implements MovieFinder &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void init(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关如何配置 application context 以利用这些注释的详细信息，请参阅每种持久性技术的具体内容。</p>
</blockquote>
<h2 id="使用-JDBC-进行数据访问"><a href="#使用-JDBC-进行数据访问" class="headerlink" title="使用 JDBC 进行数据访问"></a>使用 JDBC 进行数据访问</h2><p>Spring Framework JDBC 抽象提供的 value 可能最好通过下面的 table 中概述的操作序列来显示。 table 显示 Spring 负责哪些操作以及哪些操作是您的责任。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行动</th>
<th>弹簧</th>
<th>您</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义连接参数。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>打开连接。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>指定 SQL 语句。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>声明参数并提供参数值</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>准备并执行声明。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>设置循环以迭代结果(如果有)。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>为每次迭代做好工作。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>Process 任何 exception。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>处理 transactions。</td>
<td>X</td>
<td></td>
</tr>
<tr>
<td>关闭连接，语句和结果集。</td>
<td>X</td>
</tr>
</tbody>
</table>
</div>
<p>Spring Framework 负责处理所有可能使 JDBC 成为繁琐 API 的 low-level 细节。</p>
<h3 id="选择-JDBC-数据库访问方法"><a href="#选择-JDBC-数据库访问方法" class="headerlink" title="选择 JDBC 数据库访问方法"></a>选择 JDBC 数据库访问方法</h3><p>您可以选择多种方法来构成 JDBC 数据库访问的基础。除了三种<code>JdbcTemplate</code>之外，新的<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>方法优化了数据库元数据，而 RDBMS Object 样式采用了类似于 JDO Query 设计的更多 object-oriented 方法。一旦开始使用这些方法之一，您仍然可以混合和 match 以包含来自不同方法的 feature。所有方法都需要 JDBC 2.0-compliant 驱动程序，而某些高级 features 需要 JDBC 3.0 驱动程序。</p>
<ul>
<li><code>JdbcTemplate</code>是经典且最流行的 Spring JDBC 方法。这种“lowest-level”方法和所有其他方法都使用了 JdbcTemplate。</li>
<li><code>NamedParameterJdbcTemplate</code>包装<code>JdbcTemplate</code>以提供命名参数，而不是传统的 JDBC <code>?</code>占位符。当您有多个 SQL 语句参数时，此方法可提供更好的文档和易用性。</li>
<li><code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code>优化数据库元数据以限制必要的 configuration 数量。此方法简化了编码，因此您只需要提供 table 或过程的 name，并提供与列名匹配的参数的 map。仅当数据库提供足够的元数据时，这才有效。如果数据库未提供此元数据，则必须提供参数的显式 configuration。</li>
<li>RDBMS objects，包括<code>MappingSqlQuery</code>，<code>SqlUpdate</code>和<code>StoredProcedure</code>，要求您在 data-access 层初始化期间创建可重用和 thread-safe objects。此方法以 JDO Query 为模型，其中您定义查询 string，声明参数和编译查询。一旦这样做，就可以使用各种参数值多次调用 execute 方法。</li>
</ul>
<h3 id="包层次结构"><a href="#包层次结构" class="headerlink" title="包层次结构"></a>包层次结构</h3><p>Spring Framework 的 JDBC 抽象 framework 由四个不同的包组成：</p>
<ul>
<li><code>core</code>：<code>org.springframework.jdbc.core</code>包包含<code>JdbcTemplate</code> class 及其各种回调接口，以及各种相关的 classes。名为<code>org.springframework.jdbc.core.simple</code>的子包包含<code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code> classes。另一个名为<code>org.springframework.jdbc.core.namedparam</code>的子包包含<code>NamedParameterJdbcTemplate</code> class 和相关的支持 classes。请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-core">使用 JDBC Core Classes 控制基本 JDBC 处理和错误处理</a>，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-advanced-jdbc">JDBC 批处理操作</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-simple-jdbc">使用 SimpleJdbc Classes 简化 JDBC 操作</a>。</li>
<li><code>datasource</code>：<code>org.springframework.jdbc.datasource</code>包中包含一个用于轻松<code>DataSource</code>访问的实用程序 class 和各种简单的<code>DataSource</code> __mplementations，可用于测试和运行 Java EE 容器外的未修改的 JDBC code。名为<code>org.springfamework.jdbc.datasource.embedded</code>的子包通过使用 Java 数据库引擎(如 HSQL，H2 和 Derby)为创建嵌入式数据库提供支持。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-connections">控制数据库连接</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>。</li>
</ul>
<p><code>object</code>：<code>org.springframework.jdbc.object</code>包中包含 classes，它们将 RDBMS 查询，更新和存储过程表示为 thread-safe，可重用的 objects。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-object">将 JDBC 操作建模为 Java Objects</a>。这种方法由 JDO 建模，尽管查询返回的 objects 自然地与数据库断开连接。这个 higher-level 的 JDBC 抽象取决于<code>org.springframework.jdbc.core</code>包中的 lower-level 抽象。</p>
<p><code>support</code>：<code>org.springframework.jdbc.support</code>包提供<code>SQLException</code>转换功能和一些实用程序 classes。 _ JDBC 处理期间抛出的异常被转换为<code>org.springframework.dao</code>包中定义的 exceptions。这意味着使用 Spring JDBC 抽象层的 code 不需要实现 JDBC 或 RDBMS-specific 错误处理。所有已翻译的 exceptions 都是未选中的，这使您可以选择捕获 exceptions，从中可以恢复，同时让其他 exceptions 传播给调用者。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-SQLExceptionTranslator">使用 SQLExceptionTranslator</a>。</p>
<h3 id="使用-JDBC-Core-Classes-控制基本-JDBC-处理和错误处理"><a href="#使用-JDBC-Core-Classes-控制基本-JDBC-处理和错误处理" class="headerlink" title="使用 JDBC Core Classes 控制基本 JDBC 处理和错误处理"></a>使用 JDBC Core Classes 控制基本 JDBC 处理和错误处理</h3><p>本节介绍如何使用 JDBC 核心 classes 来控制基本的 JDBC 处理，包括错误处理。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-JdbcTemplate">使用 JdbcTemplate</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-NamedParameterJdbcTemplate">使用 NamedParameterJdbcTemplate</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-SQLExceptionTranslator">使用 SQLExceptionTranslator</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-statements-executing">Running Statements</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-statements-querying">Running Queries</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-updates">更新数据库</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-auto-generated-keys">检索 Auto-generated 键</a></li>
</ul>
<h4 id="使用-JdbcTemplate"><a href="#使用-JdbcTemplate" class="headerlink" title="使用 JdbcTemplate"></a>使用 JdbcTemplate</h4><p><code>JdbcTemplate</code>是 JDBC 核心包中的中心 class。它处理资源的创建和释放，帮助您避免 common 错误，例如忘记关闭连接。它执行核心 JDBC 工作流的基本任务(例如语句创建和执行)，留下 application code 以提供 SQL 并提取结果。 <code>JdbcTemplate</code> class：</p>
<ul>
<li>运行 SQL 查询</li>
<li>更新 statements 和存储过程 calls</li>
<li>对<code>ResultSet</code>实例执行迭代并提取返回的参数值。</li>
<li>捕获 JDBC exceptions 并将它们转换为<code>org.springframework.dao</code>包中定义的通用的，更具信息性的 exception 层次结构。 (见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#dao-exceptions">一致的 Exception 层次结构</a> .)</li>
</ul>
<p>当您为 code 使用<code>JdbcTemplate</code>时，您只需要实现回调接口，为它们提供明确定义的 contract。给定<code>JdbcTemplate</code> class 提供的<code>Connection</code>，<code>PreparedStatementCreator</code>回调接口创建一个预准备语句，提供 SQL 和任何必要的参数。 <code>CallableStatementCreator</code>接口的 true 也是如此，它创建了可调用的 statements。 <code>RowCallbackHandler</code>接口从<code>ResultSet</code>的每一行中提取值。</p>
<p>您可以通过使用<code>DataSource</code> reference 直接实例化在 DAO implementation 中使用<code>JdbcTemplate</code>，也可以在 Spring IoC 容器中对其进行配置，并将其作为 bean reference 提供给 DAO。</p>
<blockquote>
<p>始终应在 Spring IoC 容器中将<code>DataSource</code>配置为 bean。在第一种情况下，bean 直接提供给服务;在第二种情况下，它被给予准备好的模板。</p>
</blockquote>
<p>此 class 发出的所有 SQL 都记录在与模板实例的完全限定 class name 对应的类别下的<code>DEBUG</code> level 下(通常为<code>JdbcTemplate</code>，但如果使用<code>JdbcTemplate</code> class 的自定义子类，则可能会有所不同)。</p>
<p>以下部分提供了<code>JdbcTemplate</code>用法的一些示例。这些示例并不是<code>JdbcTemplate</code>所公开的所有功能的详尽列表。请参阅服务员<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html">javadoc</a>。</p>
<h5 id="查询-SELECT"><a href="#查询-SELECT" class="headerlink" title="查询(SELECT)"></a>查询(SELECT)</h5><p>以下查询获取关系中的行数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rowCount &#x3D; this.jdbcTemplate.queryForObject(&quot;select count(*) from t_actor&quot;, Integer.class);</span><br></pre></td></tr></table></figure>
<p>以下查询使用绑定变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int countOfActorsNamedJoe &#x3D; this.jdbcTemplate.queryForObject(</span><br><span class="line">        &quot;select count(*) from t_actor where first_name &#x3D; ?&quot;, Integer.class, &quot;Joe&quot;);</span><br></pre></td></tr></table></figure>
<p>以下查询查找<code>String</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String lastName &#x3D; this.jdbcTemplate.queryForObject(</span><br><span class="line">        &quot;select last_name from t_actor where id &#x3D; ?&quot;,</span><br><span class="line">        new Object[]&#123;1212L&#125;, String.class);</span><br></pre></td></tr></table></figure>
<p>以下查询查找并填充单个域 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Actor actor &#x3D; this.jdbcTemplate.queryForObject(</span><br><span class="line">        &quot;select first_name, last_name from t_actor where id &#x3D; ?&quot;,</span><br><span class="line">        new Object[]&#123;1212L&#125;,</span><br><span class="line">        new RowMapper&lt;Actor&gt;() &#123;</span><br><span class="line">            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">                Actor actor &#x3D; new Actor();</span><br><span class="line">                actor.setFirstName(rs.getString(&quot;first_name&quot;));</span><br><span class="line">                actor.setLastName(rs.getString(&quot;last_name&quot;));</span><br><span class="line">                return actor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>以下查询查找并填充了许多域 objects：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Actor&gt; actors &#x3D; this.jdbcTemplate.query(</span><br><span class="line">        &quot;select first_name, last_name from t_actor&quot;,</span><br><span class="line">        new RowMapper&lt;Actor&gt;() &#123;</span><br><span class="line">            public Actor mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">                Actor actor &#x3D; new Actor();</span><br><span class="line">                actor.setFirstName(rs.getString(&quot;first_name&quot;));</span><br><span class="line">                actor.setLastName(rs.getString(&quot;last_name&quot;));</span><br><span class="line">                return actor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>如果 code 的最后两个片段实际存在于同一个 application 中，那么删除两个<code>RowMapper</code>匿名内部 classes 中存在的重复并将它们提取到一个 class(通常是一个<code>static</code>嵌套的 class)然后可以被引用是有意义的。根据需要通过 DAO 方法。例如，最好按如下方式编写前面的 code 代码段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Actor&gt; findAllActors() &#123;</span><br><span class="line">    return this.jdbcTemplate.query( &quot;select first_name, last_name from t_actor&quot;, new ActorMapper());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static final class ActorMapper implements RowMapper&lt;Actor&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Actor mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">        Actor actor &#x3D; new Actor();</span><br><span class="line">        actor.setFirstName(rs.getString(&quot;first_name&quot;));</span><br><span class="line">        actor.setLastName(rs.getString(&quot;last_name&quot;));</span><br><span class="line">        return actor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用-JdbcTemplate-更新-INSERT，UPDATE-和-DELETE"><a href="#使用-JdbcTemplate-更新-INSERT，UPDATE-和-DELETE" class="headerlink" title="使用 JdbcTemplate 更新(INSERT，UPDATE 和 DELETE)"></a>使用 JdbcTemplate 更新(INSERT，UPDATE 和 DELETE)</h5><p>您可以使用<code>update(..)</code>方法执行 insert，update 和 delete 操作。参数值通常作为变量 arguments 提供，或者作为 object array 提供。</p>
<p>以下 example 插入一个新条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.jdbcTemplate.update(</span><br><span class="line">        &quot;insert into t_actor (first_name, last_name) values (?, ?)&quot;,</span><br><span class="line">        &quot;Leonor&quot;, &quot;Watling&quot;);</span><br></pre></td></tr></table></figure>
<p>以下 example 更新现有条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.jdbcTemplate.update(</span><br><span class="line">        &quot;update t_actor set last_name &#x3D; ? where id &#x3D; ?&quot;,</span><br><span class="line">        &quot;Banjo&quot;, 5276L);</span><br></pre></td></tr></table></figure>
<p>以下 example 删除条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.jdbcTemplate.update(</span><br><span class="line">        &quot;delete from actor where id &#x3D; ?&quot;,</span><br><span class="line">        Long.valueOf(actorId));</span><br></pre></td></tr></table></figure>
<h5 id="其他-JdbcTemplate-操作"><a href="#其他-JdbcTemplate-操作" class="headerlink" title="其他 JdbcTemplate 操作"></a>其他 JdbcTemplate 操作</h5><p>您可以使用<code>execute(..)</code>方法来运行任意 SQL。因此，该方法通常用于 DDL 语句。它过多地采用了带回调接口，binding 变量数组等的变体。以下 example 创建一个 table：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.jdbcTemplate.execute(&quot;create table mytable (id integer, name varchar(100))&quot;);</span><br></pre></td></tr></table></figure>
<p>以下 example 调用存储过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.jdbcTemplate.update(</span><br><span class="line">        &quot;call SUPPORT.REFRESH_ACTORS_SUMMARY(?)&quot;,</span><br><span class="line">        Long.valueOf(unionId));</span><br></pre></td></tr></table></figure>
<p>更复杂的存储过程支持是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-StoredProcedure">稍后报道</a>。</p>
<h5 id="JdbcTemplate-最佳实践"><a href="#JdbcTemplate-最佳实践" class="headerlink" title="JdbcTemplate 最佳实践"></a>JdbcTemplate 最佳实践</h5><p>一旦配置，<code>JdbcTemplate</code> class 的实例为 thread-safe。这很重要，因为这意味着您可以配置<code>JdbcTemplate</code>的单个实例，然后安全地将此共享 reference 注入多个 DAO(或 repositories)。 <code>JdbcTemplate</code>是有状态的，因为它维护的 reference，但是 state 不是会话 state。</p>
<p>使用<code>JdbcTemplate</code> class(以及关联的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-NamedParameterJdbcTemplate">是 NamedParameterJdbcTemplate</a> class)时的 common 实践是在 Spring configuration 文件中配置<code>DataSource</code>，然后在bean 中配置<code>DataSource</code> bean。 <code>JdbcTemplate</code>是在<code>DataSource</code>的 setter 中创建的。这导致 DAO 类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcCorporateEventDao implements CorporateEventDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; JDBC-backed implementations of the methods on the CorporateEventDao follow...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了相应的 XML configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;corporateEventDao&quot; class&#x3D;&quot;com.example.JdbcCorporateEventDao&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>显式 configuration 的替代方法是使用 component-scanning 和 annotation 支持依赖注入。在这种情况下，您可以使用<code>@Repository</code>(使其成为 component-scanning 的候选者)注释 class，并使用<code>@Autowired</code>注释<code>DataSource</code> setter 方法。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Repository (1)</span><br><span class="line">public class JdbcCorporateEventDao implements CorporateEventDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired (2)</span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource); (3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; JDBC-backed implementations of the methods on the CorporateEventDao follow...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@Repository</code>注释 class。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>@Autowired</code>注释<code>DataSource</code> setter 方法。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>使用<code>DataSource</code>创建一个新的<code>JdbcTemplate</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 显示了相应的 XML configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Scans within the base package of the application for @Component classes to configure as beans --&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;org.springframework.docs.test&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>如果你使用 Spring 的<code>JdbcDaoSupport</code> class 并从中扩展了各种 JDBC-backed DAO classes，那么 sub-class 会从<code>JdbcDaoSupport</code> class 继承一个<code>setDataSource(..)</code>方法。您可以选择是否继承此 class。 <code>JdbcDaoSupport</code> class 仅为方便起见而提供。</p>
<p>无论您选择使用(或不使用)上述哪种模板初始化样式，都很少需要在每次 time _运行 SQL 时创建<code>JdbcTemplate</code> class 的新实例。配置完成后，<code>JdbcTemplate</code>实例为 thread-safe。如果您的 application 访问多个数据库，您可能需要多个<code>JdbcTemplate</code>实例，这需要多个<code>DataSources</code>，以及随后多个不同配置的<code>JdbcTemplate</code>实例。</p>
<h4 id="使用-NamedParameterJdbcTemplate"><a href="#使用-NamedParameterJdbcTemplate" class="headerlink" title="使用 NamedParameterJdbcTemplate"></a>使用 NamedParameterJdbcTemplate</h4><p><code>NamedParameterJdbcTemplate</code> class 通过使用命名参数添加了对 JDBC statements 编程的支持，而不是仅使用经典占位符(<code>&#39;?&#39;</code>)arguments 编写 JDBC statements。 <code>NamedParameterJdbcTemplate</code> class 包装<code>JdbcTemplate</code>并委托包装的<code>JdbcTemplate</code>来完成它的大部分工作。本节仅描述<code>NamedParameterJdbcTemplate</code> class 与<code>JdbcTemplate</code>本身不同的那些区域 - 即使用命名参数编写 JDBC statements。以下 example 显示了如何使用<code>NamedParameterJdbcTemplate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; some JDBC-backed DAO class...</span><br><span class="line">private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">    this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int countOfActorsByFirstName(String firstName) &#123;</span><br><span class="line"></span><br><span class="line">    String sql &#x3D; &quot;select count(*) from T_ACTOR where first_name &#x3D; :first_name&quot;;</span><br><span class="line"></span><br><span class="line">    SqlParameterSource namedParameters &#x3D; new MapSqlParameterSource(&quot;first_name&quot;, firstName);</span><br><span class="line"></span><br><span class="line">    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在分配给<code>sql</code>变量的 value 中使用命名参数表示法，以及插入<code>namedParameters</code>变量(类型<code>MapSqlParameterSource</code>)的相应 value。</p>
<p>或者，您可以使用由<code>NamedParameterJdbcOperations</code>公开的<code>Map</code> -based style.The 剩余方法将命名参数及其相应值传递给<code>NamedParameterJdbcTemplate</code>实例，并由<code>NamedParameterJdbcTemplate</code> class 实现，遵循类似的 pattern，此处不予介绍。</p>
<p>以下 example 显示了<code>Map</code> -based 样式的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; some JDBC-backed DAO class...</span><br><span class="line">private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">    this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int countOfActorsByFirstName(String firstName) &#123;</span><br><span class="line"></span><br><span class="line">    String sql &#x3D; &quot;select count(*) from T_ACTOR where first_name &#x3D; :first_name&quot;;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; namedParameters &#x3D; Collections.singletonMap(&quot;first_name&quot;, firstName);</span><br><span class="line"></span><br><span class="line">    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>NamedParameterJdbcTemplate</code>相关的一个很好的 feature(并且存在于同一个 Java 包中)是<code>SqlParameterSource</code>接口。您已经在之前的一个 code 片段(<code>MapSqlParameterSource</code> class)中看到了此接口的实例实例。 <code>SqlParameterSource</code>是<code>NamedParameterJdbcTemplate</code>的命名参数值的来源。 <code>MapSqlParameterSource</code> class 是一个简单的 implementation，是一个围绕<code>java.util.Map</code>的适配器，其中键是参数名称，值是参数值。</p>
<p>另一个<code>SqlParameterSource</code> implementation 是<code>BeanPropertySqlParameterSource</code> class。此 class 包装任意 JavaBean(即，遵循<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html">JavaBean 约定</a>的 class 实例)，并使用包装的 JavaBean 的 properties 作为命名参数值的来源。</p>
<p>以下 example 显示了一个典型的 JavaBean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Actor &#123;</span><br><span class="line"></span><br><span class="line">    private Long id;</span><br><span class="line">    private String firstName;</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    public String getFirstName() &#123;</span><br><span class="line">        return this.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Long getId() &#123;</span><br><span class="line">        return this.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; setters omitted...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 使用<code>NamedParameterJdbcTemplate</code>来_return 前面 example 中显示的 class 成员的计数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; some JDBC-backed DAO class...</span><br><span class="line">private NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">    this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int countOfActors(Actor exampleActor) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; notice how the named parameters match the properties of the above &#39;Actor&#39; class</span><br><span class="line">    String sql &#x3D; &quot;select count(*) from T_ACTOR where first_name &#x3D; :firstName and last_name &#x3D; :lastName&quot;;</span><br><span class="line"></span><br><span class="line">    SqlParameterSource namedParameters &#x3D; new BeanPropertySqlParameterSource(exampleActor);</span><br><span class="line"></span><br><span class="line">    return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请记住，<code>NamedParameterJdbcTemplate</code> class 包装了一个经典的<code>JdbcTemplate</code>模板。如果需要访问包装的<code>JdbcTemplate</code>实例来访问仅存在于<code>JdbcTemplate</code> class 中的功能，则可以使用<code>getJdbcOperations()</code>方法通过<code>JdbcOperations</code>接口访问包装的<code>JdbcTemplate</code>。</p>
<p>有关在 application 的 context 中使用<code>NamedParameterJdbcTemplate</code> class 的指导，另请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-JdbcTemplate-idioms">JdbcTemplate 最佳实践</a>。</p>
<h4 id="使用-SQLExceptionTranslator"><a href="#使用-SQLExceptionTranslator" class="headerlink" title="使用 SQLExceptionTranslator"></a>使用 SQLExceptionTranslator</h4><p><code>SQLExceptionTranslator</code>是由 classes 实现的接口，可以在<code>SQLExceptions</code>和 Spring 自己的<code>org.springframework.dao.DataAccessException</code>之间进行转换，这与数据访问策略无关。 Implementations 可以是通用的(例如，使用 JDBC 的 SQLState 代码)或专有的(例如，使用 Oracle 错误代码)以获得更高的精度。</p>
<p><code>SQLErrorCodeSQLExceptionTranslator</code>是默认使用的<code>SQLExceptionTranslator</code>的 implementation。此 implementation 使用特定的供应商代码。它比<code>SQLState</code> implementation 更精确。错误 code 转换基于 JavaBean 类型 class 中保存的代码<code>SQLErrorCodes</code>。这个 class 由<code>SQLErrorCodesFactory</code>创建和填充，(根据 name 建议)是 creating <code>SQLErrorCodes</code>的工厂，它基于名为<code>sql-error-codes.xml</code>的 configuration 文件的内容。此文件使用供应商代码填充，并基于<code>DatabaseMetaData</code>中的<code>DatabaseProductName</code>。使用您正在使用的实际数据库的代码。</p>
<p><code>SQLErrorCodeSQLExceptionTranslator</code>按以下顺序应用匹配规则：</p>
<ul>
<li>由子类实现的任何自定义转换。通常，使用提供的具体<code>SQLErrorCodeSQLExceptionTranslator</code>，因此该规则不适用。仅当您实际提供了子类 implementation 时才适用。</li>
<li><code>SQLExceptionTranslator</code>接口的任何自定义 implementation，作为<code>SQLErrorCodes</code> class 的<code>customSqlExceptionTranslator</code> property 提供。</li>
<li>搜索<code>CustomSQLErrorCodesTranslation</code> class 的实例列表(为<code>SQLErrorCodes</code> class 的<code>customTranslations</code> property 提供)以查找 match。</li>
<li>应用错误 code 匹配。</li>
<li>使用后备翻译器。 <code>SQLExceptionSubclassTranslator</code>是默认的后备翻译器。如果此转换不可用，则下一个后备转换器为<code>SQLStateSQLExceptionTranslator</code>。</li>
</ul>
<blockquote>
<p>默认情况下，<code>SQLErrorCodesFactory</code>用于定义<code>Error</code>代码和自定义 exception 转换。它们在 classpath 中名为<code>sql-error-codes.xml</code>的文件中查找，匹配的<code>SQLErrorCodes</code>实例基于正在使用的数据库的数据库元数据中的数据库 name。</p>
</blockquote>
<p>您可以扩展<code>SQLErrorCodeSQLExceptionTranslator</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator &#123;</span><br><span class="line"></span><br><span class="line">    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) &#123;</span><br><span class="line">        if (sqlex.getErrorCode() &#x3D;&#x3D; -12345) &#123;</span><br><span class="line">            return new DeadlockLoserDataAccessException(task, sqlex);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，特定错误 code(<code>-12345</code>)被翻译，而其他错误则由默认翻译器 implementation 翻译。要使用此自定义转换程序，必须通过方法<code>setExceptionTranslator</code>将其传递给<code>JdbcTemplate</code>，并且必须将此<code>JdbcTemplate</code>用于需要此转换程序的所有数据访问处理。以下 example 显示了如何使用此自定义转换器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; create a JdbcTemplate and set data source</span><br><span class="line">    this.jdbcTemplate &#x3D; new JdbcTemplate();</span><br><span class="line">    this.jdbcTemplate.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; create a custom translator and set the DataSource for the default translation lookup</span><br><span class="line">    CustomSQLErrorCodesTranslator tr &#x3D; new CustomSQLErrorCodesTranslator();</span><br><span class="line">    tr.setDataSource(dataSource);</span><br><span class="line">    this.jdbcTemplate.setExceptionTranslator(tr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void updateShippingCharge(long orderId, long pct) &#123;</span><br><span class="line">    &#x2F;&#x2F; use the prepared JdbcTemplate for this update</span><br><span class="line">    this.jdbcTemplate.update(&quot;update orders&quot; +</span><br><span class="line">        &quot; set shipping_charge &#x3D; shipping_charge * ? &#x2F; 100&quot; +</span><br><span class="line">        &quot; where id &#x3D; ?&quot;, pct, orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义转换器在 order 中传递数据源以查找<code>sql-error-codes.xml</code>中的错误代码。</p>
<h4 id="Running-Statements"><a href="#Running-Statements" class="headerlink" title="Running Statements"></a>Running Statements</h4><p>运行 SQL 语句只需要很少的 code。您需要<code>DataSource</code>和<code>JdbcTemplate</code>，包括随<code>JdbcTemplate</code>提供的便捷方法。以下 example 显示了为创建新 table 的最小但功能齐全的 class 所需要包含的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class ExecuteAStatement &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doExecute() &#123;</span><br><span class="line">        this.jdbcTemplate.execute(&quot;create table mytable (id integer, name varchar(100))&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Running-Queries"><a href="#Running-Queries" class="headerlink" title="Running Queries"></a>Running Queries</h4><p>一些查询方法 return 一个 value。要从一行检索计数或特定 value，请使用<code>queryForObject(..)</code>。后者将返回的 JDBC <code>Type</code>转换为作为参数传入的 Java class。如果类型转换无效，则抛出<code>InvalidDataAccessApiUsageException</code>。以下 example 包含两个查询方法，一个用于<code>int</code>，另一个用于查询<code>String</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class RunAQuery &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return this.jdbcTemplate.queryForObject(&quot;select count(*) from mytable&quot;, Integer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.jdbcTemplate.queryForObject(&quot;select name from mytable&quot;, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了单个结果查询方法之外，还有几个方法_返回一个列表，其中包含查询返回的每一行的条目。最通用的方法是<code>queryForList(..)</code>，它返回<code>List</code>，其中每个元素都是<code>Map</code>，每列包含一个条目，使用 name 作为 key。如果向前面的 example 添加方法以检索所有行的列表，则可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">    this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public List&lt;Map&lt;String, Object&gt;&gt; getList() &#123;</span><br><span class="line">    return this.jdbcTemplate.queryForList(&quot;select * from mytable&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的列表将类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;name&#x3D;Bob, id&#x3D;1&#125;, &#123;name&#x3D;Mary, id&#x3D;2&#125;]</span><br></pre></td></tr></table></figure>
<h4 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h4><p>以下 example 更新某个主 key 的列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line">public class ExecuteAnUpdate &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(int id, String name) &#123;</span><br><span class="line">        this.jdbcTemplate.update(&quot;update mytable set name &#x3D; ? where id &#x3D; ?&quot;, name, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，SQL 语句具有行参数的占位符。您可以将参数值作为 varargs 传递，或者作为 objects 的 array 传递。因此，您应该在原始 wrapper classes 中显式包装 primitives，或者您应该使用 auto-boxing。</p>
<h4 id="检索-Auto-generated-键"><a href="#检索-Auto-generated-键" class="headerlink" title="检索 Auto-generated 键"></a>检索 Auto-generated 键</h4><p><code>update()</code>便捷方法支持检索数据库生成的主键。这种支持是 JDBC 3.0 标准的一部分。有关详细信息，请参阅规范的第 13.6 章。该方法将<code>PreparedStatementCreator</code>作为其第一个参数，这是指定所需的 insert 语句的方式。另一个参数是<code>KeyHolder</code>，它包含从更新成功 return 时生成的 key。没有标准的单一方法来创建适当的<code>PreparedStatement</code>(这解释了为什么方法签名就是这样)。以下 example 适用于 Oracle，但可能无法在其他平台上运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final String INSERT_SQL &#x3D; &quot;insert into my_test (name) values(?)&quot;;</span><br><span class="line">final String name &#x3D; &quot;Rob&quot;;</span><br><span class="line"></span><br><span class="line">KeyHolder keyHolder &#x3D; new GeneratedKeyHolder();</span><br><span class="line">jdbcTemplate.update(</span><br><span class="line">    new PreparedStatementCreator() &#123;</span><br><span class="line">        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException &#123;</span><br><span class="line">            PreparedStatement ps &#x3D; connection.prepareStatement(INSERT_SQL, new String[] &#123;&quot;id&quot;&#125;);</span><br><span class="line">            ps.setString(1, name);</span><br><span class="line">            return ps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    keyHolder);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; keyHolder.getKey() now contains the generated key</span><br></pre></td></tr></table></figure>
<h3 id="控制数据库连接"><a href="#控制数据库连接" class="headerlink" title="控制数据库连接"></a>控制数据库连接</h3><p>本节包括：</p>
<ul>
<li><a href="#[使用 DataSource">使用 DataSource</a></li>
<li><a href="#使用 DataSourceUtils">使用 DataSourceUtils</a></li>
<li><a href="#实现 SmartDataSource">实现 SmartDataSource</a></li>
<li><a href="#扩展 AbstractDataSource">扩展 AbstractDataSource</a></li>
<li><a href="#使用 SingleConnectionDataSource">使用 SingleConnectionDataSource</a></li>
<li><a href="#使用 DriverManagerDataSource]">使用 DriverManagerDataSource</a></li>
<li><a href="#使用 TransactionAwareDataSourceProxy">使用 TransactionAwareDataSourceProxy</a></li>
<li><a href="#使用 DataSourceTransactionManager">使用 DataSourceTransactionManager</a></li>
</ul>
<h4 id="使用-DataSource"><a href="#使用-DataSource" class="headerlink" title="使用 DataSource"></a>使用 DataSource</h4><p>Spring 通过<code>DataSource</code>获取与数据库的连接。 <code>DataSource</code>是 JDBC 规范的一部分，是一个通用的连接工厂。它允许容器或 framework 隐藏 application code 中的连接池和 transaction management 问题。作为开发人员，您无需了解有关如何连接到数据库的详细信息。这是设置数据源的管理员的责任。您最有可能在开发和测试 code 时填充这两个角色，但您不一定要知道如何配置 production 数据源。</p>
<p>当您使用 Spring 的 JDBC 层时，您可以从 JNDI 获取数据源，或者您可以使用第三方提供的连接池 implementation 配置您自己的数据源。流行的 implementations 是 Apache Jakarta Commons _DBCP 和 C3P0。 Spring 发行版中的实现仅用于测试目的，不提供合并。</p>
<p>本节使用 Spring 的<code>DriverManagerDataSource</code> implementation，稍后将介绍几个额外的 implementation。</p>
<blockquote>
<p>您应该仅将<code>DriverManagerDataSource</code> class 用于测试目的，因为它不提供池，并且在进行多个连接请求时性能很差。</p>
</blockquote>
<p>要配置<code>DriverManagerDataSource</code>：</p>
<ul>
<li>通常获取 JDBC 连接时，与<code>DriverManagerDataSource</code>建立连接。</li>
<li>指定 JDBC 驱动程序的完全限定类名，以便<code>DriverManager</code>可以加载驱动程序 class。</li>
<li>提供不同 JDBC 驱动程序之间的 URL。 (有关正确的 value.)，请参阅驱动程序的文档</li>
<li>提供用户名和密码以连接到数据库。</li>
</ul>
<p>以下 example 显示了如何在 Java 中配置<code>DriverManagerDataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DriverManagerDataSource dataSource &#x3D; new DriverManagerDataSource();</span><br><span class="line">dataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);</span><br><span class="line">dataSource.setUrl(&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:&quot;);</span><br><span class="line">dataSource.setUsername(&quot;sa&quot;);</span><br><span class="line">dataSource.setPassword(&quot;&quot;);</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了相应的 XML configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>接下来的两个示例显示了 DBCP 和 C3P0 的基本连接和 configuration。要了解有助于控制池 features 的更多选项，请参阅相应连接池 implementations 的产品文档。</p>
<p>以下 example 显示了 DBCP configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了 C3P0 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClass&quot; value&#x3D;&quot;$&#123;jdbc.driverClassName&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jdbcUrl&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;context:property-placeholder location&#x3D;&quot;jdbc.properties&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用-DataSourceUtils"><a href="#使用-DataSourceUtils" class="headerlink" title="使用 DataSourceUtils"></a>使用 DataSourceUtils</h4><p><code>DataSourceUtils</code> class 是一个方便且强大的帮助器 class，它提供<code>static</code>方法以在必要时从 JNDI 获取连接并关闭连接。它支持 thread-bound 连接，例如，<code>DataSourceTransactionManager</code>。</p>
<h4 id="实现-SmartDataSource"><a href="#实现-SmartDataSource" class="headerlink" title="实现 SmartDataSource"></a>实现 SmartDataSource</h4><p><code>SmartDataSource</code>接口应该由可以提供与关系数据库的连接的 classes 实现。它扩展了<code>DataSource</code>接口，让 classes 使用它来查询是否应该在给定的操作后关闭连接。当您知道需要重用连接时，此用法很有效。</p>
<h4 id="扩展-AbstractDataSource"><a href="#扩展-AbstractDataSource" class="headerlink" title="扩展 AbstractDataSource"></a>扩展 AbstractDataSource</h4><p><code>AbstractDataSource</code>是 Spring 的<code>DataSource</code> __mplement 的<code>abstract</code> base class。它为所有<code>DataSource</code> implementations 实现 common common。如果编写自己的<code>DataSource</code> implementation，则应扩展<code>AbstractDataSource</code> class。</p>
<h4 id="使用-SingleConnectionDataSource"><a href="#使用-SingleConnectionDataSource" class="headerlink" title="使用 SingleConnectionDataSource"></a>使用 SingleConnectionDataSource</h4><p><code>SingleConnectionDataSource</code> class 是<code>SmartDataSource</code>接口的 implementation，它包装了每次使用后未关闭的单个<code>Connection</code>。这不是 multi-threading 能力。</p>
<p>如果任何 client code calls <code>close</code>假设池化连接(如使用持久性工具时)，则应将<code>suppressClose</code> property 设置为<code>true</code>。此设置返回包装物理连接的 close-suppressing 代理。请注意，您不能再将其强制转换为本机 Oracle <code>Connection</code>或类似的 object。</p>
<p><code>SingleConnectionDataSource</code>主要是测试 class。例如，它可以在一个简单的 JNDI 环境中轻松测试 application 服务器外部的 code。与<code>DriverManagerDataSource</code>相比，它在所有 time 中重用相同的连接，避免过多地创建物理连接。</p>
<h4 id="使用-DriverManagerDataSource"><a href="#使用-DriverManagerDataSource" class="headerlink" title="使用 DriverManagerDataSource"></a>使用 DriverManagerDataSource</h4><p><code>DriverManagerDataSource</code> class 是标准<code>DataSource</code>接口的 implementation，它通过 bean properties 配置普通的 JDBC 驱动程序，并且每 time 返回一个新的<code>Connection</code>。</p>
<p>此 implementation 对于 Java EE 容器外部的测试和 stand-alone 环境非常有用，可以作为 Spring IoC 容器中的<code>DataSource</code> bean 或与简单的 JNDI 环境结合使用。 Pool-assuming <code>Connection.close()</code> calls 关闭连接，因此任何<code>DataSource</code> -aware 持久性 code 都应该有效。但是，即使在测试环境中，使用 JavaBean-style 连接池(例如<code>commons-dbcp</code>)也非常容易，因此使用这样的连接池几乎总是优于<code>DriverManagerDataSource</code>。</p>
<h4 id="使用-TransactionAwareDataSourceProxy"><a href="#使用-TransactionAwareDataSourceProxy" class="headerlink" title="使用 TransactionAwareDataSourceProxy"></a>使用 TransactionAwareDataSourceProxy</h4><p><code>TransactionAwareDataSourceProxy</code>是目标<code>DataSource</code>的代理。代理包装目标<code>DataSource</code>以添加 Spring-managed transactions 的意识。在这方面，它类似于 Java EE 服务器提供的 transactional JNDI <code>DataSource</code>。</p>
<blockquote>
<p>除非必须调用已经存在的 code 并传递标准 JDBC <code>DataSource</code>接口 implementation，否则很少使用此 class。在这种情况下，您仍然可以使此 code 可用，并且在同一时间，让 code 参与 Spring managed transactions。通常最好使用资源 management 的更高 level 抽象来编写自己的新 code，例如<code>JdbcTemplate</code>或<code>DataSourceUtils</code>。</p>
</blockquote>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jdbc/datasource/TransactionAwareDataSourceProxy.html">类 TransactionAwareDataSourceProxy</a> javadoc。</p>
<h4 id="使用-DataSourceTransactionManager"><a href="#使用-DataSourceTransactionManager" class="headerlink" title="使用 DataSourceTransactionManager"></a>使用 DataSourceTransactionManager</h4><p><code>DataSourceTransactionManager</code> class 是单个 JDBC 数据源的<code>PlatformTransactionManager</code> implementation。它将 JDBC 连接从指定的数据源绑定到当前正在执行的线程，可能允许每个数据源一个线程连接。</p>
<p>Application code 需要通过<code>DataSourceUtils.getConnection(DataSource)</code>而不是 Java EE 的标准<code>DataSource.getConnection</code>来检索 JDBC 连接。它会抛出未经检查的<code>org.springframework.dao</code> exceptions 而不是选中<code>SQLExceptions</code>。所有 framework classes(例如<code>JdbcTemplate</code>)都隐式使用此策略。如果不与此 transaction manager 一起使用，则查找策略的行为与 common 完全相同。因此，它可以在任何情况下使用。</p>
<p><code>DataSourceTransactionManager</code> class 支持自定义隔离级别和超时，这些级别和超时将作为适当的 JDBC 语句查询超时应用。要支持后者，application code 必须使用<code>JdbcTemplate</code>或为每个创建的语句调用<code>DataSourceUtils.applyTransactionTimeout(..)</code>方法。</p>
<p>您可以在 single-resource 情况下使用此 implementation 而不是<code>JtaTransactionManager</code>，因为它不需要容器支持 JTA。如果您坚持所需的连接查找 pattern，则在两者之间切换只是 configuration 的问题。 JTA 不支持自定义隔离级别。</p>
<h3 id="JDBC-批处理操作"><a href="#JDBC-批处理操作" class="headerlink" title="JDBC 批处理操作"></a>JDBC 批处理操作</h3><p>如果将多个 calls 批处理到同一个预准备语句，则大多数 JDBC 驱动程序都会提供改进的 performance。通过将更新分组到批次中，可以限制到数据库的往返次数。</p>
<h4 id="使用-JdbcTemplate-进行基本批处理操作"><a href="#使用-JdbcTemplate-进行基本批处理操作" class="headerlink" title="使用 JdbcTemplate 进行基本批处理操作"></a>使用 JdbcTemplate 进行基本批处理操作</h4><p>您通过实现特殊接口<code>BatchPreparedStatementSetter</code>的两个方法，并将 implementation 作为<code>batchUpdate</code>方法调用中的第二个参数传递来完成<code>JdbcTemplate</code>批处理。您可以使用<code>getBatchSize</code>方法提供当前批次的大小。您可以使用<code>setValues</code>方法设置预准备语句的参数值。此方法称为您在<code>getBatchSize</code>调用中指定的次数。以下 example 根据列表中的条目更新<code>actor</code> table，整个列表用作批处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcActorDao</span> <span class="keyword">implements</span> <span class="title">ActorDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] batchUpdate(<span class="keyword">final</span> List&lt;Actor&gt; actors) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate.batchUpdate(</span><br><span class="line">                <span class="string">&quot;update t_actor set first_name = ?, last_name = ? where id = ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> BatchPreparedStatementSetter() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValues</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                        ps.setString(<span class="number">1</span>, actors.get(i).getFirstName());</span><br><span class="line">                        ps.setString(<span class="number">2</span>, actors.get(i).getLastName());</span><br><span class="line">                        ps.setLong(<span class="number">3</span>, actors.get(i).getId().longValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getBatchSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> actors.size();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您处理更新流或从文件读取，则可能具有首选批量大小，但最后一批可能没有该数量的条目。在这种情况下，您可以使用<code>InterruptibleBatchPreparedStatementSetter</code>接口，该接口允许您在输入源耗尽时中断批处理。 <code>isBatchExhausted</code>方法允许您发出批次结束的信号。</p>
<h4 id="使用-Objects-列表的批处理操作"><a href="#使用-Objects-列表的批处理操作" class="headerlink" title="使用 Objects 列表的批处理操作"></a>使用 Objects 列表的批处理操作</h4><p><code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>都提供了另一种提供批量更新的方法。您可以将调用中的所有参数值作为列表提供，而不是实现特殊的批处理接口。 framework 循环遍历这些值并使用内部预处理语句 setter。 API 会有所不同，具体取决于您是否使用命名参数。对于命名参数，为<code>SqlParameterSource</code>提供 array，为批处理的每个成员提供一个条目。您可以使用<code>SqlParameterSourceUtils.createBatch</code>便捷方法创建此 array，传入 bean-style objects 的 array(使用与参数对应的 getter 方法)，<code>String</code> -keyed <code>Map</code>实例(包含相应参数作为值)，或两者的混合。</p>
<p>以下 example 显示了使用命名参数的批量更新：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private NamedParameterTemplate namedParameterJdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] batchUpdate(List&lt;Actor&gt; actors) &#123;</span><br><span class="line">        return this.namedParameterJdbcTemplate.batchUpdate(</span><br><span class="line">                &quot;update t_actor set first_name &#x3D; :firstName, last_name &#x3D; :lastName where id &#x3D; :id&quot;,</span><br><span class="line">                SqlParameterSourceUtils.createBatch(actors));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于使用经典<code>?</code>占位符的 SQL 语句，您传入包含带有更新值的 object array 的列表。此 object array 必须在 SQL 语句中为每个占位符分配一个条目，并且它们必须与 SQL 语句中定义的顺序相同。</p>
<p>以下 example 与前面的 example 相同，只是它使用经典的 JDBC <code>?</code>占位符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123;</span><br><span class="line">        List&lt;Object[]&gt; batch &#x3D; new ArrayList&lt;Object[]&gt;();</span><br><span class="line">        for (Actor actor : actors) &#123;</span><br><span class="line">            Object[] values &#x3D; new Object[] &#123;</span><br><span class="line">                    actor.getFirstName(), actor.getLastName(), actor.getId()&#125;;</span><br><span class="line">            batch.add(values);</span><br><span class="line">        &#125;</span><br><span class="line">        return this.jdbcTemplate.batchUpdate(</span><br><span class="line">                &quot;update t_actor set first_name &#x3D; ?, last_name &#x3D; ? where id &#x3D; ?&quot;,</span><br><span class="line">                batch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们之前描述的所有批处理更新方法都返回<code>int</code> array，其中包含每个批处理条目的受影响行数。 JDBC 驱动程序报告此计数。如果计数不可用，则 JDBC 驱动程序返回_val的 value。</p>
<blockquote>
<p>在这种情况下，通过在底层<code>PreparedStatement</code>上自动设置值，每个 value 的相应 JDBC 类型需要从给定的 Java 类型派生。虽然这通常很有效，但可能存在问题(例如，Map-contained <code>null</code>值)。 Spring，默认情况下，calls <code>ParameterMetaData.getParameterType</code>在这种情况下，使用 JDBC 驱动程序可能会很昂贵。如果遇到 performance 问题，您应该使用最近的驱动程序 version 并考虑将<code>spring.jdbc.getParameterType.ignore</code> property 设置为<code>true</code>(作为 JVM 系统 property 或 class 路径根目录中的<code>spring.properties</code>文件) - 对于 example，如 Oracle 12c 上报告的那样(SPR-16139)。</p>
</blockquote>
<p>或者，您可以考虑通过’BatchPreparedStatementSetter’(如前所示)，通过给定基于’List <Object[]>‘的调用的显式类型 array，通过自定义’MapSqlParameterSource’上的’registerSqlType’calls 显式指定相应的 JDBC 类型实例，或通过’BeanPropertySqlParameterSource’，即使对于 null value，它也从 Java-declared property 类型派生 SQL 类型。</p>
<h4 id="多批次批处理操作"><a href="#多批次批处理操作" class="headerlink" title="多批次批处理操作"></a>多批次批处理操作</h4><p>批量更新的前一个示例处理的批量非常大，您希望将它们分成几个较小的批次。您可以使用前面提到的方法通过对<code>batchUpdate</code>方法进行多次 calls 来完成此操作，但现在有一种更方便的方法。除了 SQL 语句之外，此方法还包含<code>Collection</code>个 objects，其中包含参数，每个批次要进行的更新次数，以及<code>ParameterizedPreparedStatementSetter</code>来设置预准备语句的参数值。 framework 循环提供的值并将 update calls 分解为指定大小的批处理。</p>
<p>以下 example 显示批量更新使用批量大小 100：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[][] batchUpdate(final Collection&lt;Actor&gt; actors) &#123;</span><br><span class="line">        int[][] updateCounts &#x3D; jdbcTemplate.batchUpdate(</span><br><span class="line">                &quot;update t_actor set first_name &#x3D; ?, last_name &#x3D; ? where id &#x3D; ?&quot;,</span><br><span class="line">                actors,</span><br><span class="line">                100,</span><br><span class="line">                new ParameterizedPreparedStatementSetter&lt;Actor&gt;() &#123;</span><br><span class="line">                    public void setValues(PreparedStatement ps, Actor argument) throws SQLException &#123;</span><br><span class="line">                        ps.setString(1, argument.getFirstName());</span><br><span class="line">                        ps.setString(2, argument.getLastName());</span><br><span class="line">                        ps.setLong(3, argument.getId().longValue());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        return updateCounts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此调用的批处理更新方法返回<code>int</code>数组的 array，其中包含每个批处理的 array 条目，每个更新的受影响行数为 array。 top level array 的长度表示执行的批次数，第二 level array 的长度表示该批次中的更新数。每个批次中的更新数量应该是为所有批次提供的批量大小(最后一个批次可能更少)，具体取决于提供的更新对象的总数。每个更新语句的更新计数是 JDBC 驱动程序报告的更新计数。如果计数不可用，则 JDBC 驱动程序返回_val的 value。</p>
<h3 id="使用-SimpleJdbc-Classes-简化-JDBC-操作"><a href="#使用-SimpleJdbc-Classes-简化-JDBC-操作" class="headerlink" title="使用 SimpleJdbc Classes 简化 JDBC 操作"></a>使用 SimpleJdbc Classes 简化 JDBC 操作</h3><p><code>SimpleJdbcInsert</code>和<code>SimpleJdbcCall</code> classes 通过利用可通过 JDBC 驱动程序检索的数据库元数据来提供简化的 configuration。这意味着您可以更少地预先配置，但如果您希望提供 code 中的所有详细信息，则可以覆盖或关闭元数据处理。</p>
<h4 id="使用-SimpleJdbcInsert-插入数据"><a href="#使用-SimpleJdbcInsert-插入数据" class="headerlink" title="使用 SimpleJdbcInsert 插入数据"></a>使用 SimpleJdbcInsert 插入数据</h4><p>我们首先使用最少量的 configuration 选项查看<code>SimpleJdbcInsert</code> class。您应该在数据访问层的初始化方法中实例化<code>SimpleJdbcInsert</code>。对于此 example，初始化方法是<code>setDataSource</code>方法。您不需要继承<code>SimpleJdbcInsert</code> class。相反，您可以使用<code>withTableName</code>方法创建新实例并设置 table name。 _class 的 Configuration 方法遵循<code>fluid</code>样式，该样式返回<code>SimpleJdbcInsert</code>的实例，它允许您链接所有 configuration 方法。以下 example 仅使用一个 configuration 方法(稍后我们将显示多个方法的示例)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcInsert insertActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.insertActor &#x3D; new SimpleJdbcInsert(dataSource).withTableName(&quot;t_actor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Actor actor) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; parameters &#x3D; new HashMap&lt;String, Object&gt;(3);</span><br><span class="line">        parameters.put(&quot;id&quot;, actor.getId());</span><br><span class="line">        parameters.put(&quot;first_name&quot;, actor.getFirstName());</span><br><span class="line">        parameters.put(&quot;last_name&quot;, actor.getLastName());</span><br><span class="line">        insertActor.execute(parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用的<code>execute</code>方法将普通<code>java.util.Map</code>作为唯一参数。这里要注意的重要一点是，用于<code>Map</code>的键必须 match table 的_list，如数据库中定义的那样。这是因为我们读取元数据来构造实际的 insert 语句。</p>
<h4 id="使用-SimpleJdbcInsert-检索-Auto-generated-键"><a href="#使用-SimpleJdbcInsert-检索-Auto-generated-键" class="headerlink" title="使用 SimpleJdbcInsert 检索 Auto-generated 键"></a>使用 SimpleJdbcInsert 检索 Auto-generated 键</h4><p>下一个 example 使用与前面的 example 相同的 insert，但是，它不是传入<code>id</code>，而是检索 auto-generated key 并在新的<code>Actor</code> object 上设置它。当它创建<code>SimpleJdbcInsert</code>时，除了指定 table name 之外，它还使用<code>usingGeneratedKeyColumns</code>方法指定生成的 key 列的 name。以下清单显示了它的工作原理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcInsert insertActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.insertActor &#x3D; new SimpleJdbcInsert(dataSource)</span><br><span class="line">                .withTableName(&quot;t_actor&quot;)</span><br><span class="line">                .usingGeneratedKeyColumns(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Actor actor) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; parameters &#x3D; new HashMap&lt;String, Object&gt;(2);</span><br><span class="line">        parameters.put(&quot;first_name&quot;, actor.getFirstName());</span><br><span class="line">        parameters.put(&quot;last_name&quot;, actor.getLastName());</span><br><span class="line">        Number newId &#x3D; insertActor.executeAndReturnKey(parameters);</span><br><span class="line">        actor.setId(newId.longValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用第二种方法运行 insert 时的主要区别在于，不要将<code>id</code>添加到<code>Map</code>，而是调用<code>executeAndReturnKey</code>方法。这将返回一个<code>java.lang.Number</code> object，您可以使用该对象创建域 class 中使用的数字类型的实例。您不能依赖所有数据库来返回特定的 Java class。 <code>java.lang.Number</code>是您可以信赖的 base class。如果您有多个 auto-generated 列或生成的值为 non-numeric，则可以使用从<code>executeAndReturnKeyHolder</code>方法返回的<code>KeyHolder</code>。</p>
<h4 id="为-SimpleJdbcInsert-指定列"><a href="#为-SimpleJdbcInsert-指定列" class="headerlink" title="为 SimpleJdbcInsert 指定列"></a>为 SimpleJdbcInsert 指定列</h4><p>您可以通过使用<code>usingColumns</code>方法指定列名列表来限制 insert 的列，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcInsert insertActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.insertActor &#x3D; new SimpleJdbcInsert(dataSource)</span><br><span class="line">                .withTableName(&quot;t_actor&quot;)</span><br><span class="line">                .usingColumns(&quot;first_name&quot;, &quot;last_name&quot;)</span><br><span class="line">                .usingGeneratedKeyColumns(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Actor actor) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; parameters &#x3D; new HashMap&lt;String, Object&gt;(2);</span><br><span class="line">        parameters.put(&quot;first_name&quot;, actor.getFirstName());</span><br><span class="line">        parameters.put(&quot;last_name&quot;, actor.getLastName());</span><br><span class="line">        Number newId &#x3D; insertActor.executeAndReturnKey(parameters);</span><br><span class="line">        actor.setId(newId.longValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert 的执行与依赖元数据确定要使用的列相同。</p>
<h4 id="使用-SqlParameterSource-提供参数值"><a href="#使用-SqlParameterSource-提供参数值" class="headerlink" title="使用 SqlParameterSource 提供参数值"></a>使用 SqlParameterSource 提供参数值</h4><p>使用<code>Map</code>提供参数值工作正常，但它不是最方便使用的 class。 Spring 提供了几个<code>SqlParameterSource</code>接口的 implementations，您可以使用它。第一个是<code>BeanPropertySqlParameterSource</code>，如果你有一个包含你的值的 JavaBean-compliant class，这是一个非常方便的 class。它使用相应的 getter 方法来提取参数值。以下 example 显示了如何使用<code>BeanPropertySqlParameterSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcInsert insertActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.insertActor &#x3D; new SimpleJdbcInsert(dataSource)</span><br><span class="line">                .withTableName(&quot;t_actor&quot;)</span><br><span class="line">                .usingGeneratedKeyColumns(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Actor actor) &#123;</span><br><span class="line">        SqlParameterSource parameters &#x3D; new BeanPropertySqlParameterSource(actor);</span><br><span class="line">        Number newId &#x3D; insertActor.executeAndReturnKey(parameters);</span><br><span class="line">        actor.setId(newId.longValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种选择是类似于<code>Map</code>的<code>MapSqlParameterSource</code>，但提供了一种可以链接的更方便的<code>addValue</code>方法。以下 example 显示了如何使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcInsert insertActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.insertActor &#x3D; new SimpleJdbcInsert(dataSource)</span><br><span class="line">                .withTableName(&quot;t_actor&quot;)</span><br><span class="line">                .usingGeneratedKeyColumns(&quot;id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(Actor actor) &#123;</span><br><span class="line">        SqlParameterSource parameters &#x3D; new MapSqlParameterSource()</span><br><span class="line">                .addValue(&quot;first_name&quot;, actor.getFirstName())</span><br><span class="line">                .addValue(&quot;last_name&quot;, actor.getLastName());</span><br><span class="line">        Number newId &#x3D; insertActor.executeAndReturnKey(parameters);</span><br><span class="line">        actor.setId(newId.longValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，configuration 是相同的。只有执行 code 必须更改为使用这些替代输入 classes。</p>
<h4 id="使用-SimpleJdbcCall-调用存储过程"><a href="#使用-SimpleJdbcCall-调用存储过程" class="headerlink" title="使用 SimpleJdbcCall 调用存储过程"></a>使用 SimpleJdbcCall 调用存储过程</h4><p><code>SimpleJdbcCall</code> class 使用数据库中的元数据来查找<code>in</code>和<code>out</code>参数的名称，这样您就不必显式声明它们。如果您愿意这样做，或者您有没有自动映射到 Java class 的参数(例如<code>ARRAY</code>或<code>STRUCT</code>)，则可以声明参数。第一个 example 显示了一个简单的过程，该过程仅从 MySQL 数据库返回<code>VARCHAR</code>和<code>DATE</code>格式的标量值。 example 过程读取指定的 actor 条目，并以<code>out</code>参数的形式返回<code>first_name</code>，<code>last_name</code>和<code>birth_date</code>列。以下列表显示了第一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE read_actor (</span><br><span class="line">    IN in_id INTEGER,</span><br><span class="line">    OUT out_first_name VARCHAR(100),</span><br><span class="line">    OUT out_last_name VARCHAR(100),</span><br><span class="line">    OUT out_birth_date DATE)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT first_name, last_name, birth_date</span><br><span class="line">    INTO out_first_name, out_last_name, out_birth_date</span><br><span class="line">    FROM t_actor where id &#x3D; in_id;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p><code>in_id</code>参数包含您正在查找的 actor 的<code>id</code>。 <code>out</code>参数 return 从 table 读取的数据。</p>
<p>您可以以类似于声明<code>SimpleJdbcInsert</code>的方式声明<code>SimpleJdbcCall</code>。您应该在 data-access 层的初始化方法中实例化和配置 class。与<code>StoredProcedure</code> class 相比，您无需创建子类，也无需声明可在数据库元数据中查找的参数。以下configuration 的示例使用前面的存储过程(除了<code>DataSource</code>之外，唯一的 configuration 选项是存储过程的 name)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcCall procReadActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        this.procReadActor &#x3D; new SimpleJdbcCall(dataSource)</span><br><span class="line">                .withProcedureName(&quot;read_actor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Actor readActor(Long id) &#123;</span><br><span class="line">        SqlParameterSource in &#x3D; new MapSqlParameterSource()</span><br><span class="line">                .addValue(&quot;in_id&quot;, id);</span><br><span class="line">        Map out &#x3D; procReadActor.execute(in);</span><br><span class="line">        Actor actor &#x3D; new Actor();</span><br><span class="line">        actor.setId(id);</span><br><span class="line">        actor.setFirstName((String) out.get(&quot;out_first_name&quot;));</span><br><span class="line">        actor.setLastName((String) out.get(&quot;out_last_name&quot;));</span><br><span class="line">        actor.setBirthDate((Date) out.get(&quot;out_birth_date&quot;));</span><br><span class="line">        return actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为执行调用而编写的 code 涉及 creating 包含 IN 参数的<code>SqlParameterSource</code>。您必须_输入为输入 value 提供的 name 与存储过程中声明的参数 name 的 name。该案例不必 match，因为您使用元数据来确定应如何在存储过程中引用数据库对象。存储过程的源中指定的内容不一定是存储在数据库中的方式。某些数据库将名称转换为全部大写，而其他数据库使用小写或使用指定的大小写。</p>
<p><code>execute</code>方法接受 IN 参数并返回<code>Map</code>，其中包含由 name 键入的任何<code>out</code>参数，如存储过程中指定的那样。在这种情况下，它们是<code>out_first_name</code>，<code>out_last_name</code>和<code>out_birth_date</code>。</p>
<p><code>execute</code>方法的最后一部分创建一个<code>Actor</code>实例，用于 return 检索的数据。同样，使用<code>out</code>参数的名称非常重要，因为它们在存储过程中声明。此外，结果 map 中存储的<code>out</code>参数名称中的情况与数据库中<code>out</code>参数名称的情况相匹配，这可能因数据库而异。为了使 code 更具可移植性，您应该进行 case-insensitive 查找或指示 Spring 使用<code>LinkedCaseInsensitiveMap</code>。要执行后者，您可以创建自己的<code>JdbcTemplate</code>并将<code>setResultsMapCaseInsensitive</code> property 设置为<code>true</code>。然后，您可以将此自定义的<code>JdbcTemplate</code>实例传递给<code>SimpleJdbcCall</code>的构造函数。以下 example 显示了此 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleJdbcCall procReadActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        jdbcTemplate.setResultsMapCaseInsensitive(true);</span><br><span class="line">        this.procReadActor &#x3D; new SimpleJdbcCall(jdbcTemplate)</span><br><span class="line">                .withProcedureName(&quot;read_actor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过执行此操作，可以避免在用于返回的<code>out</code>参数名称的情况下发生冲突。</p>
<h4 id="显式声明用于-SimpleJdbcCall-的参数"><a href="#显式声明用于-SimpleJdbcCall-的参数" class="headerlink" title="显式声明用于 SimpleJdbcCall 的参数"></a>显式声明用于 SimpleJdbcCall 的参数</h4><p>在本章的前面部分，我们描述了如何从元数据中推导出参数，但如果您愿意，可以明确声明它们。您可以通过使用<code>declareParameters</code>方法创建<code>SimpleJdbcCall</code>来实现此目的，该方法将<code>SqlParameter</code> objects 的可变数量作为输入。有关如何定义<code>SqlParameter</code>的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-params">下一节</a>。</p>
<blockquote>
<p>如果您使用的数据库不是 Spring-supported 数据库，则必须使用显式声明。目前，Spring 支持以下数据库的存储过程 calls 的元数据查找：Apache Derby，DB2，MySQL，Microsoft SQL Server，Oracle 和 Sybase。我们还支持 MySQL，Microsoft SQL Server 和 Oracle 的存储函数的元数据查找。</p>
</blockquote>
<p>您可以选择显式声明一个，部分或全部参数。在未明确声明参数的情况下，仍会使用参数元数据。要绕过对潜在参数的元数据查找的所有处理并仅使用声明的参数，可以将方法<code>withoutProcedureColumnMetaDataAccess</code>作为声明的一部分进行调用。假设您为数据库 function 声明了两个或更多不同的调用签名。在这种情况下，您调用<code>useInParameterNames</code>指定要包含给定签名的 IN 参数名称列表。</p>
<p>以下 example 显示了一个完全声明的过程调用，并使用前面的 example 中的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleJdbcCall procReadActor;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        jdbcTemplate.setResultsMapCaseInsensitive(true);</span><br><span class="line">        this.procReadActor &#x3D; new SimpleJdbcCall(jdbcTemplate)</span><br><span class="line">                .withProcedureName(&quot;read_actor&quot;)</span><br><span class="line">                .withoutProcedureColumnMetaDataAccess()</span><br><span class="line">                .useInParameterNames(&quot;in_id&quot;)</span><br><span class="line">                .declareParameters(</span><br><span class="line">                        new SqlParameter(&quot;in_id&quot;, Types.NUMERIC),</span><br><span class="line">                        new SqlOutParameter(&quot;out_first_name&quot;, Types.VARCHAR),</span><br><span class="line">                        new SqlOutParameter(&quot;out_last_name&quot;, Types.VARCHAR),</span><br><span class="line">                        new SqlOutParameter(&quot;out_birth_date&quot;, Types.DATE)</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个示例的执行和结束结果是相同的。第二个 example 明确指定所有细节，而不是依赖于元数据。</p>
<h4 id="如何定义-SqlParameters"><a href="#如何定义-SqlParameters" class="headerlink" title="如何定义 SqlParameters"></a>如何定义 SqlParameters</h4><p>要为<code>SimpleJdbc</code> classes 以及 RDBMS 操作 classes(在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-object">将 JDBC 操作建模为 Java Objects</a>中涵盖)定义参数，可以使用<code>SqlParameter</code>或其子类之一。为此，通常在构造函数中指定参数 name 和 SQL 类型。 SQL 类型是使用<code>java.sql.Types</code>常量指定的。在本章的前面，我们看到了类似于以下内容的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new SqlParameter(&quot;in_id&quot;, Types.NUMERIC),</span><br><span class="line">new SqlOutParameter(&quot;out_first_name&quot;, Types.VARCHAR),</span><br></pre></td></tr></table></figure>
<p>带<code>SqlParameter</code>的第一个 line 声明一个 IN 参数。您可以使用 IN 参数为存储过程 calls 和查询使用<code>SqlQuery</code>及其子类(在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-SqlQuery">了解 SqlQuery</a>中涵盖)。</p>
<p>第二个 line(带<code>SqlOutParameter</code>)声明了一个<code>out</code>参数，用于存储过程调用。还有<code>SqlInOutParameter</code> for <code>InOut</code>参数(为过程提供 IN value 并且 return value 的参数)。</p>
<blockquote>
<p>仅声明为<code>SqlParameter</code>和<code>SqlInOutParameter</code>的参数用于提供输入值。这与<code>StoredProcedure</code> class 不同，后者(为了向后兼容性)允许为声明为<code>SqlOutParameter</code>的参数提供输入值。</p>
</blockquote>
<p>对于 IN 参数，除了 name 和 SQL 类型之外，还可以为数字数据指定比例，或为自定义数据库类型指定类型 name。对于<code>out</code>参数，您可以提供<code>RowMapper</code>来处理从<code>REF</code>游标返回的行的映射。另一个选项是指定<code>SqlReturnType</code>，它提供了定义 return 值的自定义处理的机会。</p>
<h4 id="使用-SimpleJdbcCall-调用存储的-Function"><a href="#使用-SimpleJdbcCall-调用存储的-Function" class="headerlink" title="使用 SimpleJdbcCall 调用存储的 Function"></a>使用 SimpleJdbcCall 调用存储的 Function</h4><p>除了提供 function name 而不是 procedure name 之外，您可以使用与调用存储过程几乎相同的方式调用存储的 function。您使用<code>withFunctionName</code>方法作为 configuration 的一部分来指示您要调用 function，并生成 function 调用的相应 string。专用的执行调用(<code>executeFunction</code>)用于执行 function，它返回 function return value 作为指定类型的 object，这意味着您不必从结果 map 中检索 return value。类似的便捷方法(名为<code>executeObject</code>)也可用于只有一个<code>out</code>参数的存储过程。以下 example(对于 MySQL)基于一个名为<code>get_actor_name</code>的存储 function，它返回一个 actor 的完整 name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION get_actor_name (in_id INTEGER)</span><br><span class="line">RETURNS VARCHAR(200) READS SQL DATA</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE out_name VARCHAR(200);</span><br><span class="line">    SELECT concat(first_name, &#39; &#39;, last_name)</span><br><span class="line">        INTO out_name</span><br><span class="line">        FROM t_actor where id &#x3D; in_id;</span><br><span class="line">    RETURN out_name;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>要调用此 function，我们再次在初始化方法中创建<code>SimpleJdbcCall</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    private SimpleJdbcCall funcGetActorName;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        jdbcTemplate.setResultsMapCaseInsensitive(true);</span><br><span class="line">        this.funcGetActorName &#x3D; new SimpleJdbcCall(jdbcTemplate)</span><br><span class="line">                .withFunctionName(&quot;get_actor_name&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getActorName(Long id) &#123;</span><br><span class="line">        SqlParameterSource in &#x3D; new MapSqlParameterSource()</span><br><span class="line">                .addValue(&quot;in_id&quot;, id);</span><br><span class="line">        String name &#x3D; funcGetActorName.executeFunction(String.class, in);</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用的<code>executeFunction</code>方法返回，其中包含 function 调用的 return value。</p>
<h4 id="从-SimpleJdbcCall-返回-ResultSet-或-REF-游标"><a href="#从-SimpleJdbcCall-返回-ResultSet-或-REF-游标" class="headerlink" title="从 SimpleJdbcCall 返回 ResultSet 或 REF 游标"></a>从 SimpleJdbcCall 返回 ResultSet 或 REF 游标</h4><p>调用存储过程或返回结果集的 function 有点棘手。某些数据库在 JDBC 结果处理期间返回结果_set，而其他数据库则需要显式注册特定类型的<code>out</code>参数。这两种方法都需要额外的处理来循环结果集并处理返回的行。使用<code>SimpleJdbcCall</code>，您可以使用<code>returningResultSet</code>方法并声明<code>RowMapper</code> implementation 用于特定参数。如果在结果处理期间返回结果集，则不会定义任何名称，因此返回的结果必须_使用声明<code>RowMapper</code> __mplementations 的 order。指定的 name 仍用于在<code>execute</code>语句返回的结果 map 中存储已处理的结果列表。</p>
<p>下一个 example(对于 MySQL)使用一个不带 IN 参数的存储过程，并返回<code>t_actor</code> table 中的所有行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE read_all_actors()</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<p>要调用此过程，可以声明<code>RowMapper</code>。因为要 map 的 class 遵循 JavaBean 规则，所以可以使用通过在<code>newInstance</code>方法中将所需的 class 传递给 map 而创建的<code>BeanPropertyRowMapper</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcActorDao implements ActorDao &#123;</span><br><span class="line"></span><br><span class="line">    private SimpleJdbcCall procReadAllActors;</span><br><span class="line"></span><br><span class="line">    public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">        JdbcTemplate jdbcTemplate &#x3D; new JdbcTemplate(dataSource);</span><br><span class="line">        jdbcTemplate.setResultsMapCaseInsensitive(true);</span><br><span class="line">        this.procReadAllActors &#x3D; new SimpleJdbcCall(jdbcTemplate)</span><br><span class="line">                .withProcedureName(&quot;read_all_actors&quot;)</span><br><span class="line">                .returningResultSet(&quot;actors&quot;,</span><br><span class="line">                BeanPropertyRowMapper.newInstance(Actor.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List getActorsList() &#123;</span><br><span class="line">        Map m &#x3D; procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));</span><br><span class="line">        return (List) m.get(&quot;actors&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ... additional methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execute</code>调用传入空<code>Map</code>，因为此调用不接受任何参数。然后从结果 map 中检索 actor 列表并返回给调用者。</p>
<h3 id="将-JDBC-操作建模为-Java-Objects"><a href="#将-JDBC-操作建模为-Java-Objects" class="headerlink" title="将 JDBC 操作建模为 Java Objects"></a>将 JDBC 操作建模为 Java Objects</h3><p><code>org.springframework.jdbc.object</code>包中包含 classes，允许您以更 object-oriented 的方式访问数据库。作为示例，您可以执行查询并将结果作为包含 business objects 的列表返回，其中关系列数据映射到 business object 的 properties。您还可以 run 存储过程和 run 更新，删除和 insert statements。</p>
<blockquote>
<p>许多 Spring 开发人员认为下面描述的各种 RDBMS 操作 classes(使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-StoredProcedure">StoredProcedure</a> class 的 exception)通常可以用直<code>JdbcTemplate</code> calls 替换。通常，编写一个直接在<code>JdbcTemplate</code>上调用方法的 DAO 方法(而不是将查询封装为 full-blown class)更简单。</p>
</blockquote>
<p>但是，如果您从使用 RDBMS 操作 classes 获得可测量的 value，则应该继续使用这些 classes。</p>
<h4 id="了解-SqlQuery"><a href="#了解-SqlQuery" class="headerlink" title="了解 SqlQuery"></a>了解 SqlQuery</h4><p><code>SqlQuery</code>是一个可重用的 thread-safe class，它封装了一个 SQL 查询。子类必须实现<code>newRowMapper(..)</code>方法以提供<code>RowMapper</code>实例，该实例可以通过迭代在执行查询期间创建的<code>ResultSet</code>而获得的每行创建一个 object。 <code>SqlQuery</code> class 很少直接使用，因为<code>MappingSqlQuery</code>子类为将行映射到 Java classes 提供了更方便的 implementation。延伸<code>SqlQuery</code>的其他 implementation 是<code>MappingSqlQueryWithParameters</code>和<code>UpdatableSqlQuery</code>。</p>
<h4 id="使用-MappingSqlQuery"><a href="#使用-MappingSqlQuery" class="headerlink" title="使用 MappingSqlQuery"></a>使用 MappingSqlQuery</h4><p><code>MappingSqlQuery</code>是一个可重用的查询，其中具体的子类必须实现 abstract <code>mapRow(..)</code>方法，以将提供的<code>ResultSet</code>的每一行转换为指定类型的 object。以下 example 显示了一个自定义查询，该查询将<code>t_actor</code>关系中的数据映射到<code>Actor</code> class 的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class ActorMappingQuery extends MappingSqlQuery&lt;Actor&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public ActorMappingQuery(DataSource ds) &#123;</span><br><span class="line">        super(ds, &quot;select id, first_name, last_name from t_actor where id &#x3D; ?&quot;);</span><br><span class="line">        declareParameter(new SqlParameter(&quot;id&quot;, Types.INTEGER));</span><br><span class="line">        compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException &#123;</span><br><span class="line">        Actor actor &#x3D; new Actor();</span><br><span class="line">        actor.setId(rs.getLong(&quot;id&quot;));</span><br><span class="line">        actor.setFirstName(rs.getString(&quot;first_name&quot;));</span><br><span class="line">        actor.setLastName(rs.getString(&quot;last_name&quot;));</span><br><span class="line">        return actor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class 使用<code>Actor</code>类型扩展<code>MappingSqlQuery</code>参数化。此客户查询的构造函数将<code>DataSource</code>作为唯一参数。在此构造函数中，您可以使用<code>DataSource</code>和应该执行的 SQL 来调用超类上的构造函数，以检索此查询的行。此 SQL 用于创建<code>PreparedStatement</code>，因此它可能包含在执行期间传递的任何参数的占位符。您必须使用传入<code>SqlParameter</code>的<code>declareParameter</code>方法声明每个参数。 <code>SqlParameter</code>采用 name，以及<code>java.sql.Types</code>中定义的 JDBC 类型。定义所有参数后，可以调用<code>compile()</code>方法，以便可以准备语句并稍后运行 run。这个 class 在编译之后是 thread-safe，因此，当初始化 DAO 时，这些实例被创建为 long，它们可以作为实例变量保存并重用。以下 example 显示了如何定义这样的 class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private ActorMappingQuery actorMappingQuery;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">public void setDataSource(DataSource dataSource) &#123;</span><br><span class="line">    this.actorMappingQuery &#x3D; new ActorMappingQuery(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Customer getCustomer(Long id) &#123;</span><br><span class="line">    return actorMappingQuery.findObject(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面 example 中的方法使用作为唯一参数传入的<code>id</code>检索客户。由于我们只想返回一个 object，因此我们使用<code>id</code>作为参数调用<code>findObject</code>便捷方法。如果我们有一个返回 objects 列表并获取其他参数的查询，我们将使用<code>execute</code>方法之一，它将 array 参数值作为 varargs 传入。以下 example 显示了这样一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Actor&gt; searchForActors(int age, String namePattern) &#123;</span><br><span class="line">    List&lt;Actor&gt; actors &#x3D; actorSearchMappingQuery.execute(age, namePattern);</span><br><span class="line">    return actors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-SqlUpdate"><a href="#使用-SqlUpdate" class="headerlink" title="使用 SqlUpdate"></a>使用 SqlUpdate</h4><p><code>SqlUpdate</code> class 封装了 SQL 更新。与查询一样，更新 object 是可重用的，并且与所有<code>RdbmsOperation</code> classes 一样，更新可以具有参数并在 SQL 中定义。这个 class 提供了许多<code>update(..)</code>方法，类似于查询 objects 的<code>execute(..)</code>方法。 <code>SQLUpdate</code> class 是具体的。它可以是子类 - 例如，添加自定义更新方法。但是，您不必为<code>SqlUpdate</code> class 创建子类，因为可以通过设置 SQL 和声明参数来轻松地对其进行参数化。以下 example 创建名为<code>execute</code>的自定义更新方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Types;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.springframework.jdbc.core.SqlParameter;</span><br><span class="line">import org.springframework.jdbc.object.SqlUpdate;</span><br><span class="line"></span><br><span class="line">public class UpdateCreditRating extends SqlUpdate &#123;</span><br><span class="line"></span><br><span class="line">    public UpdateCreditRating(DataSource ds) &#123;</span><br><span class="line">        setDataSource(ds);</span><br><span class="line">        setSql(&quot;update customer set credit_rating &#x3D; ? where id &#x3D; ?&quot;);</span><br><span class="line">        declareParameter(new SqlParameter(&quot;creditRating&quot;, Types.NUMERIC));</span><br><span class="line">        declareParameter(new SqlParameter(&quot;id&quot;, Types.NUMERIC));</span><br><span class="line">        compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param id for the Customer to be updated</span><br><span class="line">     * @param rating the new value for credit rating</span><br><span class="line">     * @return number of rows updated</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int execute(int id, int rating) &#123;</span><br><span class="line">        return update(rating, id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用-StoredProcedure"><a href="#使用-StoredProcedure" class="headerlink" title="使用 StoredProcedure"></a>使用 StoredProcedure</h4><p><code>StoredProcedure</code> class 是 RDBMS 存储过程的 object 抽象的超类。这个 class 是<code>abstract</code>，它的各种<code>execute(..)</code>方法都有<code>protected</code>访问权限，阻止了通过提供更严格 typing 的子类以外的用法。</p>
<p>继承的<code>sql</code> property 是 RDBMS 中存储过程的 name。</p>
<p>要为<code>StoredProcedure</code> class 定义参数，可以使用<code>SqlParameter</code>或其子类之一。您必须在构造函数中指定参数 name 和 SQL 类型，如下面的 code 片段所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new SqlParameter(&quot;in_id&quot;, Types.NUMERIC),</span><br><span class="line">new SqlOutParameter(&quot;out_first_name&quot;, Types.VARCHAR),</span><br></pre></td></tr></table></figure>
<p>使用<code>java.sql.Types</code>常量指定 SQL 类型。</p>
<p>第一个 line(带<code>SqlParameter</code>)声明一个 IN 参数。您可以对存储过程 calls 和使用<code>SqlQuery</code>及其子类(在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-SqlQuery">了解 SqlQuery</a>中涵盖)的查询使用 IN 参数。</p>
<p>第二个 line(带<code>SqlOutParameter</code>)声明了一个<code>out</code>参数，用于存储过程调用。还有一个<code>SqlInOutParameter</code> for <code>InOut</code>参数(为过程提供<code>in</code> value 并且 return value 的参数)。</p>
<p>对于<code>in</code>参数，除了 name 和 SQL 类型之外，还可以为数字数据指定比例，或为自定义数据库类型指定类型 name。对于<code>out</code>参数，您可以提供<code>RowMapper</code>来处理从<code>REF</code>游标返回的行的映射。另一个选项是指定<code>SqlReturnType</code>，它允许您定义 return 值的自定义处理。</p>
<p>简单 DAO 的下一个示例使用<code>StoredProcedure</code>来调用 function(<code>sysdate()</code>)，它随任何 Oracle 数据库一起提供。要使用存储过程功能，您必须创建一个扩展<code>StoredProcedure</code>的 class。在这个 example 中，<code>StoredProcedure</code> class 是一个内部 class。但是，如果需要重用<code>StoredProcedure</code>，则可以将其声明为 top-level class。此 example 没有输入参数，但通过使用<code>SqlOutParameter</code> class 将输出参数声明为 date 类型。 <code>execute()</code>方法运行该过程并从结果<code>Map</code>中提取返回的 date。结果<code>Map</code>通过使用参数 name 作为 key，为每个声明的输出参数(在本例中只有一个)提供了一个条目。以下清单显示了我们的自定义 StoredProcedure class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Types;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.SqlOutParameter;</span><br><span class="line">import org.springframework.jdbc.object.StoredProcedure;</span><br><span class="line"></span><br><span class="line">public class StoredProcedureDao &#123;</span><br><span class="line"></span><br><span class="line">    private GetSysdateProcedure getSysdate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void init(DataSource dataSource) &#123;</span><br><span class="line">        this.getSysdate &#x3D; new GetSysdateProcedure(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getSysdate() &#123;</span><br><span class="line">        return getSysdate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class GetSysdateProcedure extends StoredProcedure &#123;</span><br><span class="line"></span><br><span class="line">        private static final String SQL &#x3D; &quot;sysdate&quot;;</span><br><span class="line"></span><br><span class="line">        public GetSysdateProcedure(DataSource dataSource) &#123;</span><br><span class="line">            setDataSource(dataSource);</span><br><span class="line">            setFunction(true);</span><br><span class="line">            setSql(SQL);</span><br><span class="line">            declareParameter(new SqlOutParameter(&quot;date&quot;, Types.DATE));</span><br><span class="line">            compile();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Date execute() &#123;</span><br><span class="line">            &#x2F;&#x2F; the &#39;sysdate&#39; sproc has no input parameters, so an empty Map is supplied...</span><br><span class="line">            Map&lt;String, Object&gt; results &#x3D; execute(new HashMap&lt;String, Object&gt;());</span><br><span class="line">            Date sysdate &#x3D; (Date) results.get(&quot;date&quot;);</span><br><span class="line">            return sysdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下的示例有两个输出参数(在本例中为 Oracle REF 游标)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import oracle.jdbc.OracleTypes;</span><br><span class="line">import org.springframework.jdbc.core.SqlOutParameter;</span><br><span class="line">import org.springframework.jdbc.object.StoredProcedure;</span><br><span class="line"></span><br><span class="line">public class TitlesAndGenresStoredProcedure extends StoredProcedure &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SPROC_NAME &#x3D; &quot;AllTitlesAndGenres&quot;;</span><br><span class="line"></span><br><span class="line">    public TitlesAndGenresStoredProcedure(DataSource dataSource) &#123;</span><br><span class="line">        super(dataSource, SPROC_NAME);</span><br><span class="line">        declareParameter(new SqlOutParameter(&quot;titles&quot;, OracleTypes.CURSOR, new TitleMapper()));</span><br><span class="line">        declareParameter(new SqlOutParameter(&quot;genres&quot;, OracleTypes.CURSOR, new GenreMapper()));</span><br><span class="line">        compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; execute() &#123;</span><br><span class="line">        &#x2F;&#x2F; again, this sproc has no input parameters, so an empty Map is supplied</span><br><span class="line">        return super.execute(new HashMap&lt;String, Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意<code>TitlesAndGenresStoredProcedure</code>构造函数中使用的<code>declareParameter(..)</code>方法的重载变体是如何传递<code>RowMapper</code> implementation 实例的。这是重用现有功能的一种非常方便和强大的方法。接下来的两个示例为两个<code>RowMapper</code> __mplement 提供了 code。</p>
<p>对于提供的<code>ResultSet</code>中的每一行，<code>TitleMapper</code> class maps 到<code>Title</code>域 object，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import com.foo.domain.Title;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">public final class TitleMapper implements RowMapper&lt;Title&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Title mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">        Title title &#x3D; new Title();</span><br><span class="line">        title.setId(rs.getLong(&quot;id&quot;));</span><br><span class="line">        title.setName(rs.getString(&quot;name&quot;));</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于提供的<code>ResultSet</code>中的每一行，<code>GenreMapper</code> class maps 到<code>Genre</code>域 object，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import com.foo.domain.Genre;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">public final class GenreMapper implements RowMapper&lt;Genre&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Genre mapRow(ResultSet rs, int rowNum) throws SQLException &#123;</span><br><span class="line">        return new Genre(rs.getString(&quot;name&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将参数传递给在 RDBMS 的定义中具有一个或多个输入参数的存储过程，您可以 code 一个强类型的<code>execute(..)</code>方法，该方法将委托给超类中的无类型<code>execute(Map)</code>方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Types;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import oracle.jdbc.OracleTypes;</span><br><span class="line">import org.springframework.jdbc.core.SqlOutParameter;</span><br><span class="line">import org.springframework.jdbc.core.SqlParameter;</span><br><span class="line">import org.springframework.jdbc.object.StoredProcedure;</span><br><span class="line"></span><br><span class="line">public class TitlesAfterDateStoredProcedure extends StoredProcedure &#123;</span><br><span class="line"></span><br><span class="line">    private static final String SPROC_NAME &#x3D; &quot;TitlesAfterDate&quot;;</span><br><span class="line">    private static final String CUTOFF_DATE_PARAM &#x3D; &quot;cutoffDate&quot;;</span><br><span class="line"></span><br><span class="line">    public TitlesAfterDateStoredProcedure(DataSource dataSource) &#123;</span><br><span class="line">        super(dataSource, SPROC_NAME);</span><br><span class="line">        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);</span><br><span class="line">        declareParameter(new SqlOutParameter(&quot;titles&quot;, OracleTypes.CURSOR, new TitleMapper()));</span><br><span class="line">        compile();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; execute(Date cutoffDate) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; inputs &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);</span><br><span class="line">        return super.execute(inputs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参数和数据-Value-处理的常见问题"><a href="#参数和数据-Value-处理的常见问题" class="headerlink" title="参数和数据 Value 处理的常见问题"></a>参数和数据 Value 处理的常见问题</h3><p>参数和数据值的常见问题存在于 Spring Framework 的 JDBC 支持提供的不同方法中。本节介绍如何解决这些问题。</p>
<h4 id="为参数提供-SQL-类型信息"><a href="#为参数提供-SQL-类型信息" class="headerlink" title="为参数提供 SQL 类型信息"></a>为参数提供 SQL 类型信息</h4><p>通常，Spring 根据传入的参数类型确定参数的 SQL 类型。可以显式提供设置参数值时要使用的 SQL 类型。有时需要正确设置<code>NULL</code>值。</p>
<p>您可以通过多种方式提供 SQL 类型信息：</p>
<ul>
<li><code>JdbcTemplate</code>的许多更新和查询方法以<code>int</code> array 的形式获取附加参数。此 array 用于通过使用<code>java.sql.Types</code> class 中的常量值来指示相应参数的 SQL 类型。为每个参数提供一个条目。</li>
<li>您可以使用<code>SqlParameterValue</code> class 来包装需要此附加信息的参数 value。为此，请为每个 value 创建一个新实例，并在构造函数中传入 SQL 类型和参数 value。您还可以为数值提供可选的缩放参数。</li>
<li>对于使用命名参数的方法，可以使用<code>SqlParameterSource</code> classes，<code>BeanPropertySqlParameterSource</code>或<code>MapSqlParameterSource</code>。它们都具有为任何命名参数值注册 SQL 类型的方法。</li>
</ul>
<h4 id="处理-BLOB-和-CLOB-objects"><a href="#处理-BLOB-和-CLOB-objects" class="headerlink" title="处理 BLOB 和 CLOB objects"></a>处理 BLOB 和 CLOB objects</h4><p>您可以存储数据库中的图像，其他二进制数据和大块文本。这些大 objects 被称为 BLOB(二进制大 OBject)用于二进制数据和 CLOB(字符大 OBject)用于字符数据。在 Spring 中，您可以直接使用<code>JdbcTemplate</code>处理这些大型 object，也可以使用 RDBMS Objects 和<code>SimpleJdbc</code> classes 提供的更高抽象。所有这些方法都使用<code>LobHandler</code>接口的 implementation 来实现 LOB(Large OBject)数据的实际管理。 <code>LobHandler</code>通过<code>getLobCreator</code>方法提供对<code>LobCreator</code> class 的访问，该方法用于创建要插入的新 LOB objects。</p>
<p><code>LobCreator</code>和<code>LobHandler</code>为 LOB 输入和输出提供以下支持：</p>
<ul>
<li>BLOB</li>
<li><code>byte[]</code>：<code>getBlobAsBytes</code>和<code>setBlobAsBytes</code></li>
<li><code>InputStream</code>：<code>getBlobAsBinaryStream</code>和<code>setBlobAsBinaryStream</code></li>
<li>CLOB</li>
<li><code>String</code>：<code>getClobAsString</code>和<code>setClobAsString</code></li>
<li><code>InputStream</code>：<code>getClobAsAsciiStream</code>和<code>setClobAsAsciiStream</code></li>
<li><code>Reader</code>：<code>getClobAsCharacterStream</code>和<code>setClobAsCharacterStream</code></li>
</ul>
<p>下一个 example 显示了如何创建和插入 BLOB。稍后我们将展示如何从数据库中读取它。</p>
<p>此 example 使用<code>AbstractLobCreatingPreparedStatementCallback</code>和<code>AbstractLobCreatingPreparedStatementCallback</code>的 implementation。它实现了一个方法<code>setValues</code>。此方法提供了一个<code>LobCreator</code>，我们用它来设置 SQL insert 语句中 LOB 列的值。</p>
<p>对于这个例子，我们假设有一个变量<code>lobHandler</code>，它已经被设置为<code>DefaultLobHandler</code>的一个实例。您通常通过依赖注入设置此 value。</p>
<p>以下 example 显示了如何创建和插入 BLOB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final File blobIn &#x3D; new File(&quot;spring2004.jpg&quot;);</span><br><span class="line">final InputStream blobIs &#x3D; new FileInputStream(blobIn);</span><br><span class="line">final File clobIn &#x3D; new File(&quot;large.txt&quot;);</span><br><span class="line">final InputStream clobIs &#x3D; new FileInputStream(clobIn);</span><br><span class="line">final InputStreamReader clobReader &#x3D; new InputStreamReader(clobIs);</span><br><span class="line"></span><br><span class="line">jdbcTemplate.execute(</span><br><span class="line">    &quot;INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)&quot;,</span><br><span class="line">    new AbstractLobCreatingPreparedStatementCallback(lobHandler) &#123;  (1)</span><br><span class="line">        protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException &#123;</span><br><span class="line">            ps.setLong(1, 1L);</span><br><span class="line">            lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  (2)</span><br><span class="line">            lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  (3)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">blobIs.close();</span><br><span class="line">clobReader.close();</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>传入<code>lobHandler</code>(在此 example 中)是一个普通的<code>DefaultLobHandler</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用方法<code>setClobAsCharacterStream</code>传入 CLOB 的内容。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>使用方法<code>setBlobAsBinaryStream</code>传入 BLOB 的内容。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>如果从<code>DefaultLobHandler.getLobCreator()</code>返回的<code>LobCreator</code>上调用<code>setBlobAsBinaryStream</code>，<code>setClobAsAsciiStream</code>或<code>setClobAsCharacterStream</code>方法，则可以选择为<code>contentLength</code>参数指定负值。如果指定的内容长度为负，则<code>DefaultLobHandler</code>使用 set-stream 方法的 JDBC 4.0 变体而不使用 length 参数。否则，它将指定的长度传递给驱动程序。</p>
</blockquote>
<p>请参阅用于验证它是否支持在不提供内容长度的情况下流式传输 LOB 的 JDBC 驱动程序的文档。</p>
<p>现在是 time 从数据库中读取 LOB 数据。同样，您使用<code>JdbcTemplate</code>与相同的实例变量<code>lobHandler</code>和 reference 到<code>DefaultLobHandler</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map&lt;String, Object&gt;&gt; l &#x3D; jdbcTemplate.query(&quot;select id, a_clob, a_blob from lob_table&quot;,</span><br><span class="line">    new RowMapper&lt;Map&lt;String, Object&gt;&gt;() &#123;</span><br><span class="line">        public Map&lt;String, Object&gt; mapRow(ResultSet rs, int i) throws SQLException &#123;</span><br><span class="line">            Map&lt;String, Object&gt; results &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">            String clobText &#x3D; lobHandler.getClobAsString(rs, &quot;a_clob&quot;);  (1)</span><br><span class="line">            results.put(&quot;CLOB&quot;, clobText);</span><br><span class="line">            byte[] blobBytes &#x3D; lobHandler.getBlobAsBytes(rs, &quot;a_blob&quot;);  (2)</span><br><span class="line">            results.put(&quot;BLOB&quot;, blobBytes);</span><br><span class="line">            return results;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用方法<code>getClobAsString</code>来检索 CLOB 的内容。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用方法<code>getBlobAsBytes</code>来检索 BLOB 的内容。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="传入-IN-条款的-Lists-of-Values"><a href="#传入-IN-条款的-Lists-of-Values" class="headerlink" title="传入 IN 条款的 Lists of Values"></a>传入 IN 条款的 Lists of Values</h4><p>SQL 标准允许基于包含变量值列表的表达式来选择行。典型的 example 将是<code>select * from T_ACTOR where id in (1, 2, 3)</code>。 JDBC 标准不直接支持准备的 statements 这个变量列表。您不能声明可变数量的占位符。您需要准备好所需占位符数量的多种变体，或者一旦知道需要多少占位符，就需要动态生成 SQL string。 <code>NamedParameterJdbcTemplate</code>和<code>JdbcTemplate</code>中提供的命名参数支持采用后一种方法。您可以将值作为<code>java.util.List</code>原始 objects 传递。此列表用于插入所需的占位符并在语句执行期间传入值。</p>
<blockquote>
<p>传递许多值时要小心。 JDBC 标准不保证您可以为<code>in</code>表达式列表使用 100 个以上的值。各种数据库超过此数量，但它们通常对允许的值有多少硬性限制。例如，Oracle 的限制为 1000。</p>
</blockquote>
<p>除了 value 列表中的原始值之外，您还可以创建<code>java.util.List</code>的 object 数组。此列表可以支持为<code>in</code>子句定义的多个表达式，例如<code>select * from T_ACTOR where (id, last_name) in ((1, &#39;Johnson&#39;), (2, &#39;Harrop&#39;\))</code>。当然，这要求您的数据库支持此语法。</p>
<h4 id="处理存储过程的复杂类型-Calls"><a href="#处理存储过程的复杂类型-Calls" class="headerlink" title="处理存储过程的复杂类型 Calls"></a>处理存储过程的复杂类型 Calls</h4><p>调用存储过程时，有时可以使用特定于数据库的复杂类型。为了适应这些类型，Spring 提供<code>SqlReturnType</code>用于在从存储过程调用返回它们时处理它们，并在它们作为参数传入存储过程时<code>SqlTypeValue</code>。</p>
<p><code>SqlReturnType</code>接口有一个必须实现的方法(名为<code>getTypeValue</code>)。此接口用作<code>SqlOutParameter</code>声明的一部分。以下 example 显示返回用户声明类型<code>ITEM_TYPE</code>的 Oracle <code>STRUCT</code> object 的 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class TestItemStoredProcedure extends StoredProcedure &#123;</span><br><span class="line"></span><br><span class="line">    public TestItemStoredProcedure(DataSource dataSource) &#123;</span><br><span class="line">        ...</span><br><span class="line">        declareParameter(new SqlOutParameter(&quot;item&quot;, OracleTypes.STRUCT, &quot;ITEM_TYPE&quot;,</span><br><span class="line">            new SqlReturnType() &#123;</span><br><span class="line">                public Object getTypeValue(CallableStatement cs, int colIndx, int sqlType, String typeName) throws SQLException &#123;</span><br><span class="line">                    STRUCT struct &#x3D; (STRUCT) cs.getObject(colIndx);</span><br><span class="line">                    Object[] attr &#x3D; struct.getAttributes();</span><br><span class="line">                    TestItem item &#x3D; new TestItem();</span><br><span class="line">                    item.setId(((Number) attr[0]).longValue());</span><br><span class="line">                    item.setDescription((String) attr[1]);</span><br><span class="line">                    item.setExpirationDate((java.util.Date) attr[2]);</span><br><span class="line">                    return item;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;));</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>SqlTypeValue</code>将 Java object 的 value(例如<code>TestItem</code>)传递给存储过程。 <code>SqlTypeValue</code>接口有一个必须实现的方法(名为<code>createTypeValue</code>)。传入 active 连接，您可以使用它来创建 database-specific objects，例如<code>StructDescriptor</code>实例或<code>ArrayDescriptor</code>实例。以下 example 创建<code>StructDescriptor</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">final TestItem testItem &#x3D; new TestItem(123L, &quot;A test item&quot;,</span><br><span class="line">        new SimpleDateFormat(&quot;yyyy-M-d&quot;).parse(&quot;2010-12-31&quot;));</span><br><span class="line"></span><br><span class="line">SqlTypeValue value &#x3D; new AbstractSqlTypeValue() &#123;</span><br><span class="line">    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException &#123;</span><br><span class="line">        StructDescriptor itemDescriptor &#x3D; new StructDescriptor(typeName, conn);</span><br><span class="line">        Struct item &#x3D; new STRUCT(itemDescriptor, conn,</span><br><span class="line">        new Object[] &#123;</span><br><span class="line">            testItem.getId(),</span><br><span class="line">            testItem.getDescription(),</span><br><span class="line">            new java.sql.Date(testItem.getExpirationDate().getTime())</span><br><span class="line">        &#125;);</span><br><span class="line">        return item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>您现在可以将此<code>SqlTypeValue</code>添加到<code>Map</code>，其中包含存储过程的<code>execute</code>调用的输入参数。</p>
<p><code>SqlTypeValue</code>的另一个用途是将 array 值传递给 Oracle 存储过程。 Oracle 有自己的内部<code>ARRAY</code> class，在这种情况下必须使用它，您可以使用<code>SqlTypeValue</code>创建 Oracle <code>ARRAY</code>的实例并使用 Java <code>ARRAY</code>中的值填充它，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final Long[] ids &#x3D; new Long[] &#123;1L, 2L&#125;;</span><br><span class="line"></span><br><span class="line">SqlTypeValue value &#x3D; new AbstractSqlTypeValue() &#123;</span><br><span class="line">    protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException &#123;</span><br><span class="line">        ArrayDescriptor arrayDescriptor &#x3D; new ArrayDescriptor(typeName, conn);</span><br><span class="line">        ARRAY idArray &#x3D; new ARRAY(arrayDescriptor, conn, ids);</span><br><span class="line">        return idArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h3><p><code>org.springframework.jdbc.datasource.embedded</code>包提供对嵌入式 Java 数据库引擎的支持。本机提供对<a target="_blank" rel="noopener" href="http://www.hsqldb.org/">HSQL</a>，<a target="_blank" rel="noopener" href="http://www.h2database.com/">H2</a>和<a target="_blank" rel="noopener" href="https://db.apache.org/derby">Derby</a>的支持。您还可以使用可扩展 API 来插入新的嵌入式数据库类型和<code>DataSource</code> __mplement。</p>
<h4 id="为何使用嵌入式数据库？"><a href="#为何使用嵌入式数据库？" class="headerlink" title="为何使用嵌入式数据库？"></a>为何使用嵌入式数据库？</h4><p>嵌入式数据库在项目的开发阶段非常有用，因为它具有轻量级特性。优点包括易于配置，快速启动 time，可测试性以及在开发过程中快速发展 SQL 的能力。</p>
<h4 id="使用-Spring-XML-创建嵌入式数据库"><a href="#使用-Spring-XML-创建嵌入式数据库" class="headerlink" title="使用 Spring XML 创建嵌入式数据库"></a>使用 Spring XML 创建嵌入式数据库</h4><p>如果要在 Spring <code>ApplicationContext</code>中将嵌入式数据库实例公开为 bean，则可以在<code>spring-jdbc</code>命名空间中使用<code>embedded-database</code>标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbc:embedded-database id&#x3D;&quot;dataSource&quot; generate-name&#x3D;&quot;true&quot;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:schema.sql&quot;&#x2F;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:test-data.sql&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jdbc:embedded-database&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 configuration 创建一个嵌入式 HSQL 数据库，该数据库使用 SQL 填充 classpath 根目录中的<code>schema.sql</code>和<code>test-data.sql</code>资源。此外，作为最佳实践，将为嵌入式数据库分配唯一生成的 name。嵌入式数据库作为类型的 bean 可用于 Spring 容器，然后可根据需要将其注入数据访问 objects。</p>
<h4 id="以编程方式创建嵌入式数据库"><a href="#以编程方式创建嵌入式数据库" class="headerlink" title="以编程方式创建嵌入式数据库"></a>以编程方式创建嵌入式数据库</h4><p><code>EmbeddedDatabaseBuilder</code> class 提供了一个 fluent API，用于以编程方式构建嵌入式数据库。当您需要在 stand-alone 环境或 stand-alone integration 测试中创建嵌入式数据库时，可以使用此方法，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EmbeddedDatabase db &#x3D; new EmbeddedDatabaseBuilder()</span><br><span class="line">        .generateUniqueName(true)</span><br><span class="line">        .setType(H2)</span><br><span class="line">        .setScriptEncoding(&quot;UTF-8&quot;)</span><br><span class="line">        .ignoreFailedDrops(true)</span><br><span class="line">        .addScript(&quot;schema.sql&quot;)</span><br><span class="line">        .addScripts(&quot;user_data.sql&quot;, &quot;country_data.sql&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)</span><br><span class="line"></span><br><span class="line">db.shutdown()</span><br></pre></td></tr></table></figure>
<p>有关所有支持选项的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html">用于 EmbeddedDatabaseBuilder 的 javadoc</a>。</p>
<p>您还可以使用通过 Java configuration 创建嵌入式数据库，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class DataSourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DataSource dataSource() &#123;</span><br><span class="line">        return new EmbeddedDatabaseBuilder()</span><br><span class="line">                .generateUniqueName(true)</span><br><span class="line">                .setType(H2)</span><br><span class="line">                .setScriptEncoding(&quot;UTF-8&quot;)</span><br><span class="line">                .ignoreFailedDrops(true)</span><br><span class="line">                .addScript(&quot;schema.sql&quot;)</span><br><span class="line">                .addScripts(&quot;user_data.sql&quot;, &quot;country_data.sql&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选择嵌入式数据库类型"><a href="#选择嵌入式数据库类型" class="headerlink" title="选择嵌入式数据库类型"></a>选择嵌入式数据库类型</h4><p>本节介绍如何选择 Spring 支持的三个嵌入式数据库之一。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-using-HSQL">使用 HSQL</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-using-H2">使用 H2</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-using-Derby">使用 Derby</a></li>
</ul>
<h5 id="使用-HSQL"><a href="#使用-HSQL" class="headerlink" title="使用 HSQL"></a>使用 HSQL</h5><p>Spring 支持 HSQL 1.8.0 及以上版本。如果未明确指定类型，HSQL 是默认的嵌入式数据库。要显式指定 HSQL，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>HSQL</code>。如果使用构建器 API，请使用<code>EmbeddedDatabaseType.HSQL</code>调用<code>setType(EmbeddedDatabaseType)</code>方法。</p>
<h5 id="使用-H2"><a href="#使用-H2" class="headerlink" title="使用 H2"></a>使用 H2</h5><p>Spring 支持 H2 数据库。要启用 H2，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>H2</code>。如果使用构建器 API，请使用<code>EmbeddedDatabaseType.H2</code>调用<code>setType(EmbeddedDatabaseType)</code>方法。</p>
<h5 id="使用-Derby"><a href="#使用-Derby" class="headerlink" title="使用 Derby"></a>使用 Derby</h5><p>Spring 支持 Apache Derby 10.5 及以上版本。要启用 Derby，请将<code>embedded-database</code>标记的<code>type</code>属性设置为<code>DERBY</code>。如果使用构建器 API，请使用<code>EmbeddedDatabaseType.DERBY</code>调用<code>setType(EmbeddedDatabaseType)</code>方法。</p>
<h4 id="使用嵌入式数据库测试数据访问逻辑"><a href="#使用嵌入式数据库测试数据访问逻辑" class="headerlink" title="使用嵌入式数据库测试数据访问逻辑"></a>使用嵌入式数据库测试数据访问逻辑</h4><p>嵌入式数据库提供了一种测试数据访问 code 的轻量级方法。下一个 example 是一个使用嵌入式数据库的数据访问 integration 测试模板。当嵌入式数据库不需要跨测试 classes 重用时，使用这样的模板对于 one-offs 非常有用。但是，如果您希望创建在测试套件中共享的嵌入式数据库，请考虑使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-framework">Spring TestContext Framework</a>并将嵌入式数据库配置为 Spring <code>ApplicationContext</code>中的 bean，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-xml">使用 Spring XML 创建嵌入式数据库</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-java">以编程方式创建嵌入式数据库</a>中所述。以下清单显示了测试模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DataAccessIntegrationTestTemplate &#123;</span><br><span class="line"></span><br><span class="line">    private EmbeddedDatabase db;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() &#123;</span><br><span class="line">        &#x2F;&#x2F; creates an HSQL in-memory database populated from default scripts</span><br><span class="line">        &#x2F;&#x2F; classpath:schema.sql and classpath:data.sql</span><br><span class="line">        db &#x3D; new EmbeddedDatabaseBuilder()</span><br><span class="line">                .generateUniqueName(true)</span><br><span class="line">                .addDefaultScripts()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testDataAccess() &#123;</span><br><span class="line">        JdbcTemplate template &#x3D; new JdbcTemplate(db);</span><br><span class="line">        template.query( &#x2F;* ... *&#x2F; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void tearDown() &#123;</span><br><span class="line">        db.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为嵌入式数据库生成唯一名称"><a href="#为嵌入式数据库生成唯一名称" class="headerlink" title="为嵌入式数据库生成唯一名称"></a>为嵌入式数据库生成唯一名称</h4><p>如果测试套件无意中尝试重新创建同一数据库的其他实例，则开发团队经常会遇到嵌入式数据库的错误。如果 XML configuration 文件或<code>@Configuration</code> class 负责创建嵌入式数据库，并且相应的 configuration 随后在同一个测试套件中的多个测试场景中重复使用(即，在同一个 JVM process 中)，则这很容易发生 - 对于 example， integration 测试针对嵌入式数据库，其<code>ApplicationContext</code> configuration 仅在 bean 定义 profiles 为 active 时有所不同。</p>
<p>这种错误的根本原因是 Spring 的<code>EmbeddedDatabaseFactory</code>(由<code>&lt;jdbc:embedded-database&gt;</code> XML 命名空间元素和<code>EmbeddedDatabaseBuilder</code>用于 Java configuration)在内部使用_如果没有另外指定，则将嵌入式数据库的 name 设置为<code>testdb</code>。对于<code>&lt;jdbc:embedded-database&gt;</code>的情况，嵌入式数据库通常被赋予 name 等于 bean 的<code>id</code>(通常类似于<code>dataSource</code>)。因此，后续创建嵌入式数据库的尝试不会产生新的数据库。相反，重用相同的 JDBC 连接 URL，并且尝试创建新的嵌入式数据库实际上指向从相同的 configuration 创建的现有嵌入式数据库。</p>
<p>为了解决这个常见问题，Spring Framework 4.2 支持为嵌入式数据库生成唯一名称。要启用生成的名称，请使用以下选项之一。</p>
<ul>
<li><code>EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()</code></li>
<li><code>EmbeddedDatabaseBuilder.generateUniqueName()</code></li>
<li><code>&lt;jdbc:embedded-database generate-name=&quot;true&quot; … &gt;</code></li>
</ul>
<h4 id="扩展嵌入式数据库支持"><a href="#扩展嵌入式数据库支持" class="headerlink" title="扩展嵌入式数据库支持"></a>扩展嵌入式数据库支持</h4><p>您可以通过两种方式扩展 Spring JDBC 嵌入式数据库支持：</p>
<ul>
<li>实现<code>EmbeddedDatabaseConfigurer</code>以支持新的嵌入式数据库类型。</li>
<li>实现<code>DataSourceFactory</code>以支持新的<code>DataSource</code> implementation，例如用于管理嵌入式数据库连接的连接池。</li>
</ul>
<p>我们鼓励您在<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR">jira.spring.io</a>向 Spring 社区贡献 extensions。</p>
<h3 id="初始化-DataSource"><a href="#初始化-DataSource" class="headerlink" title="初始化 DataSource"></a>初始化 DataSource</h3><p><code>org.springframework.jdbc.datasource.init</code>包提供对初始化现有<code>DataSource</code>的支持。嵌入式数据库支持提供了一个选项，用于为 application 创建<code>DataSource</code>。但是，您有时可能需要初始化在某个服务器上运行的实例。</p>
<h4 id="使用-Spring-XML-初始化数据库"><a href="#使用-Spring-XML-初始化数据库" class="headerlink" title="使用 Spring XML 初始化数据库"></a>使用 Spring XML 初始化数据库</h4><p>如果要初始化数据库并且可以为<code>DataSource</code> bean 提供 reference，则可以在<code>spring-jdbc</code>命名空间中使用<code>initialize-database</code>标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbc:initialize-database data-source&#x3D;&quot;dataSource&quot;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;foo&#x2F;sql&#x2F;db-schema.sql&quot;&#x2F;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;foo&#x2F;sql&#x2F;db-test-data.sql&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jdbc:initialize-database&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 针对数据库运行两个指定的脚本。第一个脚本创建 schema，第二个脚本使用测试数据集填充表。脚本位置也可以是带有通配符的通配符的模式，用于 Spring 中的资源(对于 example，<code>classpath*:/com/foo/**/sql/*-data.sql</code>)。如果使用 pattern，则脚本在其 URL 或文件名的词法 order 中运行。</p>
<p>数据库初始化程序的默认行为是无条件地运行提供的脚本。这可能并不总是您想要的 - 例如，如果您针对已经包含测试数据的数据库运行脚本。通过首先创建表的 common pattern(如前所示)然后插入数据，可以减少意外删除数据的可能性。如果表已经存在，则第一个 step 会失败。</p>
<p>但是，为了更好地控制现有数据的创建和删除，XML 命名空间提供了一些其他选项。第一个是 flag 来打开和关闭初始化。您可以根据环境设置它(例如从系统 properties 或环境 bean 中提取 boolean value)。以下 example 从系统 property 获取 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbc:initialize-database data-source&#x3D;&quot;dataSource&quot;</span><br><span class="line">    enabled&#x3D;&quot;#&#123;systemProperties.INITIALIZE_DATABASE&#125;&quot;&gt; (1)</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jdbc:initialize-database&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从名为<code>INITIALIZE_DATABASE</code>的系统 property 获取<code>enabled</code>的 value。</td>
</tr>
</tbody>
</table>
</div>
<p>控制现有数据发生情况的第二个选择是更容忍失败。为此，您可以控制初始化程序忽略它从脚本执行的 SQL 中的某些错误的能力，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbc:initialize-database data-source&#x3D;&quot;dataSource&quot; ignore-failures&#x3D;&quot;DROPS&quot;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jdbc:initialize-database&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，我们说我们希望脚本有时会针对空数据库运行，并且脚本中有一些<code>DROP</code> statements 因此会失败。因此失败的 SQL <code>DROP</code> statements 将被忽略，但其他失败将导致 exception。如果您的 SQL 方言不支持<code>DROP … IF EXISTS</code>(或类似)，但您希望在 re-creating 之前无条件地删除所有测试数据，这将非常有用。在这种情况下，第一个脚本通常是一组<code>DROP</code> statements，后跟一组<code>CREATE</code> statements。</p>
<p><code>ignore-failures</code>选项可以设置为<code>NONE</code>(默认值)，<code>DROPS</code>(忽略失败的丢弃)或<code>ALL</code>(忽略所有失败)。</p>
<p>如果脚本中根本不存在<code>;</code>字符，则每个语句应由<code>;</code>或新 line 分隔。您可以按脚本控制全局或脚本，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jdbc:initialize-database data-source&#x3D;&quot;dataSource&quot; separator&#x3D;&quot;@@&quot;&gt; (1)</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;myapp&#x2F;sql&#x2F;db-schema.sql&quot; separator&#x3D;&quot;;&quot;&#x2F;&gt; (2)</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;myapp&#x2F;sql&#x2F;db-test-data-1.sql&quot;&#x2F;&gt;</span><br><span class="line">    &lt;jdbc:script location&#x3D;&quot;classpath:com&#x2F;myapp&#x2F;sql&#x2F;db-test-data-2.sql&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;jdbc:initialize-database&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将分隔符脚本设置为<code>@@</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将<code>db-schema.sql</code>的分隔符设置为<code>;</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>在这个 example 中，两个<code>test-data</code>脚本使用<code>@@</code>作为语句分隔符，只有<code>db-schema.sql</code>使用<code>;</code>。此 configuration 指定默认分隔符为<code>@@</code>并覆盖<code>db-schema</code>脚本的默认值。</p>
<p>如果您需要比从 XML 命名空间获得的更多控制，可以直接使用<code>DataSourceInitializer</code>并将其定义为 application 中的 component。</p>
<h5 id="初始化依赖于数据库的其他组件"><a href="#初始化依赖于数据库的其他组件" class="headerlink" title="初始化依赖于数据库的其他组件"></a>初始化依赖于数据库的其他组件</h5><p>一个大的 class 的 applications(那些在 Spring context 启动之后才使用数据库的那些)可以使用数据库初始化程序而没有进一步的复杂化。如果您的 application 不是其中之一，您可能需要阅读本节的 rest。</p>
<p>数据库初始化程序依赖于<code>DataSource</code>实例并运行其初始化回调中提供的脚本(类似于 XML bean 定义中的<code>init-method</code>，component 中的<code>@PostConstruct</code>方法或实现<code>InitializingBean</code>的 component 中的<code>afterPropertiesSet()</code>方法)。如果其他 beans 依赖于相同的数据源并在初始化回调中使用数据源，则可能存在问题，因为数据尚未初始化。 common example 是一个缓存，它急切地初始化并在 application 启动时从数据库加载数据。</p>
<p>要解决此问题，您有两个选择：将缓存初始化策略更改为稍后阶段或确保首先初始化数据库初始化程序。</p>
<p>如果 application 在您的控件中而不是其他方式，则更改缓存初始化策略可能很容易。关于如何实现这一点的一些建议包括：</p>
<ul>
<li>在第一次使用时使缓存初始化，这可以改善 application startup time。</li>
<li>让缓存或初始化缓存的单独 component 实现<code>Lifecycle</code>或<code>SmartLifecycle</code>。当 application context 启动时，您可以通过设置<code>autoStartup</code> flag 自动启动<code>SmartLifecycle</code>，并且可以通过在封闭的 context 上调用<code>ConfigurableApplicationContext.start()</code>来手动启动<code>Lifecycle</code>。</li>
<li>使用 Spring <code>ApplicationEvent</code>或类似的自定义观察器机制来触发缓存初始化。 总是在 context 准备好使用时发布(在所有 beans 初始化之后)，所以这通常是一个有用的 hook(这是<code>SmartLifecycle</code>默认工作的方式)。</li>
</ul>
<p>确保首先初始化数据库初始化程序也很容易。关于如何实现这一点的一些建议包括：</p>
<ul>
<li>依赖 Spring <code>BeanFactory</code>的默认行为，即 beans 在 registration order 中初始化。您可以通过采用@</li>
<li>将<code>DataSource</code>和使用它的业务组件分开并通过将它们放在单独的<code>ApplicationContext</code>实例中来控制它们的启动 order(对于 example，parent context 包含<code>DataSource</code>，child context 包含业务组件)。这个结构在 Spring web applications 中是 common，但可以更普遍地应用。</li>
</ul>
<h2 id="Object-关系映射-ORM-数据访问"><a href="#Object-关系映射-ORM-数据访问" class="headerlink" title="Object 关系映射(ORM)数据访问"></a>Object 关系映射(ORM)数据访问</h2><p>本节介绍使用 Object 关系映射(ORM)时的数据访问。</p>
<h3 id="使用-Spring-介绍-ORM"><a href="#使用-Spring-介绍-ORM" class="headerlink" title="使用 Spring 介绍 ORM"></a>使用 Spring 介绍 ORM</h3><p>Spring Framework 支持与 Java Persistence API(JPA)的 integration，并支持本机 Hibernate 用于资源 management，数据访问 object(DAO)implementations 和 transaction 策略。例如，对于 Hibernate，有 first-class 支持几个方便的 IoC features，可以解决许多典型的 Hibernate integration 问题。您可以通过依赖注入为 OR(object 关系)映射工具配置所有支持的 features。他们可以参与 Spring 的资源和 transaction management，它们符合 Spring 的通用 transaction 和 DAO exception 层次结构。推荐的 integration 样式是针对普通的 Hibernate 或 JPA API 来编码 DAO。</p>
<p>当您创建数据访问应用程序时，Spring 会为您选择的 ORM 层添加重要的增强功能。您可以根据需要利用尽可能多的 integration 支持，并且您应该将此集成工作与构建类似基础架构的成本和风险进行比较 in-house。您可以像使用 library 一样使用大部分 ORM 支持，无论技术如何，因为所有内容都设计为一组可重用的 JavaBeans。 Spring IoC 容器中的 ORM 有助于配置和部署。因此，本节中的大多数示例都显示了 Spring 容器中的 configuration。</p>
<p>使用 Spring Framework 创建 ORM DAO 的好处包括：</p>
<ul>
<li><strong>更容易测试.</strong> Spring 的 IoC 方法可以轻松交换 Hibernate <code>SessionFactory</code>实例，JDBC <code>DataSource</code>实例，transaction managers 和映射 object implementations(如果需要)的 implementations 和 configuration 位置。这反过来使得单独测试每个 persistence-related code 更容易。</li>
<li><strong>公共数据访问 exceptions.</strong> Spring 可以从 ORM 工具中包装 exceptions，将它们从专有(可能已检查)的 exceptions 转换为 common runtime <code>DataAccessException</code>层次结构。这个 feature 允许您处理大多数持久性 exceptions，它们只是在适当的层中，而不会产生令人烦恼的样板捕获，抛出和 exception 声明。您仍然可以根据需要捕获和处理 exceptions。请记住，JDBC exceptions(包括 DB-specific 方言)也会转换为相同的层次结构，这意味着您可以在一致的编程 model 中使用 JDBC 执行某些操作。</li>
<li><strong>常规资源 management.</strong> Spring application 上下文可以处理 Hibernate <code>SessionFactory</code>实例，JPA <code>EntityManagerFactory</code>实例，JDBC <code>DataSource</code>实例和其他相关资源的位置和 configuration。这使得这些值易于管理和更改。 Spring 提供高效，简单，安全的持久性资源处理。对于 example，使用 Hibernate 的相关 code 通常需要使用相同的 Hibernate <code>Session</code>来确保效率和正确的 transaction 处理。 Spring 通过 Hibernate <code>SessionFactory</code>公开当前<code>Session</code>，可以很容易地透明地创建和绑定<code>Session</code>到当前线程。因此，对于任何本地或 JTA transaction 环境，Spring 解决了典型 Hibernate 使用的许多慢性问题。</li>
<li><strong>集成 transaction management.</strong>您可以通过<code>@Transactional</code> annotation 或通过在 XML configuration 文件中显式配置 transaction AOP 建议，使用声明性的 aspect-oriented 编程(AOP)样式方法拦截器包装 ORM code。在这两种情况下，都会为您处理 transaction 语义和 exception 处理(回滚等)。如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-resource-mngmnt">资源和 Transaction Management</a>中所述，您还可以交换各种 transaction managers，而不会影响 ORM-related code。例如，您可以在本地 transactions 和 JTA 之间切换，在两种方案中都可以使用相同的完整服务(例如声明性 transactions)。此外，JDBC-related code 可以与您用于执行 ORM 的 code 进行事务性完全集成。这对于不适合 ORM 的数据访问(例如批处理和 BLOB 流)很有用，但仍需要与 ORM 操作共享 common transactions。</li>
</ul>
<blockquote>
<p>要获得更全面的 ORM 支持，包括对 MongoDB 等替代数据库技术的支持，您可能需要查看<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data/">Spring Data</a>项目套件。如果您是 JPA 用户，<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io</a>的<a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-jpa/">入门使用 JPA 访问数据</a>指南提供了很好的介绍。</p>
</blockquote>
<h3 id="一般-ORM-Integration-注意事项"><a href="#一般-ORM-Integration-注意事项" class="headerlink" title="一般 ORM Integration 注意事项"></a>一般 ORM Integration 注意事项</h3><p>本节重点介绍适用于所有 ORM 技术的注意事项。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-hibernate">Hibernate</a>部分提供了更多详细信息，并在具体的 context 中显示了这些 features 和配置。</p>
<p>Spring 的 ORM integration 的主要目标是清晰的 application 分层(使用任何数据访问和 transaction 技术)以及 application objects 的松散耦合 - 不再需要对数据访问或 transaction 策略的业务服务依赖，不再需要 hard-coded 资源查找，不再需要 hard-to-replace 单身人士，没有更多的定制服务注册。目标是使用一种简单而一致的方法来连接 application objects，使它们保持可重用性并尽可能地避免容器依赖。所有单独的数据访问 features 都可以单独使用，但可以很好地与 Spring 的 application context 概念集成，提供 XML-based configuration 和 cross-referencing 无需 Spring-aware 的普通 JavaBean 实例。在典型的 Spring application 中，许多重要的 objects 是 JavaBeans：数据访问模板，数据访问 objects，transaction managers，使用数据访问的业务服务 objects 和 transaction managers，web 视图解析器，web 控制器使用业务服务，等等。</p>
<h4 id="资源和-Transaction-Management"><a href="#资源和-Transaction-Management" class="headerlink" title="资源和 Transaction Management"></a>资源和 Transaction Management</h4><p>典型的业务应用程序混杂着重复的资源 management code。许多项目试图发明自己的解决方案，有时为了方便编程而牺牲正确的故障处理。 Spring 提出了适当资源处理的简单解决方案，即在 JDBC 的情况下通过模板化 IoC 并为 ORM 技术应用 AOP 拦截器。</p>
<p>基础结构提供适当的资源处理以及将特定 API exceptions 适当转换为未经检查的基础结构 exception 层次结构。 Spring 引入了 DAO exception 层次结构，适用于任何数据访问策略。对于直接 JDBC，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-JdbcTemplate">上一节</a>中提到的<code>JdbcTemplate</code> class 提供连接处理和<code>SQLException</code>到<code>DataAccessException</code>层次的正确转换，包括将 database-specific SQL 错误代码转换为有意义的 exception classes。对于 ORM 技术，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-exception-translation">下一节</a>以了解如何获得相同的 exception 转换优势。</p>
<p>当涉及 transaction management 时，<code>JdbcTemplate</code> class 挂钩到 Spring transaction 支持，并通过各自的 Spring transaction managers 支持 JTA 和 JDBC transactions。对于支持的 ORM 技术，Spring 通过 Hibernate 和 JPA transaction managers 以及 JTA 支持提供 Hibernate 和 JPA 支持。有关 transaction 支持的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction">Transaction Management</a>章节。</p>
<h4 id="Exception翻译"><a href="#Exception翻译" class="headerlink" title="Exception翻译"></a>Exception翻译</h4><p>在 DAO 中使用 Hibernate 或 JPA 时，必须决定如何处理持久性技术的本机 exception classes。 DAO 会抛出<code>HibernateException</code>或<code>PersistenceException</code>的子类，具体取决于技术。这些 exceptions 都是运行时 exceptions，不必声明或捕获。您可能还需要处理<code>IllegalArgumentException</code>和<code>IllegalStateException</code>。这意味着调用者只能将 exceptions 视为通常致命的，除非他们想依赖持久性技术自己的 exception 结构。如果不将调用者绑定到 implementation 策略，则无法捕获特定原因(例如乐观锁定失败)。对于强 ORM-based 或不需要任何特殊 exception 处理(或两者)的应用程序，这个 trade-off 可能是可以接受的。但是，Spring 允许通过<code>@Repository</code> annotation 透明地应用 exception 转换。以下示例(一个用于 Java configuration，一个用于 XML configuration)显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class body here...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Exception translation bean post processor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myProductDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;product.ProductDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>后处理器自动查找所有 exception 转换器(<code>PersistenceExceptionTranslator</code>接口的 implementations)，并建议所有标记有<code>@Repository</code> annotation 的 beans，以便发现的转换器可以拦截并在抛出的 exceptions 上应用适当的转换。</p>
<p>总之，您可以基于普通持久性技术的 API 和 annotations 实现 DAO，同时仍然可以从 Spring 的自定义 exception 层次结构中受益于 Spring-managed transactions，依赖注入和透明 exception 转换(如果需要)。</p>
<h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><p>我们从 Spring 环境中的<a target="_blank" rel="noopener" href="http://www.hibernate.org/">Hibernate 5</a>开始，用它来演示 Spring 对集成 OR 映射器的方法。本节详细介绍了许多问题，并展示了 DAO implementations 和 transaction demarcation 的不同变体。大多数这些模式可以直接转换为所有其他支持的 ORM 工具。然后，本章后面的部分将介绍其他 ORM 技术并展示简要示例。</p>
<blockquote>
<p>从 Spring Framework 5.0 开始，Spring 需要 Hibernate ORM 4.3 或更高版本用于 JPA 支持，甚至 Hibernate ORM 5.0 用于针对本机 Hibernate Session API 进行编程。请注意，Hibernate 团队不再维护 5.1 之前的任何版本，很可能很快就会专注于 5.3.</p>
</blockquote>
<h4 id="Spring-容器中的-SessionFactory-设置"><a href="#Spring-容器中的-SessionFactory-设置" class="headerlink" title="Spring 容器中的 SessionFactory 设置"></a>Spring 容器中的 SessionFactory 设置</h4><p>为避免将 application objects 绑定到 hard-coded 资源查找，您可以在 Spring 容器中将资源(例如 JDBC <code>DataSource</code>或 Hibernate <code>SessionFactory</code>)定义为 beans。需要访问资源的 Application objects 通过 bean references 接收 references 到这些预定义实例，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-hibernate-straight">下一节</a>中的 DAO 定义所示。</p>
<p>以下摘自 XML application context 定义显示了如何在其上设置 JDBC <code>DataSource</code>和 Hibernate <code>SessionFactory</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myDataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;org.hsqldb.jdbcDriver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:9001&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;sa&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;mySessionFactory&quot; class&#x3D;&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;myDataSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mappingResources&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;product.hbm.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;hibernateProperties&quot;&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">                hibernate.dialect&#x3D;org.hibernate.dialect.HSQLDialect</span><br><span class="line">            &lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>从本地 Jakarta Commons _DBCP <code>BasicDataSource</code>切换到 JNDI-located <code>DataSource</code>(通常由 application 服务器管理)只是 configuration 的问题，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;jee:jndi-lookup id&#x3D;&quot;myDataSource&quot; jndi-name&#x3D;&quot;java:comp&#x2F;env&#x2F;jdbc&#x2F;myds&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>您还可以使用 Spring 的<code>JndiObjectFactoryBean</code>/<code>&lt;jee:jndi-lookup&gt;</code>来访问 JNDI-located <code>SessionFactory</code>来检索并公开它。但是，这通常不是 EJB context 之外的 common。</p>
<blockquote>
<p>Spring 还提供<code>LocalSessionFactoryBuilder</code>变体，与<code>@Bean</code> style configuration 和编程设置无缝集成(不涉及<code>FactoryBean</code>)。</p>
</blockquote>
<p><code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>都支持后台引导，Hibernate 初始化 running _ parallel 与给定引导程序执行程序(例如<code>SimpleAsyncTaskExecutor</code>)上的 application 引导程序线程。在<code>LocalSessionFactoryBean</code>上，这可以通过<code>bootstrapExecutor</code> property 获得。在程序的<code>LocalSessionFactoryBuilder</code>上，有一个重载的<code>buildSessionFactory</code>方法，它接受一个 bootstrap executor 参数。</p>
<p>从 Spring Framework 5.1 开始，这样的原生 Hibernate 设置还可以在本机 Hibernate 访问旁边公开 JPA <code>EntityManagerFactory</code>以进行标准 JPA 交互。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-hibernate">JPA 的原生 Hibernate 设置</a>。</p>
<h4 id="基于-Plain-Hibernate-API-实现-DAO"><a href="#基于-Plain-Hibernate-API-实现-DAO" class="headerlink" title="基于 Plain Hibernate API 实现 DAO"></a>基于 Plain Hibernate API 实现 DAO</h4><p>Hibernate 有一个称为上下文会话的 feature，其中 Hibernate 本身管理每个 transaction 的一个当前<code>Session</code>。这大致相当于 Spring 同步 Hibernate <code>Session</code>每 transaction。相应的 DAO implementation 类似于以下 example，基于 plain Hibernate API：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDaoImpl implements ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    public void setSessionFactory(SessionFactory sessionFactory) &#123;</span><br><span class="line">        this.sessionFactory &#x3D; sessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Collection loadProductsByCategory(String category) &#123;</span><br><span class="line">        return this.sessionFactory.getCurrentSession()</span><br><span class="line">                .createQuery(&quot;from test.Product product where product.category&#x3D;?&quot;)</span><br><span class="line">                .setParameter(0, category)</span><br><span class="line">                .list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了将<code>SessionFactory</code>保存在实例变量中之外，此样式类似于 Hibernate reference 文档和示例的样式。我们强烈建议在 Hibernate 的 CaveatEmptor sample application 中对 old-school <code>static</code> <code>HibernateUtil</code> class 进行这样的 instance-based 设置。 (一般情况下，除非绝对 necessary.)，否则不要在<code>static</code>变量中保留任何资源</p>
<p>前面的 DAO example 遵循依赖注入 pattern。它非常适合 Spring IoC 容器，就像它对 Spring 的<code>HibernateTemplate</code>进行编码一样。您还可以在普通 Java 中设置这样的 DAO(例如，在单元测试中)。为此，请实例化它并使用所需的工厂 reference 调用<code>setSessionFactory(..)</code>。作为 Spring bean 定义，DAO 将类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myProductDao&quot; class&#x3D;&quot;product.ProductDaoImpl&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;mySessionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>这种 DAO 风格的主要优点是它仅依赖于 Hibernate API。不需要任何 Spring class 的 import。这从 non-invasiveness 的角度来看很吸引人，并且对于 Hibernate 开发人员来说可能会更自然。</p>
<p>但是，DAO 抛出普通<code>HibernateException</code>(未经检查，因此不必声明或捕获)，这意味着调用者只能将 exceptions 视为通常致命 - 除非他们想要依赖 Hibernate 自己的 exception 层次结构。如果不将调用者绑定到 implementation 策略，则无法捕获特定原因(例如乐观锁定失败)。对于强烈 Hibernate-based 的应用程序，不需要任何特殊的 exception 处理，或两者兼而有之，这种权衡可能是可以接受的。</p>
<p>幸运的是，Spring 的<code>LocalSessionFactoryBean</code>支持 Hibernate 的<code>SessionFactory.getCurrentSession()</code>方法用于任何 Spring transaction 策略，返回当前的 Spring-managed transactional <code>Session</code>，即使是<code>HibernateTransactionManager</code>。该方法的标准行为仍然是 return 当前<code>Session</code>与正在进行的 JTA transaction 相关联，如果有的话。无论您使用 Spring 的<code>JtaTransactionManager</code>，EJB 容器托管 transactions(CMT)还是 JTA，此行为都适用。</p>
<p>总之，您可以基于普通的 Hibernate API 实现 DAO，同时仍然可以参与 Spring-managed transactions。</p>
<h4 id="声明性-Transaction-分界"><a href="#声明性-Transaction-分界" class="headerlink" title="声明性 Transaction 分界"></a>声明性 Transaction 分界</h4><p>我们建议您使用 Spring 的声明性 transaction 支持，它允许您使用 AOP transaction 拦截器替换 Java code 中的显式 transaction 分界 API calls。您可以使用 Java annotations 或 XML 在 Spring 容器中配置此 transaction 拦截器。这种声明式 transaction 功能可以让您保持业务服务不受重复的 transaction demarcation code 的影响，并专注于添加业务逻辑，这是您的 application 的真正值。</p>
<blockquote>
<p>在您继续之前，如果您还没有这样做，我们强烈建议您阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative">声明式 transaction management</a>。</p>
</blockquote>
<p>您可以使用<code>@Transactional</code> annotations 注释服务层，并指示 Spring 容器查找这些注释并为这些带注释的方法提供 transactional 语义。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    public void setProductDao(ProductDao productDao) &#123;</span><br><span class="line">        this.productDao &#x3D; productDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void increasePriceOfAllProductsInCategory(final String category) &#123;</span><br><span class="line">        List productsToChange &#x3D; this.productDao.loadProductsByCategory(category);</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional(readOnly &#x3D; true)</span><br><span class="line">    public List&lt;Product&gt; findAllProducts() &#123;</span><br><span class="line">        return this.productDao.findAllProducts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在容器中，您需要设置<code>PlatformTransactionManager</code> implementation(作为 bean)和<code>&lt;tx:annotation-driven/&gt;</code>条目，在运行时选择<code>@Transactional</code>处理。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- SessionFactory, DataSource, etc. omitted --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;transactionManager&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;tx:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myProductService&quot; class&#x3D;&quot;product.SimpleProductService&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;productDao&quot; ref&#x3D;&quot;myProductDao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="程序化交易划分"><a href="#程序化交易划分" class="headerlink" title="程序化交易划分"></a>程序化交易划分</h4><p>您可以在数据访问服务_任意数量的操作之上，在 application 的更高 level 中划分 transactions。对周围业务服务的实施也没有限制。它只需要 Spring <code>PlatformTransactionManager</code>。同样，后者可以来自任何地方，但最好是通过<code>setTransactionManager(..)</code>方法作为 bean reference。此外，<code>productDAO</code>应该由<code>setProductDao(..)</code>方法设置。以下一对片段在 Spring application context 中显示 transaction manager 和业务服务定义，为业务方法 implementation 显示 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myTxManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;mySessionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myProductService&quot; class&#x3D;&quot;product.ProductServiceImpl&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;transactionManager&quot; ref&#x3D;&quot;myTxManager&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;productDao&quot; ref&#x3D;&quot;myProductDao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">public class ProductServiceImpl implements ProductService &#123;</span><br><span class="line"></span><br><span class="line">    private TransactionTemplate transactionTemplate;</span><br><span class="line">    private ProductDao productDao;</span><br><span class="line"></span><br><span class="line">    public void setTransactionManager(PlatformTransactionManager transactionManager) &#123;</span><br><span class="line">        this.transactionTemplate &#x3D; new TransactionTemplate(transactionManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setProductDao(ProductDao productDao) &#123;</span><br><span class="line">        this.productDao &#x3D; productDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void increasePriceOfAllProductsInCategory(final String category) &#123;</span><br><span class="line">        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;</span><br><span class="line">            public void doInTransactionWithoutResult(TransactionStatus status) &#123;</span><br><span class="line">                List productsToChange &#x3D; this.productDao.loadProductsByCategory(category);</span><br><span class="line">                &#x2F;&#x2F; do the price increase...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 的<code>TransactionInterceptor</code>允许使用回调 code 抛出任何已检查的 application exception，而<code>TransactionTemplate</code>仅限于回调中未经检查的 exceptions。 <code>TransactionTemplate</code>在未经检查的 application exception 的情况下触发回滚，或者 transaction 被 application 标记为 rollback-only(通过设置<code>TransactionStatus</code>)。默认情况下，<code>TransactionInterceptor</code>的行为方式相同，但每个方法允许可配置的回滚 policies。</p>
<h4 id="Transaction-Management-Strategies"><a href="#Transaction-Management-Strategies" class="headerlink" title="Transaction Management Strategies"></a>Transaction Management Strategies</h4><p><code>TransactionTemplate</code>和<code>TransactionInterceptor</code>将实际的 transaction 处理委托给<code>PlatformTransactionManager</code>实例(可以是<code>HibernateTransactionManager</code>(对于单个 Hibernate <code>SessionFactory</code>)，通过使用<code>ThreadLocal</code> <code>Session</code>)或<code>JtaTransactionManager</code>(委托容器的 JTA 子系统)为 Hibernate applications。您甚至可以使用自定义<code>PlatformTransactionManager</code> implementation。从本机 Hibernate transaction management 切换到 JTA(例如，当面对 application 的某些部署面临分布式 transaction 要求时)只是 configuration 的问题。您可以使用 Spring 的 JTA transaction implementation 替换 Hibernate transaction manager。 transaction 划分和数据访问 code 无需更改即可正常工作，因为它们使用通用的 transaction management API。</p>
<p>对于跨多个 Hibernate session 工厂的分布式 transactions，您可以将<code>JtaTransactionManager</code>组合为 transaction 策略和多个<code>LocalSessionFactoryBean</code>定义。然后每个 DAO 将一个特定的<code>SessionFactory</code> reference 传递到其对应的 bean property。如果所有基础 JDBC 数据源都是 transactional 容器，则业务服务可以跨越任意数量的 DAO 和任意数量的 session 工厂划分 transactions，而无需特别考虑，因为它使用<code>JtaTransactionManager</code>作为策略。</p>
<p><code>HibernateTransactionManager</code>和<code>JtaTransactionManager</code>都允许使用 Hibernate 进行正确的 JVM-level 缓存处理，无需 container-specific transaction manager 查找或 JCA 连接器(如果不使用 EJB 来启动 transactions)。</p>
<p><code>HibernateTransactionManager</code>可以_portport Hibernate JDBC <code>Connection</code>到普通 JDBC 访问 code 以获取特定的<code>DataSource</code>。如果您只访问一个数据库，则此功能允许在没有 JTA 的情况下完全混合 Hibernate 和 JDBC 数据访问进行 high-level transaction 划分。如果通过<code>LocalSessionFactoryBean</code> class 的<code>dataSource</code> property 设置 passed-in <code>SessionFactory</code>和<code>DataSource</code>，<code>HibernateTransactionManager</code>会自动将 Hibernate transaction 公开为 JDBC transaction。或者，您可以通过<code>HibernateTransactionManager</code> class 的<code>dataSource</code> property 明确指定 transactions 应该公开的<code>DataSource</code>。</p>
<h4 id="比较-Container-managed-和本地定义的资源"><a href="#比较-Container-managed-和本地定义的资源" class="headerlink" title="比较 Container-managed 和本地定义的资源"></a>比较 Container-managed 和本地定义的资源</h4><p>您可以在 container-managed JNDI <code>SessionFactory</code>和本地定义的之间切换，而无需更改 application code 的单个 line。是将资源定义保留在容器中还是本地保存在 application 中主要是您使用的 transaction 策略的问题。与 Spring-defined local <code>SessionFactory</code>相比，手动注册的 JNDI <code>SessionFactory</code>不提供任何好处。部署<code>SessionFactory</code>到 Hibernate 的 JCA 连接器提供了参与 Java EE 服务器的 management 基础结构的附加 value，但不会添加超出该值的实际 value。</p>
<p>Spring 的 transaction 支持不绑定到容器。使用除 JTA 之外的任何策略进行配置时，transaction 支持也适用于 stand-alone 或测试环境。特别是在 single-database transactions 的典型情况下，Spring 的 single-resource local transaction 支持是 JTA 的轻量级和强大的替代品。当您使用本地 EJB stateless session beans 来驱动 transactions 时，您既依赖于 EJB 容器又依赖于 JTA，即使您只访问单个数据库并仅使用 stateless session beans 通过 container-managed transactions 提供声明性 transactions。以编程方式直接使用 JTA 还需要 Java EE 环境。 JTA 不仅涉及 JTA 本身和 JNDI <code>DataSource</code>实例的容器依赖性。对于 non-Spring，JTA-driven Hibernate transactions，您必须使用 Hibernate JCA 连接器或额外的 Hibernate transaction code 与<code>TransactionManagerLookup</code>配置正确的 JVM-level 缓存。</p>
<p>Spring-driven transactions 可以与本地定义的 Hibernate <code>SessionFactory</code>一样工作，就像它们使用本地 JDBC <code>DataSource</code>一样，前提是它们访问单个数据库。因此，当您具有分布式 transaction 要求时，只需使用 Spring 的 JTA transaction 策略。 JCA 连接器需要 container-specific 部署步骤，并且(显然)首先需要 JCA 支持。与使用本地资源定义和 Spring-driven transactions 部署简单的 web application 相比，此 configuration 需要更多的工作。此外，如果您使用的是 WebLogic Express，则通常需要容器的 Enterprise Edition，而不是提供 JCA。 Spring application 与本地资源和 transactions span 单个数据库在任何 Java EE web 容器(没有 JTA，JCA 或 EJB)中工作，例如 Tomcat，Resin，甚至是普通的 Jetty。此外，您可以轻松地在桌面应用程序或测试套件中重用这样的中间层。</p>
<p>考虑到所有事情，如果你不使用 EJB，坚持使用本地<code>SessionFactory</code>设置和 Spring 的<code>HibernateTransactionManager</code>或<code>JtaTransactionManager</code>。您可以获得所有好处，包括正确的 transactional JVM-level 缓存和分布式 transactions，而不会给容器部署带来不便。通过 JCA 连接器对 Hibernate <code>SessionFactory</code>进行 JNDI 注册只有在与 EJB 一起使用时才会添加 value。</p>
<h4 id="带有-Hibernate-的虚假-Application-Server-警告"><a href="#带有-Hibernate-的虚假-Application-Server-警告" class="headerlink" title="带有 Hibernate 的虚假 Application Server 警告"></a>带有 Hibernate 的虚假 Application Server 警告</h4><p>在一些具有非常严格的<code>XADataSource</code> __mplement(当前只有一些 WebLogic Server 和 WebSphere 版本)的 JTA 环境中，当配置 Hibernate 而不考虑该环境的 JTA <code>PlatformTransactionManager</code> object 时，虚假警告或 exceptions 可以显示在 application server log 中。这些警告或 exceptions 指示正在访问的连接不再有效或 JDBC 访问不再有效，可能是因为 transaction 不再是 active。作为示例，这是 WebLogic 的实际 exception：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.sql.SQLException: The transaction is no longer active - status: &#39;Committed&#39;. No</span><br><span class="line">further JDBC access is allowed within this transaction.</span><br></pre></td></tr></table></figure>
<p>您可以通过让 Hibernate 知道它同步的 JTA <code>PlatformTransactionManager</code>实例(以及 Spring)来解决此警告。您有两种选择：</p>
<ul>
<li>如果在 application context 中，您已经直接获取 JTA <code>PlatformTransactionManager</code> object(可能是从 JNDI 到<code>JndiObjectFactoryBean</code>或<code>&lt;jee:jndi-lookup&gt;</code>)并将其提供给_Spample 的<code>JtaTransactionManager</code>，最简单的方法是指定 bean 定义此 JTA 的 reference <code>PlatformTransactionManager</code>实例作为<code>LocalSessionFactoryBean.</code> property 的 value <code>LocalSessionFactoryBean.</code> Spring 然后使 object 可用于 Hibernate。</li>
<li>更有可能的是，你还没有 JTA <code>PlatformTransactionManager</code>实例，因为 Spring 的<code>JtaTransactionManager</code>可以自己找到它。因此，您需要配置 Hibernate 以直接查找 JTA <code>PlatformTransactionManager</code>。您可以通过在 Hibernate configuration 中配置 application server-specific <code>TransactionManagerLookup</code> class 来完成此操作，如 Hibernate 手册中所述。</li>
</ul>
<p>本节的其余部分描述了在 Hibernate 意识到 JTA <code>PlatformTransactionManager</code>的情况下发生的 events 的顺序。</p>
<p>当 Hibernate 没有配置任何 JTA <code>PlatformTransactionManager</code>的意识时，JTA transaction 提交时会发生以下 events：</p>
<ul>
<li>JTA transaction 提交。</li>
<li>Spring 的<code>JtaTransactionManager</code>与 JTA transaction 同步，因此 JTA transaction manager 通过<code>afterCompletion</code>回调调用它。</li>
<li>在其他活动中，这种同步可以通过 Spring 到 Hibernate 触发回调，通过 Hibernate 的<code>afterTransactionCompletion</code>回调(用于清除 Hibernate 缓存)，然后在 Hibernate session 上调用<code>close()</code>，这会导致 Hibernate 尝试<code>close()</code> JDBC 连接。</li>
<li>在某些环境中，此<code>Connection.close()</code>调用会触发警告或错误，因为 application 服务器不再认为<code>Connection</code>可用，因为 transaction 已经提交。</li>
</ul>
<p>当 Hibernate 配置了 JTA <code>PlatformTransactionManager</code>的意识时，JTA transaction 提交时会发生以下 events：</p>
<ul>
<li>JTA transaction 已准备好提交。</li>
<li>Spring 的<code>JtaTransactionManager</code>与 JTA transaction 同步，因此 transaction 通过 JTA transaction manager 的<code>beforeCompletion</code>回调来回调。</li>
<li>Spring 意识到 Hibernate 本身与 JTA transaction 同步，其行为与前一个场景不同。假设 Hibernate <code>Session</code>需要完全关闭，Spring 现在关闭它。</li>
<li>JTA transaction 提交。</li>
<li>Hibernate 与 JTA transaction 同步，因此 transaction 由 JTA transaction manager 通过<code>afterCompletion</code>回调调用，并可以正确清除其缓存。</li>
</ul>
<h3 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h3><p>在<code>org.springframework.orm.jpa</code>包下可用的 Spring JPA 以类似于与 Hibernate 的 integration 的方式提供对<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html">Java Persistence API</a>的全面支持，同时知道 order 中的基础 implementation 以提供额外的 features。</p>
<h4 id="Spring-环境中-JPA-设置的三个选项"><a href="#Spring-环境中-JPA-设置的三个选项" class="headerlink" title="Spring 环境中 JPA 设置的三个选项"></a>Spring 环境中 JPA 设置的三个选项</h4><p>Spring JPA 支持提供了三种设置 JPA <code>EntityManagerFactory</code>的方法，该方法由 application 用于获取实体 manager。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-setup-lemfb">使用 LocalEntityManagerFactoryBean</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-setup-jndi">从 JNDI 获取 EntityManagerFactory</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-setup-lcemfb">使用 LocalContainerEntityManagerFactoryBean</a></li>
</ul>
<h5 id="使用-LocalEntityManagerFactoryBean"><a href="#使用-LocalEntityManagerFactoryBean" class="headerlink" title="使用 LocalEntityManagerFactoryBean"></a>使用 LocalEntityManagerFactoryBean</h5><p>您只能在简单的部署环境中使用此选项，例如 stand-alone applications 和 integration 测试。</p>
<p><code>LocalEntityManagerFactoryBean</code>创建<code>EntityManagerFactory</code>适用于简单的部署环境，其中 application 仅使用 JPA 进行数据访问。工厂 bean 使用 JPA <code>PersistenceProvider</code> auto-detection 机制(根据 JPA 的 Java SE 引导)，并且在大多数情况下，要求您仅指定持久性单元 name。以下 XML example 配置了这样的 bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myEmf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;persistenceUnitName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;myPersistenceUnit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种形式的 JPA 部署是最简单和最有限的。您不能引用现有的 JDBC <code>DataSource</code> bean 定义，也不存在对 global transactions 的支持。此外，持久 class 的编织(byte-code 转换)是 provider-specific，通常需要在启动时指定特定的 JVM 代理。此选项仅适用于为其设计 JPA 规范的 stand-alone applications 和测试环境。</p>
<h5 id="从-JNDI-获取-EntityManagerFactory"><a href="#从-JNDI-获取-EntityManagerFactory" class="headerlink" title="从 JNDI 获取 EntityManagerFactory"></a>从 JNDI 获取 EntityManagerFactory</h5><p>部署到 Java EE 服务器时，可以使用此选项。检查服务器的文档，了解如何将自定义 JPA 提供程序部署到服务器中，从而允许使用与服务器默认提供程序不同的提供程序。</p>
<p>从 JNDI 获取<code>EntityManagerFactory</code>(对于 Java EE 环境中的 example)，需要更改 XML configuration，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;myEmf&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;persistence/myPersistenceUnit&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此操作假定标准 Java EE 引导。 Java EE 服务器 auto-detects 持久性单元(实际上， applicationjars 中的<code>META-INF/persistence.xml</code> files)和 Java EE 部署描述符中的<code>persistence-unit-ref</code>条目(用于 example，<code>web.xml</code>)，并为这些持久性单元定义环境命名 context 位置。</p>
<p>在这种情况下，整个持久性单元部署(包括持久 classes 的编织(byte-code 转换))由 Java EE 服务器决定。 JDBC <code>DataSource</code>是通过<code>META-INF/persistence.xml</code>文件中的 JNDI 位置定义的。 <code>EntityManager</code> transactions 与服务器的 JTA 子系统集成在一起。 Spring 仅使用获得的<code>EntityManagerFactory</code>，通过依赖注入将其传递给 application objects 并管理持久性单元的 transactions(通常通过<code>JtaTransactionManager</code>)。</p>
<p>如果在同一个 application 中使用多个持久性单元，则此类 JNDI-retrieved 持久性单元的 bean 名称应匹配 application 用于引用它们的持久性单元名称(对于 example，在<code>@PersistenceUnit</code>和<code>@PersistenceContext</code> 注释中)。</p>
<h5 id="使用-LocalContainerEntityManagerFactoryBean"><a href="#使用-LocalContainerEntityManagerFactoryBean" class="headerlink" title="使用 LocalContainerEntityManagerFactoryBean"></a>使用 LocalContainerEntityManagerFactoryBean</h5><p>您可以在 Spring-based application 环境中将此选项用于完整的 JPA 功能。这包括 web 容器，例如 Tomcat，stand-alone applications 和具有复杂持久性要求的 integration 测试。</p>
<blockquote>
<p>如果你想专门配置 Hibernate 设置，一个直接的选择是使用 Hibernate 5.2 或 5.3 并设置一个原生的 Hibernate <code>LocalSessionFactoryBean</code>而不是一个普通的 JPA <code>LocalContainerEntityManagerFactoryBean</code>，让它与 JPA 访问 code 以及本机 Hibernate 访问 code 进行交互。有关详细信息，请参阅<a href="#用于 JPA 交互的原生 Hibernate 设置">用于 JPA 交互的原生 Hibernate 设置</a>。</p>
</blockquote>
<p><code>LocalContainerEntityManagerFactoryBean</code>完全控制<code>EntityManagerFactory</code> configuration，适用于需要 fine-grained 自定义的环境。 <code>LocalContainerEntityManagerFactoryBean</code>基于<code>persistence.xml</code>文件，提供的<code>dataSourceLookup</code>策略和指定的<code>loadTimeWeaver</code>创建<code>PersistenceUnitInfo</code>实例。因此，可以使用 JNDI 之外的自定义数据源并控制编织进程。以下 example 显示了<code>LocalContainerEntityManagerFactoryBean</code>的典型 bean 定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myEmf&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;someDataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;loadTimeWeaver&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下 example 显示了一个典型的<code>persistence.xml</code>文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myUnit&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping-file</span>&gt;</span>META-INF/orm.xml<span class="tag">&lt;/<span class="name">mapping-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclude-unlisted-classes</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>&lt;exclude-unlisted-classes/&gt;</code>快捷方式表示不应扫描带注释的实体 classes。显式的’true’value(<code>&lt;exclude-unlisted-classes&gt;true&lt;/exclude-unlisted-classes/&gt;</code>)也意味着没有扫描。 <code>&lt;exclude-unlisted-classes&gt;false&lt;/exclude-unlisted-classes/&gt;</code>会触发扫描。但是，如果要进行实体 class 扫描，我们建议省略<code>exclude-unlisted-classes</code>元素。</p>
</blockquote>
<p>使用<code>LocalContainerEntityManagerFactoryBean</code>是最强大的 JPA 设置选项，允许在 application 中灵活的本地配置。它支持指向现有 JDBC <code>DataSource</code>的链接，支持 local 和 global transactions 等。但是，它还对运行时环境施加了要求，例如，如果持久性提供程序需要 byte-code 转换，则 weaving-capable class 加载程序的可用性。</p>
<p>此选项可能与 Java EE 服务器的 built-in JPA 功能冲突。在完整的 Java EE 环境中，请考虑从 JNDI 获取<code>EntityManagerFactory</code>。或者，在<code>LocalContainerEntityManagerFactoryBean</code>定义上指定自定义<code>persistenceXmlLocation</code>(对于 example，META-INF/my-persistence.xml)，并在 application jar files 中仅包含具有该 name 的描述符。由于 Java EE 服务器仅查找默认的<code>META-INF/persistence.xml</code> files，因此它会忽略此类自定义持久性单元，因此可以避免与之前的 Spring-driven JPA 设置冲突。 (这适用于 Resin 3.1，适用于 example.)</p>
<p>什么时候需要 load-time 编织？</p>
<p>并非所有 JPA 提供程序都需要 JVM 代理。 Hibernate 是一个没有的示例。如果您的提供商不需要代理或您有其他选择，例如通过自定义编译器或 Ant 任务在 build time 应用增强功能，则不应使用 load-time weaver。</p>
<p><code>LoadTimeWeaver</code>接口是 Spring-provided class，它允许以特定方式插入 JPA <code>ClassTransformer</code>实例，具体取决于环境是 web 容器还是 application 服务器。通过<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">代理人</a>挂钩<code>ClassTransformers</code>通常效率不高。代理程序可以对整个虚拟机进行操作，并检查每个加载的 class，这在 production 服务器环境中通常是不受欢迎的。</p>
<p>Spring 为各种环境提供了许多<code>LoadTimeWeaver</code> _implement，让<code>ClassTransformer</code>实例仅应用于每个 class 加载器而不是每个 VM。</p>
<p>有关<code>LoadTimeWeaver</code> __mplement 及其设置的更多信息，请参阅 AOP 章节中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">Spring configuration</a>，无论是通用的还是针对各种平台定制的(例如 Tomcat，WebLogic，GlassFish，Resin 和 JBoss)。</p>
<p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">Spring configuration</a>中所述，您可以使用<code>context:load-time-weaver</code> XML 元素的<code>@EnableLoadTimeWeaving</code> annotation 配置 context-wide <code>LoadTimeWeaver</code>。所有 JPA <code>LocalContainerEntityManagerFactoryBean</code>实例都会自动选择这样的 global weaver。以下 example 显示了设置 load-time weaver 的首选方法，即提供 auto-detection 平台(WebLogic，GlassFish，Tomcat，Resin，JBoss 或 VM 代理)以及将 weaver 自动传播到所有 weaver-aware beans：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:load-time-weaver&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;emf&quot; class&#x3D;&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>但是，如果需要，您可以通过<code>loadTimeWeaver</code> property 手动指定专用的 weaver，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;emf&quot; class&#x3D;&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;loadTimeWeaver&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>无论如何配置 LTW，通过使用这种技术，依赖于检测的 JPA 应用程序可以在目标平台中运行(对于 example，Tomcat)而无需代理。当托管应用程序依赖于不同的 JPA implementations 时，这一点尤其重要，因为 JPA 变换器仅应用于 class-loader level，因此彼此隔离。</p>
<h5 id="处理多个持久性单元"><a href="#处理多个持久性单元" class="headerlink" title="处理多个持久性单元"></a>处理多个持久性单元</h5><p>对于依赖于多个持久性单元位置的应用程序(存储在 classpath 中的各种 JARS 中，对于 example)，Spring 提供<code>PersistenceUnitManager</code>作为中央 repository 并避免持久性单元 discovery process，这可能很昂贵。默认 implementation 允许指定多个位置。解析这些位置，然后通过持久性单元 name 检索这些位置。 (默认情况下，搜索 classpath <code>META-INF/persistence.xml</code> files.)以下 example 配置多个位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;pum&quot; class&#x3D;&quot;org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;persistenceXmlLocations&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;org&#x2F;springframework&#x2F;orm&#x2F;jpa&#x2F;domain&#x2F;persistence-multi.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;classpath:&#x2F;my&#x2F;package&#x2F;**&#x2F;custom-persistence.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;classpath*:META-INF&#x2F;persistence.xml&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSources&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;localDataSource&quot; value-ref&#x3D;&quot;local-db&quot;&#x2F;&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;remoteDataSource&quot; value-ref&#x3D;&quot;remote-db&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- if no datasource is specified, use this one --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultDataSource&quot; ref&#x3D;&quot;remoteDataSource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;emf&quot; class&#x3D;&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;persistenceUnitManager&quot; ref&#x3D;&quot;pum&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;persistenceUnitName&quot; value&#x3D;&quot;myCustomUnit&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>默认的 implementation 允许自定义<code>PersistenceUnitInfo</code>实例(在它们被提供给 JPA 提供者之前)，以声明方式(通过其 properties，它影响所有托管单元)或以编程方式(通过<code>PersistenceUnitPostProcessor</code>，允许持久性单元选择)。如果未指定<code>PersistenceUnitManager</code>，则会在<code>LocalContainerEntityManagerFactoryBean</code>内部创建并使用一个<code>PersistenceUnitManager</code>。</p>
<h5 id="背景引导"><a href="#背景引导" class="headerlink" title="背景引导"></a>背景引导</h5><p><code>LocalContainerEntityManagerFactoryBean</code>支持通过<code>bootstrapExecutor</code> property 进行后台自举，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;emf&quot; class&#x3D;&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;bootstrapExecutor&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.core.task.SimpleAsyncTaskExecutor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>将实际的 JPA 提供程序引导传递给指定的执行程序，然后在 parallel 中运行到 application 引导程序线程。暴露的<code>EntityManagerFactory</code>代理可以注入其他 application 组件，甚至能够响应<code>EntityManagerFactoryInfo</code> configuration 检查。但是，一旦实际的 JPA 提供程序被其他组件访问(例如，调用<code>createEntityManager</code>)，那些 calls 会阻塞，直到后台引导完成。特别是，当您使用 Spring Data JPA 时，请确保为其 repositories 设置延迟引导。</p>
<h4 id="基于-JPA-实现-DAO：EntityManagerFactory-和-EntityManager"><a href="#基于-JPA-实现-DAO：EntityManagerFactory-和-EntityManager" class="headerlink" title="基于 JPA 实现 DAO：EntityManagerFactory 和 EntityManager"></a>基于 JPA 实现 DAO：EntityManagerFactory 和 EntityManager</h4><blockquote>
<p>虽然<code>EntityManagerFactory</code>实例是 thread-safe，但<code>EntityManager</code>实例不是。注入的 JPA <code>EntityManager</code>的行为类似于从 application 服务器的 JNDI 环境中获取的<code>EntityManager</code>，如 JPA 规范所定义。它将所有 calls 委托给当前 transactional <code>EntityManager</code>，如果有的话。否则，它会回退到每个操作新创建的<code>EntityManager</code>，实际上使其使用 thread-safe。</p>
</blockquote>
<p>通过使用注入的<code>EntityManagerFactory</code>或<code>EntityManager</code>，可以在没有任何 Spring 依赖项的情况下对普通 JPA 编写 code。如果启用<code>PersistenceAnnotationBeanPostProcessor</code>，Spring 可以理解字段和方法 level 中的<code>@PersistenceUnit</code>和<code>@PersistenceContext</code> 注释。以下 example 显示了一个使用<code>@PersistenceUnit</code> annotation 的普通 JPA DAO implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDaoImpl implements ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    private EntityManagerFactory emf;</span><br><span class="line"></span><br><span class="line">    @PersistenceUnit</span><br><span class="line">    public void setEntityManagerFactory(EntityManagerFactory emf) &#123;</span><br><span class="line">        this.emf &#x3D; emf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Collection loadProductsByCategory(String category) &#123;</span><br><span class="line">        EntityManager em &#x3D; this.emf.createEntityManager();</span><br><span class="line">        try &#123;</span><br><span class="line">            Query query &#x3D; em.createQuery(&quot;from Product as p where p.category &#x3D; ?1&quot;);</span><br><span class="line">            query.setParameter(1, category);</span><br><span class="line">            return query.getResultList();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            if (em !&#x3D; null) &#123;</span><br><span class="line">                em.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 DAO 不依赖于 Spring，并且仍然可以很好地适应 Spring application context。此外，DAO 利用 annotations 要求注入默认的<code>EntityManagerFactory</code>，如下面的 example bean 定义所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean post-processor for JPA annotations --&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myProductDao&quot; class&#x3D;&quot;product.ProductDaoImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>作为显式定义<code>PersistenceAnnotationBeanPostProcessor</code>的替代方法，请考虑在 application context configuration 中使用 Spring <code>context:annotation-config</code> XML 元素。这样做会自动将所有 Spring 标准 post-processors 注册为 annotation-based configuration，包括<code>CommonAnnotationBeanPostProcessor</code>等等。</p>
<p>考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- post-processors for all standard config annotations --&gt;</span><br><span class="line">    &lt;context:annotation-config&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myProductDao&quot; class&#x3D;&quot;product.ProductDaoImpl&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>这样一个 DAO 的主要问题是它总是通过工厂创建一个新的<code>EntityManager</code>。您可以通过请求 transactional <code>EntityManager</code>(也称为“共享 EntityManager”，因为它是实际 transactional EntityManager 的共享，thread-safe 代理)而不是工厂来避免这种情况。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class ProductDaoImpl implements ProductDao &#123;</span><br><span class="line"></span><br><span class="line">    @PersistenceContext</span><br><span class="line">    private EntityManager em;</span><br><span class="line"></span><br><span class="line">    public Collection loadProductsByCategory(String category) &#123;</span><br><span class="line">        Query query &#x3D; em.createQuery(&quot;from Product as p where p.category &#x3D; :category&quot;);</span><br><span class="line">        query.setParameter(&quot;category&quot;, category);</span><br><span class="line">        return query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@PersistenceContext</code> annotation 有一个名为<code>type</code>的可选属性，默认为<code>PersistenceContextType.TRANSACTION</code>。您可以使用此默认值来接收共享的<code>EntityManager</code>代理。另一种选择<code>PersistenceContextType.EXTENDED</code>是完全不同的事情。这导致 so-called 扩展<code>EntityManager</code>，这不是 thread-safe，因此，不能在并发访问的 component 中使用，例如 Spring-managed singleton bean。扩展<code>EntityManager</code>实例仅应用于有状态组件，例如，它们驻留在 session 中，<code>EntityManager</code>的生命周期不与当前 transaction 绑定，而是完全取决于 application。</p>
<p>方法和 field-level 注射</p>
<p>您可以在 class 中的字段或方法上应用指示依赖注入(例如<code>@PersistenceUnit</code>和<code>@PersistenceContext</code>)的注释 - 因此表达式为“method-level injection”和“field-level injection”。 Field-level 注释简洁易用，而 method-level 注释允许进一步处理注入的依赖项。在这两种情况下，成员可见性(公共，受保护或私有)都无关紧要。</p>
<p>class-level 注释怎么样？</p>
<p>在 Java EE 平台上，它们用于依赖性声明，而不用于资源注入。</p>
<p>注入的<code>EntityManager</code>是 Spring-managed(意识到正在进行的 transaction)。即使新的 DAO implementation 使用 method-level 注入<code>EntityManager</code>而不是<code>EntityManagerFactory</code>，但由于 annotation 用法，application context XML 不需要进行任何更改。</p>
<p>这种 DAO 风格的主要优点是它仅依赖于 Java Persistence API。不需要任何 Spring class 的 import。此外，当理解 JPA 注释时，Spring 容器会自动应用注入。从 non-invasiveness 的角度来看，这很有吸引力，对 JPA 开发人员来说感觉更自然。</p>
<h4 id="Spring-driven-JPA-transactions"><a href="#Spring-driven-JPA-transactions" class="headerlink" title="Spring-driven JPA transactions"></a>Spring-driven JPA transactions</h4><blockquote>
<p>我们强烈建议您阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative">声明式 transaction management</a>(如果您还没有这样做)，以便更详细地了解 Spring 的声明性 transaction 支持。</p>
</blockquote>
<p>JPA 推荐的策略是通过 JPA 的本地 transaction 支持进行本地 transactions。 Spring 的<code>JpaTransactionManager</code>提供了许多本地 JDBC transactions(例如 transaction-specific 隔离级别和 resource-level read-only 优化)对任何常规 JDBC 连接池(无 XA 要求)的功能。</p>
<p>Spring JPA 还允许配置<code>JpaTransactionManager</code>将 JPA transaction 暴露给访问相同<code>DataSource</code>的 JDBC 访问 code，前提是已注册的<code>JpaDialect</code>支持检索底层 JDBC <code>Connection</code>。 Spring 为 EclipseLink 和 Hibernate JPA implementations 提供方言。有关<code>JpaDialect</code>机制的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-dialect">下一节</a>。</p>
<blockquote>
<p>作为一个直接的选择，Spring 的本机<code>HibernateTransactionManager</code>能够与 JPA 访问 code 进行交互，从 Spring Framework 5.1 和 Hibernate 5.2/5.3 开始，适应几个 Hibernate 细节并提供 JDBC 交互。这与<code>LocalSessionFactoryBean</code>设置相结合特别有意义。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-hibernate">JPA Interaction 的原生 Hibernate 设置</a>。</p>
</blockquote>
<h4 id="了解-JpaDialect-和-JpaVendorAdapter"><a href="#了解-JpaDialect-和-JpaVendorAdapter" class="headerlink" title="了解 JpaDialect 和 JpaVendorAdapter"></a>了解 JpaDialect 和 JpaVendorAdapter</h4><p>作为高级 feature，<code>JpaTransactionManager</code>和<code>AbstractEntityManagerFactoryBean</code>的子类允许将自定义<code>JpaDialect</code>传递到<code>jpaDialect</code> bean property。 <code>JpaDialect</code> implementation 可以启用 Spring 支持的以下高级 features，通常以 vendor-specific 方式：</p>
<ul>
<li>应用特定的 transaction 语义(例如自定义隔离 level 或 transaction timeout)</li>
<li>检索 transactional JDBC <code>Connection</code>(用于暴露于 JDBC-based DAO)</li>
<li><code>PersistenceExceptions</code>到 Spring <code>DataAccessExceptions</code>的高级翻译</li>
</ul>
<p>这对于特殊的 transaction 语义和 exception 的高级转换特别有用。默认 implementation(<code>DefaultJpaDialect</code>)不提供任何特殊功能，如果需要前面列出的 features，则必须指定相应的方言。</p>
<blockquote>
<p>作为一个更广泛的提供者适应设施，主要用于 Spring 的 full-featured <code>LocalContainerEntityManagerFactoryBean</code>设置，<code>JpaVendorAdapter</code>将<code>JpaDialect</code>的功能与其他 provider-specific 默认值相结合。指定<code>HibernateJpaVendorAdapter</code>或<code>EclipseLinkJpaVendorAdapter</code>分别是 Hibernate 或 EclipseLink 的 auto-configuring <code>EntityManagerFactory</code>设置的最便捷方式。请注意，这些提供程序适配器主要设计用于 Spring-driven transaction management(即，与<code>JpaTransactionManager</code>一起使用)。</p>
</blockquote>
<p>有关其操作的更多详细信息以及如何在 Spring 的 JPA 支持中使用它们，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaDialect.html">JpaDialect</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/JpaVendorAdapter.html">JpaVendorAdapter</a> javadoc。</p>
<h4 id="使用-JTA-Transaction-Management-设置-JPA"><a href="#使用-JTA-Transaction-Management-设置-JPA" class="headerlink" title="使用 JTA Transaction Management 设置 JPA"></a>使用 JTA Transaction Management 设置 JPA</h4><p>作为<code>JpaTransactionManager</code>的替代，Spring 还允许通过 JTA 进行 multi-resource transaction 协调，无论是在 Java EE 环境中还是与 stand-alone transaction 协调器(如 Atomikos)。除了选择 Spring 的<code>JtaTransactionManager</code>而不是<code>JpaTransactionManager</code>之外，您还需要采取进一步的措施：</p>
<ul>
<li>底层 JDBC 连接池需要 XA-capable 并与 transaction 协调器集成。这在 Java EE 环境中通常很简单，通过 JNDI 公开不同类型的<code>DataSource</code>。有关详细信息，请参阅 application 服务器文档。类似地，独立的 transaction 协调器通常带有特殊的 XA-integrated <code>DataSource</code> __mplementations。再次，检查其文档。</li>
<li>需要为 JTA 配置 JPA <code>EntityManagerFactory</code>设置。这是 provider-specific，通常通过特殊的 properties 在<code>LocalContainerEntityManagerFactoryBean</code>上指定为<code>jpaProperties</code>。在 Hibernate 的情况下，这些 properties 甚至是 version-specific。有关详细信息，请参阅 Hibernate 文档。</li>
<li>Spring 的<code>HibernateJpaVendorAdapter</code>强制执行某些 Spring-oriented 默认值，例如连接释放模式<code>on-close</code>，它与 Hibernate 在 Hibernate 5.0 中的默认值匹配，但在 5.1/5.2 中不再存在。对于 JTA 设置，要么不声明<code>HibernateJpaVendorAdapter</code>开始或关闭其<code>prepareConnection</code> flag。或者，将 Hibernate 5.2 的<code>hibernate.connection.handling_mode</code> property 设置为<code>DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT</code>以恢复 Hibernate 自己的默认值。有关 WebLogic 的相关说明，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-hibernate-invalid-jdbc-access-error">带有 Hibernate 的虚假 Application Server 警告</a>。</li>
<li>或者，考虑从 application 服务器本身获取<code>EntityManagerFactory</code>(即通过 JNDI 查找而不是本地声明的<code>LocalContainerEntityManagerFactoryBean</code>)。 server-provided <code>EntityManagerFactory</code>可能需要在服务器 configuration 中使用特殊定义(使部署不那么便携)，但是为服务器的 JTA 环境设置了。</li>
</ul>
<h4 id="原生-Hibernate-设置和原生-Hibernate-Transactions-for-JPA-Interaction"><a href="#原生-Hibernate-设置和原生-Hibernate-Transactions-for-JPA-Interaction" class="headerlink" title="原生 Hibernate 设置和原生 Hibernate Transactions for JPA Interaction"></a>原生 Hibernate 设置和原生 Hibernate Transactions for JPA Interaction</h4><p>从 Spring Framework 5.1 和 Hibernate 5.2/5.3 开始，与<code>HibernateTransactionManager</code>组合的原生<code>LocalSessionFactoryBean</code>设置允许与<code>@PersistenceContext</code>和其他 JPA 访问 code 进行交互。 Hibernate <code>SessionFactory</code>本身实现了 JPA 的<code>EntityManagerFactory</code>接口，而 Hibernate <code>Session</code>句柄本身就是 JPA <code>EntityManager</code>。 Spring 的 JPA 支持工具自动检测本机 Hibernate 会话。</p>
<p>因此，在许多场景中，这种本机 Hibernate 设置可以替代标准 JPA <code>LocalContainerEntityManagerFactoryBean</code>和<code>JpaTransactionManager</code>组合，允许在同一本地 transaction 内与<code>@PersistenceContext EntityManager</code>(以及<code>HibernateTemplate</code>)相邻进行交互。这样的设置还提供了更强的 Hibernate integration 和更多 configuration 灵活性，因为它不受 JPA bootstrap contracts 的限制。</p>
<p>在这种情况下，您不需要<code>HibernateJpaVendorAdapter</code> configuration，因为 Spring 的本机 Hibernate 设置提供了更多 features(对于 example，自定义 Hibernate Integrator 设置，Hibernate 5.3 bean 容器 integration，以及 read-only transactions 的更强优化)。最后但并非最不重要的是，您还可以通过<code>LocalSessionFactoryBuilder</code>表达本机 Hibernate 设置，与<code>@Bean</code> style configuration 无缝集成(不涉及<code>FactoryBean</code>)。</p>
<blockquote>
<p><code>LocalSessionFactoryBean</code>和<code>LocalSessionFactoryBuilder</code>支持后台自举，就像 JPA <code>LocalContainerEntityManagerFactoryBean</code>一样。有关介绍，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#orm-jpa-setup-background">背景引导</a>。</p>
</blockquote>
<p>在<code>LocalSessionFactoryBean</code>上，可以通过<code>bootstrapExecutor</code> property 获得。在程序<code>LocalSessionFactoryBuilder</code>上，重载的<code>buildSessionFactory</code>方法采用 bootstrap executor 参数。</p>
<h2 id="使用Object-XML映射器编组XML"><a href="#使用Object-XML映射器编组XML" class="headerlink" title="使用Object-XML映射器编组XML"></a>使用Object-XML映射器编组XML</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>本章介绍 Spring 的 Object-XML Mapping 支持。 Object-XML Mapping(简称 O-X mapping)是将 XML 文档转换为 object 和从 object 转换 XML 文档的行为。此转换 process 也称为 XML 编组或 XML 序列化。本章可互换使用这些术语。</p>
<p>在 O-X mapping 的字段中，marshaller 负责将 object(图形)序列化为 XML。以类似的方式，unmarshaller 将 XML 反序列化为 object 图。此 XML 可以采用 DOM 文档，输入或输出流或 SAX 处理程序的形式。</p>
<p>使用 Spring 满足 O/X 映射需求的一些好处是：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-ease-of-configuration">易于配置</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-consistent-interfaces">一致的接口</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-consistent-exception-hierarchy">一致的 Exception 层次结构</a></li>
</ul>
<h4 id="易于配置"><a href="#易于配置" class="headerlink" title="易于配置"></a>易于配置</h4><p>Spring 的 bean 工厂可以轻松配置 marshallers，而无需构建 JAXB context，JiBX binding 工厂等。你可以像 application context 中的任何其他 bean 一样配置 marshallers。此外，XML namespace-based configuration 可用于许多 marshallers，使 configuration 更简单。</p>
<h4 id="一致的接口"><a href="#一致的接口" class="headerlink" title="一致的接口"></a>一致的接口</h4><p>Spring 的 O-X 映射通过两个 global 接口运行：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/oxm/Marshaller.html">编组</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/oxm/Unmarshaller.html">解组</a>。这些抽象使您可以相对轻松地切换 O-X 映射框架，对执行编组的 classes 几乎不需要进行任何更改。这种方法的另一个好处是可以使用 mix-and-match 方法进行 XML 编组(例如，使用 JAXB 执行一些编组，一些使用 Castor 执行编组)，让您使用每种技术的强度。</p>
<h4 id="一致的-Exception-层次结构-1"><a href="#一致的-Exception-层次结构-1" class="headerlink" title="一致的 Exception 层次结构"></a>一致的 Exception 层次结构</h4><p>Spring 提供从基础 O-X 映射工具的 exceptions 到其自己的 exception 层次结构的转换，其中<code>XmlMappingException</code>作为根 exception。这些运行时 exceptions 包装原始 exception，以便不丢失任何信息。</p>
<h3 id="Marshaller-和-Unmarshaller"><a href="#Marshaller-和-Unmarshaller" class="headerlink" title="Marshaller 和 Unmarshaller"></a>Marshaller 和 Unmarshaller</h3><p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-introduction">介绍</a>中所述，marshaller 将 object 序列化为 XML，而 unmarshaller 将 XML 流反序列化为 object。本节介绍用于此目的的两个 Spring 接口。</p>
<h4 id="了解-Marshaller"><a href="#了解-Marshaller" class="headerlink" title="了解 Marshaller"></a>了解 Marshaller</h4><p>Spring 抽象<code>org.springframework.oxm.Marshaller</code>接口后面的所有编组操作，其主要方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Marshaller &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Marshal the object graph with the given root into the provided Result.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void marshal(Object graph, Result result) throws XmlMappingException, IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Marshaller</code>接口有一个 main 方法，它将给定的 object 封送到给定的<code>javax.xml.transform.Result</code>。结果是一个标记接口，它基本上代表 XML 输出抽象。具体的 implementations 包含各种 XML 表示，如下面的 table 表示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结果 implementation</th>
<th>包装 XML 表示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DOMResult</code></td>
<td><code>org.w3c.dom.Node</code></td>
</tr>
<tr>
<td><code>SAXResult</code></td>
<td><code>org.xml.sax.ContentHandler</code></td>
</tr>
<tr>
<td><code>StreamResult</code></td>
<td><code>java.io.File</code>，<code>java.io.OutputStream</code>或<code>java.io.Writer</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>尽管<code>marshal()</code>方法接受普通的 object 作为其第一个参数，但大多数<code>Marshaller</code> implementations 都无法处理任意的 objects。相反，object class 必须映射到映射文件中，标记为 annotation，向 marshaller 注册，或者具有 common base class。请参阅本章后面的部分，以确定 O-X 技术如何管理它。</p>
</blockquote>
<h4 id="了解-Unmarshaller"><a href="#了解-Unmarshaller" class="headerlink" title="了解 Unmarshaller"></a>了解 Unmarshaller</h4><p>与<code>Marshaller</code>类似，我们有<code>org.springframework.oxm.Unmarshaller</code>接口，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Unmarshaller &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Unmarshal the given provided Source into an object graph.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Object unmarshal(Source source) throws XmlMappingException, IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口还有一个方法，它从给定的<code>javax.xml.transform.Source</code>(XML 输入抽象)读取并返回 object 读取。与<code>Result</code>一样，<code>Source</code>是一个标记接口，具有三个具体的 implementation。每个包装一个不同的 XML 表示，如下面的 table 表示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>来源实现</th>
<th>包装 XML 表示</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DOMSource</code></td>
<td><code>org.w3c.dom.Node</code></td>
</tr>
<tr>
<td><code>SAXSource</code></td>
<td><code>org.xml.sax.InputSource</code>，<code>org.xml.sax.XMLReader</code></td>
</tr>
<tr>
<td><code>StreamSource</code></td>
<td><code>java.io.File</code>，<code>java.io.InputStream</code>或<code>java.io.Reader</code></td>
</tr>
</tbody>
</table>
</div>
<p>即使有两个单独的编组接口(<code>Marshaller</code>和<code>Unmarshaller</code>)，Spring-WS 中的所有_implement 都在一个 class 中实现。这意味着您可以连接一个 marshaller class 并将其作为 marshaller 和<code>applicationContext.xml</code>中的 unmarshaller 引用。</p>
<h4 id="了解-XmlMappingException"><a href="#了解-XmlMappingException" class="headerlink" title="了解 XmlMappingException"></a>了解 XmlMappingException</h4><p>Spring 将 exceptions 从底层的 O-X 映射工具转换为自己的 exception 层次结构，并将<code>XmlMappingException</code>作为根 exception。这些运行时 exceptions 包装原始 exception，以便不会丢失任何信息。</p>
<p>此外，<code>MarshallingFailureException</code>和<code>UnmarshallingFailureException</code>提供了编组和解组操作之间的区别，即使底层的 O-X 映射工具不这样做。</p>
<p>O-X Mapping exception 层次结构如下图所示：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/oxm-exceptions.jpg" alt="oxm exceptions"></p>
<h3 id="使用-Marshaller-和-Unmarshaller"><a href="#使用-Marshaller-和-Unmarshaller" class="headerlink" title="使用 Marshaller 和 Unmarshaller"></a>使用 Marshaller 和 Unmarshaller</h3><p>您可以在各种情况下使用 Spring 的 OXM。在下面的示例中，我们使用它来将 Spring-managed application 的设置编组为 XML 文件。在下面的示例中，我们使用一个简单的 JavaBean 来表示设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Settings &#123;</span><br><span class="line"></span><br><span class="line">    private boolean fooEnabled;</span><br><span class="line"></span><br><span class="line">    public boolean isFooEnabled() &#123;</span><br><span class="line">        return fooEnabled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFooEnabled(boolean fooEnabled) &#123;</span><br><span class="line">        this.fooEnabled &#x3D; fooEnabled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>application class 使用此 bean 来存储其设置。除了 main 方法之外，class 还有两个方法：<code>saveSettings()</code>将设置 bean 保存到名为<code>settings.xml</code>的文件中，<code>loadSettings()</code>再次加载这些设置。以下<code>main()</code>方法构造 Spring application context 并_call 这两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import javax.xml.transform.stream.StreamResult;</span><br><span class="line">import javax.xml.transform.stream.StreamSource;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line">import org.springframework.oxm.Marshaller;</span><br><span class="line">import org.springframework.oxm.Unmarshaller;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    private static final String FILE_NAME &#x3D; &quot;settings.xml&quot;;</span><br><span class="line">    private Settings settings &#x3D; new Settings();</span><br><span class="line">    private Marshaller marshaller;</span><br><span class="line">    private Unmarshaller unmarshaller;</span><br><span class="line"></span><br><span class="line">    public void setMarshaller(Marshaller marshaller) &#123;</span><br><span class="line">        this.marshaller &#x3D; marshaller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUnmarshaller(Unmarshaller unmarshaller) &#123;</span><br><span class="line">        this.unmarshaller &#x3D; unmarshaller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void saveSettings() throws IOException &#123;</span><br><span class="line">        FileOutputStream os &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            os &#x3D; new FileOutputStream(FILE_NAME);</span><br><span class="line">            this.marshaller.marshal(settings, new StreamResult(os));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (os !&#x3D; null) &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void loadSettings() throws IOException &#123;</span><br><span class="line">        FileInputStream is &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            is &#x3D; new FileInputStream(FILE_NAME);</span><br><span class="line">            this.settings &#x3D; (Settings) this.unmarshaller.unmarshal(new StreamSource(is));</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (is !&#x3D; null) &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ApplicationContext appContext &#x3D;</span><br><span class="line">                new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</span><br><span class="line">        Application application &#x3D; (Application) appContext.getBean(&quot;application&quot;);</span><br><span class="line">        application.saveSettings();</span><br><span class="line">        application.loadSettings();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Application</code>需要设置<code>marshaller</code>和<code>unmarshaller</code> property。我们可以使用以下<code>applicationContext.xml</code>来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;application&quot; class&#x3D;&quot;Application&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;marshaller&quot; ref&#x3D;&quot;castorMarshaller&quot; &#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;unmarshaller&quot; ref&#x3D;&quot;castorMarshaller&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;castorMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.castor.CastorMarshaller&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>此 application context 使用 Castor，但我们可以使用本章后面介绍的任何其他 marshaller 实例。请注意，默认情况下，Castor 不需要任何进一步的 configuration，因此 bean 定义相当简单。另请注意，<code>CastorMarshaller</code>同时实现了<code>Marshaller</code>和<code>Unmarshaller</code>，因此我们可以在 application 的<code>marshaller</code>和<code>unmarshaller</code>property 中引用<code>castorMarshaller</code> bean。</p>
<p>此 sample application 生成以下<code>settings.xml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;settings foo-enabled&#x3D;&quot;false&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="XML-Configuration-命名空间"><a href="#XML-Configuration-命名空间" class="headerlink" title="XML Configuration 命名空间"></a>XML Configuration 命名空间</h3><p>您可以使用 OXM 命名空间中的标记更简洁地配置 marshallers。要使这些标记可用，必须首先在 XML configuration 文件的前导码中引用相应的 schema。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:oxm&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;oxm&quot; (1)</span><br><span class="line">xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">  http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;oxm http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;oxm&#x2F;spring-oxm.xsd&quot;&gt; (2)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>参考<code>oxm</code> schema。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>指定<code>oxm</code> schema 位置。</td>
</tr>
</tbody>
</table>
</div>
<p>目前，schema 提供以下元素：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-jaxb2-xsd">jaxb2-marshaller</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-jibx-xsd">jibx-marshaller</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-castor-xsd">castor-marshaller</a></li>
</ul>
<p>每个标签都在其各自的编组部分中进行了解释。但是，作为一个示例，JAXB2 marshaller 的 configuration 可能类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oxm:jaxb2-marshaller id&#x3D;&quot;marshaller&quot; contextPath&#x3D;&quot;org.springframework.ws.samples.airline.schema&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JAXB"><a href="#JAXB" class="headerlink" title="JAXB"></a>JAXB</h3><p>JAXB binding 编译器将 W3C XML Schema 转换为一个或多个 Java classes，一个<code>jaxb.properties</code>文件，可能还有一些资源 files。 JAXB 还提供了一种从带注释的 Java classes 生成 schema 的方法。</p>
<p>Spring 支持 JAXB 2.0 API 作为 XML 编组策略，遵循<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#oxm-marshaller-unmarshaller">Marshaller 和 Unmarshaller</a>中描述的<code>Marshaller</code>和<code>Unmarshaller</code>接口。相应的 integration classes 位于<code>org.springframework.oxm.jaxb</code>包中。</p>
<h4 id="使用-Jaxb2Marshaller"><a href="#使用-Jaxb2Marshaller" class="headerlink" title="使用 Jaxb2Marshaller"></a>使用 Jaxb2Marshaller</h4><p><code>Jaxb2Marshaller</code> class 实现了 Spring 的<code>Marshaller</code>和<code>Unmarshaller</code>接口。它需要 context 路径才能运行。您可以通过设置<code>contextPath</code> property 来设置 context 路径。 context 路径是包含 schema 派生 classes 的 colon-separated Java 包名称列表。它还提供<code>classesToBeBound</code> property，允许您设置 marshaller 支持的_arlass 的 array。 Schema 验证是通过为 bean 指定一个或多个 schema 资源来执行的，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;jaxb2Marshaller&quot; class&#x3D;&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;classesToBeBound&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;org.springframework.oxm.jaxb.Flight&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;value&gt;org.springframework.oxm.jaxb.Flights&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;schema&quot; value&#x3D;&quot;classpath:org&#x2F;springframework&#x2F;oxm&#x2F;schema.xsd&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="XML-Configuration-命名空间-1"><a href="#XML-Configuration-命名空间-1" class="headerlink" title="XML Configuration 命名空间"></a>XML Configuration 命名空间</h5><p><code>jaxb2-marshaller</code>元素配置<code>org.springframework.oxm.jaxb.Jaxb2Marshaller</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oxm:jaxb2-marshaller id&#x3D;&quot;marshaller&quot; contextPath&#x3D;&quot;org.springframework.ws.samples.airline.schema&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用<code>class-to-be-bound</code> child 元素提供要绑定到编组程序的 classes 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;oxm:jaxb2-marshaller id&#x3D;&quot;marshaller&quot;&gt;</span><br><span class="line">    &lt;oxm:class-to-be-bound name&#x3D;&quot;org.springframework.ws.samples.airline.schema.Airport&quot;&#x2F;&gt;</span><br><span class="line">    &lt;oxm:class-to-be-bound name&#x3D;&quot;org.springframework.ws.samples.airline.schema.Flight&quot;&#x2F;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;oxm:jaxb2-marshaller&gt;</span><br></pre></td></tr></table></figure>
<p>以下 table 描述了可用的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>需要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>编组员的身份证</td>
<td>没有</td>
</tr>
<tr>
<td><code>contextPath</code></td>
<td>JAXB Context 路径</td>
<td>没有</td>
</tr>
</tbody>
</table>
</div>
<h3 id="蓖麻"><a href="#蓖麻" class="headerlink" title="蓖麻"></a>蓖麻</h3><p>Castor XML mapping 是一个开源的 XML binding framework。它允许您将 Java object model 中包含的数据转换为 XML 文档或从 XML 文档转换。默认情况下，它不需要任何进一步的 configuration，但您可以使用映射文件来更好地控制 Castor 的行为。</p>
<p>有关 Castor 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://castor-data-binding.github.io/castor">Castor web 网站</a>。 Spring integration classes 位于<code>org.springframework.oxm.castor</code>包中。</p>
<h4 id="使用-CastorMarshaller"><a href="#使用-CastorMarshaller" class="headerlink" title="使用 CastorMarshaller"></a>使用 CastorMarshaller</h4><p>与 JAXB 一样，<code>CastorMarshaller</code>实现了<code>Marshaller</code>和<code>Unmarshaller</code>接口。它可以按如下方式连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;castorMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.castor.CastorMarshaller&quot; &#x2F;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="制图"><a href="#制图" class="headerlink" title="制图"></a>制图</h4><p>尽管可以依赖 Castor 的默认编组行为，但可能需要对其进行更多控制。您可以使用 Castor 映射文件获得更多控制。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/index.html#xml.mapping">Castor XML Mapping</a>。</p>
<p>您可以使用<code>mappingLocation</code> resource property 设置映射，在以下 example 中使用 classpath 资源指示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;castorMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.castor.CastorMarshaller&quot; &gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mappingLocation&quot; value&#x3D;&quot;classpath:mapping.xml&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="XML-Configuration-命名空间-2"><a href="#XML-Configuration-命名空间-2" class="headerlink" title="XML Configuration 命名空间"></a>XML Configuration 命名空间</h5><p><code>castor-marshaller</code>标记配置<code>org.springframework.oxm.castor.CastorMarshaller</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oxm:castor-marshaller id&#x3D;&quot;marshaller&quot; mapping-location&#x3D;&quot;classpath:org&#x2F;springframework&#x2F;oxm&#x2F;castor&#x2F;mapping.xml&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>您可以通过两种方式配置 marshaller 实例：通过指定映射文件的位置(通过<code>mapping-location</code> property)或通过标识存在相应 XML 描述符 classes 的 Java POJO(通过<code>target-class</code>或<code>target-package</code>properties)。后一种方法通常与 XML 模式的 XML code 生成结合使用。</p>
<p>以下 table 描述了可用的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>需要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>编组员的身份证</td>
<td>没有</td>
</tr>
<tr>
<td><code>encoding</code></td>
<td>用于从 XML 解组的编码</td>
<td>没有</td>
</tr>
<tr>
<td><code>target-class</code></td>
<td>可用于 XML class 描述符的 POJO 的 Java class name(通过 code 生成生成)</td>
<td>没有</td>
</tr>
<tr>
<td><code>target-package</code></td>
<td>一个 Java 包 name，用于标识包含 POJO 的包及其对应的 Castor XML 描述符 classes(通过从 XML 模式生成 code 生成)</td>
<td>没有</td>
</tr>
<tr>
<td><code>mapping-location</code></td>
<td>Castor XML 映射文件的位置</td>
<td>没有</td>
</tr>
</tbody>
</table>
</div>
<h3 id="JiBX"><a href="#JiBX" class="headerlink" title="JiBX"></a>JiBX</h3><p>JiBX framework 提供了类似于 Hibernate 为 ORM 提供的解决方案：binding 定义定义了 Java objects 如何转换为 XML 或从 XML 转换的规则。在准备 binding 并编译 classes 之后，JiBX binding 编译器增强 class files 并添加 code 以处理从或 XML 转换 classes 的实例。</p>
<p>有关 JiBX 的更多信息，请参阅<a target="_blank" rel="noopener" href="http://jibx.sourceforge.net/">JiBX web 网站</a>。 Spring integration classes 位于<code>org.springframework.oxm.jibx</code>包中。</p>
<h4 id="使用-JibxMarshaller"><a href="#使用-JibxMarshaller" class="headerlink" title="使用 JibxMarshaller"></a>使用 JibxMarshaller</h4><p><code>JibxMarshaller</code> class 实现<code>Marshaller</code>和<code>Unmarshaller</code>接口。要进行操作，需要 class 的 name 编组，您可以使用<code>targetClass</code> property 进行设置。 (可选)您可以通过设置<code>bindingName</code> property 来设置 binding name。在下面的示例中，我们绑定<code>Flights</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;jibxFlightsMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.jibx.JibxMarshaller&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;targetClass&quot;&gt;org.springframework.oxm.jibx.Flights&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>配置为单个 class。如果要编组多个 classes，则必须使用不同的<code>targetClass</code> property 值配置多个<code>JibxMarshaller</code>实例。</p>
<h5 id="XML-Configuration-命名空间-3"><a href="#XML-Configuration-命名空间-3" class="headerlink" title="XML Configuration 命名空间"></a>XML Configuration 命名空间</h5><p><code>jibx-marshaller</code>标记配置<code>org.springframework.oxm.jibx.JibxMarshaller</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;oxm:jibx-marshaller id&#x3D;&quot;marshaller&quot; target-class&#x3D;&quot;org.springframework.ws.samples.airline.schema.Flight&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>以下 table 描述了可用的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>需要</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>编组员的身份证</td>
<td>没有</td>
</tr>
<tr>
<td><code>target-class</code></td>
<td>此 marshaller 的目标 class</td>
<td>是</td>
</tr>
<tr>
<td><code>bindingName</code></td>
<td>这个编组使用的 binding name</td>
<td>没有</td>
</tr>
</tbody>
</table>
</div>
<h3 id="XStream"><a href="#XStream" class="headerlink" title="XStream"></a>XStream</h3><p>XStream 是一个简单的 library，可以将 objects 序列化为 XML，然后再返回。它不需要任何映射并生成干净的 XML。</p>
<p>有关 XStream 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://x-stream.github.io/">XStream web 网站</a>。 Spring integration classes 位于<code>org.springframework.oxm.xstream</code>包中。</p>
<h4 id="使用-XStreamMarshaller"><a href="#使用-XStreamMarshaller" class="headerlink" title="使用 XStreamMarshaller"></a>使用 XStreamMarshaller</h4><p><code>XStreamMarshaller</code>不需要任何 configuration，可以直接在 application context 中配置。要进一步自定义 XML，可以设置别名 map，它由映射到 classes 的 string 别名组成，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;xstreamMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;aliases&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;Flight&quot;&gt;org.springframework.oxm.xstream.Flight&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，XStream 允许任意 classes 被解组，这可能导致不安全的 Java 序列化效果。因此，我们不建议使用<code>XStreamMarshaller</code>从外部源(即 Web)解组 XML，因为这可能导致安全漏洞。</p>
</blockquote>
<p>如果您选择使用<code>XStreamMarshaller</code>从外部源解组 XML，请在<code>XStreamMarshaller</code>上设置<code>supportedClasses</code> property，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;xstreamMarshaller&quot; class&#x3D;&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;supportedClasses&quot; value&#x3D;&quot;org.springframework.oxm.xstream.Flight&quot;&#x2F;&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>这样做可确保只有已注册的 classes 才有资格进行解组。</p>
<p>此外，您可以注册<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher…">定制转换器</a>)以确保只有您支持的 classes 可以被解组。除了显式支持应支持的域 classes 的转换器之外，您可能还希望在列表中添加<code>CatchAllConverter</code>作为最后一个转换器。因此，不会调用具有较低优先级和可能的安全漏洞的默认 XStream 转换器。</p>
<blockquote>
<p>请注意，XStream 是 XML 序列化 library，而不是数据 binding library。因此，它具有有限的命名空间支持。因此，它不适合在 Web services 中使用。</p>
</blockquote>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="XML-模式"><a href="#XML-模式" class="headerlink" title="XML 模式"></a>XML 模式</h3><p>附录的这一部分列出了用于数据访问的 XML 模式，包括以下内容：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#xsd-schemas-tx">tx Schema</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#xsd-schemas-jdbc">jdbc Schema</a></li>
</ul>
<h4 id="tx-Schema"><a href="#tx-Schema" class="headerlink" title="tx Schema"></a>tx Schema</h4><p><code>tx</code>标签处理 Spring 对 transactions 的全面支持中所有 beans 的配置。这些标签在标题为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction">Transaction Management</a>的章节中介绍。</p>
<blockquote>
<p>我们强烈建议您查看 Spring 发行版附带的<code>&#39;spring-tx.xsd&#39;</code>文件。此文件包含 Spring 的 transaction configuration 的 XML Schema，并涵盖<code>tx</code>命名空间中的所有各种元素，包括属性默认值和类似信息。该文件以内联方式记录，因此，为了遵守 DRY(不要重复自己)原则，此处不再重复这些信息。</p>
</blockquote>
<p>为了完整性，要使用<code>tx</code> schema 中的元素，您需要在 Spring XML configuration 文件的顶部包含以下前导码。以下代码段中的文本引用了正确的 schema，以便<code>tx</code>命名空间中的标记可供您使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot; (1)</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd (2)</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明<code>tx</code>名称空间的使用。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>指定位置(使用其他 schema 位置)。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>通常，当您使用<code>tx</code>命名空间中的元素时，您还使用<code>aop</code>命名空间中的元素(因为 Spring 中的声明性 transaction 支持是通过使用 AOP 实现的)。前面的 XML 片段包含schema 引用所需的相关 lines，以便<code>aop</code>命名空间中的元素可供您使用。</p>
</blockquote>
<h4 id="jdbc-Schema"><a href="#jdbc-Schema" class="headerlink" title="jdbc Schema"></a>jdbc Schema</h4><p><code>jdbc</code>元素使您可以快速配置嵌入式数据库或初始化现有数据源。这些元素分别记录在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-embedded-database-support">嵌入式数据库支持</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc-initializing-datasource">初始化 DataSource</a>中。</p>
<p>要使用<code>jdbc</code> schema 中的元素，您需要在 Spring XML configuration 文件的顶部添加以下前导码。以下代码段中的文本引用了正确的 schema，以便<code>jdbc</code>命名空间中的元素可供您使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jdbc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jdbc&quot; (1)</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jdbc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jdbc&#x2F;spring-jdbc.xsd&quot;&gt; (2)</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明<code>jdbc</code>名称空间的使用。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>指定位置(使用其他 schema 位置)。</td>
</tr>
</tbody>
</table>
</div>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/" rel="prev" title="SpringFramework官方文档翻译-测试">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-测试
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/" rel="next" title="SpringFramework官方文档翻译-Servlet Stack上的Web">
      SpringFramework官方文档翻译-Servlet Stack上的Web <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-number">1.</span> <span class="nav-text">数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringFramework%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.1.</span> <span class="nav-text">SpringFramework事务模型的优点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">全局事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">本地事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringFramework%E7%9A%84%E4%B8%80%E8%87%B4%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">SpringFramework的一致编程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3SpringFramework%E4%BA%8B%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.1.2.</span> <span class="nav-text">理解SpringFramework事务抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Transactions%E5%90%8C%E6%AD%A5%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.3.</span> <span class="nav-text">使用Transactions同步资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#High-level%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">High-level同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Low-level%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Low-level同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BBTransactionAwareDataSourceProxy"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">类TransactionAwareDataSourceProxy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.4.</span> <span class="nav-text">声明式事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%90%86%E8%A7%A3SpringFramework%E7%9A%84%E5%A3%B0%E6%98%8ETransaction-Implementation"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">理解SpringFramework的声明Transaction Implementation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">声明式事务实现示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E6%BB%9A%E5%A3%B0%E6%98%8E%E5%BC%8F-Transaction"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">回滚声明式 Transaction</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%B8%8D%E5%90%8C%E7%9A%84-Beans-%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84-Transactional-%E8%AF%AD%E4%B9%89"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">为不同的 Beans 配置不同的 Transactional 语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lt-hh-211-h-gt-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +211+ .h &gt;设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Transactional"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">使用 @Transactional</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Transactional-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.4.6.1.</span> <span class="nav-text">@Transactional 设置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA-Transaction-Managers-with-Transactional"><span class="nav-number">1.1.4.6.2.</span> <span class="nav-text">多个 Transaction Managers with @Transactional</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%B3%A8%E9%87%8A"><span class="nav-number">1.1.4.6.3.</span> <span class="nav-text">自定义快捷方式注释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transaction-%E4%BC%A0%E6%92%AD"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">Transaction 传播</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-PROPAGATION-REQUIRED"><span class="nav-number">1.1.4.7.1.</span> <span class="nav-text">了解 PROPAGATION_REQUIRED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-PROPAGATION-REQUIRES-NEW"><span class="nav-number">1.1.4.7.2.</span> <span class="nav-text">了解 PROPAGATION_REQUIRES_NEW</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-PROPAGATION-NESTED"><span class="nav-number">1.1.4.7.3.</span> <span class="nav-text">了解 PROPAGATION_NESTED</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE-Transactional-Operations"><span class="nav-number">1.1.4.8.</span> <span class="nav-text">建议 Transactional Operations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-AspectJ-%E4%B8%AD%E4%BD%BF%E7%94%A8-Transactional"><span class="nav-number">1.1.4.9.</span> <span class="nav-text">在 AspectJ 中使用 @Transactional</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96%E4%BA%A4%E6%98%93%E7%AE%A1%E7%90%86"><span class="nav-number">1.1.5.</span> <span class="nav-text">程序化交易管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-TransactionTemplate"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">使用 TransactionTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A-Transaction-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.1.5.1.1.</span> <span class="nav-text">指定 Transaction 设置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PlatformTransactionManager"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">使用 PlatformTransactionManager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Programmatic-%E5%92%8C-Declarative-%E4%B9%8B%E9%97%B4%E9%80%89%E6%8B%A9-Transaction-Management"><span class="nav-number">1.1.6.</span> <span class="nav-text">在 Programmatic 和 Declarative 之间选择 Transaction Management</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transaction-bound-Events"><span class="nav-number">1.1.7.</span> <span class="nav-text">Transaction-bound Events</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Application-server-specific-integration"><span class="nav-number">1.1.8.</span> <span class="nav-text">Application server-specific integration</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IBM-WebSphere"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">IBM WebSphere</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Oracle-WebLogic-Server"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">Oracle WebLogic Server</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Common-%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.1.9.</span> <span class="nav-text">Common 问题的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%94%99%E8%AF%AF%E7%9A%84-Transaction-Manager-%E7%94%A8%E4%BA%8E%E7%89%B9%E5%AE%9A%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">使用错误的 Transaction Manager 用于特定数据源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.10.</span> <span class="nav-text">更多资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DAO-%E6%94%AF%E6%8C%81"><span class="nav-number">1.2.</span> <span class="nav-text">DAO 支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E7%9A%84-Exception-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.1.</span> <span class="nav-text">一致的 Exception 层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Annotations-%E7%94%A8%E4%BA%8E%E9%85%8D%E7%BD%AE-DAO-%E6%88%96-Repository-Classes"><span class="nav-number">1.2.2.</span> <span class="nav-text">Annotations 用于配置 DAO 或 Repository Classes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JDBC-%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-number">1.3.</span> <span class="nav-text">使用 JDBC 进行数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9-JDBC-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">选择 JDBC 数据库访问方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">包层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JDBC-Core-Classes-%E6%8E%A7%E5%88%B6%E5%9F%BA%E6%9C%AC-JDBC-%E5%A4%84%E7%90%86%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用 JDBC Core Classes 控制基本 JDBC 处理和错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JdbcTemplate"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">使用 JdbcTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2-SELECT"><span class="nav-number">1.3.3.1.1.</span> <span class="nav-text">查询(SELECT)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JdbcTemplate-%E6%9B%B4%E6%96%B0-INSERT%EF%BC%8CUPDATE-%E5%92%8C-DELETE"><span class="nav-number">1.3.3.1.2.</span> <span class="nav-text">使用 JdbcTemplate 更新(INSERT，UPDATE 和 DELETE)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-JdbcTemplate-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.3.1.3.</span> <span class="nav-text">其他 JdbcTemplate 操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JdbcTemplate-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">1.3.3.1.4.</span> <span class="nav-text">JdbcTemplate 最佳实践</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-NamedParameterJdbcTemplate"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">使用 NamedParameterJdbcTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SQLExceptionTranslator"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">使用 SQLExceptionTranslator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Running-Statements"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">Running Statements</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Running-Queries"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">Running Queries</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">更新数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E7%B4%A2-Auto-generated-%E9%94%AE"><span class="nav-number">1.3.3.7.</span> <span class="nav-text">检索 Auto-generated 键</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.4.</span> <span class="nav-text">控制数据库连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DataSource"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">使用 DataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DataSourceUtils"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">使用 DataSourceUtils</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0-SmartDataSource"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">实现 SmartDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95-AbstractDataSource"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">扩展 AbstractDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SingleConnectionDataSource"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">使用 SingleConnectionDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DriverManagerDataSource"><span class="nav-number">1.3.4.6.</span> <span class="nav-text">使用 DriverManagerDataSource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-TransactionAwareDataSourceProxy"><span class="nav-number">1.3.4.7.</span> <span class="nav-text">使用 TransactionAwareDataSourceProxy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DataSourceTransactionManager"><span class="nav-number">1.3.4.8.</span> <span class="nav-text">使用 DataSourceTransactionManager</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC-%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.5.</span> <span class="nav-text">JDBC 批处理操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JdbcTemplate-%E8%BF%9B%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">使用 JdbcTemplate 进行基本批处理操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Objects-%E5%88%97%E8%A1%A8%E7%9A%84%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">使用 Objects 列表的批处理操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%89%B9%E6%AC%A1%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">多批次批处理操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleJdbc-Classes-%E7%AE%80%E5%8C%96-JDBC-%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.6.</span> <span class="nav-text">使用 SimpleJdbc Classes 简化 JDBC 操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleJdbcInsert-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">使用 SimpleJdbcInsert 插入数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleJdbcInsert-%E6%A3%80%E7%B4%A2-Auto-generated-%E9%94%AE"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">使用 SimpleJdbcInsert 检索 Auto-generated 键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA-SimpleJdbcInsert-%E6%8C%87%E5%AE%9A%E5%88%97"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">为 SimpleJdbcInsert 指定列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SqlParameterSource-%E6%8F%90%E4%BE%9B%E5%8F%82%E6%95%B0%E5%80%BC"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">使用 SqlParameterSource 提供参数值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleJdbcCall-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">使用 SimpleJdbcCall 调用存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E7%94%A8%E4%BA%8E-SimpleJdbcCall-%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">显式声明用于 SimpleJdbcCall 的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89-SqlParameters"><span class="nav-number">1.3.6.7.</span> <span class="nav-text">如何定义 SqlParameters</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleJdbcCall-%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E7%9A%84-Function"><span class="nav-number">1.3.6.8.</span> <span class="nav-text">使用 SimpleJdbcCall 调用存储的 Function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E-SimpleJdbcCall-%E8%BF%94%E5%9B%9E-ResultSet-%E6%88%96-REF-%E6%B8%B8%E6%A0%87"><span class="nav-number">1.3.6.9.</span> <span class="nav-text">从 SimpleJdbcCall 返回 ResultSet 或 REF 游标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86-JDBC-%E6%93%8D%E4%BD%9C%E5%BB%BA%E6%A8%A1%E4%B8%BA-Java-Objects"><span class="nav-number">1.3.7.</span> <span class="nav-text">将 JDBC 操作建模为 Java Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-SqlQuery"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">了解 SqlQuery</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-MappingSqlQuery"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">使用 MappingSqlQuery</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SqlUpdate"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">使用 SqlUpdate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-StoredProcedure"><span class="nav-number">1.3.7.4.</span> <span class="nav-text">使用 StoredProcedure</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C%E6%95%B0%E6%8D%AE-Value-%E5%A4%84%E7%90%86%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.8.</span> <span class="nav-text">参数和数据 Value 处理的常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%8F%82%E6%95%B0%E6%8F%90%E4%BE%9B-SQL-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">为参数提供 SQL 类型信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86-BLOB-%E5%92%8C-CLOB-objects"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">处理 BLOB 和 CLOB objects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E5%85%A5-IN-%E6%9D%A1%E6%AC%BE%E7%9A%84-Lists-of-Values"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">传入 IN 条款的 Lists of Values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B-Calls"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">处理存储过程的复杂类型 Calls</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81"><span class="nav-number">1.3.9.</span> <span class="nav-text">嵌入式数据库支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">为何使用嵌入式数据库？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-XML-%E5%88%9B%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">使用 Spring XML 创建嵌入式数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">以编程方式创建嵌入式数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">选择嵌入式数据库类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-HSQL"><span class="nav-number">1.3.9.4.1.</span> <span class="nav-text">使用 HSQL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-H2"><span class="nav-number">1.3.9.4.2.</span> <span class="nav-text">使用 H2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Derby"><span class="nav-number">1.3.9.4.3.</span> <span class="nav-text">使用 Derby</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91"><span class="nav-number">1.3.9.5.</span> <span class="nav-text">使用嵌入式数据库测试数据访问逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%94%9F%E6%88%90%E5%94%AF%E4%B8%80%E5%90%8D%E7%A7%B0"><span class="nav-number">1.3.9.6.</span> <span class="nav-text">为嵌入式数据库生成唯一名称</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81"><span class="nav-number">1.3.9.7.</span> <span class="nav-text">扩展嵌入式数据库支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-DataSource"><span class="nav-number">1.3.10.</span> <span class="nav-text">初始化 DataSource</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-XML-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.3.10.1.</span> <span class="nav-text">使用 Spring XML 初始化数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6"><span class="nav-number">1.3.10.1.1.</span> <span class="nav-text">初始化依赖于数据库的其他组件</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-%E5%85%B3%E7%B3%BB%E6%98%A0%E5%B0%84-ORM-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="nav-number">1.4.</span> <span class="nav-text">Object 关系映射(ORM)数据访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Spring-%E4%BB%8B%E7%BB%8D-ORM"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用 Spring 介绍 ORM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC-ORM-Integration-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.4.2.</span> <span class="nav-text">一般 ORM Integration 注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%92%8C-Transaction-Management"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">资源和 Transaction Management</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception%E7%BF%BB%E8%AF%91"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Exception翻译</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hibernate"><span class="nav-number">1.4.3.</span> <span class="nav-text">Hibernate</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84-SessionFactory-%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">Spring 容器中的 SessionFactory 设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-Plain-Hibernate-API-%E5%AE%9E%E7%8E%B0-DAO"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">基于 Plain Hibernate API 实现 DAO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%80%A7-Transaction-%E5%88%86%E7%95%8C"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">声明性 Transaction 分界</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%8C%96%E4%BA%A4%E6%98%93%E5%88%92%E5%88%86"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">程序化交易划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Transaction-Management-Strategies"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">Transaction Management Strategies</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83-Container-managed-%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AE%9A%E4%B9%89%E7%9A%84%E8%B5%84%E6%BA%90"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">比较 Container-managed 和本地定义的资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89-Hibernate-%E7%9A%84%E8%99%9A%E5%81%87-Application-Server-%E8%AD%A6%E5%91%8A"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">带有 Hibernate 的虚假 Application Server 警告</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JPA"><span class="nav-number">1.4.4.</span> <span class="nav-text">JPA</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E7%8E%AF%E5%A2%83%E4%B8%AD-JPA-%E8%AE%BE%E7%BD%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E9%80%89%E9%A1%B9"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">Spring 环境中 JPA 设置的三个选项</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-LocalEntityManagerFactoryBean"><span class="nav-number">1.4.4.1.1.</span> <span class="nav-text">使用 LocalEntityManagerFactoryBean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%8E-JNDI-%E8%8E%B7%E5%8F%96-EntityManagerFactory"><span class="nav-number">1.4.4.1.2.</span> <span class="nav-text">从 JNDI 获取 EntityManagerFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-LocalContainerEntityManagerFactoryBean"><span class="nav-number">1.4.4.1.3.</span> <span class="nav-text">使用 LocalContainerEntityManagerFactoryBean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E6%8C%81%E4%B9%85%E6%80%A7%E5%8D%95%E5%85%83"><span class="nav-number">1.4.4.1.4.</span> <span class="nav-text">处理多个持久性单元</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E5%BC%95%E5%AF%BC"><span class="nav-number">1.4.4.1.5.</span> <span class="nav-text">背景引导</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E-JPA-%E5%AE%9E%E7%8E%B0-DAO%EF%BC%9AEntityManagerFactory-%E5%92%8C-EntityManager"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">基于 JPA 实现 DAO：EntityManagerFactory 和 EntityManager</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-driven-JPA-transactions"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">Spring-driven JPA transactions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-JpaDialect-%E5%92%8C-JpaVendorAdapter"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">了解 JpaDialect 和 JpaVendorAdapter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JTA-Transaction-Management-%E8%AE%BE%E7%BD%AE-JPA"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">使用 JTA Transaction Management 设置 JPA</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F-Hibernate-%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8E%9F%E7%94%9F-Hibernate-Transactions-for-JPA-Interaction"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">原生 Hibernate 设置和原生 Hibernate Transactions for JPA Interaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Object-XML%E6%98%A0%E5%B0%84%E5%99%A8%E7%BC%96%E7%BB%84XML"><span class="nav-number">1.5.</span> <span class="nav-text">使用Object-XML映射器编组XML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.5.1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%93%E4%BA%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">易于配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">一致的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E7%9A%84-Exception-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84-1"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">一致的 Exception 层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Marshaller-%E5%92%8C-Unmarshaller"><span class="nav-number">1.5.2.</span> <span class="nav-text">Marshaller 和 Unmarshaller</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-Marshaller"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">了解 Marshaller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-Unmarshaller"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">了解 Unmarshaller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-XmlMappingException"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">了解 XmlMappingException</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Marshaller-%E5%92%8C-Unmarshaller"><span class="nav-number">1.5.3.</span> <span class="nav-text">使用 Marshaller 和 Unmarshaller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-Configuration-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.5.4.</span> <span class="nav-text">XML Configuration 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JAXB"><span class="nav-number">1.5.5.</span> <span class="nav-text">JAXB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Jaxb2Marshaller"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">使用 Jaxb2Marshaller</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#XML-Configuration-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-1"><span class="nav-number">1.5.5.1.1.</span> <span class="nav-text">XML Configuration 命名空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%93%96%E9%BA%BB"><span class="nav-number">1.5.6.</span> <span class="nav-text">蓖麻</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-CastorMarshaller"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">使用 CastorMarshaller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%B6%E5%9B%BE"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">制图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#XML-Configuration-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-2"><span class="nav-number">1.5.6.2.1.</span> <span class="nav-text">XML Configuration 命名空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JiBX"><span class="nav-number">1.5.7.</span> <span class="nav-text">JiBX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-JibxMarshaller"><span class="nav-number">1.5.7.1.</span> <span class="nav-text">使用 JibxMarshaller</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#XML-Configuration-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-3"><span class="nav-number">1.5.7.1.1.</span> <span class="nav-text">XML Configuration 命名空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XStream"><span class="nav-number">1.5.8.</span> <span class="nav-text">XStream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-XStreamMarshaller"><span class="nav-number">1.5.8.1.</span> <span class="nav-text">使用 XStreamMarshaller</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">1.6.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.6.1.</span> <span class="nav-text">XML 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#tx-Schema"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">tx Schema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdbc-Schema"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">jdbc Schema</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-数据访问/";
    this.page.title = "SpringFramework官方文档翻译-数据访问";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
