<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Web on Reactive Stack 这一部分文档介绍了对构建在响应流API上的可在非阻塞服务器(如Netty、Undertow和Servlet 3.1+容器)上运行的反应堆栈web应用程序的支持。个别章节涵盖了Spring WebFlux框架、响应式web客户端、对测试的支持以及响应式库。有关Servlet堆栈web应用程序，请参阅Servlet堆栈上的web SpringWebFluxS">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-Web on Reactive Stack">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="Web on Reactive Stack 这一部分文档介绍了对构建在响应流API上的可在非阻塞服务器(如Netty、Undertow和Servlet 3.1+容器)上运行的反应堆栈web应用程序的支持。个别章节涵盖了Spring WebFlux框架、响应式web客户端、对测试的支持以及响应式库。有关Servlet堆栈web应用程序，请参阅Servlet堆栈上的web SpringWebFluxS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg">
<meta property="article:published_time" content="2020-08-25T00:35:41.000Z">
<meta property="article:modified_time" content="2020-09-23T03:31:34.849Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-Web on Reactive Stack | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-Web on Reactive Stack
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 08:35:41" itemprop="dateCreated datePublished" datetime="2020-08-25T08:35:41+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-23 11:31:34" itemprop="dateModified" datetime="2020-09-23T11:31:34+08:00">2020-09-23</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Web on Reactive Stack</p>
<p>这一部分文档介绍了对构建在<a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">响应流</a>API上的可在非阻塞服务器(如Netty、Undertow和Servlet 3.1+容器)上运行的反应堆栈web应用程序的支持。个别章节涵盖了Spring WebFlux框架、响应式web客户端、对测试的支持以及<a href="#Reactive库">响应式库</a>。有关Servlet堆栈web应用程序，请参阅Servlet堆栈上的web</p>
<h1 id="SpringWebFlux"><a href="#SpringWebFlux" class="headerlink" title="SpringWebFlux"></a>SpringWebFlux</h1><p>Spring框架中包含的原始web框架Spring web MVC是专门为Servlet API和Servlet容器构建的。随后在5.0版本中添加了响应堆栈web框架Spring WebFlux。它是完全无阻塞的，支持<a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">响应流</a>回压，并在Netty、Undertow和Servlet 3.1+容器上运行。</p>
<p>这两个web框架反映了它们的源模块的名称(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">Spring-webmvc</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">Spring-webflux</a>)，并在Spring框架中共存。每个模块都是可选的。应用程序可以使用其中一个或另一个模块，或者在某些情况下同时使用这两个模块——例如，Spring MVC控制器和响应式WebClient。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为什么创建 Spring WebFlux？</p>
<p>部分原因是需要使用非阻塞web堆栈来处理少量线程的并发性，并使用更少的硬件资源进行伸缩。Servlet 3.1确实为非阻塞I/O提供了一个API。但是，使用它将远离Servlet API的其他部分，其中契约是同步的(过滤器、Servlet)或阻塞的(getParameter、getPart)。这就是新的公共API作为跨任何非阻塞运行时的基础的动机。这一点很重要，因为服务器(比如Netty)已经在异步、非阻塞空间中建立了良好的功能。</p>
<p>答案的另一部分是函数式编程。与Java 5中添加注释创造机会(如带注释的REST控制器或单元测试)一样，Java 8中添加lambda表达式为Java中的函数api创造机会。这对于允许异步逻辑声明式组合的非阻塞应用程序和延续风格api(由CompletableFuture和<a target="_blank" rel="noopener" href="http://reactivex.io/">ReactiveX</a>推广)来说是一个福音。在编程模型级别，Java 8支持Spring WebFlux在带注释的控制器之外提供功能性web端点。</p>
<h3 id="定义“Reactive”"><a href="#定义“Reactive”" class="headerlink" title="定义“Reactive”"></a>定义“Reactive”</h3><p>我们触及“non-blocking”和“功能性”但是 reactive 是什么意思？</p>
<p>术语“reactive”指的是围绕对变化做出反应的编程模型 - 对 I/O events 做出反应的网络组件，对鼠标 events 做出反应的 UI 控制器等。从这个意义上讲，non-blocking 是 reactive，因为我们现在处于一种模式，即在操作完成或数据可用时对通知作出反应。</p>
<p>我们在 Spring 团队中还有另一个重要的机制是“reactive”，这就是 non-blocking 背压。在同步，命令式 code 中，阻塞 calls 是一种自然形式的背压，迫使调用者等待。在 non-blocking code 中，控制 events 的速率变得很重要，这样快速的 producer 就不会压倒它的目的地。</p>
<p>Reactive Streams 是一个<a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">小规格</a>(在 Java 9 中也是<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用</a>)，用于定义具有背压的异步组件之间的交互。对于 example，data repository(充当<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">出版者</a>)可以生成 HTTP 服务器(充当<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">订阅</a>)然后可以写入响应的数据。 Reactive Streams 的主要目的是让订阅者控制发布者生成数据的速度或速度。</p>
<blockquote>
<p><strong>常见问题：如果发布者不能放慢速度怎么办？</strong> Reactive Streams 的目的只是建立机制和边界。如果发布者不能减速，则必须决定是缓冲，丢弃还是失败。</p>
</blockquote>
<h3 id="ReactiveAPI"><a href="#ReactiveAPI" class="headerlink" title="ReactiveAPI"></a>ReactiveAPI</h3><p>Reactive Streams 在互操作性方面发挥着重要作用。它对 libraries 和基础架构组件很感兴趣，但作为 application API 不太有用，因为它太 low-level。 Applications 需要一个 higher-level 和更丰富的功能 API 来组成异步逻辑 - 类似于 Java 8 <code>Stream</code> API，但不仅仅是集合。这是 reactive libraries 扮演的角色。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/reactor/reactor">Reactor</a>是 Spring WebFlux 的 reactive library 选择。它提供<a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">单</a>和<a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">助焊剂</a> API 类型，通过与 ReactiveX <a target="_blank" rel="noopener" href="http://reactivex.io/documentation/operators.html">operators 的词汇</a>对齐的一组丰富的 operators 来处理 0..1(<code>Mono</code>)和 0..N(<code>Flux</code>)的数据序列。 Reactor 是 Reactive Streams library，因此，它的所有 operators 都支持 non-blocking 背压。 Reactor 非常关注 server-side Java。它是与 Spring 密切合作开发的。</p>
<p>WebFlux 要求 Reactor 作为核心依赖项，但它可以通过 Reactive Streams 与其他 reactive libraries 互操作。作为一般规则，WebFlux API 接受普通<code>Publisher</code>作为输入，在内部使其适应 Reactor 类型，使用它，并返回<code>Flux</code>或<code>Mono</code>作为输出。因此，您可以传递任何<code>Publisher</code>作为输入，并且可以对输出应用操作，但是您需要调整输出以与另一个 reactive library 一起使用。只要可行(对于 example，带注释的控制器)，WebFlux 就会透明地适应 RxJava 或其他 reactive library 的使用。有关详细信息，请参阅<a href="#Reactive库">Reactive Libraries</a>。</p>
<h3 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h3><p><code>spring-web</code>模块包含作为 Spring WebFlux 基础的 reactive 基础，包括 HTTP 抽象，Reactive Streams <a href="#HttpHandler">适配器</a>用于支持的服务器，<a href="#编解码器">编解码器</a>，以及与 Servlet API 相当但具有 non-blocking contracts 的核<a href="#WebHandlerAPI">WebHandler API</a>。</p>
<p>在此基础上，Spring WebFlux 提供了两种编程模型的选择：</p>
<ul>
<li><a href="#带注解的控制器">带注解的控制器</a>：与 Spring MVC 一致，并基于<code>spring-web</code>模块的相同注解。 Spring MVC 和 WebFlux 控制器都支持 reactive(Reactor 和 RxJava)return 类型，因此，要区分它们并不容易。一个值得注意的区别是 WebFlux 还支持 reactive <code>@RequestBody</code> arguments。</li>
<li><a href="#功能Endpoints">功能 Endpoints</a>：Lambda-based，轻量级和函数式编程 model。您可以将此视为一个小的 library 或一组实用程序，application 可以用它来路由和处理请求。与带注释的控制器的最大区别在于，application 负责从头到尾的请求处理，而不是通过 annotations 声明意图并被回调。</li>
</ul>
<h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>Spring MVC 或 WebFlux？</p>
<p>这是一个自然而然的问题，但却是一个不合理的二分法。实际上，两者共同努力扩大可用选项的范围。两者的设计是为了保持连续性和一致性，它们可以并排使用，每一方的反馈都有利于双方。下图显示了两者之间的关系，它们在 common 中的含义以及每个对象的唯一性：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg" alt="spring mvc 和 webflux venn"></p>
<p>我们建议您考虑以下具体要点：</p>
<ul>
<li>如果你有一个工作正常的 Spring MVC application，则无需更改。命令式编程是编写，理解和调试 code 的最简单方法。您有 libraries 的最大选择，因为从历史上看，大多数都是阻塞的。</li>
<li>如果您已经在购买 non-blocking web 堆栈，Spring WebFlux 提供与此空间中的其他人相同的执行 model 优势，并且还提供服务器选择(Netty，Tomcat，Jetty，Undertow 和 Servlet 3.1 容器)，这是一种编程选择 models(带注解的控制器和函数 web endpoints)，以及 reactive libraries(Reactor，RxJava 或其他)的选择。</li>
<li>如果您对使用 Java 8 lambdas 或 Kotlin 的轻量级，功能 web framework 感兴趣，可以使用 Spring WebFlux 功能 web endpoints。对于较小的应用程序或微服务而言，这也是一个不错的选择，其需求较少，可以从更高的透明度和控制中受益。</li>
<li>在微服务架构中，您可以将 applications 与 Spring MVC 或 Spring WebFlux 控制器或 Spring WebFlux 功能 endpoints 混合使用。在两个框架中支持相同的基于注解编程 model 使得更容易 re-use 知识，同时也为正确的 job 选择正确的工具。</li>
<li>评估 application 的一种简单方法是检查其依赖关系。如果您要使用阻塞持久性 API(JPA，JDBC)或网络 API，则 Spring MVC 至少是 common 体系结构的最佳选择。 Reactor 和 RxJava 在单独的线程上执行阻塞 calls 在技术上是可行的，但你不会充分利用 non-blocking web 堆栈。</li>
<li>如果你有 Spring MVC application 与 calls 到 remote 服务，请尝试 reactive <code>WebClient</code>。您可以直接从 Spring MVC 控制器方法 return reactive 类型(Reactor，RxJava，<a href="#Reactive库">或其他</a>)。每次呼叫的延迟或 calls 之间的相互依赖性越大，其益处就越大。 Spring MVC 控制器也可以调用其他 reactive 组件。</li>
<li>如果你有一个庞大的团队，请记住转向 non-blocking，功能和声明性编程时的陡峭学习曲线。在没有完整切换的情况下启动的实用方法是使用 reactive <code>WebClient</code>。除此之外，从小处着手衡量效益。我们希望，对于广泛的应用，这种转变是不必要的。如果您不确定要查找哪些好处，请首先了解 non-blocking I/O 如何工作(对于示例，single-threaded Node.js 上的并发)及其效果。</li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>Tomcat，Jetty，Servlet 3.1 容器以及_Net和 Undertow 等 non-Servlet 运行时支持 Spring WebFlux。所有服务器都适用于 low-level，<a href="#HttpHandler">common API</a>，以便跨服务器支持 higher-level <a href="#编程模型">编程模型</a>。</p>
<p>Spring WebFlux 没有启动或停止服务器的 built-in 支持。但是，很容易从 Spring configuration 中应用程序，和<a href="#WebHandlerAPI">运行</a>以及 code 的几行 lines。</p>
<p>Spring Boot 有一个自动执行这些步骤的 WebFlux starter。默认情况下，starter 使用 Netty，但通过更改 Maven 或 Gradle 依赖项可以轻松切换到 Tomcat，Jetty 或 Undertow。 Spring Boot 默认为 Netty，因为它在异步 non-blocking 空间中使用得更广泛，让 client 和服务器共享资源。</p>
<p>Tomcat 和 Jetty 可以与 Spring MVC 和 WebFlux 一起使用。但请记住，它们的使用方式非常不同。 Spring MVC 依赖于 Servlet 阻塞 I/O，并允许 applications 在需要时直接使用 Servlet API。 Spring WebFlux 依赖 Servlet 3.1 non-blocking I/O 并在 low-level 适配器后面使用 Servlet API，不会公开直接使用。</p>
<p>对于 Undertow，Spring WebFlux 直接使用 Undertow API 而不使用 Servlet API。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Performance 具有许多特征和含义。 Reactive 和 non-blocking 通常不会使 applications run 更快。在某些情况下，它们可以(例如，如果使用<code>WebClient</code>在 parallel 中执行 remote calls)。总的来说，non-blocking 方式需要做更多的工作，并且可以稍微增加所需的处理时间。</p>
<p>reactive 和 non-blocking 的 key 预期好处是能够使用少量固定数量的线程进行扩展，而不是 memory。这使得 applications 在负载下更具弹性，因为它们以更可预测的方式扩展。但是，为了观察这些好处，您需要有一些延迟(包括慢速和不可预测的网络混合 I/O)。这就是 reactive 堆栈开始显示其优势的地方，差异可能是戏剧性的。</p>
<h3 id="并发Model"><a href="#并发Model" class="headerlink" title="并发Model"></a>并发Model</h3><p>Spring MVC 和 Spring WebFlux 都支持带注释的控制器，但并发 model 和阻塞和线程的默认假设存在 key 差异。</p>
<p>在 Spring MVC(和 servlet applications)中，假设 applications 可以阻塞当前线程(例如，remote calls)，因此，servlet 容器使用大型线程池来吸收请求期间的潜在阻塞处理。</p>
<p>在 Spring WebFlux(以及一般的 non-blocking 服务器)中，假设 applications 不会阻塞，因此 non-blocking 服务器使用一个小的 fixed-size 线程池(event loop workers)来处理请求。</p>
<blockquote>
<p>“缩放”和“少量线程”听起来可能相互矛盾，但永远不会阻塞当前线程(并依赖于回调)意味着您不需要额外的线程，因为没有阻塞 calls 吸收。</p>
</blockquote>
<p>调用阻止 API</p>
<p>如果你确实需要使用阻止 library 怎么办？ Reactor 和 RxJava 都提供<code>publishOn</code> operator 来继续处理不同的线程。这意味着有一个简单的逃生舱口。但请记住，阻塞 API 不适合这种并发 model。</p>
<p>可变 State</p>
<p>在 Reactor 和 RxJava 中，您通过 operators 声明逻辑，并且在运行时，形成 reactive 管道，其中数据在不同阶段按顺序处理。这样做的好处是它可以使 applications 免于必须保护 mutable state，因为该管道中的 application code 永远不会同时被调用。</p>
<p>Threading Model</p>
<p>您希望在服务器上看到哪些线程运行 Spring WebFlux？</p>
<ul>
<li>在“vanilla”Spring WebFlux 服务器上(例如，没有数据访问或其他可选依赖项)，您可以期望服务器有一个线程，而其他几个用于请求处理(通常与 CPU 核心数一样多)。但是，Servlet 容器可能以更多线程开始(对于示例，Tomcat 上为 10)，以支持 servlet(阻塞)I/O 和 servlet 3.1(non-blocking)I/O 用法。</li>
<li>reactive <code>WebClient</code>以 event 循环样式运行。因此，您可以看到与此相关的少量固定数量的处理线程(对于 example，<code>reactor-http-nio-</code>与 Reactor Netty 连接器)。但是，如果 Reactor Netty 同时用于 client 和 server，则默认情况下两者共享 event 循环资源。</li>
<li>Reactor 和 RxJava 提供线程池抽象，称为调度程序，与<code>publishOn</code> operator 一起使用，用于将处理切换到不同的线程池。调度程序具有建议特定并发策略的名称 - 例如，“ parallel”(对于 CPU-bound 使用有限数量的线程工作)或“elastic”(对于具有大量线程的 I/O-bound 工作)。如果你看到这样的线程，这意味着一些 code 正在使用特定的线程池<code>Scheduler</code>策略。</li>
<li>数据访问 libraries 和其他第三方依赖项也可以创建和使用自己的线程。</li>
</ul>
<p>配置</p>
<p>Spring Framework 不支持启动和停止<a href="#WebFlux配置">服务器</a>。要为服务器配置 threading model，需要使用 server-specific configuration API，或者，如果使用 Spring Boot，请检查每个服务器的 Spring Boot configuration 选项。你可以直接<a href="#HttpHandler">配置</a> <code>WebClient</code>。对于所有其他 libraries，请参阅其各自的文档。</p>
<h2 id="Reactive核心"><a href="#Reactive核心" class="headerlink" title="Reactive核心"></a>Reactive核心</h2><p><code>spring-web</code>模块包含以下对 reactive web applications 的基础支持：</p>
<ul>
<li>对于服务器请求处理，有两个级别的支持。</li>
<li><a href="#服务器">HttpHandler</a>：用于 HTTP 请求处理的基本 contract non-blocking I/O 和 Reactive Streams 背压，以及 Reactor Netty，Undertow，Tomcat，Jetty 和任何 Servlet 3.1 容器的适配器。</li>
<li><a href="#配置">WebHandler API</a>：稍高的 level，general-purpose web API 用于请求处理，在此基础上构建了具体的编程模型，如带注释的控制器和功能 endpoints。</li>
<li>对于 client 方面，有一个基本的<code>ClientHttpConnector</code> contract 来执行带有 non-blocking I/O 和 Reactive Streams 背压的 HTTP 请求，以及<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a>和 reactive <a target="_blank" rel="noopener" href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HtpClient</a>的适配器。 applications 中使用的较高 level <a href="#HttpHandler">Web 客户端</a>建立在这个基本的 contract 上。</li>
<li>对于 client 和 server，<a href="#WebHandlerAPI">编解码器</a>用于序列化和反序列化 HTTP 请求和响应内容。</li>
</ul>
<h3 id="HttpHandler"><a href="#HttpHandler" class="headerlink" title="HttpHandler"></a>HttpHandler</h3><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>是一个简单的 contract，它有一个方法来处理请求和响应。它是故意最小的，它的主要目的是成为不同 HTTP 服务器 API 的最小抽象。</p>
<p>以下 table 描述了支持的服务器 API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>使用的服务器 API</th>
<th>Reactive Streams 支持</th>
</tr>
</thead>
<tbody>
<tr>
<td>Netty</td>
<td>Netty API</td>
<td><a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a></td>
</tr>
<tr>
<td>Undertow</td>
<td>Undertow API</td>
<td>spring-web：Undertow to Reactive Streams bridge</td>
</tr>
<tr>
<td>Tomcat</td>
<td>Servlet 3.1 non-blocking I/O; Tomcat API 读写 ByteBuffers vs byte [98]</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
<tr>
<td>码头</td>
<td>Servlet 3.1 non-blocking I/O; Jetty API 写 ByteBuffers vs byte [99]</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
<tr>
<td>Servlet 3.1 容器</td>
<td>Servlet 3.1 non-blocking I/O</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
</tbody>
</table>
</div>
<p>以下 table 描述了服务器依赖性(另请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/What&#39;s-New-in-the-Spring-Framework">支持的版本</a>)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>Group id</th>
<th>Artifact name</th>
</tr>
</thead>
<tbody>
<tr>
<td>反应堆 Netty</td>
<td>io.projectreactor.netty</td>
<td>reactor-netty</td>
</tr>
<tr>
<td>Undertow</td>
<td>io.undertow</td>
<td>undertow-core</td>
</tr>
<tr>
<td>Tomcat</td>
<td>org.apache.tomcat.embed</td>
<td>tomcat-embed-core</td>
</tr>
<tr>
<td>码头</td>
<td>org.eclipse.jetty</td>
<td>jetty-server，jetty-servlet</td>
</tr>
</tbody>
</table>
</div>
<p>下面的 code 片段显示了对每个服务器 API 使用<code>HttpHandler</code>适配器：</p>
<p><strong>Reactor Netty</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler = ...</span><br><span class="line">ReactorHttpHandlerAdapter adapter = <span class="keyword">new</span> ReactorHttpHandlerAdapter(handler);</span><br><span class="line">HttpServer.create(host, port).newHandler(adapter).block();</span><br></pre></td></tr></table></figure>
<p><strong>Undertow</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler = ...</span><br><span class="line">UndertowHttpHandlerAdapter adapter = <span class="keyword">new</span> UndertowHttpHandlerAdapter(handler);</span><br><span class="line">Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p>Tomcat</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler = ...</span><br><span class="line">Servlet servlet = <span class="keyword">new</span> TomcatHttpHandlerAdapter(handler);</span><br><span class="line"></span><br><span class="line">Tomcat server = <span class="keyword">new</span> Tomcat();</span><br><span class="line">File base = <span class="keyword">new</span> File(System.getProperty(<span class="string">&quot;java.io.tmpdir&quot;</span>));</span><br><span class="line">Context rootContext = server.addContext(<span class="string">&quot;&quot;</span>, base.getAbsolutePath());</span><br><span class="line">Tomcat.addServlet(rootContext, <span class="string">&quot;main&quot;</span>, servlet);</span><br><span class="line">rootContext.addServletMappingDecoded(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;main&quot;</span>);</span><br><span class="line">server.setHost(host);</span><br><span class="line">server.setPort(port);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p><strong>Jetty</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler = ...</span><br><span class="line">Servlet servlet = <span class="keyword">new</span> JettyHttpHandlerAdapter(handler);</span><br><span class="line"></span><br><span class="line">Server server = <span class="keyword">new</span> Server();</span><br><span class="line">ServletContextHandler contextHandler = <span class="keyword">new</span> ServletContextHandler(server, <span class="string">&quot;&quot;</span>);</span><br><span class="line">contextHandler.addServlet(<span class="keyword">new</span> ServletHolder(servlet), <span class="string">&quot;/&quot;</span>);</span><br><span class="line">contextHandler.start();</span><br><span class="line"></span><br><span class="line">ServerConnector connector = <span class="keyword">new</span> ServerConnector(server);</span><br><span class="line">connector.setHost(host);</span><br><span class="line">connector.setPort(port);</span><br><span class="line">server.addConnector(connector);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>
<p><strong>Servlet 3.1 容器</strong></p>
<p>要将 WAR 部署到任何 Servlet 3.1 容器，可以在 WAR 中扩展并包含<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html">AbstractReactiveWebInitializer</a>。 class 用<code>ServletHttpHandlerAdapter</code>包装<code>HttpHandler</code>并将其注册为<code>Servlet</code>。</p>
<h3 id="WebHandlerAPI"><a href="#WebHandlerAPI" class="headerlink" title="WebHandlerAPI"></a>WebHandlerAPI</h3><p><code>org.springframework.web.server</code>包构建在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-client">HttpHandler</a> contract 上，以提供 general-purpose web API，用于通过多个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html">WebExceptionHandler</a>，多个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html">网页过滤</a>和一个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html">WebHandler</a> component 链处理请求。链可以与<code>WebHttpHandlerBuilder</code>放在一起，只需指向 Spring <code>ApplicationContext</code>，其中组件是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">auto-detected</a>，and/or，通过向构建器注册组件。</p>
<p>虽然<code>HttpHandler</code>有一个简单的目标来抽象使用不同的 HTTP 服务器，但<code>WebHandler</code> API 旨在提供 web applications 中常用的更广泛的 features 集合，例如：</p>
<ul>
<li>用户 session 属性。</li>
<li>请求属性。</li>
<li>已解决请求的<code>Locale</code>或<code>Principal</code>。</li>
<li>访问已分析和缓存的表单数据。</li>
<li>multipart 数据的抽象。</li>
<li>和更多..</li>
</ul>
<h4 id="特殊的bean类型"><a href="#特殊的bean类型" class="headerlink" title="特殊的bean类型"></a>特殊的bean类型</h4><p>table 下面的 table 列出了<code>WebHttpHandlerBuilder</code>可以在 Spring ApplicationContext 中的组件，或者可以直接用它注册的组件：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bean name</th>
<th>Bean 类型</th>
<th>计数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><any></td>
<td><code>WebExceptionHandler</code></td>
<td>0..N</td>
<td>为<code>WebFilter</code>实例链和目标<code>WebHandler</code>提供 exceptions 的处理。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">Exceptions</a>。</td>
</tr>
<tr>
<td><any></td>
<td><code>WebFilter</code></td>
<td>0..N</td>
<td>将拦截样式逻辑应用于过滤器链的 rest 和目标<code>WebHandler</code>之前和之后。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api-special-beans">过滤器</a>。</td>
</tr>
<tr>
<td><code>webHandler</code></td>
<td><code>WebHandler</code></td>
<td>1</td>
<td>请求的处理程序。</td>
</tr>
<tr>
<td><code>webSessionManager</code></td>
<td><code>WebSessionManager</code></td>
<td>0..1</td>
<td>通过<code>ServerWebExchange</code>上的方法公开的<code>WebSession</code>实例的 manager。 <code>DefaultWebSessionManager</code>默认情况下。</td>
</tr>
<tr>
<td><code>serverCodecConfigurer</code></td>
<td><code>ServerCodecConfigurer</code></td>
<td>0..1</td>
<td>用于访问<code>HttpMessageReader</code>实例以解析表单数据和 multipart 数据，然后通过<code>ServerWebExchange</code>上的方法公开。 <code>ServerCodecConfigurer.create()</code>默认情况下。</td>
</tr>
<tr>
<td><code>localeContextResolver</code></td>
<td><code>LocaleContextResolver</code></td>
<td>0..1</td>
<td>通过<code>ServerWebExchange</code>上的方法暴露<code>LocaleContext</code>的解析器。 <code>AcceptHeaderLocaleContextResolver</code>默认情况下。</td>
</tr>
<tr>
<td><code>forwardedHeaderTransformer</code></td>
<td><code>ForwardedHeaderTransformer</code></td>
<td>0..1</td>
<td>用于处理转发类型 headers，可以通过提取和删除它们或仅删除它们。默认情况下不使用。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="WebHandlerAPI表单数据"><a href="#WebHandlerAPI表单数据" class="headerlink" title="WebHandlerAPI表单数据"></a>WebHandlerAPI表单数据</h4><p><code>ServerWebExchange</code>公开以下方法来访问表单数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();</span><br></pre></td></tr></table></figure>
<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader</code>将表单数据(<code>application/x-www-form-urlencoded</code>)解析为<code>MultiValueMap</code>。默认情况下，<code>FormHttpMessageReader</code>配置为由<code>ServerCodecConfigurer</code> bean 使用(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-exception-handler">Web Handler API</a>)。</p>
<h4 id="Multipart数据"><a href="#Multipart数据" class="headerlink" title="Multipart数据"></a>Multipart数据</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#过滤器">与 Spring MVC 相同</a></p>
<p><code>ServerWebExchange</code>公开以下方法来访问 multipart 数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();</span><br></pre></td></tr></table></figure>
<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code>将<code>multipart/form-data</code>内容解析为<code>MultiValueMap</code>。目前，<a target="_blank" rel="noopener" href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的 third-party library，也是我们知道的_解析 multipart 请求的唯一 library。它通过<code>ServerCodecConfigurer</code> bean 启用(参见<a href="#WebHandlerAPI">Web Handler API</a>)。</p>
<p>要以流方式解析 multipart 数据，您可以使用从<code>HttpMessageReader&lt;Part&gt;</code>返回的<code>Flux&lt;Part&gt;</code>。例如，在带注释的控制器中，使用<code>@RequestPart</code>意味着按 name 对@相比之下，您可以使用<code>@RequestBody</code>将内容解码为<code>Flux&lt;Part&gt;</code>而无需收集到<code>MultiValueMap</code>。</p>
<h4 id="转发Headers"><a href="#转发Headers" class="headerlink" title="转发Headers"></a>转发Headers</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Multipart解析器">与 Spring MVC 相同</a></p>
<p>当请求通过代理(例如负载平衡器)时，host， port 和 scheme 可能会发生变化，从 client 的角度来看，这使得创建指向正确的 host，port 和 scheme 的链接成为一种挑战。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可用于提供有关原始请求的信息的<code>Forwarded</code> HTTP 标头。还有其他 non-standard headers，包括<code>X-Forwarded-Host</code>，<code>X-Forwarded-Port</code>，<code>X-Forwarded-Proto</code>，<code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderTransformer</code>是一个 component，它根据转发的 headers 修改请求的 host，port 和 scheme，然后删除那些 headers。您可以将其声明为</p>
<p>转发的 headers 有安全注意事项，因为 application 无法知道 headers 是由代理按预期添加还是由恶意 client 添加。这就是为什么应该配置信任边界的代理来删除来自外部的不受信任的转发流量。您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderTransformer</code>，在这种情况下，它会删除但不使用_header。</p>
<blockquote>
<p>在 5.1 <code>ForwardedHeaderFilter</code>被弃用并被<code>ForwardedHeaderTransformer</code>取代，因此在创建交换之前可以更早地处理转发的 headers。如果仍然配置了过滤器，则将其从过滤器列表中取出，而使用<code>ForwardedHeaderTransformer</code>。</p>
</blockquote>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#过滤器">与 Spring MVC 相同</a></p>
<p>在<a href="#WebHandlerAPI">WebHandler API</a>中，您可以使用<code>WebFilter</code>在过滤器处理链的 rest 和目标<code>WebHandler</code>之前和之后应用 interception-style 逻辑。当使用<a href="#WebFlux配置">WebFlux 配置</a>时，注册<code>WebFilter</code>就像将它声明为 Spring bean 和(可选)通过在 bean 声明上使用<code>@Order</code>或通过实现<code>Ordered</code>来表示优先级一样简单。</p>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CORS">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 通过控制器上的 annotations 为 CORS configuration 提供 fine-grained 支持。但是，当您将其与 Spring Security 一起使用时，我们建议依赖 built-in <code>CorsFilter</code>，必须在 Spring Security 的过滤器链之前进行排序。</p>
<p>有关详细信息，请参阅<a href="#WebHandlerAPI">CORS</a>和<a href="#WebFlux配置">CORS WebFilter</a>部分。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CORS过滤器">与 Spring MVC 相同</a></p>
<p>在<a href="#CORS">WebHandler API</a>中，您可以使用<code>WebExceptionHandler</code>来处理<code>WebFilter</code>实例链和目标<code>WebHandler</code>中的 exceptions。当使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors-webfilter">WebFlux 配置</a>时，注册<code>WebExceptionHandler</code>就像将它声明为 Spring bean 和(可选)通过在 bean 声明上使用<code>@Order</code>或通过实现<code>Ordered</code>来表示优先级一样简单。</p>
<p>以下 table 描述了可用的<code>WebExceptionHandler</code>实现：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Exception Handler</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResponseStatusExceptionHandler</code></td>
<td>通过设置对 exception 的 HTTP 状态 code 的响应来提供对<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html">ResponseStatusException</a>类型的 exceptions 的处理。</td>
</tr>
<tr>
<td><code>WebFluxResponseStatusExceptionHandler</code></td>
<td><code>ResponseStatusExceptionHandler</code>的扩展，也可以确定任何 exception 上<code>@ResponseStatus</code> annotation 的 HTTP 状态 code。 此处理程序在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-customer-servlet-container-error-page">WebFlux 配置</a>中声明。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-web-handler-api">与 Spring MVC 相同</a></p>
<p><code>spring-web</code>和<code>spring-core</code>模块支持使用 Reactive Streams 背压通过 non-blocking I/O 序列化和反序列化高级 level objects 的字节内容。以下描述了这种支持：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html">编码器</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html">解码器</a>是低 level contracts 来编码和解码独立于 HTTP 的内容。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html">HttpMessageReader</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html">HttpMessageWriter</a>是 contracts 来编码和解码 HTTP 消息内容。</li>
<li>可以用<code>EncoderHttpMessageWriter</code>包装以使其适用于 web application，而<code>Decoder</code>可以用<code>DecoderHttpMessageReader</code>包装。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html">DataBuffer</a>抽象不同的字节缓冲区表示(e.g. Netty <code>ByteBuf</code>，<code>java.nio.ByteBuffer</code>，etc.)并且是所有编解码器都可以工作的。有关此 topic 的更多信息，请参阅“Spring Core”部分中的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#数据缓冲区和编解码器">数据缓冲区和编解码器</a>。</li>
</ul>
<p><code>spring-core</code>模块提供<code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code>和<code>String</code>编码器和解码器 implementations。 <code>spring-web</code>模块提供 Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers 和其他编码器和解码器以及 web-only HTTP message reader 和 writer implementations，用于表单数据，multipart 内容，server-sent events 等。</p>
<p><code>ClientCodecConfigurer</code>和<code>ServerCodecConfigurer</code>通常用于配置和自定义要在 application 中使用的编解码器。请参阅有关配置<a href="#HTTP消息编解码器">HTTP 消息编解码器</a>的部分。</p>
<h4 id="Jackson-JSON"><a href="#Jackson-JSON" class="headerlink" title="Jackson-JSON"></a>Jackson-JSON</h4><p>当 Jackson library 存在时，都支持 JSON 和二进制 JSON(<a target="_blank" rel="noopener" href="https://github.com/FasterXML/smile-format-specification">Smile</a>)。</p>
<p><code>Jackson2Decoder</code>的工作原理如下：</p>
<ul>
<li>Jackson 的异步，non-blocking 解析器用于将字节块流聚合到<code>TokenBuffer</code>中，每个字节块代表一个 JSON object。</li>
<li>每个<code>TokenBuffer</code>都传递给 Jackson 的<code>ObjectMapper</code>以创建更高的 level object。</li>
<li>解码到 single-value 发布者(e.g. <code>Mono</code>)时，有一个<code>TokenBuffer</code>。</li>
<li>当解码为 multi-value 发布者(e.g. <code>Flux</code>)时，只要收到完全形成的 object 的足够字节，每个<code>TokenBuffer</code>就会传递给<code>ObjectMapper</code>。输入内容可以是 JSON array，如果 content-type 是“application/stream json”，则为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a>。</li>
</ul>
<p><code>Jackson2Encoder</code>的工作原理如下：</p>
<ul>
<li>对于单个 value 发布者(e.g. <code>Mono</code>)，只需通过<code>ObjectMapper</code>序列化它。</li>
<li>对于具有“application/json”的 multi-value 发布者，默认情况下使用<code>Flux#collectToList()</code>收集值，然后序列化生成的集合。</li>
<li>对于具有流媒体类型(如<code>application/stream+json</code>或<code>application/stream+x-jackson-smile</code>)的 multi-value 发布者，使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a>格式单独编码，写入和刷新每个 value。</li>
<li>对于 SSE，每 event 调用<code>Jackson2Encoder</code>并刷新输出以确保无延迟地传递。</li>
</ul>
<blockquote>
<p>默认情况下，<code>Jackson2Encoder</code>和<code>Jackson2Decoder</code>都不支持<code>String</code>类型的元素。相反，默认假设是 string 或 strings 序列表示由<code>CharSequenceEncoder</code>呈现的序列化 JSON 内容。如果您需要从<code>Flux&lt;String&gt;</code>渲染 JSON array，请使用<code>Flux#collectToList()</code>并编码<code>Mono&lt;List&lt;String&gt;&gt;</code>。</p>
</blockquote>
<h4 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h4><p><code>FormHttpMessageReader</code>和<code>FormHttpMessageWriter</code>支持解码和编码“application/x-www-form-urlencoded”内容。</p>
<p>在通常需要从多个位置访问表单内容的服务器端，<code>ServerWebExchange</code>提供了一个专用的<code>getFormData()</code>方法，该方法通过<code>FormHttpMessageReader</code>解析内容，然后缓存结果以便重复访问。请参阅WebHandler API部分中的<a href="#WebHandlerAPI表单数据">表格数据</a>。</p>
<p>使用<code>getFormData()</code>后，将无法再从请求正文中读取原始原始内容。出于这个原因，预期应用程序将始终通过<code>ServerWebExchange</code>来访问缓存的表单数据，而不是从原始请求正文中读取。</p>
<h4 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h4><p><code>MultipartHttpMessageReader</code>和<code>MultipartHttpMessageWriter</code>支持解码和编码“multipart/form-data”内容。反过来<code>MultipartHttpMessageReader</code>委托给另一个<code>HttpMessageReader</code>实际解析为<code>Flux&lt;Part&gt;</code>然后简单地将部分收集到<code>MultiValueMap</code>。目前<a target="_blank" rel="noopener" href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>用于实际解析。</p>
<p>在可能需要从多个位置访问 multipart 表单内容的服务器端，<code>ServerWebExchange</code>提供了一个专用的<code>getMultipartData()</code>方法，该方法通过<code>MultipartHttpMessageReader</code>解析内容，然后缓存结果以便重复访问。请参阅WebHandler API部分中的<a href="#Multipart数据">Multipart 数据</a>。</p>
<p>使用<code>getMultipartData()</code>后，将无法再从请求正文中读取原始原始内容。出于这个原因，applications 必须始终使用<code>getMultipartData()</code>重复，map-like 访问部分，或者依赖<code>SynchronossPartHttpMessageReader</code>来</p>
<h4 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-web-handler-api">与 Spring MVC 相同</a></p>
<p>当流式传输到 HTTP 响应时(对于 example，<code>text/event-stream</code>，<code>application/stream+json</code>)，定期发送数据非常重要，以便可以更快地可靠地检测断开的客户端。这样的发送可以是 comment-only，空的 SSE event 或任何其他有效充当心跳的“no-op”数据。</p>
<h4 id="DataBuffer"><a href="#DataBuffer" class="headerlink" title="DataBuffer"></a>DataBuffer</h4><p><code>DataBuffer</code>是 WebFlux 中字节缓冲区的表示。 reference 的 Spring 核心部分在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#数据缓冲区和编解码器">数据缓冲区和编解码器</a>部分有更多内容。要理解的 key 要点是在像 Netty 这样的服务器上，字节缓冲区被池化并且 reference 计数，并且必须在被消耗时释放以避免 memory 泄漏。</p>
<p>WebFlux applications 通常不需要关心这些问题，除非它们直接使用或生成数据缓冲区，而不是依赖于编解码器与更高级别的 objects 进行转换。或者除非他们选择创建自定义编解码器。对于此类情况，请查看<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-web-handler-api">数据缓冲区和编解码器</a>中的信息，尤其是<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#使用DataBuffer">使用 DataBuffer</a>部分。</p>
<h3 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Logging">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 中的 DEBUG level logging 设计为紧凑，最小和 human-friendly。它侧重于高 value 位信息，这些信息对于仅在调试特定问题时有用的其他信息一次又一次有用。</p>
<p>TRACE level logging 通常遵循与 DEBUG 相同的原则(对于 example 也不应该是一个 firehose)，但可以用于调试任何问题。此外，一些 log 消息可能在 TRACE vs DEBUG 中显示不同的 level 细节。</p>
<p>好 logging 来自使用日志的经验。如果您发现任何不符合既定目标的事件，请告诉我们。</p>
<h4 id="日志Id"><a href="#日志Id" class="headerlink" title="日志Id"></a>日志Id</h4><p>在 WebFlux 中，可以在多个线程上执行单个请求，并且线程 ID 对于关联属于特定请求的 log 消息没有用。这就是为什么 WebFlux log 消息默认以 request-specific ID 为前缀。</p>
<p>在服务器端，log ID 存储在<code>ServerWebExchange</code>属性(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#databuffers">LOG_ID_ATTRIBUTE</a>)中，而基于该 ID 的完全格式化的前缀可从<code>ServerWebExchange#getLogPrefix()</code>获得。在<code>WebClient</code>侧，log ID 存储在<code>ClientRequest</code>属性(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#databuffers-using">LOG_ID_ATTRIBUTE</a>)中，而完全格式化的前缀可从<code>ClientRequest#logPrefix()</code>获得。</p>
<h4 id="敏感数据"><a href="#敏感数据" class="headerlink" title="敏感数据"></a>敏感数据</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#敏感数据">与 Spring MVC 相同</a></p>
<p><code>DEBUG</code>和<code>TRACE</code> logging 可以 log 敏感信息。这就是默认情况下屏蔽表单参数和 headers 的原因，您必须完全显式启用它们的 logging。</p>
<p>followig example 显示了如何为 server-side 请求执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHttpMessageCodecs</span><span class="params">(ServerCodecConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.defaultCodecs().enableLoggingRequestDetails(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何为 client-side 请求执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;ClientCodecConfigurer&gt; consumer = configurer -&gt;</span><br><span class="line">        configurer.defaultCodecs().enableLoggingRequestDetails(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">WebClient webClient = WebClient.builder()</span><br><span class="line">        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p><span id="SpecialBeanTypes"></span></p>
<h2 id="DispatcherHandler"><a href="#DispatcherHandler" class="headerlink" title="DispatcherHandler"></a>DispatcherHandler</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#SpecialBeanTypes">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 与 Spring MVC 类似，是围绕前端控制器 pattern 设计的，其中中心<code>WebHandler</code>，<code>DispatcherHandler</code>为请求处理提供了共享算法，而实际工作则由可配置的委托组件执行。这个 model 非常灵活，支持各种工作流程。</p>
<p><code>DispatcherHandler</code>从 Spring configuration 中发现它需要的委托组件。它也被设计为 Spring bean 本身，并实现<code>ApplicationContextAware</code>以访问运行它的 context。如果声明的</p>
<p>WebFlux application 中的 Spring configuration 通常包含：</p>
<ul>
<li><code>DispatcherHandler</code>与 bean name，<code>webHandler</code></li>
<li><code>WebFilter</code>和<code>WebExceptionHandler</code> beans</li>
<li><a href="#特殊的Bean类型">DispatcherHandler 特殊 beans</a></li>
<li>其他</li>
</ul>
<p>赋予<code>WebHttpHandlerBuilder</code>以 build 处理链，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = ...</span><br><span class="line">HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context);</span><br></pre></td></tr></table></figure>
<p>结果<code>HttpHandler</code>准备好与<a href="#HttpHandler">服务器适配器</a>一起使用。</p>
<h3 id="特殊的Bean类型"><a href="#特殊的Bean类型" class="headerlink" title="特殊的Bean类型"></a>特殊的Bean类型</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#SpecialBeanTypes">与 Spring MVC 相同</a></p>
<p><code>DispatcherHandler</code>委托特殊的 beans 来处理请求并呈现适当的响应。 “special beans”是指实现 WebFlux framework contracts 的 Spring-managed <code>Object</code>实例。那些通常带有 built-in contracts，但您可以自定义它们的 properties，扩展它们或替换它们。</p>
<p>以下 table lists 列出<code>DispatcherHandler</code>检测到的特殊 beans。请注意，在较低的 level 处还检测到一些其他 beans(请参阅 Web Handler API 中的<a href="#特殊的Bean类型">特殊的 bean 类型</a>)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bean 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandlerMapping</code></td>
<td>将请求映射到处理程序。映射基于某些标准，其详细信息因<code>HandlerMapping</code> implementation - 带注释的控制器，简单的 URL pattern 映射等而异。 主<code>HandlerMapping</code> __mplement 为<code>RequestMappingHandlerMapping</code>用于<code>@RequestMapping</code>注释方法，<code>RouterFunctionMapping</code>用于功能端点 routes，<code>SimpleUrlHandlerMapping</code>用于显式注册 URI 路径模式和<code>WebHandler</code>实例。</td>
</tr>
<tr>
<td><code>HandlerAdapter</code></td>
<td>无论实际调用处理程序如何，都帮助<code>DispatcherHandler</code>调用映射到请求的处理程序。例如，调用带注释的控制器需要解析 annotations。 <code>HandlerAdapter</code>的主要目的是保护<code>DispatcherHandler</code>免受这些细节的影响。</td>
</tr>
<tr>
<td><code>HandlerResultHandler</code></td>
<td>处理处理程序调用的结果并完成响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-special-bean-types">结果处理</a>。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="WebFlux配置"><a href="#WebFlux配置" class="headerlink" title="WebFlux配置"></a>WebFlux配置</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebMVC配置">与 Spring MVC 相同</a></p>
<p>Applications 可以声明 process 请求所需的基础结构 beans(列在<a href="#特殊的Bean类型">Web Handler API</a>和<a href="#特殊的Bean类型">DispatcherHandler</a>下)。但是，在大多数情况下，<a href="#WebFlux配置">WebFlux 配置</a>是最好的起点。它声明了所需的 beans 并提供了一个 higher-level configuration 回调 API 来自定义它。</p>
<blockquote>
<p>Spring Boot 依赖于 WebFlux 配置来配置 Spring WebFlux，还提供了许多额外的方便选项。</p>
</blockquote>
<h3 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Processing">与 Spring MVC 相同</a></p>
<p><code>DispatcherHandler</code>处理请求如下：</p>
<ul>
<li>要求每个<code>HandlerMapping</code>找到匹配的处理程序，并使用第一个 match。</li>
<li>如果找到一个处理程序，它将通过适当的<code>HandlerAdapter</code>执行，它将 return value 从执行中公开为<code>HandlerResult</code>。</li>
<li>通过直接写入响应或使用视图进行渲染，<code>HandlerResult</code>被赋予适当的<code>HandlerResultHandler</code>以完成处理。</li>
</ul>
<h3 id="结果处理"><a href="#结果处理" class="headerlink" title="结果处理"></a>结果处理</h3><p>从处理程序的调用到<code>HandlerAdapter</code>的 return value 被包装为<code>HandlerResult</code>，以及一些额外的 context，并传递给声称支持它的第一个<code>HandlerResultHandler</code>。以下 table 显示了可用的<code>HandlerResultHandler</code>实现，所有这些都在<a href="#WebFlux配置">WebFlux 配置</a>中声明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>结果处理程序类型</th>
<th>Return 值</th>
<th>默认 Order</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ResponseEntityResultHandler</code></td>
<td><code>ResponseEntity</code>，通常来自<code>@Controller</code>个实例。</td>
<td>0</td>
</tr>
<tr>
<td><code>ServerResponseResultHandler</code></td>
<td><code>ServerResponse</code>，通常来自功能 endpoints。</td>
<td>0</td>
</tr>
<tr>
<td><code>ResponseBodyResultHandler</code></td>
<td>处理<code>@ResponseBody</code>方法或<code>@RestController</code> classes 中的 return 值。</td>
<td>100</td>
</tr>
<tr>
<td><code>ViewResolutionResultHandler</code></td>
<td><code>CharSequence</code>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html">视图</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/ui/Model.html">模型</a>，<code>Map</code>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a>或任何其他<code>Object</code>被视为 model 属性。 另见<a href="#查看分辨率">查看分辨率</a>。</td>
<td><code>Integer.MAX_VALUE</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Exceptions">与 Spring MVC 相同</a></p>
<p>从<code>HandlerAdapter</code>返回的<code>HandlerResult</code>可以基于某些 handler-specific 机制公开函数以进行错误处理。在以下情况下调用此错误 function：</p>
<ul>
<li>处理程序(用于 example，<code>@Controller</code>)调用失败。</li>
<li>通过<code>HandlerResultHandler</code>处理处理程序 return value 失败。</li>
</ul>
<p>错误 function 可以将响应(对于 example，更改为错误状态)更改为 long，因为错误信号发生在从处理程序返回的 reactive 类型生成任何数据项之前。</p>
<p>这是<code>@Controller</code> classes 中<code>@ExceptionHandler</code>方法的支持方式。相比之下，Spring MVC 中对它的支持是建立在<code>HandlerExceptionResolver</code>上的。这通常无关紧要。但是，请记住，在 WebFlux 中，您不能使用<code>@ControllerAdvice</code>来处理在选择处理程序之前发生的 exceptions。</p>
<p>另请参阅“Annotated Controller”部分中的<a href="#管理Exceptions">管理 Exceptions</a>或 WebHandler API 部分中的<a href="#异常">Exceptions</a>。</p>
<h3 id="View解析器"><a href="#View解析器" class="headerlink" title="View解析器"></a>View解析器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#View解析器">与 Spring MVC 相同</a></p>
<p>视图分辨率允许使用 HTML 模板和 model 呈现给浏览器，而无需将您与特定的视图技术联系起来。在 Spring WebFlux 中，视图解析通过专用的<a href="#结果处理">HandlerResultHandler</a>支持，该HandlerResultHandler使用<code>ViewResolver</code>实例将 String(表示逻辑视图 name)map 映射到<code>View</code>实例。然后使用<code>View</code>来呈现响应。</p>
<h4 id="Handling"><a href="#Handling" class="headerlink" title="Handling"></a>Handling</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Handling">与 Spring MVC 相同</a></p>
<p>传递给<code>ViewResolutionResultHandler</code>的<code>HandlerResult</code>包含来自处理程序的 return value 和包含在请求处理期间添加的属性的 model。 return value 将作为以下之一处理：</p>
<ul>
<li><code>String</code>，<code>CharSequence</code>：要通过已配置的<code>ViewResolver</code> __mplement 列表解析为<code>View</code>的逻辑视图 name。</li>
<li><code>void</code>：根据请求路径选择默认视图 name，减去前导和尾部斜杠，并将其解析为<code>View</code>。如果未提供视图 name(对于 example，返回 model 属性)或 async return value(对于 example，<code>Mono</code>已完成为空)，也会发生相同的情况。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a>：用于视图解析方案的 API。使用 code 完成浏览 IDE 中的选项。</li>
<li><code>Model</code>，<code>Map</code>：要添加到请求的 model 的额外 model 属性。</li>
<li>任何其他：任何其他 return value(由简单类型除外，由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-viewresolver">BeanUtils 的#isSimpleProperty</a>确定)被视为要添加到 model 的 model 属性。除非存在处理程序方法<code>@ModelAttribute</code> annotation，否则属性 name 是使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html">公约</a>从 class name 派生的。</li>
</ul>
<p>model 可以包含异步，reactive 类型(对于 example，来自 Reactor 或 RxJava)。在渲染之前，<code>AbstractView</code>将此类 model 属性解析为具体值并更新 model。 Single-value reactive 类型被解析为单个 value 或没有 value(如果为空)，而 multi-value reactive 类型(对于 example，<code>Flux&lt;T&gt;</code>)被收集并解析为<code>List&lt;T&gt;</code>。</p>
<p>配置视图解析器就像在 Spring configuration 中添加<code>ViewResolutionResultHandler</code> bean 一样简单。 <a href="#视图解析器">WebFlux 配置</a>提供专用的 configuration API 以进行视图分辨率。</p>
<p>有关与 Spring WebFlux 集成的视图技术的更多信息，请参阅<a href="#View技术">查看技术</a>。</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#重定向">与 Spring MVC 相同</a></p>
<p>视图 name 中的特殊<code>redirect:</code>前缀允许您执行重定向。 <code>UrlBasedViewResolver</code>(和 sub-classes)将此识别为需要重定向的指令。视图 name 的 rest 是重定向 URL。</p>
<p>净效果与控制器返回<code>RedirectView</code>或<code>Rendering.redirectTo(&quot;abc&quot;).build()</code>相同，但现在控制器本身可以按逻辑视图名称操作。视图 name(例如<code>redirect:/some/resource</code>)与当前 application 相关，而视图 name(例如<code>redirect:http://example.com/arbitrary/path</code>)重定向到绝对 URL。</p>
<h4 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#内容协商">与 Spring MVC 相同</a></p>
<p><code>ViewResolutionResultHandler</code>支持内容 negotiation。它将请求媒体类型与每个选定的<code>View</code>支持的媒体类型进行比较。使用支持所请求媒体 type(s 的第一个<code>View</code>。</p>
<p>在 order 中支持 JSON 和 XML 等媒体类型，Spring WebFlux 提供<code>HttpMessageWriterView</code>，这是一个特殊的<code>View</code>，通过<a href="#编解码器">HttpMessageWriter</a>呈现。通常，您可以通过<a href="#视图解析器">WebFlux Configuration</a>将它们配置为默认视图。如果它们匹配所请求的媒体类型，则始终选择并使用默认视图。</p>
<h2 id="带注解的控制器"><a href="#带注解的控制器" class="headerlink" title="带注解的控制器"></a>带注解的控制器</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#带注解的控制器">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 提供 annotation-based 编程 model，其中<code>@Controller</code>和<code>@RestController</code>组件使用 annotations 来表达请求映射，请求输入，处理 exceptions 等。带注释的控制器具有灵活的方法签名，不必扩展 base classes，也不必实现特定的接口。</p>
<p>以下清单显示了一个基本的 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello WebFlux&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，该方法返回一个<code>String</code>以写入响应主体。</p>
<h3 id="Controller注解"><a href="#Controller注解" class="headerlink" title="Controller注解"></a>Controller注解</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#宣言">与 Spring MVC 相同</a></p>
<p>您可以使用标准的 Spring bean 定义来定义 controller beans。 <code>@Controller</code>构造型允许 auto-detection 并与 Spring 一般支持对齐，以检测 classpath 中的<code>@Component</code> classes 和 auto-registering bean 定义。它还充当带注释的 class 的构造型，表明它作为 web component 的角色。</p>
<p>要启用 auto-detection 这样的<code>@Controller</code> beans，可以将 component 扫描添加到 Java configuration 中，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;org.example.web&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>扫描<code>org.example.web</code>包。</td>
</tr>
</tbody>
</table>
</div>
<p><code>@RestController</code>是一个[复合注解由元注解<code>@Controller</code>和<code>@ResponseBody</code>组成，表示一个控制器，其每个方法都继承 type-level <code>@ResponseBody</code> 注解，因此，直接写入响应主体，而不是视图解析器，并使用 HTML 模板进行渲染。</p>
<h3 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#请求映射">与 Spring MVC 相同</a></p>
<p><code>@RequestMapping</code> annotation 用于 map 对控制器方法的请求。它具有 match 的各种属性，包括 URL，HTTP 方法，请求参数，headers 和媒体类型。您可以在 class level 中使用它来表示共享映射，或者在方法 level 中使用它来缩小到特定的端点映射。</p>
<p>还有<code>@RequestMapping</code>的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>前面提到的注解是<a href="#自定义注解">自定义注解</a>，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。在同一 time，class level 仍然需要<code>@RequestMapping</code>来表示共享映射。</p>
<p>以下 example 使用类型和方法 level 映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/persons&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.CREATED)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="URI模式"><a href="#URI模式" class="headerlink" title="URI模式"></a>URI模式</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#URI模式">与 Spring MVC 相同</a></p>
<p>您可以使用 glob 模式和通配符 map 请求：</p>
<ul>
<li><code>?</code>匹配一个字符</li>
<li><code>*</code>匹配路径段中的零个或多个字符</li>
<li><code>**</code> 匹配零个或多个路径段</li>
</ul>
<p>您还可以声明 URI 变量并使用<code>@PathVariable</code>访问它们的值，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> Long ownerId, <span class="meta">@PathVariable</span> Long petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在 class 和方法级别声明 URI 变量，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pets/&#123;petId&#125;&quot;)</span> (<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> Long ownerId, <span class="meta">@PathVariable</span> Long petId)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Class-level URI 映射。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Method-level URI 映射。</td>
</tr>
</tbody>
</table>
</div>
<p>URI 变量会自动转换为适当的类型，或者引发<code>TypeMismatchException</code>。默认情况下支持简单类型(<code>int</code>，<code>long</code>，<code>Date</code>等)，您可以注册对任何其他数据类型的支持。见<a href="#类型转换">类型转换</a>和<a href="#DataBinder">DataBinder</a>。</p>
<p>URI 变量可以显式命名(对于 example，<code>@PathVariable(&quot;customId&quot;)</code>)，但是如果名称相同则可以保留该详细信息，并使用调试信息或使用 Java 8 上的<code>-parameters</code>编译器 flag 编译 code。</p>
<p>语法<code>&#123;*varName&#125;</code>声明一个 URI 变量，该变量匹配零个或多个剩余路径段。对于 example <code>/resources/&#123;*path&#125;</code>匹配所有 files <code>/resources/</code>，<code>&quot;path&quot;</code>变量捕获完整的相对路径。</p>
<p>语法<code>&#123;varName:regex&#125;</code>声明了一个 URI 变量，其正则表达式的语法为：<code>&#123;varName:regex&#125;</code>。对于 example，给定<code>/spring-web-3.0.5 .jar</code>的 URL，以下方法将提取 name，version 和文件扩展名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@PathVariable</span> String version, <span class="meta">@PathVariable</span> String ext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URI 路径模式还可以嵌入<code>$&#123;…&#125;</code>占位符，这些占位符在启动时通过<code>PropertyPlaceHolderConfigurer</code>针对本地，系统，环境和其他 property 源进行解析。例如，您可以使用它来基于某些外部 configuration 参数化基本 URL。</p>
<blockquote>
<p>Spring WebFlux 使用<code>PathPattern</code>和<code>PathPatternParser</code>进行 URI 路径匹配支持。这两个 classes 都位于<code>spring-web</code>中，并且明确设计用于 web applications 中的 HTTP URL paths，其中在运行时匹配大量 URI 路径模式。</p>
</blockquote>
<p>Spring WebFlux 不支持后缀 pattern 匹配 - 与 Spring MVC 不同，其中<code>/person</code>等映射也与<code>/person.*</code>匹配。对于 URL-based content negotiation，如果需要，我们建议使用查询参数，该参数更简单，更明确，并且不易受基于 URL 路径的攻击。</p>
<h4 id="Pattern比较"><a href="#Pattern比较" class="headerlink" title="Pattern比较"></a>Pattern比较</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Pattern比较">与 Spring MVC 相同</a></p>
<p>当多个模式匹配 URL 时，必须对它们进行比较以找到最佳的 match。这是通过<code>PathPattern.SPECIFICITY_COMPARATOR</code>完成的，它会查找更具体的模式。</p>
<p>对于每个 pattern，根据 URI 变量和通配符的数量计算得分，其中 URI 变量得分低于通配符。总得分较低的 pattern 获胜。如果两个模式具有相同的分数，则选择的时间越长。</p>
<p>Catch-all 个模式(对于 example，<code>**</code>，<code>&#123;*varName&#125;</code>)将从评分中排除，并始终排在最后。如果两个模式都是 catch-all，则选择的时间越长。</p>
<h4 id="可消费的媒体类型"><a href="#可消费的媒体类型" class="headerlink" title="可消费的媒体类型"></a>可消费的媒体类型</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#可消费的媒体类型">与 Spring MVC 相同</a></p>
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(path = &quot;/pets&quot;, consumes = &quot;application/json&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPet</span><span class="params">(<span class="meta">@RequestBody</span> Pet pet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>consumemes 属性还支持否定表达式 - 对于 example，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何 content type。</p>
<p>您可以在 class level 声明共享的<code>consumes</code>属性。但是，与大多数其他请求映射属性不同，当在 class level 中使用时，method-level <code>consumes</code>属性会覆盖而不是扩展 class-level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量 - 对于 example，<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h4 id="可生产的媒体类型"><a href="#可生产的媒体类型" class="headerlink" title="可生产的媒体类型"></a>可生产的媒体类型</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#可生产的媒体类型">与 Spring MVC 相同</a></p>
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表缩小请求映射，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>媒体类型可以指定字符集。支持否定表达式 - 例如，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何 content type。</p>
<blockquote>
<p>对于 JSON content type，即使<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7159#mvc-ann-requestmapping-pattern-comparison">RFC7159</a>明确指出“没有为此注册定义 charset 参数”，也应指定 UTF-8 <code>charset</code>，因为某些浏览器要求它正确解释 UTF-8 特殊字符。</p>
</blockquote>
<p>您可以在 class level 声明共享的<code>produces</code>属性。但是，与大多数其他请求映射属性不同，当在 class level 中使用时，method-level <code>produces</code>属性会覆盖而不是扩展 class level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量 - e.g. <code>APPLICATION_JSON_UTF8_VALUE</code>，<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h4 id="参数和Headers"><a href="#参数和Headers" class="headerlink" title="参数和Headers"></a>参数和Headers</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#参数和Headers">与 Spring MVC 相同</a></p>
<p>您可以根据查询参数条件缩小请求映射。您可以测试是否存在查询参数(<code>myParam</code>)，缺少(<code>!myParam</code>)或特定 value(<code>myParam=myValue</code>)。以下示例测试带有 value 的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, params = &quot;myParam=myValue&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>检查<code>myParam</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>您也可以使用相同的请求标头条件，如下面的 example 显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets&quot;, headers = &quot;myHeader=myValue&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>检查<code>myHeader</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="HTTP头-OPTIONS"><a href="#HTTP头-OPTIONS" class="headerlink" title="HTTP头,OPTIONS"></a>HTTP头,OPTIONS</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#HTTP头,OPTIONS">与 Spring MVC 相同</a></p>
<p><code>@GetMapping</code>和<code>@RequestMapping(method=HttpMethod.GET)</code>透明地支持 HTTP HEAD 以进行请求映射。控制器方法无需更改。应用于<code>HttpHandler</code>服务器适配器的响应 wrapper 确保将<code>Content-Length</code>标头设置为写入的字节数，而不实际写入响应。</p>
<p>默认情况下，通过将<code>Allow</code>响应标头设置为具有匹配 URL 模式的所有<code>@RequestMapping</code>方法中列出的 HTTP 方法列表来处理 HTTP OPTIONS。</p>
<p>对于没有 HTTP 方法声明的<code>@RequestMapping</code>，<code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。控制器方法应始终声明支持的 HTTP 方法(对于 example，使用 HTTP 方法特定的变体 - <code>@GetMapping</code>，<code>@PostMapping</code>等)。</p>
<p>您可以将<code>@RequestMapping</code>方法显式 map 到 HTTP HEAD 和 HTTP OPTIONS，但在 common 情况下这不是必需的。</p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#自定义注解">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 支持使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#使用元注解和复合注解">复合注解</a>进行请求映射。这些是注释本身 meta-annotated 与<code>@RequestMapping</code>并且用于重新声明<code>@RequestMapping</code>属性的子集(或全部)以及更窄，更具体的目的。</p>
<p><code>@GetMapping</code>，<code>@PostMapping</code>，<code>@PutMapping</code>，<code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。它们是提供的，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。如果您需要_notample of annotations，请查看如何声明它们。</p>
<p>Spring WebFlux 还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要 sub-classing <code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并 return 您自己的<code>RequestCondition</code>。</p>
<h4 id="显式注册"><a href="#显式注册" class="headerlink" title="显式注册"></a>显式注册</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#显式注册">与 Spring MVC 相同</a></p>
<p>您可以以编程方式注册 Handler 方法，这些方法可用于动态注册或高级案例，例如不同 URL 下的同一处理程序的不同实例。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandlerMapping</span><span class="params">(RequestMappingHandlerMapping mapping, UserHandler handler)</span> <span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestMappingInfo info = RequestMappingInfo</span><br><span class="line">                .paths(<span class="string">&quot;/user/&#123;id&#125;&quot;</span>).methods(RequestMethod.GET).build(); (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        Method method = UserHandler.class.getMethod(&quot;getUser&quot;, Long.class); (<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        mapping.registerMapping(info, handler, method); (<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Inject 目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>添加注册。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="处理程序方法"><a href="#处理程序方法" class="headerlink" title="处理程序方法"></a>处理程序方法</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#处理程序方法">与 Spring MVC 相同</a></p>
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从一系列受支持的控制器方法 arguments 和 return 值中进行选择。</p>
<h4 id="方法Arguments"><a href="#方法Arguments" class="headerlink" title="方法Arguments"></a>方法Arguments</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#方法Arguments">与 Spring MVC 相同</a></p>
<p>以下表格显示支持的控制器方法 arguments。</p>
<p>arguments 支持 Reactive 类型(Reactor，RxJava，<a href="#Reactive库">或其他</a>)，需要阻塞 I/O(对于 example，读取请求主体)才能解析。这在“描述”列中标记。 活动类型不适用于不需要阻止的 arguments。</p>
<p>JDK 1.8 的<code>java.util.Optional</code>作为方法参数与 annotations 一起被支持，该注释具有<code>required</code>属性(对于 example，<code>@RequestParam</code>，<code>@RequestHeader</code>和其他)并且等同于<code>required=false</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制器方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ServerWebExchange</code></td>
<td>访问 HTTP 请求和响应，请求和 session 属性，<code>checkNotModified</code>方法等的完整<code>ServerWebExchange</code> - 容器。</td>
</tr>
<tr>
<td><code>ServerHttpRequest</code> , <code>ServerHttpResponse</code></td>
<td>访问 HTTP 请求或响应。</td>
</tr>
<tr>
<td><code>WebSession</code></td>
<td>访问 session。除非添加属性，否则这不会强制启动新的 session。支持 reactive 类型。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code> implementation class。支持 reactive 类型。</td>
</tr>
<tr>
<td><code>org.springframework.http.HttpMethod</code></td>
<td>请求的 HTTP 方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求 locale，由最具体的<code>LocaleResolver</code>可用 - 确定 - 生效，配置为<code>LocaleResolver</code>/<code>LocaleContextResolver</code>。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td>与当前请求关联的 time zone，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问 URI 模板变量。见<a href="#URI模式">URI 模式</a>。</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td>用于访问 URI 路径段中的 name-value 对。见<a href="#矩阵变量">矩阵变量</a>。</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数。参数值将转换为声明的方法参数类型。见<a href="#RequestParam注解">@RequestParam</a>。 请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。请参阅本 table 后面的“任何其他参数”。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求 headers。标头值将转换为声明的方法参数类型。见<a href="#RequestHeader注解">@RequestHeader</a>。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>访问 cookies。 Cookie 值将转换为声明的方法参数类型。见<a href="#CookieValue注解">@CookieValue</a>。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求正文。使用<code>HttpMessageReader</code>实例将正文内容转换为声明的方法参数类型。支持 reactive 类型。见<a href="#RequestBody注解">@RequestBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td>用于访问请求 headers 和 body。正文用<code>HttpMessageReader</code>实例转换。支持 reactive 类型。见<a href="#HttpEntity">HttpEntity</a>。</td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>用于访问<code>multipart/form-data</code>请求中的部分。支持 reactive 类型。见<a href="#MultipartContent">Multipart Content</a>和<a href="#Multipart数据">Multipart 数据</a>。</td>
</tr>
<tr>
<td><code>java.util.Map</code>，<code>org.springframework.ui.Model</code>和<code>org.springframework.ui.ModelMap</code>。</td>
<td>用于访问 HTML 控制器中使用的 model，并作为视图呈现的一部分向模板公开。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>用于访问 model 中的现有属性(如果不存在则实例化)，并应用数据 binding 和验证。见<a href="#ModelAttribute">@ModelAttribute</a>以及<a href="#模型">模型</a>和<a href="#DataBinder">DataBinder</a>。 请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。请参阅本 table 后面的“任何其他参数”。</td>
</tr>
<tr>
<td><code>Errors</code> , <code>BindingResult</code></td>
<td>用于从命令 object(即<code>@ModelAttribute</code>参数)的验证和数据 binding 访问错误或从验证<code>@RequestBody</code>或<code>@RequestPart</code>参数的错误。必须在经过验证的方法参数之后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td>
</tr>
<tr>
<td><code>SessionStatus</code> class-level <code>@SessionAttributes</code></td>
<td>用于标记表单处理完成，它触发通过 class-level <code>@SessionAttributes</code> 注释声明的 session 属性的清除。有关详细信息，请参阅<a href="#SessionAttributes注解">@SessionAttributes</a>。</td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td>用于准备相对于当前请求的 host， port，scheme 和 path 的 URL。见<a href="#URI链接">URI 链接</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何 session 属性 - 与 session 属性存储在 session 中的 model 属性相反。有关详细信息，请参阅<a href="#SessionAttribute注解">@SessionAttribute</a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。有关详细信息，请参阅<a href="#RequestAttribute注解">@RequestAttribute</a>。</td>
</tr>
<tr>
<td>任何其他论点</td>
<td>如果方法参数与上述任何一个都不匹配，则默认情况下，如果它是一个简单类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-uri-building">BeanUtils 的#isSimpleProperty</a>确定)，则为<code>@RequestParam</code>，否则为<code>@ModelAttribute</code>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Return值"><a href="#Return值" class="headerlink" title="Return值"></a>Return值</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Return值">与 Spring MVC 相同</a></p>
<p>以下 table 显示支持的控制器方法 return 值。请注意，libraries 中的 reactive 类型(如 Reactor，RxJava，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestattrib">或其他</a>)通常支持所有 return 值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制器方法 return value</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ResponseBody</code></td>
<td>return value 通过<code>HttpMessageWriter</code>实例编码并写入响应。见<a href="#ResponseBody注解">@ResponseBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code> , <code>ResponseEntity&lt;B&gt;</code></td>
<td>return value 指定完整响应，包括 HTTP headers，主体通过<code>HttpMessageWriter</code>实例编码并写入响应。见<a href="#ResponseEntity">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>HttpHeaders</code></td>
<td>用 headers 返回响应，没有正文。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code>实例解析并与隐式 model 一起使用的视图 name - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(描述为<a href="#Handling">前</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>一个<code>View</code>实例，用于与隐式 model 一起呈现 - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(描述为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-responsebody">前</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式 model 的属性，其中 view name 基于请求路径隐式确定。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到 model 的属性，其中 view name 基于请求路径隐式确定。 请注意<code>@ModelAttribute</code>是可选的。请参阅本 table 后面的“任何其他 return value”。</td>
</tr>
<tr>
<td><code>Rendering</code></td>
<td>model 和视图渲染方案的 API。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>具有<code>void</code>，可能是异步(对于 example，<code>Mono&lt;Void&gt;</code>)， return 类型(或<code>null</code> return value)的方法被认为已完全处理了响应，如果它还具有<code>ServerHttpResponse</code>，<code>ServerWebExchange</code>参数或<code>@ResponseStatus</code> 注释。如果控制器进行了正 ETag 或<code>lastModified</code>时间戳检查，则同样也是 true。 // TODO：有关详情，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-responseentity">控制器</a>。 如果上面的 none 是 true，则<code>void</code> return 类型也可以为 REST 控制器指示“无响应主体”或为 HTML 控制器指定默认视图 name 选择。</td>
</tr>
<tr>
<td><code>Flux&lt;ServerSentEvent&gt;</code>，<code>Observable&lt;ServerSentEvent&gt;</code>或其他 reactive 类型</td>
<td>发出 server-sent events。当只需要写入数据时，可以省略<code>ServerSentEvent</code> wrapper(但是，必须通过<code>produces</code>属性在映射中请求或声明<code>text/event-stream</code>)。</td>
</tr>
<tr>
<td>任何其他 return value</td>
<td>如果 return value 与上述任何一个都不匹配，则默认情况下，它被视为 view name，如果它是<code>String</code>或<code>void</code>(默认视图 name 选择适用)，或者作为 model 属性添加到 model ，除非它是一个简单的类型，由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-viewresolution-handling">BeanUtils 的#isSimpleProperty</a>确定，在这种情况下它仍然没有得到解决。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#类型转换">与 Spring MVC 相同</a></p>
<p>一些带注释的控制器方法 arguments 表示 String-based 请求输入(对于 example，<code>@RequestParam</code>，<code>@RequestHeader</code>，<code>@PathVariable</code>，<code>@MatrixVariable</code>和<code>@CookieValue</code>)，如果参数声明为<code>String</code>以外的其他类型，则可能需要进行类型转换。</p>
<p>对于此类情况，将根据配置的转换器自动应用类型转换。默认情况下，支持简单类型(例如<code>int</code>，<code>long</code>，<code>Date</code>和其他)。可以通过<code>WebDataBinder</code>(参见<a href="#DataBinder">DataBinder</a>)或通过<code>FormattingConversionService</code>(参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Spring字段格式">Spring 字段格式</a>)注册<code>Formatters</code>来自定义类型转换。</p>
<h4 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#矩阵变量">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3986#mvc-ann-initbinder">RFC 3986</a>讨论路径段中的 name-value 对。在 Spring WebFlux 中，我们将它们称为基于 Tim Berners-Lee 的<a target="_blank" rel="noopener" href="https://www.w3.org/DesignIssues/MatrixURIs.html">“老帖子”</a>的“矩阵变量”，但它们也可以称为 URI 路径参数。</p>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔 - 对于 example，<code>&quot;/cars;color=red,green;year=2012&quot;</code>。也可以通过重复的变量名来指定多个值 - 对于 example，<code>&quot;color=red;color=green;color=blue&quot;</code>。</p>
<p>与 Spring MVC 不同，在 WebFlux 中，URL 中矩阵变量的存在与否不会影响请求映射。换句话说，您不需要使用 URI 变量来屏蔽变量内容。也就是说，如果要从控制器方法访问矩阵变量，则需要将 URI 变量添加到期望矩阵变量的路径段中。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42;q=11;r=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId, <span class="meta">@MatrixVariable</span> <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// petId == 42</span></span><br><span class="line">    <span class="comment">// q == 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于所有路径段都可以包含矩阵变量，您有时可能需要消除矩阵变量所在的路径变量的歧义，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11/pets/21;q=22</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@MatrixVariable(name=&quot;q&quot;, pathVar=&quot;ownerId&quot;)</span> <span class="keyword">int</span> q1,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@MatrixVariable(name=&quot;q&quot;, pathVar=&quot;petId&quot;)</span> <span class="keyword">int</span> q2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q1 == 11</span></span><br><span class="line">    <span class="comment">// q2 == 22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以定义矩阵变量，可以将其定义为可选，并指定默认 value，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /pets/42</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(<span class="meta">@MatrixVariable(required=false, defaultValue=&quot;1&quot;)</span> <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// q == 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取所有矩阵变量，请使用<code>MultiValueMap</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@MatrixVariable</span> MultiValueMap&lt;String, String&gt; matrixVars,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@MatrixVariable(pathVar=&quot;petId&quot;&quot;)</span> MultiValueMap&lt;String, String&gt; petMatrixVars)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]</span></span><br><span class="line">    <span class="comment">// petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#RequestParam注解">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestParam</code> annotation 将查询参数绑定到控制器中的方法参数。以下 code 代码段显示了用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pets&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setupForm</span><span class="params">(<span class="meta">@RequestParam(&quot;petId&quot;)</span> <span class="keyword">int</span> petId, Model model)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">        Pet pet = <span class="keyword">this</span>.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(<span class="string">&quot;pet&quot;</span>, pet);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestParam</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Servlet API“请求参数”概念将查询参数，表单数据和多部分合并为一个。但是，在 WebFlux 中，每个都通过<code>ServerWebExchange</code>单独访问。虽然<code>@RequestParam</code>仅绑定到查询参数，但您可以使用 data binding 将查询参数，表单数据和多部分应用于<a href="#ModelAttribute注解">命令 object</a>。</p>
</blockquote>
<p>默认情况下，需要使用<code>@RequestParam</code> annotation 的方法参数，但您可以通过将<code>@RequestParam</code>的 flag 设置为<code>false</code>或通过<code>java.util.Optional</code> wrapper 声明参数来指定方法参数是可选的。</p>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见<a href="#类型转换">类型转换</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>参数上声明<code>@RequestParam</code> annotation 时，map 将填充所有查询参数。</p>
<p>请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。默认情况下，任何属于简单 value 类型的参数(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-ann-requestparam">BeanUtils 的#isSimpleProperty</a>确定)并且未被任何其他参数解析器解析的视图都被视为使用<code>@RequestParam</code>进行注释。</p>
<h4 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="RequestHeader注解"></a>RequestHeader注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#RequestHeader注解">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestHeader</code> annotation 将请求标头绑定到控制器中的方法参数。</p>
<p>以下 example 显示了带有 headers 的请求：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:8080</span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=0.9</span><br><span class="line">Accept-Language         fr,en-gb;q=0.7,en;q=0.3</span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7</span><br><span class="line">Keep-Alive              300</span><br></pre></td></tr></table></figure>
<p>以下 example 获取<code>Accept-Encoding</code>和<code>Keep-Alive</code> headers 的 value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, (<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        @<span class="title">RequestHeader</span><span class="params">(<span class="string">&quot;Keep-Alive&quot;</span>)</span> <span class="keyword">long</span> keepAlive) </span>&#123; (<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>获取<code>Accept-Encoging</code>标头的 value。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>获取<code>Keep-Alive</code>标头的 value。</td>
</tr>
</tbody>
</table>
</div>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见<a href="#类型转换">类型转换</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>，<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code> annotation 时，map 将填充所有标题值。</p>
<blockquote>
<p>Built-in 支持可用于将 comma-separated string 转换为 array 或 strings 集合或类型转换系统已知的其他类型。对于 example，使用<code>@RequestHeader(&quot;Accept&quot;)</code>注释的方法参数可以是<code>String</code>类型，但也可以是<code>String[]</code>或<code>List&lt;String&gt;</code>。</p>
</blockquote>
<h4 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="CookieValue注解"></a>CookieValue注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CookieValue注解">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@CookieValue</code> annotation 将 HTTP cookie 的 value 绑定到控制器中的方法参数。</p>
<p>以下 example 显示了一个带有 cookie 的请求：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">JSESSIONID</span>=<span class="string">415A4AC178C59DACE0B2C9CA727CDD84</span></span><br></pre></td></tr></table></figure>
<p>以下 code sample 演示了如何获取 cookie value：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>获取 cookie value。</td>
</tr>
</tbody>
</table>
</div>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见<a href="#类型转换">类型转换</a>。</p>
<h4 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#ModelAttribute注解">与 Spring MVC 相同</a></p>
<p>您可以在方法参数上使用<code>@ModelAttribute</code> annotation 来从 model 访问属性，或者如果不存在则将其实例化。 model 属性还覆盖了查询参数和表单字段的值，其名称为 match 到字段名称。这称为数据 binding，它使您不必处理解析和转换单个查询参数和表单字段。以下 example 绑定<code>Pet</code>的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute</span> Pet pet)</span> </span>&#123; &#125; (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>绑定<code>Pet</code>的实例。</td>
</tr>
</tbody>
</table>
</div>
<p>前面的 example 中的<code>Pet</code>实例解析如下：</p>
<ul>
<li>如果已经通过<a href="#模型">模型</a>添加了 model。</li>
<li>从 HTTP session 到<a href="#SessionAttributes注解">@SessionAttributes</a>。</li>
<li>从默认构造函数的调用。</li>
<li>从“主构造函数”调用 arguments match 查询参数或表单字段。参数名称通过字节码中的 JavaBeans <code>@ConstructorProperties</code>或 runtime-retained 参数名称确定。</li>
</ul>
<p>获取 model 属性实例后，将应用数据 binding。 <code>WebExchangeDataBinder</code> class 将查询参数和表单字段的名称与目标<code>Object</code>上的字段名称相匹配。在必要时应用类型转换后填充匹配字段。有关数据 binding(和验证)的更多信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#验证,数据绑定和类型转换">验证</a>。有关自定义数据 binding 的更多信息，请参阅<a href="#DataBinder">DataBinder</a>。</p>
<p>数据绑定可能导致错误。默认情况下，会引发<code>WebExchangeBindException</code>，但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加<code>BindingResult</code>参数，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(<span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>添加<code>BindingResult</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>您可以在数据 binding 之后通过添加<code>javax.validation.Valid</code> annotation 或 Spring 的<code>@Validated</code> annotation 自动应用验证(另请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Spring验证">Bean 验证</a>和<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#验证,数据绑定和类型转换">Spring 验证</a>)。以下 example 使用<code>@Valid</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">processSubmit</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Pet pet, BindingResult result)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;petForm&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在 model 属性参数上使用<code>@Valid</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>与 Spring MVC 不同，Spring WebFlux 支持 model 中的 reactive 类型 - 对于 example，<code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code>。您可以使用或不使用 reactive 类型 wrapper 声明<code>@ModelAttribute</code>参数，并且如果需要，它将相应地解析为实际的 value。但是，请注意，要使用<code>BindingResult</code>参数，必须在没有 reactive 类型 wrapper 的情况下声明<code>@ModelAttribute</code>参数，如前所示。或者，您可以通过 reactive 类型处理任何错误，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/owners/&#123;ownerId&#125;/pets/&#123;petId&#125;/edit&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Mono&lt;String&gt; <span class="title">processSubmit</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@ModelAttribute(&quot;pet&quot;)</span> Mono&lt;Pet&gt; petMono)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> petMono</span><br><span class="line">        .flatMap(pet -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorResume(ex -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。默认情况下，任何不是简单 value 类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-ann-initbinder">BeanUtils 的#isSimpleProperty</a>确定)并且未被任何其他参数解析器解析的参数都被视为使用<code>@ModelAttribute</code>进行注释。</p>
<h4 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="SessionAttributes注解"></a>SessionAttributes注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#SessionAttributes注解">与 Spring MVC 相同</a></p>
<p><code>@SessionAttributes</code>用于在请求之间<code>WebSession</code>中存储 model 属性。它是 type-level annotation，声明特定控制器使用的 session 属性。这通常列出 model 属性的名称或 model 属性的类型，这些属性应该透明地存储在 session 中以供后续访问请求使用。</p>
<p>考虑以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttributes</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<p>在第一个请求中，当 model 的 model 属性被添加到 model 时，它会自动提升并保存在<code>WebSession</code>中。它保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@SessionAttributes(&quot;pet&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EditPetForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/pets/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(Pet pet, BindingResult errors, SessionStatus status)</span> </span>&#123; (<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (errors.hasErrors) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">            status.setComplete();</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttributes</code> annotation。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>SessionStatus</code>变量。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SessionAttribute注解"><a href="#SessionAttribute注解" class="headerlink" title="SessionAttribute注解"></a>SessionAttribute注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#SessionAttribute注解">与 Spring MVC 相同</a></p>
<p>如果需要访问全局管理的 pre-existing session 属性(即，在控制器外部 - 对于 example，通过过滤器)并且可能存在或不存在，则可以在方法参数上使用<code>@SessionAttribute</code> annotation，如下所示 example 说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@SessionAttribute</span> User user)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttribute</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>对于需要添加或删除 session 属性的用例，请考虑将<code>WebSession</code>注入控制器方法。</p>
<p>要在 session 中临时存储 model 属性作为控制器工作流的一部分，请考虑使用<code>SessionAttributes</code>，如<a href="#SessionAttributes注解">@SessionAttributes</a>中所述。</p>
<h4 id="RequestAttribute注解"><a href="#RequestAttribute注解" class="headerlink" title="RequestAttribute注解"></a>RequestAttribute注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#RequestAttribute注解">与 Spring MVC 相同</a></p>
<p>与<code>@SessionAttribute</code>类似，您可以使用<code>@RequestAttribute</code> annotation 访问之前创建的 pre-existing 请求属性(对于 example，通过<code>WebFilter</code>)，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@RequestAttribute</span> Client client)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestAttribute</code>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="MultipartContent"><a href="#MultipartContent" class="headerlink" title="MultipartContent"></a>MultipartContent</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Multipart">与 Spring MVC 相同</a></p>
<p>如<a href="#Multipart数据">Multipart 数据</a>中所述，<code>ServerWebExchange</code>提供对 multipart 内容的访问。在控制器中处理文件上载表单(对于 example，从浏览器)的最佳方法是通过数据绑定到<a href="#ModelAttribute">命令 object</a>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MultipartFile file;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/form&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handleFormUpload</span><span class="params">(MyForm form, BindingResult errors)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以在 RESTful 服务方案中从 non-browser clients 提交 multipart 请求。以下 example 使用文件和 JSON：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST /someUrl</span><br><span class="line">Content-Type: multipart/mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;meta-data&quot;</span><br><span class="line">Content-Type: application/json; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;value&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name=&quot;file-data&quot;; filename=&quot;file.properties&quot;</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>@RequestPart</code>访问各个部分，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@RequestPart(&quot;meta-data&quot;)</span> Part metadata, (<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        @<span class="title">RequestPart</span><span class="params">(<span class="string">&quot;file-data&quot;</span>)</span> FilePart file) </span>&#123; (<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>@RequestPart</code>获取文件。</td>
</tr>
</tbody>
</table>
</div>
<p>要反序列化原始部件内容(对于 example，为 JSON - 类似于<code>@RequestBody</code>)，您可以声明具体目标<code>Object</code>，而不是<code>Part</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
</tbody>
</table>
</div>
<p>您可以使用<code>@RequestPart</code>与<code>javax.validation.Valid</code>或 Spring 的<code>@Validated</code> annotation 组合，这会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code>，这会转换为 400(<code>BAD_REQUEST</code>)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata, (<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">        BindingResult result) </span>&#123; (<span class="number">2</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@Valid</code> 注释。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>BindingResult</code>参数。</td>
</tr>
</tbody>
</table>
</div>
<p>要将所有 multipart 数据作为<code>MultiValueMap</code>访问，您可以使用<code>@RequestBody</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@RequestBody</span> Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestBody</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>要以流方式顺序访问 multipart 数据，您可以使用<code>@RequestBody</code>而不是<code>Flux&lt;Part&gt;</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@RequestBody</span> Flux&lt;Part&gt; parts)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestBody</code>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#RequestBody注解">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestBody</code> annotation 将请求主体读取并反序列化为<code>Object</code>到<a href="#编解码器">HttpMessageReader</a>。以下 example 使用<code>@RequestBody</code>参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@RequestBody</span> Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 Spring MVC 不同，在 WebFlux 中，<code>@RequestBody</code>方法参数支持 reactive 类型和完全 non-blocking 读取和(client-to-server)流式传输。以下 example 使用<code>Mono</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@RequestBody</span> Mono&lt;Account&gt; account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<a href="#WebFlux配置">WebFlux 配置</a>的<a href="#HTTP消息编解码器">HTTP 消息编解码器</a>选项来配置或自定义消息 readers。</p>
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.Valid</code>或 Spring 的<code>@Validated</code> annotation 结合使用，这会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code>，这会转换为 400(<code>BAD_REQUEST</code>)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误。以下 example 使用<code>BindingResult</code>参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> Account account, BindingResult result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="HttpEntity"><a href="#HttpEntity" class="headerlink" title="HttpEntity"></a>HttpEntity</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#HttpEntity">与 Spring MVC 相同</a></p>
<p><code>HttpEntity</code>与使用<a href="#RequestBody">@RequestBody</a>或多或少完全相同，但它基于一个容器 object，它暴露了 request headers 和 body。以下 example 使用<code>HttpEntity</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(HttpEntity&lt;Account&gt; entity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="ResponseBody注解"></a>ResponseBody注解</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#ResponseBody注解">与 Spring MVC 相同</a></p>
<p>您可以在方法上使用<code>@ResponseBody</code> annotation 通过<a href="#编解码器">HttpMessageWriter</a>将 return 序列化到响应正文。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class level 也支持<code>@ResponseBody</code>，在这种情况下，它由所有控制器方法继承。这是<code>@RestController</code>的效果，它只不过标有<code>@Controller</code>和<code>@ResponseBody</code>。</p>
<p><code>@ResponseBody</code>支持 reactive 类型，这意味着您可以 return Reactor 或 RxJava 类型，并将它们生成的异步值呈现给响应。有关其他详细信息，请参阅<a href="#Streaming">流</a>和<a href="#Jackson-JSON">JSON 渲染</a>。</p>
<p>您可以将<code>@ResponseBody</code>方法与 JSON 序列化视图结合使用。有关详细信息，请参阅<a href="#JacksonJSON">Jackson JSON</a>。</p>
<p>您可以使用<a href="#WebFlux配置">WebFlux 配置</a>的<a href="#HTTP消息编解码器">HTTP 消息编解码器</a>选项来配置或自定义消息编写。</p>
<h4 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#ResponseEntity">与 Spring MVC 相同</a></p>
<p><code>ResponseEntity</code>就像<a href="#ResponseBody注解">@ResponseBody</a>但有状态和 headers。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/something&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String body = ... ;</span><br><span class="line">    String etag = ... ;</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.ok().eTag(etag).build(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebFlux 支持使用单个 value <a href="#Reactive库">reactive 类型</a>为主体生成<code>ResponseEntity</code>异步，and/or 单和 multi-valuereactive 类型。</p>
<h4 id="JacksonJSON"><a href="#JacksonJSON" class="headerlink" title="JacksonJSON"></a>JacksonJSON</h4><p>Spring 支持 Jackson JSON library。</p>
<h5 id="Jackson-Views"><a href="#Jackson-Views" class="headerlink" title="Jackson Views"></a>Jackson Views</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#JacksonJSON">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 为<a target="_blank" rel="noopener" href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson 的序列化视图</a>提供 built-in 支持，允许只渲染<code>Object</code>中所有字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，可以使用 Jackson 的<code>@JsonView</code> annotation 来激活序列化视图 class，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="meta">@JsonView(User.WithoutPasswordView.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;eric&quot;</span>, <span class="string">&quot;7!jd#h23&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WithPasswordView</span> <span class="keyword">extends</span> <span class="title">WithoutPasswordView</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView(WithoutPasswordView.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonView(WithPasswordView.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@JsonView</code>允许 array 视图 classes，但每个控制器方法只能指定一个。如果需要激活多个视图，请使用复合接口。</p>
</blockquote>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Model">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@ModelAttribute</code> annotation：</p>
<ul>
<li>在<a href="#ModelAttribute注解">方法参数</a> in <code>@RequestMapping</code>方法中，从 model 创建或访问 Object 并通过<code>WebDataBinder</code>将其绑定到请求。</li>
<li>作为<code>@Controller</code>或<code>@ControllerAdvice</code> classes 中的 method-level annotation，帮助在任何<code>@RequestMapping</code>方法调用之前初始化 model。</li>
<li>在<code>@RequestMapping</code>方法上将 return value 标记为 model 属性。</li>
</ul>
<p>本节讨论<code>@ModelAttribute</code>方法，或前面列表中的第二个 item。控制器可以有任意数量的<code>@ModelAttribute</code>方法。所有这些方法都在同一控制器中的<code>@RequestMapping</code>方法之前调用。也可以通过<code>@ControllerAdvice</code>在控制器之间共享<code>@ModelAttribute</code>方法。有关详细信息，请参阅<a href="#ControllerAdvice">控制器建议</a>部分。</p>
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的 arguments(除了<code>@ModelAttribute</code>本身以及与请求体相关的任何事物)。</p>
<p>以下 example 使用<code>@ModelAttribute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateModel</span><span class="params">(<span class="meta">@RequestParam</span> String number, Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    <span class="comment">// add more ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 仅添加一个属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">addAccount</span><span class="params">(<span class="meta">@RequestParam</span> String number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果未明确指定 name，则会根据类型选择默认 name，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>的 javadoc 中所述。您始终可以使用重载的<code>addAttribute</code>方法或<code>@ModelAttribute</code>上的 name 属性(对于 return value)分配显式 name。</p>
</blockquote>
<p>与 Spring MVC 不同，Spring WebFlux 显式支持 model 中的 reactive 类型(对于 example，<code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code>)。如果在没有 wrapper 的情况下声明<code>@ModelAttribute</code>参数，则可以在<code>@RequestMapping</code>调用的 time 处将此类异步 model 属性透明地解析(并且 model 更新)为其实际值，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAccount</span><span class="params">(<span class="meta">@RequestParam</span> String number)</span> </span>&#123;</span><br><span class="line">    Mono&lt;Account&gt; accountMono = accountRepository.findAccount(number);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;account&quot;</span>, accountMono);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping(&quot;/accounts&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handle</span><span class="params">(<span class="meta">@ModelAttribute</span> Account account, BindingResult errors)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，具有 reactive 类型 wrapper 的任何 model 属性在视图呈现之前被解析为其实际值(并且 model 已更新)。</p>
<p>您还可以在<code>@RequestMapping</code>方法上使用<code>@ModelAttribute</code>作为 method-level annotation，在这种情况下，<code>@RequestMapping</code>方法的 return value 将被解释为 model 属性。这通常不是必需的，因为它是 HTML 控制器中的默认行为，除非 return value 是<code>String</code>否则将被解释为 view name。 <code>@ModelAttribute</code>还可以帮助自定义 model 属性 name，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ModelAttribute(&quot;myAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Account <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DataBinder"><a href="#DataBinder" class="headerlink" title="DataBinder"></a>DataBinder</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#DataBinder">与 Spring MVC 相同</a></p>
<p><code>@Controller</code>或<code>@ControllerAdvice</code> classes 可以有<code>@InitBinder</code>方法来初始化<code>WebDataBinder</code>的实例。反过来，这些用于：</p>
<ul>
<li>将请求参数(即表单数据或查询)绑定到 model object。</li>
<li>将<code>String</code> -based 请求值(例如请求参数，路径变量，headers，cookies 等)转换为控制器方法 arguments 的目标类型。</li>
<li>在呈现 HTML 表单时将 model object 值格式化为<code>String</code>值。</li>
</ul>
<p><code>@InitBinder</code>方法可以注册 controller-specific <code>java.bean.PropertyEditor</code>或 Spring <code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a href="#转换，格式化">WebFlux Java configuration</a>在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>类型。</p>
<p><code>@InitBinder</code>方法支持许多与<code>@RequestMapping</code>方法相同的 arguments，但<code>@ModelAttribute</code>(命令 object)arguments 除外。通常，它们使用<code>WebDataBinder</code>参数声明，用于注册，以及<code>void</code> return value。以下 example 使用<code>@InitBinder</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        dateFormat.setLenient(<span class="keyword">false</span>);</span><br><span class="line">        binder.registerCustomEditor(Date.class, <span class="keyword">new</span> CustomDateEditor(dateFormat, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@InitBinder</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<p>或者，当通过共享<code>FormattingConversionService</code>使用<code>Formatter</code> -based 设置时，您可以使用相同的方法并注册 controller-specific <code>Formatter</code>实例，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FormController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addCustomFormatter(<span class="keyword">new</span> DateFormatter(<span class="string">&quot;yyyy-MM-dd&quot;</span>)); (<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>添加自定义格式化程序(在本例中为<code>DateFormatter</code>)。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="管理Exceptions"><a href="#管理Exceptions" class="headerlink" title="管理Exceptions"></a>管理Exceptions</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Exceptions">与 Spring MVC 相同</a></p>
<p><code>@Controller</code>和<a href="#ControllerAdvice">@ControllerAdvice</a> classes 可以有<code>@ExceptionHandler</code>方法来处理来自控制器方法的 exceptions。以下 example 包含这样的处理程序方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">(IOException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明<code>@ExceptionHandler</code>：</td>
</tr>
</tbody>
</table>
</div>
<p>exception 可以对传播的 top-level exception(也就是抛出的直接<code>IOException</code>)进行匹配，或者对wrapper exception 中的直接原因进行匹配(对于 example，包裹在<code>IllegalStateException</code>中)。</p>
<p>对于匹配 exception 类型，最好将目标 exception 声明为方法参数，如前面的 example 所示。或者，annotation 声明可以将 exception 类型缩小为 match。我们通常建议在参数签名中尽可能具体，并在<code>@ControllerAdvice</code>上使用相应的 order 优先声明主根 exception 映射。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Exceptions">MVC 部分</a>。</p>
<blockquote>
<p>WebFlux 中的<code>@ExceptionHandler</code>方法支持与<code>@RequestMapping</code>方法相同的 arguments 和 return 值方法，以及请求 body-和<code>@ModelAttribute</code> -related 方法 arguments 的 exception。</p>
</blockquote>
<p>方法支持_Sp_ _FF 中的<code>@ExceptionHandler</code>方法。有关详细信息，请参阅<a href="#DispatcherHandler">DispatcherHandler</a>。</p>
<h4 id="REST-API异常"><a href="#REST-API异常" class="headerlink" title="REST-API异常"></a>REST-API异常</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#REST-API异常">与 Spring MVC 相同</a></p>
<p>REST 服务的 common 要求是在响应正文中包含错误详细信息。 Spring Framework 不会自动执行此操作，因为响应正文中错误详细信息的表示形式为 application-specific。但是，<code>@RestController</code>可以使用<code>@ExceptionHandler</code>方法和<code>ResponseEntity</code> return value 来设置响应的状态和正文。此类方法也可以在<code>@ControllerAdvice</code> classes 中声明，以便全局应用它们。</p>
<blockquote>
<p>请注意，Spring WebFlux 没有 Spring MVC <code>ResponseEntityExceptionHandler</code>的等效项，因为 WebFlux 仅引发<code>ResponseStatusException</code>(或其子类)，并且不需要将它们转换为 HTTP 状态 code。</p>
</blockquote>
<h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="ControllerAdvice"></a>ControllerAdvice</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#ControllerAdvice">与 Spring MVC 相同</a></p>
<p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于声明它们的<code>@Controller</code> class(或 class 层次结构)。如果您希望此类方法更全局地应用(跨控制器)，则可以在标有<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>的 class 中声明它们。</p>
<p><code>@ControllerAdvice</code>标有<code>@Component</code>，这意味着这样的 classes 可以通过<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#使用scan启用组件扫描">component 扫描</a>注册为 Spring beans。 <code>@RestControllerAdvice</code>也是 meta-annotation 标有<code>@ControllerAdvice</code>和<code>@ResponseBody</code>，这实质上意味着通过消息转换(与视图解析器或模板渲染相比)将<code>@ExceptionHandler</code>方法呈现给响应主体。</p>
<p>在启动时，@RequestMapping和@ExceptionHandler方法的基础结构类检测带有@ControllerAdvice注释的Spring bean，然后在运行时应用它们的方法。全局@ExceptionHandler方法(来自@ControllerAdvice)被应用在本地方法(来自@Controller)之后。相比之下，全局@ModelAttribute和@InitBinder方法会在局部方法之前应用。</p>
<p>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求(即所有控制器)，但您可以通过 annotation 上的属性将其缩小到控制器的子集，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Target all Controllers annotated with @RestController</span></span><br><span class="line"><span class="meta">@ControllerAdvice(annotations = RestController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers within specific packages</span></span><br><span class="line"><span class="meta">@ControllerAdvice(&quot;org.example.controllers&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice2</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Target all Controllers assignable to specific classes</span></span><br><span class="line"><span class="meta">@ControllerAdvice(assignableTypes = &#123;ControllerInterface.class, AbstractController.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleAdvice3</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 selectors 在运行时进行评估，如果您广泛使用它们，可能会对 performance 产生负面影响。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html">@ControllerAdvice</a> javadoc。</p>
<h2 id="功能性Endpoints"><a href="#功能性Endpoints" class="headerlink" title="功能性Endpoints"></a>功能性Endpoints</h2><p>Spring WebFlux 包含 WebFlux.fn，一个轻量级函数式编程 model，其中函数用于 route 和处理请求，contracts 是为不变性而设计的。它是 annotation-based 编程 model 的替代品，但是在相同的<a href="#Reactive核心">Reactive Core</a>基础上运行。</p>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>在 WebFlux.fn 中，HTTP 请求使用<code>HandlerFunction</code>：函数处理，该函数接受<code>ServerRequest</code>并返回延迟的<code>ServerResponse</code>(i.e .<code>Mono&lt;ServerResponse&gt;</code>)。作为响应 object 的请求都具有不可变的 contracts，它提供对 HTTP 请求和响应的 JDK 8-friendly 访问。 <code>HandlerFunction</code>相当于 annotation-based 编程 model 中<code>@RequestMapping</code>方法的主体。</p>
<p>传入的请求被路由到处理程序 function，其中<code>RouterFunction</code>：功能需要<code>ServerRequest</code>并返回延迟的<code>HandlerFunction</code>(i.e.<code>Mono&lt;HandlerFunction&gt;</code>)。当 router function 匹配时，返回一个 handler function;否则是一个空的单声道。 <code>RouterFunction</code>相当于<code>@RequestMapping</code> annotation，但主要区别在于 router 函数不仅提供数据，还提供行为。</p>
<p><code>RouterFunctions.route()</code>提供了一个便于创建 router 的 router 构建器，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line">PersonRepository repository = ...</span><br><span class="line">PersonHandler handler = <span class="keyword">new</span> PersonHandler(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .GET(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">    .GET(<span class="string">&quot;/person&quot;</span>, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">    .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">listPeople</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">createPerson</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getPerson</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<code>RouterFunction</code>的一种方法是将其转换为<code>HttpHandler</code>并通过 built-in <a href="#HttpHandler">服务适配器</a>之一安装它：</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<p>大多数 applications 可以通过 WebFlux Java configuration 运行，请参见<a href="#运行服务器">运行服务器</a>。</p>
<h3 id="HandlerFunction"><a href="#HandlerFunction" class="headerlink" title="HandlerFunction"></a>HandlerFunction</h3><p><code>ServerRequest</code>和<code>ServerResponse</code>是不可变接口，提供对 HTTP 请求和响应的 JDK 8-friendly 访问。请求和响应都对身体流提供了<a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">Reactive Streams</a>背压。请求体用 Reactor <code>Flux</code>或<code>Mono</code>表示。响应正文用任何 Reactive Streams <code>Publisher</code>表示，包括<code>Flux</code>和<code>Mono</code>。有关更多信息，请参阅<a href="#Reactive库">Reactive Libraries</a>。</p>
<h4 id="ServerRequest"><a href="#ServerRequest" class="headerlink" title="ServerRequest"></a>ServerRequest</h4><p><code>ServerRequest</code>提供对 HTTP 方法，URI，headers 和查询参数的访问，同时通过<code>body</code>方法提供对正文的访问。</p>
<p>以下 example 将请求正文提取到<code>Mono&lt;String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; string = request.bodyToMono(String.class);</span><br></pre></td></tr></table></figure>
<p>以下 example 将主体提取到<code>Flux&lt;Person&gt;</code>，其中<code>Person</code> objects 从某些序列化形式(如 JSON 或 XML)解码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Person&gt; people = request.bodyToFlux(Person.class);</span><br></pre></td></tr></table></figure>
<p>前面的示例是使用更通用的<code>ServerRequest.body(BodyExtractor)</code>的快捷方式，它接受<code>BodyExtractor</code>功能策略接口。实用程序 class <code>BodyExtractors</code>提供对许多实例的访问。例如，前面的例子也可以写成如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; string = request.body(BodyExtractors.toMono(String.class));</span><br><span class="line">Flux&lt;Person&gt; people = request.body(BodyExtractors.toFlux(Person.class));</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何访问表单数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, String&gt; map = request.body(BodyExtractors.toFormData());</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何将 multipart 数据作为 map 访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, Part&gt; map = request.body(BodyExtractors.toMultipartData());</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何以流方式访问多个部分，一个在 time 时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Part&gt; parts = request.body(BodyExtractos.toParts());</span><br></pre></td></tr></table></figure>
<h4 id="ServerResponse"><a href="#ServerResponse" class="headerlink" title="ServerResponse"></a>ServerResponse</h4><p><code>ServerResponse</code>提供对 HTTP 响应的访问，因为它是不可变的，所以您可以使用<code>build</code>方法来创建它。您可以使用构建器来设置响应状态，添加响应_header 或提供正文。以下 example 使用 JSON 内容创建 200(OK)响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; person = ...</span><br><span class="line">ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用<code>Location</code>标头 build 201(CREATED)响应并且没有正文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI location = ...</span><br><span class="line">ServerResponse.created(location).build();</span><br></pre></td></tr></table></figure>
<h4 id="HandlerClasses"><a href="#HandlerClasses" class="headerlink" title="HandlerClasses"></a>HandlerClasses</h4><p>我们可以将 handler function 编写为 lambda，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HandlerFunction&lt;ServerResponse&gt; helloWorld =</span><br><span class="line">  request -&gt; ServerResponse.ok().body(fromObject(<span class="string">&quot;Hello World&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这很方便，但在 application 中我们需要多个函数，多个内联 lambda 可能会变得混乱。因此，将相关的处理函数组合成一个处理程序 class 是很有用的，它在 annotation-based application 中具有与<code>@Controller</code>类似的作用。对于 example，以下 class 公开 reactive <code>Person</code> repository：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.ServerResponse.ok;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.BodyInserters.fromObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PersonRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonHandler</span><span class="params">(PersonRepository repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">listPeople</span><span class="params">(ServerRequest request)</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line">        Flux&lt;Person&gt; people = repository.allPeople();</span><br><span class="line">        <span class="keyword">return</span> ok().contentType(APPLICATION_JSON).body(people, Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">createPerson</span><span class="params">(ServerRequest request)</span> </span>&#123; (<span class="number">2</span>)</span><br><span class="line">        Mono&lt;Person&gt; person = request.bodyToMono(Person.class);</span><br><span class="line">        <span class="keyword">return</span> ok().build(repository.savePerson(person));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getPerson</span><span class="params">(ServerRequest request)</span> </span>&#123; (<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">int</span> personId = Integer.valueOf(request.pathVariable(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> repository.getPerson(personId)</span><br><span class="line">            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).body(fromObject(person)))</span><br><span class="line">            .switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>listPeople</code>是一个 handler function，它将 repository 中找到的所有<code>Person</code> objects 作为 JSON 返回。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>createPerson</code>是一个处理程序 function，它存储请求体中包含的新<code>Person</code>。请注意<code>PersonRepository.savePerson(Person)</code>返回<code>Mono&lt;Void&gt;</code>：一个空<code>Mono</code>，当该人从请求中读取并存储时，它会发出完成信号。因此，我们使用<code>build(Publisher&lt;Void&gt;)</code>方法在收到完成信号时(即保存<code>Person</code>时)发送响应。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>getPerson</code>是一个 handler function，它返回一个由<code>id</code> path 变量标识的人。我们从 repository 中检索<code>Person</code>并创建一个 JSON 响应(如果找到它)。如果找不到，我们使用<code>switchIfEmpty(Mono&lt;T&gt;)</code>来_retret 404 Not Found 响应。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="RouterFunction"><a href="#RouterFunction" class="headerlink" title="RouterFunction"></a>RouterFunction</h3><p>Router 函数用于将请求路由到相应的<code>HandlerFunction</code>。通常，您不会自己编写 router 函数，而是使用<code>RouterFunctions</code> utility class 上的方法创建一个。 <code>RouterFunctions.route()</code>(无参数)为 creating router function 提供 fluent 构建器，而<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>提供了创建 router 的直接方法。</p>
<p>通常，建议使用<code>route()</code>构建器，因为它为典型的映射方案提供了方便的 short-cuts，而不需要 hard-to-discover 静态导入。例如，router function 构建器提供方法<code>GET(String, HandlerFunction)</code>来为 GET 请求创建映射;和<code>POST(String, HandlerFunction)</code>用于 POST。</p>
<p>除了 HTTP method-based 映射之外，route 构建器还提供了一种在映射到请求时引入其他谓词的方法。对于每个 HTTP 方法，都有一个重载变量，它将<code>RequestPredicate</code>作为参数，但可以表示其他约束。</p>
<h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>您可以编写自己的<code>RequestPredicate</code>，但<code>RequestPredicates</code>实用程序 class 根据请求路径，HTTP 方法，content-type 等提供常用的 implementations。以下 example 使用请求谓词来基于<code>Accept</code>标头创建约束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = RouterFunctions.route()</span><br><span class="line">    .GET(<span class="string">&quot;/hello-world&quot;</span>, accept(MediaType.TEXT_PLAIN),</span><br><span class="line">        request -&gt; Response.ok().body(fromObject(<span class="string">&quot;Hello World&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>您可以使用以下命令组合多个请求谓词：</p>
<ul>
<li><code>RequestPredicate.and(RequestPredicate)</code> - 两者都必须 match。</li>
<li><code>RequestPredicate.or(RequestPredicate)</code> - 要么 match。</li>
</ul>
<p>来自<code>RequestPredicates</code>的许多谓词都是由组成的。例如，<code>RequestPredicates.GET(String)</code>由<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code>组成。上面显示的 example 也使用两个请求谓词，因为构建器在内部使用<code>RequestPredicates.GET</code>，并使用<code>accept</code>谓词组合它。</p>
<h4 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h4><p>order 函数在 order 中计算：如果第一个 route 不匹配，则计算第二个，依此类推。因此，在通用之前声明更具体的 routes 是有意义的。请注意，此行为与 annotation-based programming model 不同，后者会自动选择“最具体”的控制器方法。</p>
<p>使用 router function 构建器时，所有已定义的 routes 都组成一个从<code>build()</code>返回的<code>RouterFunction</code>。还有其他方法可以组合多个 router 函数：</p>
<ul>
<li>在<code>RouterFunctions.route()</code>构建器上<code>add(RouterFunction)</code></li>
<li><code>RouterFunction.and(RouterFunction)</code></li>
<li><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> - 嵌套<code>RouterFunctions.route()</code>的<code>RouterFunction.and()</code>快捷方式。</li>
</ul>
<p>以下 example 显示了四个 routes 的组成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"></span><br><span class="line">PersonRepository repository = ...</span><br><span class="line">PersonHandler handler = <span class="keyword">new</span> PersonHandler(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; otherRoute = ...</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .GET(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, accept(APPLICATION_JSON), handler::getPerson) (<span class="number">1</span>)</span><br><span class="line">    .GET(<span class="string">&quot;/person&quot;</span>, accept(APPLICATION_JSON), handler::listPeople) (<span class="number">2</span>)</span><br><span class="line">    .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson) (<span class="number">3</span>)</span><br><span class="line">    .add(otherRoute) (<span class="number">4</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>带有与 JSON 匹配的<code>Accept</code>标头的<code>GET /person/&#123;id&#125;</code>被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>带有与 JSON 匹配的<code>Accept</code>标头的<code>GET /person</code>被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>没有附加谓词的<code>POST /person</code>被映射到<code>PersonHandler.createPerson</code>，和</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><code>otherRoute</code>是在其他地方创建的 router function，并添加到构建的 route 中。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="嵌套Routes"><a href="#嵌套Routes" class="headerlink" title="嵌套Routes"></a>嵌套Routes</h4><p>对于一组 router 函数来说，共享谓词(例如共享路径)是 common。在上面的 example 中，共享谓词将是与<code>/person</code>匹配的路径谓词，由三个 routes 使用。使用 annotations 时，您可以使用 maps 到<code>/person</code>的 type-level <code>@RequestMapping</code> 注释来删除此重复项。在 WebFlux.fn 中，可以通过 router function 构建器上的<code>path</code>方法共享路径谓词。例如，通过使用嵌套的 routes，可以通过以下方式改进上述 example 的最后几行行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, builder -&gt; builder</span><br><span class="line">        .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">        .GET(<span class="string">&quot;&quot;</span>, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>请注意，<code>path</code>的第二个参数是一个 consumer，它接受一个 router 构建器。</p>
<p>尽管 path-based 嵌套是最常见的，但您可以使用构建器上的<code>nest</code>方法嵌套在任何类型的谓词上。以上仍然包含共享<code>Accept</code> -header 谓词形式的一些重复。我们可以通过<code>nest</code>方法和<code>accept</code>一起使用来进一步改进：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handler::getPerson)</span><br><span class="line">            .GET(<span class="string">&quot;&quot;</span>, handler::listPeople))</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><p>你如何在 HTTP 服务器中运行 router function？一个简单的选项是使用以下方法之一将 router function 转换为<code>HttpHandler</code>：</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<p>然后，您可以使用返回的<code>HttpHandler</code>与多个服务器适配器一起使用<a href="#HttpHandler">HttpHandler</a>来执行 server-specific 指令。</p>
<p>Spring Boot 也使用的一个更典型的选项是通过<a href="#WebFlux配置">WebFlux 配置</a>运行<a href="#DispatcherHandler">DispatcherHandler</a> -based，它使用 Spring configuration 来声明 process 请求所需的组件。 WebFlux Java configuration 声明以下基础结构组件以支持功能 endpoints：</p>
<ul>
<li><code>RouterFunctionMapping</code>：在 Spring configuration 中检测一个或多个<code>RouterFunction&lt;?&gt;</code> beans，通过<code>RouterFunction.andOther</code>和 routes 请求将它们组合到生成的组合<code>RouterFunction</code>中。</li>
<li><code>HandlerFunctionAdapter</code>：简单的适配器，允许<code>DispatcherHandler</code>调用映射到请求的<code>HandlerFunction</code>。</li>
<li><code>ServerResponseResultHandler</code>：通过调用<code>ServerResponse</code>的<code>writeTo</code>方法处理调用<code>HandlerFunction</code>的结果。</li>
</ul>
<p>前面的组件允许函数 endpoints 适合<code>DispatcherHandler</code>请求处理生命周期，并且(可能)与带注释的控制器并行运行(如果有的话)。它也是 Spring Boot WebFlux starter 启用功能 endpoints 的方式。</p>
<p>以下 example 显示了 WebFlux Java configuration(有关如何运行它，请参阅<a href="#DispatcherHandler">DispatcherHandler</a>)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionA() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RouterFunction&lt;?&gt; routerFunctionB() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHttpMessageCodecs</span><span class="params">(ServerCodecConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// configure message conversion...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// configure CORS...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// configure view resolution for HTML rendering...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤处理程序函数"><a href="#过滤处理程序函数" class="headerlink" title="过滤处理程序函数"></a>过滤处理程序函数</h3><p>您可以使用 routing function 构建器上的<code>before</code>，<code>after</code>或<code>filter</code>方法过滤处理函数。使用 annotations，您可以使用<code>@ControllerAdvice</code>，<code>ServletFilter</code>或两者来实现类似的功能。过滤器将应用于构建器构建的所有 routes。这意味着嵌套的 routes 中定义的过滤器不适用于“top-level”routes。例如，请考虑以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handler::getPerson)</span><br><span class="line">            .GET(<span class="string">&quot;&quot;</span>, handler::listPeople)</span><br><span class="line">            .before(request -&gt; ServerRequest.from(request) (<span class="number">1</span>)</span><br><span class="line">                .header(<span class="string">&quot;X-RequestHeader&quot;</span>, <span class="string">&quot;Value&quot;</span>)</span><br><span class="line">                .build()))</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .after((request, response) -&gt; logResponse(response)) (<span class="number">2</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>添加自定义请求标头的<code>before</code>过滤器仅应用于两个 GET routes。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>记录响应的<code>after</code>过滤器将应用于所有 routes，包括嵌套的 routes。</td>
</tr>
</tbody>
</table>
</div>
<p>router 构建器上的<code>filter</code>方法采用<code>HandlerFilterFunction</code>：函数，它接受<code>ServerRequest</code>和<code>HandlerFunction</code>并返回<code>ServerResponse</code>。 handler function 参数表示链中的下一个元素。这通常是路由到的处理程序，但如果应用了多个，它也可以是另一个过滤器。</p>
<p>现在我们可以为 route 添加一个简单的安全过滤器，假设我们有<code>SecurityManager</code>可以确定是否允许特定路径。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager securityManager = ...</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route = route()</span><br><span class="line">    .path(<span class="string">&quot;/person&quot;</span>, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(<span class="string">&quot;/&#123;id&#125;&quot;</span>, handler::getPerson)</span><br><span class="line">            .GET(<span class="string">&quot;&quot;</span>, handler::listPeople))</span><br><span class="line">        .POST(<span class="string">&quot;/person&quot;</span>, handler::createPerson))</span><br><span class="line">    .filter((request, next) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (securityManager.allowAccessTo(request.path())) &#123;</span><br><span class="line">            <span class="keyword">return</span> next.handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.status(UNAUTHORIZED).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>前面的 example 演示了调用<code>next.handle(ServerRequest)</code>是可选的。我们只允许在允许访问时执行 handler function。</p>
<p>除了在 router function 构建器上使用<code>filter</code>方法之外，还可以通过<code>RouterFunction.filter(HandlerFilterFunction)</code>将过滤器应用于现有的 router function。</p>
<blockquote>
<p>功能 endpoints 的 CORS 支持通过专用的<a href="#DispatcherHandler">CorsWebFilter</a>提供。</p>
</blockquote>
<h2 id="URI链接"><a href="#URI链接" class="headerlink" title="URI链接"></a>URI链接</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#URI链接">与 Spring MVC 相同</a></p>
<p>本节介绍 Spring Framework 中可用于准备 URI 的各种选项。</p>
<h3 id="UriComponents"><a href="#UriComponents" class="headerlink" title="UriComponents"></a>UriComponents</h3><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>有助于使用变量从 URI 模板中构建 URI，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)  (<span class="number">1</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)  (<span class="number">2</span>)</span><br><span class="line">        .encode() (<span class="number">3</span>)</span><br><span class="line">        .build(); (<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">URI uri = uriComponents.expand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>).toUri();  (<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>带有 URI 模板的静态工厂方法。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>添加或替换 URI 组件。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>请求编码 URI 模板和 URI 变量。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Build a <code>UriComponents</code>。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>展开变量并获取<code>URI</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>前面的 example 可以合并为一个链并用<code>buildAndExpand</code>缩短，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .encode()</span><br><span class="line">        .buildAndExpand(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>)</span><br><span class="line">        .toUri();</span><br></pre></td></tr></table></figure>
<p>您可以通过直接转到 URI(这意味着编码)来进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;http://example.com/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>您可以使用完整的 URI 模板进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder</span><br><span class="line">        .fromUriString(<span class="string">&quot;http://example.com/hotels/&#123;hotel&#125;?q=&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="UriBuilder"><a href="#UriBuilder" class="headerlink" title="UriBuilder"></a>UriBuilder</h3><p>Spring MVC 和 Spring WebFlux</p>
<p><a href="#UriComponents">UriComponentsBuilder</a>实现<code>UriBuilder</code>。您可以使用<code>UriBuilderFactory</code>创建<code>UriBuilder</code>。 <code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置(例如基本 URL，编码首选项和其他详细信息)从 URI 模板中构建 URI。</p>
<p>您可以使用<code>UriBuilderFactory</code>配置<code>RestTemplate</code>和<code>WebClient</code>以自定义 URI 的准备。 <code>DefaultUriBuilderFactory</code>是<code>UriBuilderFactory</code>的默认_impleration，它在内部使用<code>UriComponentsBuilder</code>并公开共享 configuration 选项。</p>
<p>以下 example 显示了如何配置<code>RestTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span></span><br><span class="line"></span><br><span class="line">String baseUrl = <span class="string">&quot;http://example.org&quot;</span>;</span><br><span class="line">DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br></pre></td></tr></table></figure>
<p>以下 example 配置<code>WebClient</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span></span><br><span class="line"></span><br><span class="line">String baseUrl = <span class="string">&quot;http://example.org&quot;</span>;</span><br><span class="line">DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>
<p>此外，您还可以直接使用<code>DefaultUriBuilderFactory</code>。它类似于使用<code>UriComponentsBuilder</code>但是，它不是静态工厂方法，而是一个包含 configuration 和 preferences 的实际实例，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl = <span class="string">&quot;http://example.com&quot;</span>;</span><br><span class="line">DefaultUriBuilderFactory uriBuilderFactory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl);</span><br><span class="line"></span><br><span class="line">URI uri = uriBuilderFactory.uriString(<span class="string">&quot;/hotels/&#123;hotel&#125;&quot;</span>)</span><br><span class="line">        .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">        .build(<span class="string">&quot;Westin&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h3><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
<ul>
<li>首先<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#webflux-cors-webfilter">UriComponentsBuilder#encode()</a>：Pre-encodes URI 模板，然后在扩展时严格编码 URI 变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#mvc-uri-building">UriComponents#encode()</a>：扩展 URI 变量后对 URI 组件进行编码。</li>
</ul>
<p>这两个选项都使用转义的八位字节替换 non-ASCII 和非法字符。但是，第一个选项还会替换出现在 URI 变量中的保留含义的字符。</p>
<blockquote>
<p>考虑“;”，这在路径中是合法的但具有保留意义。第一个选项取代“;”在 URI 变量中使用“％3B”但在 URI 模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p>
</blockquote>
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将 URI 变量视为完全编码的不透明数据，而选项 2 仅在 URI 变量故意包含保留字符时才有用。</p>
<p>以下 example 使用第一个选项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder.fromPath(<span class="string">&quot;/hotel list/&#123;city&#125;&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">            .encode()</span><br><span class="line">            .buildAndExpand(<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;foo+bar&quot;</span>)</span><br><span class="line">            .toUri();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Result is &quot;/hotel%20list/New%20York?q=foo%2Bbar&quot;</span></span><br></pre></td></tr></table></figure>
<p>您可以通过直接转到 URI(这意味着编码)来缩短前面的 example，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder.fromPath(<span class="string">&quot;/hotel list/&#123;city&#125;&quot;</span>)</span><br><span class="line">            .queryParam(<span class="string">&quot;q&quot;</span>, <span class="string">&quot;&#123;q&#125;&quot;</span>)</span><br><span class="line">            .build(<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;foo+bar&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>您可以使用完整的 URI 模板进一步缩短它，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI uri = UriComponentsBuilder.fromPath(<span class="string">&quot;/hotel list/&#123;city&#125;?q=&#123;q&#125;&quot;</span>)</span><br><span class="line">            .build(<span class="string">&quot;New York&quot;</span>, <span class="string">&quot;foo+bar&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>WebClient</code>和<code>RestTemplate</code>通过<code>UriBuilderFactory</code>策略在内部扩展和编码 URI 模板。两者都可以配置自定义策略。如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl = <span class="string">&quot;http://example.com&quot;</span>;</span><br><span class="line">DefaultUriBuilderFactory factory = <span class="keyword">new</span> DefaultUriBuilderFactory(baseUrl)</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Customize the RestTemplate..</span></span><br><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Customize the WebClient..</span></span><br><span class="line">WebClient client = WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>
<p><code>DefaultUriBuilderFactory</code> 实现在内部使用<code>UriComponentsBuilder</code>来扩展和编码 URI 模板。作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
<ul>
<li><code>TEMPLATE_AND_VALUES</code>：使用<code>UriComponentsBuilder#encode()</code>(对应于前面列表中的第一个选项)pre-encode URI 模板，并在扩展时严格编码 URI 变量。</li>
<li><code>VALUES_ONLY</code>：不对 URI 模板进行编码，而是在将 URI 变量扩展到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对 URI 变量应用严格编码。</li>
<li><code>URI_COMPONENTS</code>：使用<code>UriComponents#encode()</code>(对应于前面列表中的第二个选项)，在扩展 URI 变量后对 URI component value 进行编码。</li>
<li><code>NONE</code>：未应用编码。</li>
</ul>
<p>出于历史原因和向后兼容性，<code>RestTemplate</code>设置为<code>EncodingMode.URI_COMPONENTS</code>。 <code>WebClient</code>依赖于<code>DefaultUriBuilderFactory</code>中的默认 value，它在 5.0.x 中从<code>EncodingMode.URI_COMPONENTS</code>更改为 5.1 中的<code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p>
<h2 id="CORS-1"><a href="#CORS-1" class="headerlink" title="CORS"></a>CORS</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CORS">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 允许您处理 CORS(Cross-Origin 资源共享)。本节介绍如何执行此操作。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#介绍">与 Spring MVC 相同</a></p>
<p>出于安全原因，浏览器禁止 AJAX calls 到当前源之外的资源。例如，您可以将您的银行帐户放在一个标签中，将 evil.com 放在另一个标签中。来自 evil.com 的脚本不应该使用您的凭据向您的银行 API 发出 AJAX 请求 - 例如，从您的帐户中提取资金！</p>
<p>Cross-Origin 资源共享(CORS)是由<a target="_blank" rel="noopener" href="https://caniuse.com/#encode--">大多数浏览器</a>实现的<a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">W3C 规范</a>，它允许您指定授权的 cross-domain 请求类型，而不是使用基于 IFRAME 或 JSONP 的安全性较低且功能较弱的变通方法。</p>
<h3 id="Processing-1"><a href="#Processing-1" class="headerlink" title="Processing"></a>Processing</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Processing">与 Spring MVC 相同</a></p>
<p>CORS 规范区分了预检，简单和实际请求。要了解 CORS 的工作原理，您可以阅读<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>等许多其他内容，或者查看规范以获取更多详细信息。</p>
<p>Spring WebFlux <code>HandlerMapping</code> implementations 为 CORS 提供 built-in 支持。成功将请求映射到处理程序后，<code>HandlerMapping</code>检查给定请求和处理程序的 CORS configuration 并采取进一步操作。直接处理预检请求，同时拦截，验证简单和实际的 CORS 请求，并设置所需的 CORS 响应头。</p>
<p>在 order 中启用 cross-origin 请求(即，<code>Origin</code>标头存在且与请求的 host 不同)，您需要有一些显式声明的 CORS configuration。如果未找到匹配的 CORS configuration，则拒绝预检请求。没有 CORS headers 被添加到简单和实际 CORS 请求的响应中，因此浏览器拒绝它们。</p>
<p>每个<code>HandlerMapping</code>可以_11单独使用 URL pattern-based <code>CorsConfiguration</code>映射。在大多数情况下，applications 使用 WebFlux Java configuration 来声明这样的映射，这会导致单个 global map 传递给所有<code>HadlerMappping</code> __mplement。</p>
<p>您可以将<code>HandlerMapping</code> level 上的 global CORS configuration 与更多 fine-grained，handler-level CORS configuration 结合使用。对于 example，带注释的控制器可以使用 class-或 method-level <code>@CrossOrigin</code> 注释(其他处理程序可以实现<code>CorsConfigurationSource</code>)。</p>
<p>组合 global 和 local configuration 的规则通常是加法的 - 例如，所有 global 和所有本地起源。对于只能接受单个 value 的属性，例如<code>allowCredentials</code>和<code>maxAge</code>，本地会覆盖 global value。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#mvc-cors-intro">CorsConfiguration#combine(CorsConfiguration)</a>。</p>
<blockquote>
<p>要从源中了解更多信息或进行高级自定义，请参阅：</p>
</blockquote>
<ul>
<li><code>CorsConfiguration</code></li>
<li><code>CorsProcessor</code>和<code>DefaultCorsProcessor</code></li>
<li><code>AbstractHandlerMapping</code></li>
</ul>
<h3 id="CrossOrigin注解"><a href="#CrossOrigin注解" class="headerlink" title="CrossOrigin注解"></a>CrossOrigin注解</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CrossOrigin注解">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html">@CrossOrigin</a> 注解在带注释的控制器方法上启用 cross-origin 请求，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Account&gt; <span class="title">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>@CrossOrigin</code>允许：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li>控制器方法映射到的所有 HTTP 方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它会建立一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的时候使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<p>class level 也支持<code>@CrossOrigin</code>，并且由所有方法继承。以下 example 指定某个域并_set <code>maxAge</code>到一小时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://domain2.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Account&gt; <span class="title">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在 class 和方法 level 中使用<code>@CrossOrigin</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(maxAge = 3600)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(&quot;http://domain2.com&quot;)</span> (<span class="number">2</span>)</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Account&gt; <span class="title">retrieve</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">remove</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在 class level 上使用<code>@CrossOrigin</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>在 level 方法中使用<code>@CrossOrigin</code>。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#全局配置">与 Spring MVC 相同</a></p>
<p>除了 fine-grained，controller method-level configuration 之外，您可能还想定义一些 global CORS configuration。您可以在任何<code>HandlerMapping</code>上单独设置 URL-based <code>CorsConfiguration</code>映射。但是，大多数 applications 都使用 WebFlux Java configuration 来实现这一点。</p>
<p>默认情况下 global configuration 启用以下内容：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li><code>GET</code>，<code>HEAD</code>和<code>POST</code>方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它会建立一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的时候使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<p>要在 WebFlux Java configuration 中启用 CORS，可以使用<code>CorsRegistry</code>回调，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">            .allowedOrigins(<span class="string">&quot;http://domain2.com&quot;</span>)</span><br><span class="line">            .allowedMethods(<span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">            .allowedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>, <span class="string">&quot;header3&quot;</span>)</span><br><span class="line">            .exposedHeaders(<span class="string">&quot;header1&quot;</span>, <span class="string">&quot;header2&quot;</span>)</span><br><span class="line">            .allowCredentials(<span class="keyword">true</span>).maxAge(<span class="number">3600</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add more mappings...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CORS过滤器"><a href="#CORS过滤器" class="headerlink" title="CORS过滤器"></a>CORS过滤器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CORS过滤器">与 Spring MVC 相同</a></p>
<p>您可以通过 built-in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html">CorsWebFilter</a>应用 CORS 支持，这非常适合<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#combine-org.springframework.web.cors.CorsConfiguration-">功能 endpoints</a>。</p>
<p>要配置过滤器，可以声明<code>CorsWebFilter</code> bean 并将<code>CorsConfigurationSource</code>传递给其构造函数，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">CorsWebFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Possibly...</span></span><br><span class="line">    <span class="comment">// config.applyPermitDefaultValues()</span></span><br><span class="line"></span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">&quot;http://domain1.com&quot;</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Web安全">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security/">Spring Security</a>项目支持保护 web applications 免受恶意攻击。请参阅 Spring Security reference 文档，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-cors-global">WebFlux 安全</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-cors-filter">WebFlux 测试支持</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-fn">CSRF 保护</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-web-security">安全响应 Headers</a></li>
</ul>
<h2 id="View技术"><a href="#View技术" class="headerlink" title="View技术"></a>View技术</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#View技术">与 Spring MVC 相同</a></p>
<p>在 Spring WebFlux 中使用视图技术是可插拔的。您是否决定使用 Thymeleaf，FreeMarker 或其他一些视图技术主要是配置更改的问题。本章介绍与 Spring WebFlux 集成的视图技术。我们假设您已经熟悉<a href="#View解析器">View解析器</a>。</p>
<h3 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Thymeleaf">与 Spring MVC 相同</a></p>
<p>Thymeleaf 是一个现代的 server-side Java 模板引擎，它强调自然的 HTML 模板，可以通过 double-clicking 在浏览器中预览，这对于 UI 模板的独立工作非常有用(例如，设计者)，而不需要运行服务器。 Thymeleaf 提供了广泛的 features，并且积极开发和维护。有关更完整的介绍，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
<p>与 Spring WebFlux 的 Thymeleaf integration 由 Thymeleaf 项目管理。 configuration 涉及一些 bean 声明，例如<code>SpringResourceTemplateResolver</code>，<code>SpringWebFluxTemplateEngine</code>和<code>ThymeleafReactiveViewResolver</code>。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/documentation.html">Thymeleaf Spring</a>和 WebFlux integration <a target="_blank" rel="noopener" href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">公告</a>。</p>
<h3 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#FreeMarker">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="http://www.freemarker.org/">Apache FreeMarker</a>是一个模板引擎，用于生成从 HTML 到电子邮件和其他人的任何类型的文本输出。 Spring Framework 有一个 built-in integration 用于将 Spring WebFlux 与 FreeMarker 模板一起使用。</p>
<h4 id="View配置"><a href="#View配置" class="headerlink" title="View配置"></a>View配置</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#View配置">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何将 FreeMarker 配置为视图技术：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.freemarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure FreeMarker...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerConfigurer <span class="title">freeMarkerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;classpath:/templates&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您的模板需要存储在<code>FreeMarkerConfigurer</code>指定的目录中，如前面的 example 所示。给定前面的 configuration，如果控制器返回视图 name，<code>welcome</code>，解析器将查找<code>classpath:/templates/freemarker/welcome.ftl</code>模板。</p>
<h4 id="FreeMarker配置"><a href="#FreeMarker配置" class="headerlink" title="FreeMarker配置"></a>FreeMarker配置</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#FreeMarker配置">与 Spring MVC 相同</a></p>
<p>您可以通过在<code>FreeMarkerConfigurer</code> bean 上设置相应的 bean properties，将 FreeMarker 的“设置”和“SharedVariables”直接传递给 FreeMarker <code>Configuration</code> object(由 Spring 管理)。 <code>freemarkerSettings</code> property 需要<code>java.util.Properties</code> object，而<code>freemarkerVariables</code> property 需要<code>java.util.Map</code>。以下 example 显示了如何使用<code>FreeMarkerConfigurer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerConfigurer <span class="title">freeMarkerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; variables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        variables.put(<span class="string">&quot;xml_escape&quot;</span>, <span class="keyword">new</span> XmlEscape());</span><br><span class="line"></span><br><span class="line">        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;classpath:/templates&quot;</span>);</span><br><span class="line">        configurer.setFreemarkerVariables(variables);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关适用于<code>Configuration</code> object 的设置和变量的详细信息，请参阅 FreeMarker 文档。</p>
<h4 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#表单处理">与Spring MVC相同</a></p>
<p>Spring提供了用于jsp的标记库，其中包含&lt; Spring:bind/&gt;元素。该元素主要让表单显示来自表单支持对象的值，并显示来自web层或业务层验证器的失败验证的结果。在FreeMarker中，Spring也支持相同的功能，还提供了用于生成表单输入元素本身的方便宏。</p>
<h5 id="绑定宏"><a href="#绑定宏" class="headerlink" title="绑定宏"></a>绑定宏</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#绑定宏">Web MVC</a></p>
<p>在FreeMarker的spring-webflux.jar文件中维护了一组标准的宏，因此它们始终可用于经过适当配置的应用程序。</p>
<p>在Spring模板库中定义的一些宏被认为是内部的(私有的)，但是在宏定义中不存在这样的范围，这使得所有宏对于调用代码和用户模板都是可见的。下面的部分只关注需要从模板中直接调用的宏。如果您希望直接查看宏代码，则该文件名为spring。在org.springframework.web.reactive.result.view.freemarker包中。</p>
<p>有关绑定支持的更多细节，请参见Spring MVC的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#简单绑定">简单绑定</a>。</p>
<h5 id="表单宏"><a href="#表单宏" class="headerlink" title="表单宏"></a>表单宏</h5><p>有关Spring对FreeMarker模板的表单宏支持的详细信息，请参阅Spring MVC文档的以下部分。</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#输入宏">输入宏</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#InputFields">输入字段</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#SelectionFields">选择的字段</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#HTML转义">HTML转义</a></p>
</li>
</ul>
<h3 id="脚本视图"><a href="#脚本视图" class="headerlink" title="脚本视图"></a>脚本视图</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#脚本视图">与 Spring MVC 相同</a></p>
<p>Spring Framework 有一个 built-in integration，可以使用 Spring WebFlux 和任何可以在<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java 脚本引擎上运行的模板 library。以下 table 显示了我们在不同脚本引擎上测试的模板 libraries：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>脚本 Library</th>
<th>脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="http://handlebarsjs.com/">Handlebars</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mustache.github.io/">Mustache</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://facebook.github.io/react/">React</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.embeddedjs.com/">EJS</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">Nashorn</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.stuartellis.eu/articles/erb/">ERB</a></td>
<td><a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/string.html#mvc-view-freemarker">String templates</a></td>
<td><a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin Script templating</a></td>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/">Kotlin</a></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。</p>
</blockquote>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#需求">与 Spring MVC 相同</a></p>
<p>您需要在 classpath 上安装脚本引擎，其详细信息因脚本引擎而异：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">Nashorn</a> JavaScript 引擎随 Java 8 一起提供。强烈建议使用最新的更新版本。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a>作为 Ruby 支持的依赖项。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a>作为 Python 支持的依赖项。</li>
<li>应为 Kotlin 脚本支持添加<code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和包含<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code> line 的<code>META-INF/services/javax.script.ScriptEngineFactory</code>文件。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">这个 example</a>。</li>
</ul>
<p>你需要有脚本模板 library。对 Javascript 执行此操作的一种方法是通过<a target="_blank" rel="noopener" href="http://www.webjars.org/">WebJars</a>。</p>
<h4 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#脚本模板">与 Spring MVC 相同</a></p>
<p>您可以声明<code>ScriptTemplateConfigurer</code> bean 来指定要使用的脚本引擎，要加载的脚本 files，要调用渲染模板的 function，等等。以下 example 使用 Mustache 模板和 Nashorn JavaScript 引擎：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScriptTemplateConfigurer <span class="title">configurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">        configurer.setScripts(<span class="string">&quot;mustache.js&quot;</span>);</span><br><span class="line">        configurer.setRenderObject(<span class="string">&quot;Mustache&quot;</span>);</span><br><span class="line">        configurer.setRenderFunction(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以下参数调用<code>render</code> function：</p>
<ul>
<li><code>String template</code>：模板内容</li>
<li><code>Map model</code>：视图 model</li>
<li><code>RenderingContext renderingContext</code>：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html">RenderingContext</a>可以访问 application context，locale，模板加载器和 URL(自 5.0 以来)</li>
</ul>
<p><code>Mustache.render()</code>本身与此签名兼容，因此您可以直接调用它。</p>
<p>如果您的模板技术需要一些自定义，您可以提供实现自定义 render function 的脚本。例如，<a target="_blank" rel="noopener" href="http://handlebarsjs.com/">Handlerbars</a>需要在使用它们之前编译模板，并且需要<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polyfill">填充工具</a> in order 来模拟 server-side 脚本引擎中不可用的某些浏览器工具。以下 example 显示了如何设置自定义 render function：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ScriptTemplateConfigurer <span class="title">configurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer = <span class="keyword">new</span> ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(<span class="string">&quot;nashorn&quot;</span>);</span><br><span class="line">        configurer.setScripts(<span class="string">&quot;polyfill.js&quot;</span>, <span class="string">&quot;handlebars.js&quot;</span>, <span class="string">&quot;render.js&quot;</span>);</span><br><span class="line">        configurer.setRenderFunction(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">        configurer.setSharedEngine(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将 non-thread-safe property 设置为<code>false</code>是必需的，因为 non-thread-safe 脚本引擎的模板 libraries 不是为并发而设计的，例如 Handlebars 或 Nactorn 上的 React running。在这种情况下，由于<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8076099">这个 bug</a>，需要 Java 8u60 或更高版本。</p>
</blockquote>
<p><code>polyfill.js</code>仅定义 Handlebars 正确运行所需的<code>window</code> object，如下面的代码段所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">window</span> = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这个基本的<code>render.js</code> implementation 在使用之前编译模板。 production ready implementation 还应该 store 并重用缓存的模板或 pre-compiled 模板。这可以在脚本端完成，也可以完成所需的任何自定义(管理 example 的模板引擎 configuration)。以下 example 显示了如何编译模板：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">template, model</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> compiledTemplate = Handlebars.compile(template);</span><br><span class="line">    <span class="keyword">return</span> compiledTemplate(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Spring Framework 单元测试，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">资源</a>，了解更多 configuration 示例。</p>
<h3 id="JSON和XML"><a href="#JSON和XML" class="headerlink" title="JSON和XML"></a>JSON和XML</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/Jackson">与 Spring MVC 相同</a></p>
<p>出于<a href="#内容协商">内容谈判</a>目的，根据 client 请求的 content type，能够在使用 HTML 模板或其他格式(如 JSON 或 XML)呈现 model 之间进行交替是很有用的。为了支持这样做，Spring WebFlux 提供<code>HttpMessageWriterView</code>，您可以使用它来插入<code>spring-web</code>中的任何可用<a href="#编解码器">编解码器</a>，例如<code>Jackson2JsonEncoder</code>，<code>Jackson2SmileEncoder</code>或<code>Jaxb2XmlEncoder</code>。</p>
<p>与其他视图技术不同，<code>HttpMessageWriterView</code>不需要<code>ViewResolver</code>，而是<a href="#View解析器">配置</a>作为默认视图。您可以配置一个或多个此类默认视图，包装不同的<code>HttpMessageWriter</code>实例或<code>Encoder</code>实例。匹配请求的 content type 的那个在运行时使用。</p>
<p>在大多数情况下，model 包含多个属性。要确定要序列化的序列，可以使用 model 属性的 name 配置<code>HttpMessageWriterView</code>以用于呈现。如果 model 只包含一个属性，则使用该属性。</p>
<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#HTTP缓存">与 Spring MVC 相同</a></p>
<p>HTTP 缓存可以显着改善 web application 的 performance。 HTTP 缓存围绕<code>Cache-Control</code>响应头和随后的条件请求 headers，例如<code>Last-Modified</code>和<code>ETag</code>。 <code>Cache-Control</code>建议私有(对于 example，浏览器)和 public(对于 example，代理)缓存如何缓存和 re-use 响应。如果内容未更改，<code>ETag</code>标头用于生成条件请求，该请求可能导致 304(NOT_MODIFIED)没有正文。 <code>ETag</code>可以被视为<code>Last-Modified</code>标题的更复杂的继承者。</p>
<p>本节介绍 Spring WebFlux 中可用的 HTTP 缓存相关选项。</p>
<h3 id="CacheControl"><a href="#CacheControl" class="headerlink" title="CacheControl"></a>CacheControl</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#CacheControl">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/CacheControl.html">CacheControl</a>支持配置与<code>Cache-Control</code>标头相关的设置，并且在许多地方被接受为参数：</p>
<ul>
<li><a href="#控制器">控制器</a></li>
<li><a href="#静态资源">静态资源</a></li>
</ul>
<p>虽然<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234#mvc-caching">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用了一种使用 case-oriented 方法，该方法专注于 common 场景，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cache for an hour - &quot;Cache-Control: max-age=3600&quot;</span></span><br><span class="line">CacheControl ccCacheOneHour = CacheControl.maxAge(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prevent caching - &quot;Cache-Control: no-store&quot;</span></span><br><span class="line">CacheControl ccNoStore = CacheControl.noStore();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache for ten days in public and private caches,</span></span><br><span class="line"><span class="comment">// public caches should not transform the response</span></span><br><span class="line"><span class="comment">// &quot;Cache-Control: max-age=864000, public, no-transform&quot;</span></span><br><span class="line">CacheControl ccCustom = CacheControl.maxAge(<span class="number">10</span>, TimeUnit.DAYS).noTransform().cachePublic();</span><br></pre></td></tr></table></figure>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#控制器">与 Spring MVC 相同</a></p>
<p>控制器可以添加对 HTTP 缓存的显式支持。我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>value 需要先计算才能与条件请求 headers 进行比较。控制器可以将<code>ETag</code>和<code>Cache-Control</code>设置添加到<code>ResponseEntity</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/book/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;Book&gt; <span class="title">showBook</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Book book = findBook(id);</span><br><span class="line">    String version = book.getVersion();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ResponseEntity</span><br><span class="line">            .ok()</span><br><span class="line">            .cacheControl(CacheControl.maxAge(<span class="number">30</span>, TimeUnit.DAYS))</span><br><span class="line">            .eTag(version) <span class="comment">// lastModified is also available</span></span><br><span class="line">            .body(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果与条件请求 headers 的比较表明内容未更改，则前面的 example 将使用空主体发送 304(NOT_MODIFIED)响应。否则，<code>ETag</code>和<code>Cache-Control</code> headers 将添加到响应中。</p>
<p>您还可以在控制器中对条件请求 headers 进行检查，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">myHandleMethod</span><span class="params">(ServerWebExchange exchange, Model model)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> eTag = ... (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exchange.checkNotModified(eTag)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; (<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(...); (<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;myViewName&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Application-specific 计算。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>响应已设置为 304(NOT_MODIFIED)。没有进一步处理。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>继续请求处理。</td>
</tr>
</tbody>
</table>
</div>
<p>有三种变体可用于检查针对<code>eTag</code>值，<code>lastModified</code>值或两者的条件请求。对于条件<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为 304(NOT_MODIFIED)。对于条件<code>POST</code>，<code>PUT</code>和<code>DELETE</code>，您可以将响应设置为 409(PRECONDITION_FAILED)以防止并发修改。</p>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#静态资源">与 Spring MVC 相同</a></p>
<p>您应该使用<code>Cache-Control</code>和条件响应 headers 为静态资源提供最佳的 performance。请参阅有关配置<a href="#静态资源配置">静态资源</a>的部分。</p>
<h2 id="WebFlux配置-1"><a href="#WebFlux配置-1" class="headerlink" title="WebFlux配置"></a>WebFlux配置</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebMVC配置">与 Spring MVC 相同</a></p>
<p>WebFlux Java configuration 声明了使用带注释的控制器或函数 endpoints 处理请求所需的组件，并且它提供了一个 API 来自定义 configuration。这意味着您不需要了解 Java configuration 创建的底层 beans。但是，如果您想了解它们，可以在<code>WebFluxConfigurationSupport</code>中查看它们，或者阅读更多关于它们在<a href="#特殊的Bean类型">特殊的 Bean 类型</a>中的内容。</p>
<p>对于 configuration API 中未提供的更高级自定义，您可以通过<a href="#高级配置模式">高级配置模式</a>完全控制 configuration。</p>
<h3 id="启用WebFlux配置"><a href="#启用WebFlux配置" class="headerlink" title="启用WebFlux配置"></a>启用WebFlux配置</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#启用MVC配置">与 Spring MVC 相同</a></p>
<p>您可以在 Java 配置中使用<code>@EnableWebFlux</code> annotation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 example 注册了一些 Spring WebFlux <a href="#特殊的Bean类型">基础设施 beans</a>并适应了 classpath 上可用的依赖项 - 适用于 JSON，XML 和其他。</p>
<h3 id="WebFlux配置API"><a href="#WebFlux配置API" class="headerlink" title="WebFlux配置API"></a>WebFlux配置API</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#MVC配置API">与 Spring MVC 相同</a></p>
<p>在 Java configuration 中，您可以实现<code>WebFluxConfigurer</code>接口，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Implement configuration methods...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换，格式化"><a href="#转换，格式化" class="headerlink" title="转换，格式化"></a>转换，格式化</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#类型转换">与 Spring MVC 相同</a></p>
<p>默认情况下，会安装<code>Number</code>和<code>Date</code>类型的格式化程序，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code> 注释的支持。如果 class 路径中存在 Joda-Time，则还会安装对 Joda-Time 格式 library 的完全支持。</p>
<p>以下 example 显示了如何注册自定义格式化程序和转换器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFormatters</span><span class="params">(FormatterRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关何时使用<code>FormatterRegistrar</code> implementations 的详细信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#FormatterRegistrarSPI">FormatterRegistrar SPI</a>和<code>FormattingConversionServiceFactoryBean</code>。</p>
</blockquote>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#验证">与 Spring MVC 相同</a></p>
<p>默认情况下，如果 class 路径上存在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#BeanValidationAPI概述">Bean 验证</a>(对于 example，Hibernate Validator)，则<code>LocalValidatorFactoryBean</code>将注册为 global <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#使用Spring的验证器接口进行验证">验证器</a>，以便在<code>@Controller</code> method arguments 上与<code>@Valid</code>和<code>Validated</code>一起使用。</p>
<p>在 Java configuration 中，您可以自定义 global <code>Validator</code>实例，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Validator <span class="title">getValidator</span><span class="params">()</span></span>; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，您还可以在本地注册<code>Validator</code> implementations，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@InitBinder</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> </span>&#123;</span><br><span class="line">        binder.addValidators(<span class="keyword">new</span> FooValidator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要在某处注入<code>LocalValidatorFactoryBean</code>，请创建 bean 并在 order 中使用<code>@Primary</code>标记它以避免与 MVC 配置中声明的冲突。</p>
</blockquote>
<h3 id="ContentType解析器"><a href="#ContentType解析器" class="headerlink" title="ContentType解析器"></a>ContentType解析器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#内容类型">与 Spring MVC 相同</a></p>
<p>您可以配置 Spring WebFlux 如何从请求中确定<code>@Controller</code>实例的请求媒体类型。默认情况下，仅选中<code>Accept</code>标头，但您也可以启用查询 parameter-based 策略。</p>
<p>以下 example 显示了如何自定义请求的 content type 解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureContentTypeResolver</span><span class="params">(RequestedContentTypeResolverBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HTTP消息编解码器"><a href="#HTTP消息编解码器" class="headerlink" title="HTTP消息编解码器"></a>HTTP消息编解码器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#消息转换器">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何自定义读取和写入请求和响应主体的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureHttpMessageCodecs</span><span class="params">(ServerCodecConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ServerCodecConfigurer</code>提供了一组默认的 readers 和 writers。您可以使用它来添加更多 readers 和 writers，自定义默认值，或完全替换默认值。</p>
<p>对于 Jackson JSON 和 XML，请考虑使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html">Jackson2ObjectMapperBuilder</a>，它使用以下方法自定义 Jackson 的默认 properties：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#validation-beanvalidation-overview">DeserializationFeature.FAIL_ON_UNKNOWNPROPERTIES</a>已禁用。</li>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#validator">MapperFeature.DEFAULT_VIEW_INCLUSION</a>已禁用。</li>
</ul>
<p>如果在 classpath 上检测到以下 well-known 模块，它还会自动注册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>：支持 Java 7 类型，如<code>java.nio.file.Path</code>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>：支持 Joda-Time 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>：支持 Java 8 Date 和 Time API 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>：支持其他 Java 8 类型，例如<code>Optional</code>。</li>
</ul>
<h3 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#View解析器">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何配置视图分辨率：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ViewResolverRegistry</code>具有 Spring Framework 集成的视图技术的快捷方式。以下 example 使用 FreeMarker(还需要配置基础 FreeMarker 视图技术)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.freeMarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure Freemarker...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FreeMarkerConfigurer <span class="title">freeMarkerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FreeMarkerConfigurer configurer = <span class="keyword">new</span> FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(<span class="string">&quot;classpath:/templates&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以插入任何<code>ViewResolver</code> implementation，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        ViewResolver resolver = ... ;</span><br><span class="line">        registry.viewResolver(resolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要支持<a href="#内容协商">内容谈判</a>并通过视图解析(除了 HTML)呈现其他格式，您可以基于<code>HttpMessageWriterView</code> 实现配置一个或多个默认视图，该视图接受来自<code>spring-web</code>的任何可用<a href="#编解码器">编解码器</a>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.freeMarker();</span><br><span class="line"></span><br><span class="line">        Jackson2JsonEncoder encoder = <span class="keyword">new</span> Jackson2JsonEncoder();</span><br><span class="line">        registry.defaultViews(<span class="keyword">new</span> HttpMessageWriterView(encoder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关与 Spring WebFlux 集成的视图技术的更多信息，请参阅<a href="#View技术">视图技术</a>。</p>
<p><span id="静态资源配置"/></p>
<h3 id="静态资源-1"><a href="#静态资源-1" class="headerlink" title="静态资源"></a>静态资源</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#静态资源">与 Spring MVC 相同</a></p>
<p>此选项提供了一种从<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/Resource.html">资源</a> -based 位置列表中提供静态资源的便捷方法。</p>
<p>在下一个示例中，给定以<code>/resources</code>开头的请求，相对路径用于在 classpath 上查找和提供相对于<code>/static</code>的静态资源。资源的使用期限为 one-year，以确保最大程度地使用浏览器缓存并减少浏览器发出的 HTTP 请求。还会评估<code>Last-Modified</code>标头，如果存在，则返回<code>304</code> status code。以下列表显示了 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">            .addResourceLocations(<span class="string">&quot;/public&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>)</span><br><span class="line">            .setCacheControl(CacheControl.maxAge(<span class="number">365</span>, TimeUnit.DAYS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>资源处理程序还支持<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html">ResourceResolver</a> 实现和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html">ResourceTransformer</a> 实现链，可用于创建工具链以使用优化的资源。</p>
<p>您可以根据从内容计算的 MD5 哈希，固定的 application version 或其他信息，将<code>VersionResourceResolver</code>用于版本化资源 URL。对于一些值得注意的 exceptions(例如与模块加载器一起使用的 JavaScript 资源)，<code>ContentVersionStrategy</code>(MD5 哈希)是一个不错的选择。</p>
<p>以下 example 显示了如何在 Java configuration 中使用<code>VersionResourceResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/resources/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/public/&quot;</span>)</span><br><span class="line">                .resourceChain(<span class="keyword">true</span>)</span><br><span class="line">                .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string">&quot;/**&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>ResourceUrlProvider</code>来 rewrite URL 并应用完整的解析器和变换器链(对于 example，为 insert 版本)。 WebFlux configuration 提供<code>ResourceUrlProvider</code>，以便可以将其注入其他人。</p>
<p>与 Spring MVC 不同，目前，在 WebFlux 中，没有办法透明地编写静态资源 URL，因为没有可以使用 non-blocking 链解析器和变换器的视图技术。仅提供本地资源时，解决方法是直接使用<code>ResourceUrlProvider</code>(对于 example，通过自定义元素)和阻止。</p>
<p>请注意，当同时使用<code>EncodedResourceResolver</code>(对于 example，Gzip，Brotli 编码)和<code>VersionedResourceResolver</code>时，必须在该 order 中注册它们，以确保始终基于未编码的文件可靠地计算 content-based 版本。</p>
<p><code>WebJarsResourceResolver</code>也通过<code>WebJarsResourceResolver</code>支持，并在 class 路径上存在<code>org.webjars:webjars-locator</code>时自动注册。解析器可以 re-write URL 包含 jar 的 version，也可以匹配到没有版本的传入 URL(对于 example，<code>/jquery/jquery.min.js</code>到<code>/jquery/1.2.0/jquery.min.js</code>)。</p>
<h3 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#路径匹配">与 Spring MVC 相同</a></p>
<p>您可以自定义与路径匹配相关的选项。有关各个选项的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html">PathMatchConfigurer</a> javadoc。以下 example 显示了如何使用<code>PathMatchConfigurer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebFlux</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">implements</span> <span class="title">WebFluxConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseCaseSensitiveMatch(<span class="keyword">true</span>)</span><br><span class="line">            .setUseTrailingSlashMatch(<span class="keyword">false</span>)</span><br><span class="line">            .addPathPrefix(<span class="string">&quot;/api&quot;</span>,</span><br><span class="line">                    HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Spring WebFlux 依赖于名为<code>RequestPath</code>的请求路径的解析表示，用于访问已解码的路径段值，并删除分号内容(即路径或矩阵变量)。这意味着，与 Spring MVC 不同，您无需指示是否解码请求路径，也不需要删除分号内容以进行路径匹配。</p>
</blockquote>
<p>Spring WebFlux 也不支持后缀 pattern 匹配，不像 Spring MVC，我们也不再依赖它。</p>
<h3 id="高级配置模式"><a href="#高级配置模式" class="headerlink" title="高级配置模式"></a>高级配置模式</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#高级Java配置">与 Spring MVC 相同</a></p>
<p><code>@EnableWebFlux</code>进口<code>DelegatingWebFluxConfiguration</code>：</p>
<ul>
<li>为 WebFlux applications 提供默认的 Spring configuration</li>
<li>检测并委托<code>WebFluxConfigurer</code> implementations 来自定义 configuration。</li>
</ul>
<p>对于高级模式，您可以删除<code>@EnableWebFlux</code>并直接从<code>DelegatingWebFluxConfiguration</code>扩展而不是实现<code>WebFluxConfigurer</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">DelegatingWebFluxConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在<code>WebConfig</code>中保留现有方法，但现在您也可以从 base class 覆盖 bean 声明，并且在 classpath 上仍然有任意数量的其他<code>WebMvcConfigurer</code> 实现。</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#HTTP/2">与 Spring MVC 相同</a></p>
<p>Servlet 4 容器需要支持 HTTP/2，而 Spring Framework 5 与 Servlet API 兼容 4.从编程 model 的角度来看，没有特定的 applications 需要做的事情。但是，有一些与 server configuration 相关的注意事项。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 维基页面</a>。</p>
<p>目前，Spring WebFlux 不支持 HTTP/2 与 Netty。也没有支持以编程方式将资源推送到 client。</p>
<h1 id="WebClient"><a href="#WebClient" class="headerlink" title="WebClient"></a>WebClient</h1><p>Spring WebFlux 包含 reactive，non-blocking <code>WebClient</code>用于 HTTP 请求。 client 有一个函数式 fluent API，其中 reactive 类型用于声明性组合，请参阅<a href="#Reactive库">Reactive Libraries</a>。 WebFlux client 和服务器依赖相同的 non-blocking <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-path-matching">编解码器</a>来编码和解码请求和响应内容。</p>
<p>内部<code>WebClient</code>委托给 HTTP client library。默认情况下，它使用<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a>，Jetty <a target="_blank" rel="noopener" href="https://github.com/jetty-project/jetty-reactive-httpclient">reactive HtpClient</a>有 built-in 支持，其他可以通过<code>ClientHttpConnector</code>插入。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>创建<code>WebClient</code>的最简单方法是通过一个静态工厂方法：</p>
<ul>
<li><code>WebClient.create()</code></li>
<li><code>WebClient.create(String baseUrl)</code></li>
</ul>
<p>上述方法使用 Reactor Netty <code>HttpClient</code>和默认设置，并期望<code>io.projectreactor.netty:reactor-netty</code>在 classpath 上。</p>
<p>您还可以将<code>WebClient.builder()</code>与其他选项一起使用：</p>
<ul>
<li><code>uriBuilderFactory</code>：自定义<code>UriBuilderFactory</code>以用作基本 URL。</li>
<li>每个请求都<code>defaultHeader</code>：Headers。</li>
<li><code>defaultCookie</code>：Cookies 为每个请求。</li>
<li><code>defaultRequest</code>：<code>Consumer</code>来自定义每个请求。</li>
<li><code>filter</code>：Client 过滤每个请求。</li>
<li><code>exchangeStrategies</code>：HTTP 消息 reader/writer 自定义。</li>
<li><code>clientConnector</code>：HTTP client library 设置。</li>
</ul>
<p>以下 example 配置<a href="#HTTP编解码器">HTTP 编解码器</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExchangeStrategies strategies = ExchangeStrategies.builder()</span><br><span class="line">            .codecs(configurer -&gt; &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    WebClient client = WebClient.builder()</span><br><span class="line">            .exchangeStrategies(strategies)</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<p>构建后，<code>WebClient</code>实例是不可变的。但是，您可以克隆它并 build 修改后的副本而不会影响原始实例，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WebClient client1 = WebClient.builder()</span><br><span class="line">            .filter(filterA).filter(filterB).build();</span><br><span class="line"></span><br><span class="line">    WebClient client2 = client1.mutate()</span><br><span class="line">            .filter(filterC).filter(filterD).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client1 has filterA, filterB</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// client2 has filterA, filterB, filterC, filterD</span></span><br></pre></td></tr></table></figure>
<h3 id="MaxInMemorySize"><a href="#MaxInMemorySize" class="headerlink" title="MaxInMemorySize"></a>MaxInMemorySize</h3><p>Spring WebFlux为在编解码器中缓冲内存中的数据设置了限制，以避免应用程序内存问题。默认情况下，它被配置为256KB，如果这对您的用例来说还不够，您将看到以下内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.core.io.buffer.DataBufferLimitException: Exceeded <span class="built_in">limit</span> on max bytes to buffer</span><br></pre></td></tr></table></figure>
<p>你可以用下面的代码样例在所有默认的编解码器上配置这个限制:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient = WebClient.builder()</span><br><span class="line">        .exchangeStrategies(builder -&gt;</span><br><span class="line">            builder.codecs(codecs -&gt;</span><br><span class="line">                codecs.defaultCodecs().maxInMemorySize(<span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<h3 id="ReactorNetty"><a href="#ReactorNetty" class="headerlink" title="ReactorNetty"></a>ReactorNetty</h3><p>要自定义 Reactor Netty 设置，只需提供 pre-configured <code>HttpClient</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = HttpClient.create().secure(sslSpec -&gt; ...);</span><br><span class="line"></span><br><span class="line">    WebClient webClient = WebClient.builder()</span><br><span class="line">            .clientConnector(<span class="keyword">new</span> ReactorClientHttpConnector(httpClient))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>默认情况下，<code>HttpClient</code>参与<code>reactor.netty.http.HttpResources</code>中保存的 global Reactor Netty 资源，包括 event 循环线程和连接池。这是推荐的模式，因为固定的共享资源是 event 循环并发的首选。在这种模式下， global 资源保持 active，直到 process 退出。</p>
<p>如果服务器与 process 同步，则通常不需要显式关闭。但是，如果服务器可以启动或停止 in-process(对于示例，Spring MVC application 部署为 WAR)，您可以使用<code>globalResources=true</code>(默认值)声明类型为<code>ReactorResourceFactory</code>的 Spring-managed bean，以确保关闭 Reactor Netty global 资源当 Spring <code>ApplicationContext</code>关闭时，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReactorResourceFactory <span class="title">reactorResourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReactorResourceFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您也可以选择不参与 global Reactor Netty 资源。但是，在此模式下，您需要确保所有 Reactor Netty client 和服务器实例都使用共享资源，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReactorResourceFactory <span class="title">resourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReactorResourceFactory factory = <span class="keyword">new</span> ReactorResourceFactory();</span><br><span class="line">        factory.setGlobalResources(<span class="keyword">false</span>); (<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebClient <span class="title">webClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Function&lt;HttpClient, HttpClient&gt; mapper = client -&gt; &#123;</span><br><span class="line">            <span class="comment">// Further customizations...</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ClientHttpConnector connector =</span><br><span class="line">                <span class="keyword">new</span> ReactorClientHttpConnector(resourceFactory(), mapper); (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build(); (<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>创建独立于 global 资源的资源。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将<code>ReactorClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>将连接器插入<code>WebClient.Builder</code>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>配置连接超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"></span><br><span class="line">HttpClient httpClient = HttpClient.create()</span><br><span class="line">        .tcpConfiguration(client -&gt;</span><br><span class="line">                client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">10000</span>));</span><br></pre></td></tr></table></figure>
<p>配置读 and/or 写超时值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.ReadTimeoutHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.timeout.WriteTimeoutHandler;</span><br><span class="line"></span><br><span class="line">HttpClient httpClient = HttpClient.create()</span><br><span class="line">        .tcpConfiguration(client -&gt;</span><br><span class="line">                client.doOnConnected(conn -&gt; conn</span><br><span class="line">                        .addHandlerLast(<span class="keyword">new</span> ReadTimeoutHandler(<span class="number">10</span>))</span><br><span class="line">                        .addHandlerLast(<span class="keyword">new</span> WriteTimeoutHandler(<span class="number">10</span>))));</span><br></pre></td></tr></table></figure>
<h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><p>以下 example 显示了如何自定义 Jetty <code>HttpClient</code>设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">httpClient.setCookieStore(...);</span><br><span class="line">ClientHttpConnector connector = <span class="keyword">new</span> JettyClientHttpConnector(httpClient);</span><br><span class="line"></span><br><span class="line">WebClient webClient = WebClient.builder().clientConnector(connector).build();</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>HttpClient</code>创建自己的资源(<code>Executor</code>，<code>ByteBufferPool</code>，<code>Scheduler</code>)，这些资源在 process 退出或<code>stop()</code>被调用之前保持 active。</p>
<p>您可以在 Jetty client(和服务器)的多个实例之间共享资源，并通过声明类型<code>JettyResourceFactory</code>的 Spring-managed bean 来确保在关闭 Spring <code>ApplicationContext</code>时关闭资源，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JettyResourceFactory <span class="title">resourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JettyResourceFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebClient <span class="title">webClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Consumer&lt;HttpClient&gt; customizer = client -&gt; &#123;</span><br><span class="line">        <span class="comment">// Further customizations...</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ClientHttpConnector connector =</span><br><span class="line">        <span class="keyword">new</span> JettyClientHttpConnector(resourceFactory(), customizer); (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> WebClient.builder().clientConnector(connector).build(); (<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将<code>JettyClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将连接器插入<code>WebClient.Builder</code>。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="retrieve"><a href="#retrieve" class="headerlink" title="retrieve()"></a>retrieve()</h2><p><code>retrieve()</code>方法是获取响应主体并对其进行解码的最简单方法。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebClient client = WebClient.create(<span class="string">&quot;http://example.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;Person&gt; result = client.get()</span><br><span class="line">    .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Person.class);</span><br></pre></td></tr></table></figure>
<p>您还可以获取从响应中解码的 objects 流，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Quote&gt; result = client.get()</span><br><span class="line">            .uri(<span class="string">&quot;/quotes&quot;</span>).accept(MediaType.TEXT_EVENT_STREAM)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToFlux(Quote.class);</span><br></pre></td></tr></table></figure>
<p>默认情况下，具有 4xx 或 5xx 状态代码的响应会导致<code>WebClientResponseException</code>或其某个 HTTP 状态特定 sub-classes，例如<code>WebClientResponseException.BadRequest</code>，<code>WebClientResponseException.NotFound</code>等。您还可以使用<code>onStatus</code>方法自定义生成的 exception，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; result = client.get()</span><br><span class="line">            .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .onStatus(HttpStatus::is4xxServerError, response -&gt; ...)</span><br><span class="line">            .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)</span><br><span class="line">            .bodyToMono(Person.class);</span><br></pre></td></tr></table></figure>
<p>当使用<code>onStatus</code>时，如果预期响应具有内容，则<code>onStatus</code>回调应该使用它。如果没有，内容将自动耗尽，以确保释放资源。</p>
<h2 id="exchange"><a href="#exchange" class="headerlink" title="exchange()"></a>exchange()</h2><p><code>exchange()</code>方法提供比<code>retrieve</code>方法更多的控制。以下 example 等同于<code>retrieve()</code>，但也提供对<code>ClientResponse</code>的访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; result = client.get()</span><br><span class="line">            .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(response -&gt; response.bodyToMono(Person.class));</span><br></pre></td></tr></table></figure>
<p>在此 level 中，您还可以创建一个完整的<code>ResponseEntity</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;ResponseEntity&lt;Person&gt;&gt; result = client.get()</span><br><span class="line">            .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(response -&gt; response.toEntity(Person.class));</span><br></pre></td></tr></table></figure>
<p>请注意(与<code>retrieve()</code>不同)，<code>exchange()</code>，4xx 和 5xx 响应没有自动错误信号。您必须检查状态 code 并决定如何继续。</p>
<blockquote>
<p>使用<code>exchange()</code>时，必须始终使用<code>ClientResponse</code>的任何<code>body</code>或<code>toEntity</code>方法来确保释放资源并避免 HTTP 连接池的潜在问题。如果没有预期的响应内容，您可以使用<code>bodyToMono(Void.class)</code>。但是，如果响应确实包含内容，则连接将关闭，并且不会放回池中。</p>
</blockquote>
<h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>请求正文可以从<code>Object</code>编码，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; personMono = ... ;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">    .body(personMono, Person.class)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<p>您还可以编写一个 objects 流，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Person&gt; personFlux = ... ;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">    .contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">    .body(personFlux, Person.class)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<p>或者，如果您有实际的 value，则可以使用<code>syncBody</code>快捷方法，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person = ... ;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/persons/&#123;id&#125;&quot;</span>, id)</span><br><span class="line">    .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">    .syncBody(person)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<h3 id="表单数据-1"><a href="#表单数据-1" class="headerlink" title="表单数据"></a>表单数据</h3><p>要发送表单数据，您可以提供<code>MultiValueMap&lt;String, String&gt;</code>作为正文。请注意，<code>FormHttpMessageWriter</code>会自动将内容设置为<code>application/x-www-form-urlencoded</code>。以下 example 显示了如何使用<code>MultiValueMap&lt;String, String&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; formData = ... ;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/path&quot;</span>, id)</span><br><span class="line">    .syncBody(formData)</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<p>您还可以使用<code>BodyInserters</code>提供表单数据 in-line，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.BodyInserters.*;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/path&quot;</span>, id)</span><br><span class="line">    .body(fromFormData(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>).with(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>))</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<h3 id="Multipart数据-1"><a href="#Multipart数据-1" class="headerlink" title="Multipart数据"></a>Multipart数据</h3><p>要发送 multipart 数据，您需要提供<code>MultiValueMap&lt;String, ?&gt;</code>，其值为表示部件内容的<code>Object</code>实例或表示部件的内容和_header 的<code>HttpEntity</code>实例。 <code>MultipartBodyBuilder</code>提供了一个方便的 API 来准备 multipart 请求。以下 example 显示了如何创建<code>MultiValueMap&lt;String, ?&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder = <span class="keyword">new</span> MultipartBodyBuilder();</span><br><span class="line">builder.part(<span class="string">&quot;fieldPart&quot;</span>, <span class="string">&quot;fieldValue&quot;</span>);</span><br><span class="line">builder.part(<span class="string">&quot;filePart&quot;</span>, <span class="keyword">new</span> FileSystemResource(<span class="string">&quot;...logo.png&quot;</span>));</span><br><span class="line">builder.part(<span class="string">&quot;jsonPart&quot;</span>, <span class="keyword">new</span> Person(<span class="string">&quot;Jason&quot;</span>));</span><br><span class="line"></span><br><span class="line">MultiValueMap&lt;String, HttpEntity&lt;?&gt;&gt; parts = builder.build();</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，您不必为每个零件指定<code>Content-Type</code>。 content type 是根据所选的<code>HttpMessageWriter</code>自动确定的，以便序列化它，如果是<code>Resource</code>，则根据文件扩展名自动确定。如有必要，您可以通过其中一个重载的构建器<code>part</code>方法显式提供<code>MediaType</code>以用于每个部件。</p>
<p>准备好<code>MultiValueMap</code>后，将其传递给<code>WebClient</code>的最简单方法是通过<code>syncBody</code>方法，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder = ...;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/path&quot;</span>, id)</span><br><span class="line">    .syncBody(builder.build())</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code> value，它也可以表示常规表单数据(即<code>application/x-www-form-urlencoded</code>)，则无需将<code>Content-Type</code>设置为<code>multipart/form-data</code>。使用<code>MultipartBodyBuilder</code>时始终如此，这确保了<code>HttpEntity</code> wrapper。</p>
<p>作为<code>MultipartBodyBuilder</code>的替代，您还可以通过 built-in <code>BodyInserters</code>提供 multipart 内容 inline-style，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.web.reactive.function.BodyInserters.*;</span><br><span class="line"></span><br><span class="line">Mono&lt;Void&gt; result = client.post()</span><br><span class="line">    .uri(<span class="string">&quot;/path&quot;</span>, id)</span><br><span class="line">    .body(fromMultipartData(<span class="string">&quot;fieldPart&quot;</span>, <span class="string">&quot;value&quot;</span>).with(<span class="string">&quot;filePart&quot;</span>, resource))</span><br><span class="line">    .retrieve()</span><br><span class="line">    .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>
<h2 id="Client过滤器"><a href="#Client过滤器" class="headerlink" title="Client过滤器"></a>Client过滤器</h2><p>您可以通过<code>WebClient.Builder</code> in order 注册 client 过滤器(<code>ExchangeFilterFunction</code>)来拦截和修改请求，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WebClient client = WebClient.builder()</span><br><span class="line">        .filter((request, next) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            ClientRequest filtered = ClientRequest.from(request)</span><br><span class="line">                    .header(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> next.exchange(filtered);</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>这可用于 cross-cutting 问题，例如身份验证。以下 example 使用过滤器通过静态工厂方法进行基本身份验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of ExchangeFilterFunctions.basicAuthentication</span></span><br><span class="line"></span><br><span class="line">WebClient client = WebClient.builder()</span><br><span class="line">        .filter(basicAuthentication(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>过滤器全局应用于每个请求。要更改特定请求的过滤器行为，您可以向<code>ClientRequest</code>添加请求属性，然后链中的所有过滤器都可以访问这些属性，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebClient client = WebClient.builder()</span><br><span class="line">        .filter((request, next) -&gt; &#123;</span><br><span class="line">            Optional&lt;Object&gt; usr = request.attribute(<span class="string">&quot;myAttribute&quot;</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">client.get().uri(<span class="string">&quot;http://example.org/&quot;</span>)</span><br><span class="line">        .attribute(<span class="string">&quot;myAttribute&quot;</span>, <span class="string">&quot;...&quot;</span>)</span><br><span class="line">        .retrieve()</span><br><span class="line">        .bodyToMono(Void.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>您还可以复制现有的<code>WebClient</code>，插入新过滤器，或删除已注册的过滤器。以下 example，在索引 0 处插入基本身份验证筛选器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of ExchangeFilterFunctions.basicAuthentication</span></span><br><span class="line"></span><br><span class="line">WebClient client = webClient.mutate()</span><br><span class="line">        .filters(filterList -&gt; &#123;</span><br><span class="line">            filterList.add(<span class="number">0</span>, basicAuthentication(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;password&quot;</span>));</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<h2 id="同步使用"><a href="#同步使用" class="headerlink" title="同步使用"></a>同步使用</h2><p>通过在结果末尾进行阻塞，可以以同步方式使用WebClient：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person = client.get().uri(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, i).retrieve()</span><br><span class="line">    .bodyToMono(Person.class)</span><br><span class="line">    .block();</span><br><span class="line"></span><br><span class="line">List&lt;Person&gt; persons = client.get().uri(<span class="string">&quot;/persons&quot;</span>).retrieve()</span><br><span class="line">    .bodyToFlux(Person.class)</span><br><span class="line">    .collectList()</span><br><span class="line">    .block();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = runBlocking &#123;</span><br><span class="line">    client.<span class="keyword">get</span>().uri(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, i).retrieve()</span><br><span class="line">            .awaitBody&lt;Person&gt;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> persons = runBlocking &#123;</span><br><span class="line">    client.<span class="keyword">get</span>().uri(<span class="string">&quot;/persons&quot;</span>).retrieve()</span><br><span class="line">            .bodyToFlow&lt;Person&gt;()</span><br><span class="line">            .toList()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果需要进行多次通话，则可以避免单独阻止每个响应，而等待合并的结果，这样会更有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; personMono = client.get().uri(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, personId)</span><br><span class="line">        .retrieve().bodyToMono(Person.class);</span><br><span class="line"></span><br><span class="line">Mono&lt;List&lt;Hobby&gt;&gt; hobbiesMono = client.get().uri(<span class="string">&quot;/person/&#123;id&#125;/hobbies&quot;</span>, personId)</span><br><span class="line">        .retrieve().bodyToFlux(Hobby.class).collectList();</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; data = Mono.zip(personMono, hobbiesMono, (person, hobbies) -&gt; &#123;</span><br><span class="line">            Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">            map.put(<span class="string">&quot;person&quot;</span>, person);</span><br><span class="line">            map.put(<span class="string">&quot;hobbies&quot;</span>, hobbies);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;)</span><br><span class="line">        .block();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> personDeferred = async &#123;</span><br><span class="line">            client.<span class="keyword">get</span>().uri(<span class="string">&quot;/person/&#123;id&#125;&quot;</span>, personId)</span><br><span class="line">                    .retrieve().awaitBody&lt;Person&gt;()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> hobbiesDeferred = async &#123;</span><br><span class="line">            client.<span class="keyword">get</span>().uri(<span class="string">&quot;/person/&#123;id&#125;/hobbies&quot;</span>, personId)</span><br><span class="line">                    .retrieve().bodyToFlow&lt;Hobby&gt;().toList()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mapOf(<span class="string">&quot;person&quot;</span> to personDeferred.await(), <span class="string">&quot;hobbies&quot;</span> to hobbiesDeferred.await())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上仅是一个示例。 还有许多其他模式和运算符可用于构建响应式管道，该管道可进行许多远程调用（可能是嵌套的，相互依赖的），而不会阻塞到最后。</p>
<blockquote>
<p>Note</p>
<p>使用<code>Flux</code>或<code>Mono</code>，您永远不必阻塞Spring MVC或Spring WebFlux控制器。 只需从controller方法返回返回的反应类型。 相同的原则适用于Kotlin Coroutines和Spring WebFlux，只需在控制器方法中使用暂停功能或返回<code>Flow</code>即可。</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>要测试使用<code>WebClient</code>的 code，可以使用 mock web 服务器，例如<a target="_blank" rel="noopener" href="https://github.com/square/okhttp#mvc-config-advanced-java">OkHttp MockWebServer</a>。要查看其使用的 example，请查看 Spring Framework 测试套件中的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java">WebClientIntegrationTests</a>或 OkHttp repository 中的<a target="_blank" rel="noopener" href="https://github.com/square/okhttp/tree/master/samples/static-server">static-server</a> sample。</p>
<h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebSockets">与 Servlet 堆栈中的相同</a></p>
<p>reference 文档的这一部分涵盖了对 reactive-stack WebSocket 消息传递的支持。</p>
<h2 id="WebSocket简介"><a href="#WebSocket简介" class="headerlink" title="WebSocket简介"></a>WebSocket简介</h2><p>WebSocket 协议<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准方法，可以通过单个 TCP 连接在 client 和服务器之间建立 full-duplex，two-way 通信 channel。它是来自 HTTP 的不同 TCP 协议，但设计为使用端口 80 和 443 并允许 re-use 现有防火墙规则通过 HTTP 工作。</p>
<p>WebSocket 交互以 HTTP 请求开始，该 HTTP 请求使用 HTTP <code>Upgrade</code>标头进行升级，或者在这种情况下，切换到 WebSocket 协议。以下 example 显示了这样的交互：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/spring-websocket-portfolio/portfolio</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: localhost:8080</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket (1)</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade (2)</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: Uc9l9TMkWGbHFD2qnFHltg==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: v10.stomp, v11.stomp</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br><span class="line"><span class="attribute">Origin</span>: http://localhost:8080</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>Upgrade</code>标题。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</tbody>
</table>
</div>
<p>具有 WebSocket 支持的服务器返回类似于以下内容的输出，而不是通常的 200 状态 code：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols (1)</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span>: 1qVdfYHU9hPOl4JYYNXF623Gzn0=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: v10.stomp</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>协议切换</td>
</tr>
</tbody>
</table>
</div>
<p>成功握手后，HTTP 升级请求所基于的 TCP socket 将保持打开状态，以便 client 和服务器继续发送和接收消息。</p>
<p>有关 WebSockets 如何工作的完整介绍超出了本文档的范围。请参阅 RFC 6455，HTML5 的 WebSocket 章节，或者 Web 上的任何介绍和教程。</p>
<p>请注意，如果 WebSocket 服务器在 web 服务器(e.g. nginx)后面运行，则可能需要将其配置为将 WebSocket 升级请求传递到 WebSocket 服务器。同样，如果 application 在云环境中运行，请检查与 WebSocket 支持相关的云提供程序的说明。</p>
<h3 id="HTTP与WebSocket"><a href="#HTTP与WebSocket" class="headerlink" title="HTTP与WebSocket"></a>HTTP与WebSocket</h3><p>尽管 WebSocket 被设计为 HTTP-compatible 并以 HTTP 请求开始，但重要的是要理解这两种协议会导致非常不同的体系结构和 application 编程模型。</p>
<p>在 HTTP 和 REST 中，application 被建模为多个 URL。要与 application 进行交互，clients 访问这些 URL，request-response 样式。 Servers 根据 HTTP URL，方法和 headers 将请求路由到相应的处理程序。</p>
<p>相比之下，在 WebSockets 中，初始连接通常只有一个 URL。随后，所有 application 消息都在同一 TCP 连接上流动。这指向一个完全不同的异步，event-driven，messaging architecture。</p>
<p>WebSocket 也是一种 low-level 传输协议，与 HTTP 不同，它不对消息内容规定任何语义。这意味着除非 client 和服务器就消息语义达成一致，否则无法对路由进行 route 或 process。</p>
<p>WebSocket clients 和服务器可以通过 HTTP 握手请求上的<code>Sec-WebSocket-Protocol</code>标头协商使用 higher-level，消息传递协议(对于 example，STOMP)。如果没有，他们需要提出自己的惯例。</p>
<h3 id="何时使用WebSockets"><a href="#何时使用WebSockets" class="headerlink" title="何时使用WebSockets"></a>何时使用WebSockets</h3><p>WebSockets可以使网页具有动态性和交互性。但是，在许多情况下，结合使用Ajax和HTTP流或长时间轮询可以提供一种简单有效的解决方案。</p>
<p>例如，新闻，邮件和社交订阅源需要动态更新，但是每隔几分钟这样做是完全可以的。另一方面，协作，游戏和金融应用程序需要更接近实时。</p>
<p>仅延迟并不是决定因素。如果消息量相对较少（例如，监视网络故障），则HTTP流或轮询可以提供有效的解决方案。低延迟，高频率和高音量的结合才是使用WebSocket的最佳案例。</p>
<p>还请记住，在Internet上，控件之外的限制性代理可能会阻止WebSocket交互，这可能是因为未将它们配置为传递Upgrade标头，或者是因为它们关闭了长期处于空闲状态的连接。这意味着与面向公众的应用程序相比，将WebSocket用于防火墙内部的应用程序是一个更直接的决定。</p>
<h2 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI"></a>WebSocketAPI</h2><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebSocketAPI">与 Servlet 堆栈中的相同</a></p>
<p>Spring Framework 提供了一个 WebSocket API，您可以使用它来编写处理 WebSocket 消息的 client-和 server-side applications。</p>
<h3 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebSocketHandler">与 Servlet 堆栈中的相同</a></p>
<p>要创建 WebSocket 服务器，可以先创建<code>WebSocketHandler</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.reactive.socket.WebSocketSession;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocketHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以将其映射到 URL 并添加<code>WebSocketHandlerAdapter</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HandlerMapping <span class="title">handlerMapping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, WebSocketHandler&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;/path&quot;</span>, <span class="keyword">new</span> MyWebSocketHandler());</span><br><span class="line"></span><br><span class="line">        SimpleUrlHandlerMapping mapping = <span class="keyword">new</span> SimpleUrlHandlerMapping();</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        mapping.setOrder(-<span class="number">1</span>); <span class="comment">// before annotated controllers</span></span><br><span class="line">        <span class="keyword">return</span> mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandlerAdapter <span class="title">handlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WebSocketHandler"><a href="#WebSocketHandler" class="headerlink" title="WebSocketHandler"></a>WebSocketHandler</h3><p><code>WebSocketHandler</code>的<code>handle</code>方法接受<code>WebSocketSession</code>并返回<code>Mono&lt;Void&gt;</code>以指示 session 的 application 处理何时完成。 session 通过两个流处理，一个用于入站消息，一个用于出站消息。以下 table 描述了处理流的两种方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>WebSocketSession</code>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Flux&lt;WebSocketMessage&gt; receive()</code></td>
<td>提供对入站消息流的访问，并在关闭连接时完成。</td>
</tr>
<tr>
<td><code>Mono&lt;Void&gt; send(Publisher&lt;WebSocketMessage&gt;)</code></td>
<td>获取传出消息的源，写入消息，并返回在源完成并写入完成时完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody>
</table>
</div>
<p><code>WebSocketHandler</code>必须将入站和出站流组成一个统一的流，并返回反映该流完成的<code>Mono&lt;Void&gt;</code>。根据 application 要求，统一流程在以下情况下完成：</p>
<ul>
<li>入站或出站消息流完成。</li>
<li>入站流完成(即连接已关闭)，而出站流是无限的。</li>
<li>在选定的点上，通过<code>WebSocketSession</code>的<code>close</code>方法。</li>
</ul>
<p>当入站和出站消息流组合在一起时，无需检查连接是否打开，因为 Reactive Streams 信号终止活动。入站流接收完成或错误信号，并且出站流接收取消信号。</p>
<p>处理程序的最基本的 implementation 是处理入站流的。以下 example 显示了这样的 implementation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> session.receive()            (<span class="number">1</span>)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...                  (2)</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...                  (3)</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .then();                    (<span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>访问入站邮件流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>对每条消息做点什么。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>执行使用消息内容的嵌套异步操作。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>返回收到完成后完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>对于嵌套的异步操作，您可能需要在使用池数据缓冲区的基础服务器上调用<code>message.retain()</code>(对于 example， Netty)。否则，可能在您有机会读取数据之前释放数据缓冲区。有关更多背景信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#数据缓冲区和编解码器">数据缓冲区和编解码器</a>。</p>
</blockquote>
<p>以下 implementation 组合了入站和出站流：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Flux&lt;WebSocketMessage&gt; output = session.receive()               (<span class="number">1</span>)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .map(value -&gt; session.textMessage(<span class="string">&quot;Echo &quot;</span> + value));    (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> session.send(output);                                    (<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>创建出站消息，生成组合流。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>当我们继续接收时，返回未完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>入站和出站流可以是独立的，只有完成才能连接，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleHandler</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(WebSocketSession session)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Mono&lt;Void&gt; input = session.receive()                                (<span class="number">1</span>)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;)</span><br><span class="line">                .then();</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; source = ... ;</span><br><span class="line">        Mono&lt;Void&gt; output = session.send(source.map(session::textMessage)); (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Mono.zip(input, output).then();                              (<span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>发送外发邮件。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>加入流并返回，当流结束时完成。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="DataBuffer-1"><a href="#DataBuffer-1" class="headerlink" title="DataBuffer"></a>DataBuffer</h3><p><code>DataBuffer</code>是 WebFlux 中字节缓冲区的表示。 reference 的 Spring 核心部分在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#数据缓冲区和编解码器">数据缓冲区和编解码器</a>部分有更多内容。要理解的 key 要点是在像 Netty 这样的服务器上，字节缓冲区被池化并且 reference 计数，并且必须在被消耗时释放以避免 memory 泄漏。</p>
<p>当在 Netty 上运行时，applications 必须使用<code>DataBufferUtils.retain(dataBuffer)</code>，如果他们希望保持 order 中的输入数据缓冲区以确保它们不被释放，并且随后在消耗缓冲区时使用<code>DataBufferUtils.release(dataBuffer)</code>。</p>
<h3 id="信号交换"><a href="#信号交换" class="headerlink" title="信号交换"></a>信号交换</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#WebSocket信号交换">与 Servlet 堆栈中的相同</a></p>
<p><code>WebSocketHandlerAdapter</code>委托给<code>WebSocketService</code>。默认情况下，这是<code>HandshakeWebSocketService</code>的一个实例，它对 WebSocket 请求执行基本检查，然后对正在使用的服务器使用<code>RequestUpgradeStrategy</code>。目前，对于 Reactor Netty，Tomcat，Jetty 和 Undertow 有 built-in 支持。</p>
<p><code>HandshakeWebSocketService</code>公开<code>sessionAttributePredicate</code> property，允许设置<code>Predicate&lt;String&gt;</code>从<code>WebSession</code>中提取属性，并将它们插入到<code>WebSocketSession</code>的属性中。</p>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/服务器Configuation">与 Servlet 堆栈中的相同</a></p>
<p>每个服务器的<code>RequestUpgradeStrategy</code>公开了可用于底层 WebSocket 引擎的 WebSocket-related configuration 选项。在 Tomcat 上 running 时，以下 example sets WebSocket 选项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketHandlerAdapter <span class="title">handlerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSocketHandlerAdapter(webSocketService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebSocketService <span class="title">webSocketService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatRequestUpgradeStrategy strategy = <span class="keyword">new</span> TomcatRequestUpgradeStrategy();</span><br><span class="line">        strategy.setMaxSessionIdleTimeout(<span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HandshakeWebSocketService(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查服务器的升级策略以查看可用的选项。目前，只有 Tomcat 和 Jetty 公开了这样的选项。</p>
<h3 id="CORS-2"><a href="#CORS-2" class="headerlink" title="CORS"></a>CORS</h3><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#允许Origins">与 Servlet 堆栈中的相同</a></p>
<p>配置 CORS 并限制对 WebSocket 端点的访问的最简单方法是让<code>WebSocketHandler</code>实现<code>CorsConfigurationSource</code>和@如果您不能这样做，您还可以在<code>SimpleUrlHandler</code>上设置<code>corsConfigurations</code> property 以通过 URL pattern 指定 CORS 设置。如果同时指定了两者，则使用<code>CorsConfiguration</code>上的<code>combine</code>方法将它们组合在一起。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>Spring WebFlux 为 Reactor Netty，Tomcat，Jetty，Undertow 和标准 Java(即 JSR-356)提供<code>WebSocketClient</code>抽象和 implementations。</p>
<blockquote>
<p>Tomcat client 实际上是标准 Java 的扩展，在<code>WebSocketSession</code>处理中具有一些额外的功能，以利用 Tomcat-specific API 来暂停接收消息以获得背压。</p>
</blockquote>
<p>要启动 WebSocket session，您可以创建 client 的实例并使用其<code>execute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebSocketClient client = <span class="keyword">new</span> ReactorNettyWebSocketClient();</span><br><span class="line"></span><br><span class="line">URI url = <span class="keyword">new</span> URI(<span class="string">&quot;ws://localhost:8080/path&quot;</span>);</span><br><span class="line">client.execute(url, session -&gt;</span><br><span class="line">        session.receive()</span><br><span class="line">                .doOnNext(System.out::println)</span><br><span class="line">                .then());</span><br></pre></td></tr></table></figure>
<p>某些客户端(例如 Jetty)实现<code>Lifecycle</code>，需要先停止并启动它们才能使用它们。所有 clients 都具有与底层 WebSocket client 的 configuration 相关的构造函数选项。</p>
<h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/#Testing">在 Spring MVC 中也是如此</a></p>
<p><code>spring-test</code>模块提供了<code>ServerHttpRequest</code>，<code>ServerHttpResponse</code>和<code>ServerWebExchange</code>的 mock implementations。有关 mock objects 的讨论，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-测试/#SpringWebReactive">Spring Web Reactive</a>。</p>
<p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-测试/#WebTestClient">WebTestClient</a>建立在这些 mock 请求和响应 objects 的基础上，以支持在没有 HTTP 服务器的情况下测试 WebFlux applications。您也可以使用<code>WebTestClient</code>进行 end-to-end integration 测试。</p>
<h1 id="RSocket"><a href="#RSocket" class="headerlink" title="RSocket"></a>RSocket</h1><p>本节描述了Spring Framework对RSocket协议的支持。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>RSocket是一种应用协议，用于使用以下交互模型之一通过TCP，WebSocket和其他字节流传输进行多路复用，双工通信：</p>
<ul>
<li><p><code>Request-Response</code> －发送一条消息并收到一条回信。</p>
</li>
<li><p><code>Request-Stream</code>-发送一条消息并接收回来的消息流。</p>
</li>
<li><p><code>Channel</code>-双向发送消息流。</p>
</li>
<li><p><code>Fire-and-Forget</code>—发送单向消息。</p>
</li>
</ul>
<p>一旦建立了初始连接，由于双方变得对称，并且双方都可以发起上述交互之一，因此“客户端”与“服务器”的区别将消失。 这就是为什么在协议中将参与方称为“请求者”和“响应者”，而将上述交互称为“请求流”或简称为“请求”的原因。</p>
<p>这些是RSocket协议的关键功能和优势：</p>
<ul>
<li>跨网络边界的<a target="_blank" rel="noopener" href="https://www.reactive-streams.org/">Reactive Streams</a>语义-对于诸如<code>Request-Stream</code>和<code>Channel</code>之类的流请求，背压信号在请求者和响应者之间传播，从而允许请求者放慢源处的响应者的速度，从而减少了对网络层拥塞控制的依赖，以及 需要在网络级别或任何级别进行缓冲。</li>
</ul>
<ul>
<li>请求限制-该功能在<code>LEASE</code>帧之后被称为“租赁”，可以从两端发送以限制给定时间内另一端允许的请求总数。 租约会定期更新。</li>
</ul>
<ul>
<li>会话恢复-这是为断开连接而设计的，需要维护某些状态。 状态管理对于应用程序是透明的，并且可以与背压结合使用，从而可以在可能的情况下停止生产者并减少所需的状态量。</li>
</ul>
<ul>
<li>大邮件的碎片化和重组。</li>
</ul>
<ul>
<li>Keepalive（心跳）。</li>
</ul>
<p>RSocket具有多种语言的<a target="_blank" rel="noopener" href="https://github.com/rsocket">实现</a>。 <a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket-java">Java库</a>基于<a target="_blank" rel="noopener" href="https://projectreactor.io/">Project Reactor</a>和<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">Reactor Netty</a>进行传输。 这意味着来自应用程序中的Reactive Streams Publishers的信号通过RSocket在网络上透明地传播。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>RSocket的优点之一是它在线路上具有定义明确的行为，并且易于阅读的<a target="_blank" rel="noopener" href="https://rsocket.io/docs/Protocol">规范</a>以及某些协议<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/tree/master/Extensions">扩展</a>。因此，独立于语言实现和更高级别的框架API，阅读规范是一个好主意。本节提供简要概述，以建立一些上下文。</p>
<p><strong>连接中</strong></p>
<p>最初，客户端通过一些低级流传输（例如TCP或WebSocket）连接到服务器，然后将<code>SETUP</code>帧发送到服务器以设置连接参数。</p>
<p>服务器可以拒绝<code>SETUP</code>帧，但是通常在发送（对于客户端）和接收（对于服务器）之后，双方都可以开始发出请求，除非<code>SETUP</code>指示使用租赁语义来限制请求的数量。在这种情况下，双方都必须等待另一端的<code>LEASE</code>帧以允许发出请求。</p>
<p><strong>发出请求</strong></p>
<p>一旦建立连接，双方就可以通过帧<code>REQUEST_RESPONSE</code>，<code>REQUEST_STREAM</code>，<code>REQUEST_CHANNEL</code>或<code>REQUEST_FNF</code>中的一个来发起请求。这些帧中的每一个都将一条消息从请求者传送到响应者。</p>
<p>然后，响应者可以返回带有响应消息的<code>PAYLOAD</code>帧，并且在<code>REQUEST_CHANNEL</code>的情况下，请求者还可以发送带有更多请求消息的<code>PAYLOAD</code>帧。</p>
<p>当请求涉及消息流（例如<code>Request-Stream</code>和<code>Channel</code>）时，响应者必须遵守来自请求者的需求信号。需求表示为许多消息。初始需求在REQUEST_STREAM和<code>REQUEST_CHANNEL</code>帧中指定。后续需求通过<code>REQUEST_N</code>帧发出信号。</p>
<p>每一端还可以通过<code>METADATA_PUSH</code>帧发送元数据通知，该元数据通知与任何单独的请求无关，而与整个连接有关。</p>
<p><strong>讯息格式</strong></p>
<p>RSocket消息包含数据和元数据。元数据可用于发送路由，安全令牌等。数据和元数据的格式可以不同。每个MIME类型都在SETUP框架中声明，并应用于给定连接上的所有请求。</p>
<p>尽管所有消息都可以具有元数据，但是通常每个请求都包含诸如路由之类的元数据，因此仅包含在请求的第一条消息中，即与帧<code>REQUEST_RESPONSE</code>，<code>REQUEST_STREAM</code>，<code>REQUEST_CHANNEL</code>或<code>REQUEST_FNF</code>中的一个一起使用。</p>
<p>协议扩展定义了用于应用程序的通用元数据格式：</p>
<ul>
<li>复合元数据-多个独立格式化的元数据条目。</li>
</ul>
<ul>
<li>路由－请求的路由。</li>
</ul>
<h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><p>RSocket的<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket-java">Java实现</a>基于<a target="_blank" rel="noopener" href="https://projectreactor.io/">Project Reactor</a>构建。 TCP和WebSocket的传输建立在<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">Reactor Netty</a>上。作为反应流库，Reactor简化了实现协议的工作。对于应用程序，自然而然的选择是将Flux和Mono与声明性运算符和透明背压支持一起使用。</p>
<p>RSocket Java中的API故意是最小且基本的。它着重于协议功能，并将应用程序编程模型（例如RPC代码生成与其他）作为更高层次的独立关注点。</p>
<p>主合同<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket-java/blob/master/rsocket-core/src/main/java/io/rsocket/RSocket.java">io.rsocket.RSocket</a>对四种请求交互类型进行建模，其中<code>Mono</code>表示单个消息的承诺，<code>Flux</code>表示消息流，而<code>io.rsocket.Payload</code>通过访问实际数据消息来访问数据和元数据作为字节缓冲区。 RSocket合同是对称使用的。对于请求，将为应用程序提供一个RSocket来执行请求。为了响应，应用程序实现了RSocket来处理请求。</p>
<p>这并不意味着要进行全面介绍。在大多数情况下，Spring应用程序将不必直接使用其API。但是，独立于Spring查看或试验RSocket可能很重要。 RSocket Java存储库包含许多示例应用程序，以演示其API和协议功能。</p>
<h3 id="Spring支持"><a href="#Spring支持" class="headerlink" title="Spring支持"></a>Spring支持</h3><p><code>spring-messaging</code>模块包含以下内容：</p>
<ul>
<li>RSocketRequester-一种流式API，可通过<code>io.rsocket.RSocket</code>进行请求，并进行数据和元数据编码/解码。</li>
</ul>
<ul>
<li>带注解的响应程序— — <code>@MessageMapping</code>用于响应的带注释的处理程序方法。</li>
</ul>
<p><code>spring-web</code>模块包含RSocket应用程序可能需要的<code>Encoder</code>和<code>Decoder</code>实现，例如Jackson CBOR / JSON和Protobuf。它还包含<code>PathPatternParser</code>，可以将其插入以进行有效的路由匹配。</p>
<p>Spring Boot 2.2支持通过TCP或WebSocket站立RSocket服务器，包括在WebFlux服务器中通过WebSocket公开RSocket的选项。 RSocketRequester.Builder和<code>RSocketStrategies</code>也有客户端支持和自动配置。有关更多详细信息，请参见Spring Boot参考中的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/#RSocket">RSocket部分</a>。</p>
<p>Spring Security 5.2提供了RSocket支持。</p>
<p>Spring Integration 5.2提供了入站和出站网关以与RSocket客户端和服务器进行交互。有关更多详细信息，请参见《 Spring Integration参考手册》。</p>
<p>Spring Cloud Gateway支持RSocket连接。</p>
<h2 id="RSocketRequester"><a href="#RSocketRequester" class="headerlink" title="RSocketRequester"></a>RSocketRequester</h2><p><code>RSocketRequester</code>提供了一个流畅的API来执行RSocket请求，接受和返回数据和元数据的对象，而不是底层数据缓冲区。 它可以对称地用于从客户端发出请求和从服务器发出请求。</p>
<p><span id="client-requester"></span></p>
<h3 id="Client-Requester"><a href="#Client-Requester" class="headerlink" title="Client Requester"></a>Client Requester</h3><p>要在客户端获得<code>RSocketRequester</code>，需要连接到服务器，同时准备并发送初始RSocket <code>SETUP</code>帧。 RSocketRequester为此提供了一个生成器。 在内部，它基于<code>io.rsocket.core.RSocketConnector</code>。</p>
<p>这是使用默认设置进行连接的最基本方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>);</span><br><span class="line"></span><br><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .connectWebSocket(URI.create(<span class="string">&quot;https://example.org:8080/rsocket&quot;</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectWebSocketAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .connectWebSocketAndAwait(URI.create(<span class="string">&quot;https://example.org:8080/rsocket&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>以上是推迟的。 实际连接和使用请求者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect asynchronously</span></span><br><span class="line">RSocketRequester.builder().connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br><span class="line">    .subscribe(requester -&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or block</span></span><br><span class="line">RSocketRequester requester = RSocketRequester.builder()</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br><span class="line">    .block(Duration.ofSeconds(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect asynchronously</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> requester: RSocketRequester? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">requester</span><span class="params">()</span></span> = requester ?:</span><br><span class="line">        RSocketRequester.builder().connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>).also &#123; requester = it &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = requester().route(...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or block</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> requester = runBlocking &#123;</span><br><span class="line">        RSocketRequester.builder().connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">doSomething</span><span class="params">()</span></span> = requester.route(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="连接设置"><a href="#连接设置" class="headerlink" title="连接设置"></a>连接设置</h4><p><code>RSocketRequester.Builder</code>提供了以下自定义初始SETUP框架的功能：</p>
<ul>
<li>dataMimeType(MimeType）-设置连接数据的mime类型。</li>
</ul>
<ul>
<li>metadataMimeType(MimeType）-设置连接上元数据的mime类型。</li>
</ul>
<ul>
<li>setupData(Object）-要包含在SETUP中的数据。</li>
</ul>
<ul>
<li>setupRoute(String，Object …））-在元数据中路由以包含在SETUP中。</li>
</ul>
<ul>
<li>setupMetadata(Object，MimeType）-其他要包含在SETUP中的元数据。</li>
</ul>
<p>对于数据，默认的mime类型是从第一个配置的<code>Decoder</code>派生的。对于元数据，默认的mime类型是<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a>，它允许每个请求有多个元数据值和mime类型对。通常，两者都不需要更改。</p>
<p>SETUP框架中的数据和元数据是可选的。在服务器端，<a href="#ConnectMapping">@ConnectMapping</a>方法可用于处理连接的开始和<code>SETUP</code>框架的内容。元数据可用于连接级别的安全性。</p>
<h4 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h4><p><code>RSocketRequester.Builder</code>接受<code>RSocketStrategies</code>来配置请求者。您需要使用它来提供编码器和解码器，以对数据和元数据值进行（反）序列化。默认情况下，仅注册<code>spring-core</code>中用于<code>String</code>，<code>byte[]</code>和<code>ByteBuffer</code>的基本编解码器。添加<code>spring-web</code>可以访问更多可以注册的内容，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RSocketStrategies strategies = RSocketStrategies.builder()</span><br><span class="line">    .encoders(encoders -&gt; encoders.add(<span class="keyword">new</span> Jackson2CborEncoder()))</span><br><span class="line">    .decoders(decoders -&gt; decoders.add(<span class="keyword">new</span> Jackson2CborDecoder()))</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .rsocketStrategies(strategies)</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strategies = RSocketStrategies.builder()</span><br><span class="line">        .encoders &#123; it.add(Jackson2CborEncoder()) &#125;</span><br><span class="line">        .decoders &#123; it.add(Jackson2CborDecoder()) &#125;</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .rsocketStrategies(strategies)</span><br><span class="line">        .connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br></pre></td></tr></table></figure>
<p><code>RSocketStrategies</code>设计为可重复使用。 在某些情况下，例如 客户和服务器在同一应用程序中，最好在Spring配置中声明它。</p>
<p><span id="overview-client-responders"></span></p>
<h4 id="Client-Responders"><a href="#Client-Responders" class="headerlink" title="Client Responders"></a>Client Responders</h4><p><code>RSocketRequester.Builder</code>可用于配置响应器以响应来自服务器的请求。</p>
<p>您可以根据服务器上使用的相同基础结构，使用带注释的处理程序进行客户端响应，但需要通过程序注册，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RSocketStrategies strategies = RSocketStrategies.builder()</span><br><span class="line">    .routeMatcher(<span class="keyword">new</span> PathPatternRouteMatcher())  (<span class="number">1</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">SocketAcceptor responder =</span><br><span class="line">    RSocketMessageHandler.responder(strategies, <span class="keyword">new</span> ClientHandler()); (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .rsocketConnector(connector -&gt; connector.acceptor(responder)) (<span class="number">3</span>)</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strategies = RSocketStrategies.builder()</span><br><span class="line">        .routeMatcher(PathPatternRouteMatcher())  <span class="number">1</span></span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> responder =</span><br><span class="line">    RSocketMessageHandler.responder(strategies, new ClientHandler()); <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .rsocketConnector &#123; it.acceptor(responder) &#125; <span class="number">3</span></span><br><span class="line">        .connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果存在<code>spring-web</code>，请使用<code>PathPatternRouteMatcher</code>，以提高效率<br>路线匹配。</li>
<li>使用<code>@MessageMaping</code>和/或<code>@ConnectMapping</code>方法从类中创建响应者。</li>
<li>注册响应者。</li>
</ol>
<p>请注意，以上只是设计用于客户端响应程序的程序化注册的快捷方式。 对于客户端响应者处于Spring配置的替代方案，您仍然可以将RSocketMessageHandler声明为Spring bean，然后按以下方式应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = ... ;</span><br><span class="line">RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);</span><br><span class="line"></span><br><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .rsocketConnector(connector -&gt; connector.acceptor(handler.responder()))</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.getBean</span><br><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> context: ApplicationContext = ...</span><br><span class="line"><span class="keyword">val</span> handler = context.getBean&lt;RSocketMessageHandler&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .rsocketConnector &#123; it.acceptor(handler.responder()) &#125;</span><br><span class="line">        .connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br></pre></td></tr></table></figure>
<p>对于上述情况，您可能还需要使用<code>RSocketMessageHandler</code>中的<code>setHandlerPredicate</code>来切换到用于检测客户端响应程序的其他策略，例如 基于自定义注释，例如<code>@RSocketClientResponder</code>与默认<code>@Controller</code>。 在客户端和服务器或同一应用程序中有多个客户端的情况下，这是必需的。</p>
<p>有关编程模型的更多信息，请参见<a href="#Annotated-Responders">带注解的响应者</a>。</p>
<h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><p><code>RSocketRequesterBuilder</code>提供了一个回调，以公开底层的<code>io.rsocket.core.RSocketConnector</code>，以提供有关keepalive间隔，会话恢复，拦截器等的更多配置选项。 您可以按以下方式在该级别上配置选项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;RSocketRequester&gt; requesterMono = RSocketRequester.builder()</span><br><span class="line">    .rsocketConnector(connector -&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .connectTcp(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.connectTcpAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester = RSocketRequester.builder()</span><br><span class="line">        .rsocketConnector &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;.connectTcpAndAwait(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>)</span><br></pre></td></tr></table></figure>
<p><span id="RSocketRequester-server-requester"></span></p>
<h3 id="Server-Requester"><a href="#Server-Requester" class="headerlink" title="Server Requester"></a>Server Requester</h3><p>从服务器向连接的客户端发出请求是从服务器获取连接客户端的请求者的问题。</p>
<p>在<a href="#Annotated-Responders">带注解的响应者</a>中，<code>@ConnectMapping</code>和<code>@MessageMapping</code>方法支持<code>RSocketRequester</code>参数。 使用它来访问连接的请求者。 请记住，<code>@ConnectMapping</code>方法本质上是<code>SETUP</code>框架的处理程序，必须在请求开始之前对其进行处理。 因此，一开始的请求必须与处理分离。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConnectMapping</span></span><br><span class="line"><span class="function">Mono&lt;Void&gt; <span class="title">handle</span><span class="params">(RSocketRequester requester)</span> </span>&#123;</span><br><span class="line">    requester.route(<span class="string">&quot;status&quot;</span>).data(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">        .retrieveFlux(StatusReport.class)</span><br><span class="line">        .subscribe(bar -&gt; &#123; <span class="number">1</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span> ... <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConnectMapping</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">handle</span><span class="params">(requester: <span class="type">RSocketRequester</span>)</span></span> &#123;</span><br><span class="line">    GlobalScope.launch &#123;</span><br><span class="line">        requester.route(<span class="string">&quot;status&quot;</span>).<span class="keyword">data</span>(<span class="string">&quot;5&quot;</span>).retrieveFlow&lt;StatusReport&gt;().collect &#123; <span class="number">1</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// ... 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>独立于处理，异步启动请求。</li>
<li>在挂起功能中执行处理。<h3 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h3>有了客户端或服务器请求者后，可以按以下方式发出请求：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ViewBox viewBox = ... ;</span><br><span class="line"></span><br><span class="line">Flux&lt;AirportLocation&gt; locations = requester.route(<span class="string">&quot;locate.radars.within&quot;</span>) <span class="number">1</span></span><br><span class="line">        .data(viewBox) <span class="number">2</span></span><br><span class="line">        .retrieveFlux(AirportLocation.class); <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> viewBox: ViewBox = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> locations = requester.route(<span class="string">&quot;locate.radars.within&quot;</span>) <span class="number">1</span></span><br><span class="line">        .<span class="keyword">data</span>(viewBox) <span class="number">2</span></span><br><span class="line">        .retrieveFlow&lt;AirportLocation&gt;() <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>指定要包含在请求消息的元数据中的路由。</li>
<li>提供请求消息的数据。</li>
<li>声明预期的响应。</li>
</ol>
<p>交互类型由输入和输出的基数隐式确定。 上面的示例是一个<code>Request-Stream</code>，因为发送了一个值并接收了一个值流。 在大多数情况下，只要输入和输出的选择与RSocket交互类型以及响应者期望的输入和输出类型相匹配，就无需考虑这一点。 无效组合的唯一示例是多对一。</p>
<p><code>data(object）</code>方法还接受任何Reactive Streams <code>Publisher</code>，包括<code>Flux</code>和<code>Mono</code>，以及在<code>ReactiveAdapterRegistry</code>中注册的任何其他值的生产者。 对于产生相同类型值的多值发布器（例如Flux），请考虑使用一种重载数据方法，以避免对每个元素进行类型检查和编码器查找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data(Object producer, Class&lt;?&gt; elementClass);</span><br><span class="line">data(Object producer, ParameterizedTypeReference&lt;?&gt; elementTypeRef);</span><br></pre></td></tr></table></figure>
<p><code>data（Object）</code>步骤是可选的。 跳过不发送数据的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;AirportLocation&gt; location = requester.route(<span class="string">&quot;find.radar.EWR&quot;</span>))</span><br><span class="line">    .retrieveMono(AirportLocation.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.retrieveAndAwait</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> location = requester.route(<span class="string">&quot;find.radar.EWR&quot;</span>)</span><br><span class="line">    .retrieveAndAwait&lt;AirportLocation&gt;()</span><br></pre></td></tr></table></figure>
<p>如果使用<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a>（默认设置）并且注册的编码器支持这些值，则可以添加额外的元数据值。 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String securityToken = ... ;</span><br><span class="line">ViewBox viewBox = ... ;</span><br><span class="line">MimeType mimeType = MimeType.valueOf(<span class="string">&quot;message/x.rsocket.authentication.bearer.v0&quot;</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;AirportLocation&gt; locations = requester.route(<span class="string">&quot;locate.radars.within&quot;</span>)</span><br><span class="line">        .metadata(securityToken, mimeType)</span><br><span class="line">        .data(viewBox)</span><br><span class="line">        .retrieveFlux(AirportLocation.class);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.retrieveFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> requester: RSocketRequester = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> securityToken: String = ...</span><br><span class="line"><span class="keyword">val</span> viewBox: ViewBox = ...</span><br><span class="line"><span class="keyword">val</span> mimeType = MimeType.valueOf(<span class="string">&quot;message/x.rsocket.authentication.bearer.v0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> locations = requester.route(<span class="string">&quot;locate.radars.within&quot;</span>)</span><br><span class="line">        .metadata(securityToken, mimeType)</span><br><span class="line">        .<span class="keyword">data</span>(viewBox)</span><br><span class="line">        .retrieveFlow&lt;AirportLocation&gt;()</span><br></pre></td></tr></table></figure>
<p>对于“即发即弃”，请使用返回<code>Mono &lt;Void&gt;</code>的<code>send()</code>方法。 请注意，<code>Mono</code>仅指示消息已成功发送，而不是已被处理。</p>
<p><span id="Annotated-Responders"></span></p>
<h2 id="带注解的响应者"><a href="#带注解的响应者" class="headerlink" title="带注解的响应者"></a>带注解的响应者</h2><p>RSocket响应器可以实现为<code>@MessageMapping</code>和<code>@ConnectMapping</code>方法。 <code>@MessageMapping</code>方法处理单个请求，而<code>@ConnectMapping</code>方法处理连接级事件（设置和元数据推送）。 对称支持带注释的响应者，用于从服务器端响应和从客户端端响应。</p>
<h3 id="服务器响应者"><a href="#服务器响应者" class="headerlink" title="服务器响应者"></a>服务器响应者</h3><p>要在服务器端使用带注释的响应者，请将<code>RSocketMessageHandler</code>添加到您的Spring配置中，以使用<code>@MessageMapping</code>和@ConnectMapping方法检测<code>@Controller</code> Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RSocketMessageHandler <span class="title">rsocketMessageHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RSocketMessageHandler handler = <span class="keyword">new</span> RSocketMessageHandler();</span><br><span class="line">        handler.routeMatcher(<span class="keyword">new</span> PathPatternRouteMatcher());</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rsocketMessageHandler</span><span class="params">()</span></span> = RSocketMessageHandler().apply &#123;</span><br><span class="line">        routeMatcher = PathPatternRouteMatcher()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过Java RSocket API启动RSocket服务器，并为响应者插入<code>RSocketMessageHandler</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = ... ;</span><br><span class="line">RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);</span><br><span class="line"></span><br><span class="line">CloseableChannel server =</span><br><span class="line">    RSocketServer.create(handler.responder())</span><br><span class="line">        .bind(TcpServerTransport.create(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>))</span><br><span class="line">        .block();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.getBean</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> context: ApplicationContext = ...</span><br><span class="line"><span class="keyword">val</span> handler = context.getBean&lt;RSocketMessageHandler&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> server = RSocketServer.create(handler.responder())</span><br><span class="line">        .bind(TcpServerTransport.create(<span class="string">&quot;localhost&quot;</span>, <span class="number">7000</span>))</span><br><span class="line">        .awaitFirst()</span><br></pre></td></tr></table></figure>
<p>默认情况下，RSocketMessageHandler支持<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合</a>和<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">路由</a>元数据。 如果需要切换到其他mime类型或注册其他元数据mime类型，则可以设置其<a href="#MetadataExtractor">MetadataExtractor</a>。</p>
<p>您需要设置支持元数据和数据格式所需的<code>Encoder</code>和<code>Decoder</code>实例。 您可能需要<code>spring-web</code>模块来实现编解码器。</p>
<p>默认情况下，<code>SimpleRouteMatcher</code>用于通过<code>AntPathMatcher</code>匹配路由。 我们建议从<code>spring-web</code>插入<code>PathPatternRouteMatcher</code>，以实现有效的路由匹配。 RSocket路由可以是分层的，但不是URL路径。 两个路由匹配器都配置为使用“。” 默认为分隔符，并且没有HTTP网址那样的URL解码。</p>
<p><code>RSocketMessageHandler</code>可以通过<code>RSocketStrategies</code>进行配置，如果您需要在同一过程中在客户端和服务器之间共享配置，这可能会很有用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RSocketMessageHandler <span class="title">rsocketMessageHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RSocketMessageHandler handler = <span class="keyword">new</span> RSocketMessageHandler();</span><br><span class="line">        handler.setRSocketStrategies(rsocketStrategies());</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RSocketStrategies <span class="title">rsocketStrategies</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RSocketStrategies.builder()</span><br><span class="line">            .encoders(encoders -&gt; encoders.add(<span class="keyword">new</span> Jackson2CborEncoder()))</span><br><span class="line">            .decoders(decoders -&gt; decoders.add(<span class="keyword">new</span> Jackson2CborDecoder()))</span><br><span class="line">            .routeMatcher(<span class="keyword">new</span> PathPatternRouteMatcher())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rsocketMessageHandler</span><span class="params">()</span></span> = RSocketMessageHandler().apply &#123;</span><br><span class="line">        rSocketStrategies = rsocketStrategies()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rsocketStrategies</span><span class="params">()</span></span> = RSocketStrategies.builder()</span><br><span class="line">            .encoders &#123; it.add(Jackson2CborEncoder()) &#125;</span><br><span class="line">            .decoders &#123; it.add(Jackson2CborDecoder()) &#125;</span><br><span class="line">            .routeMatcher(PathPatternRouteMatcher())</span><br><span class="line">            .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="annotated-client-responders"></span></p>
<h4 id="Client-Responders-1"><a href="#Client-Responders-1" class="headerlink" title="Client Responders"></a>Client Responders</h4><p>需要在<code>RSocketRequester.Builder</code>中配置客户端的带注解的响应者。 有关详细信息，请参阅<a href="#overview-client-responders">客户端响应程序</a>。</p>
<p><span id="message-mapping"></span></p>
<h3 id="MessageMapping"><a href="#MessageMapping" class="headerlink" title="@MessageMapping"></a>@MessageMapping</h3><p><a href="#服务器响应者">服务器</a>或<a href="#annotated-client-responders">客户端</a>响应器配置到位后，可以按以下方式使用<code>@MessageMapping</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadarsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(&quot;locate.radars.within&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;AirportLocation&gt; <span class="title">radars</span><span class="params">(MapRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RadarsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MessageMapping(<span class="meta-string">&quot;locate.radars.within&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">radars</span><span class="params">(request: <span class="type">MapRequest</span>)</span></span>: Flow&lt;AirportLocation&gt; &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>@MessageMapping</code>方法响应具有路由“ locate.radars.within”的请求-流交互。 它支持灵活的方法签名，并可以选择使用以下方法参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Method Argument</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>@Payload</code></td>
<td style="text-align:left">请求的有效负载。 这可以是诸如Mono或Flux之类的异步类型的具体值。<br/><br/>注意：注释的使用是可选的。 并非简单类型并且不是其他任何受支持参数的方法参数都假定为预期的有效负载。</td>
</tr>
<tr>
<td style="text-align:left"><code>RSocketRequester</code></td>
<td style="text-align:left">向远端发出请求的请求者。</td>
</tr>
<tr>
<td style="text-align:left"><code>@DestinationVariable</code></td>
<td style="text-align:left">根据映射模式中的变量从路线提取的值，例如 @MessageMapping（“ find.radar。{id}”）。</td>
</tr>
<tr>
<td style="text-align:left"><code>@Header</code></td>
<td style="text-align:left">如<a href="#MetadataExtractor">MetadataExtractor</a>中所述注册要提取的元数据值。</td>
</tr>
<tr>
<td style="text-align:left"><code>@Headers Map&lt;String, Object&gt;</code></td>
<td style="text-align:left">如<a href="#MetadataExtractor">MetadataExtractor</a>中所述，注册所有用于提取的元数据值。</td>
</tr>
</tbody>
</table>
</div>
<p>返回值应该是一个或多个要序列化为响应有效负载的对象。 可以是诸如Mono或Flux的异步类型，具体值，也可以是void或无值的异步类型，例如<code>Mono&lt;Void&gt;</code>。</p>
<p>@MessageMapping方法支持的RSocket交互类型由输入（即<code>@Payload</code>参数）和输出的基数确定，其中基数表示以下内容：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">基数</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Either an explicit value, or a single-value asynchronous type such as <code>Mono&lt;T&gt;</code>.</td>
</tr>
<tr>
<td style="text-align:left">Many</td>
<td style="text-align:left">A multi-value asynchronous type such as <code>Flux&lt;T&gt;</code>.</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">For input this means the method does not have an <code>@Payload</code> argument.For output this is <code>void</code> or a no-value asynchronous type such as <code>Mono&lt;Void&gt;</code>.</td>
</tr>
</tbody>
</table>
</div>
<p>下表显示了所有输入和输出基数组合以及相应的交互类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Input Cardinality</th>
<th style="text-align:left">Output Cardinality</th>
<th style="text-align:left">Interaction Types</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0, 1</td>
<td style="text-align:left">0</td>
<td style="text-align:left">Fire-and-Forget, Request-Response</td>
</tr>
<tr>
<td style="text-align:left">0, 1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">Request-Response</td>
</tr>
<tr>
<td style="text-align:left">0, 1</td>
<td style="text-align:left">Many</td>
<td style="text-align:left">Request-Stream</td>
</tr>
<tr>
<td style="text-align:left">Many</td>
<td style="text-align:left">0, 1, Many</td>
<td style="text-align:left">Request-Channel</td>
</tr>
</tbody>
</table>
</div>
<h3 id="ConnectMapping"><a href="#ConnectMapping" class="headerlink" title="@ConnectMapping"></a>@ConnectMapping</h3><p><code>@ConnectMapping</code>在RSocket连接开始时处理<code>SETUP</code>帧，并通过<code>METADATA_PUSH</code>帧（即<code>io.rsocket.RSocket</code>中的<code>metadataPush(Payload</code>））处理任何后续的元数据推送通知。</p>
<p><code>@ConnectMapping</code>方法支持与<a href="#message-mapping">@MessageMapping</a>相同的参数，但是基于<code>SETUP</code>和<code>METADATA_PUSH</code>帧中的元数据和数据。 <code>@ConnectMapping</code>可以具有将处理范围缩小到元数据中具有路由的特定连接的模式，或者，如果未声明任何模式，则所有连接都匹配。</p>
<p><code>@ConnectMapping</code>方法无法返回数据，必须使用<code>void</code>或<code>Mono&lt;Void&gt;</code>作为返回值进行声明。 如果处理为新连接返回错误，则连接被拒绝。 不得阻止向<code>RSocketRequester</code>发出连接请求的处理。 有关详细信息，请参见<a href="#RSocketRequester-server-requester">服务器请求程序</a>。</p>
<h2 id="MetadataExtractor"><a href="#MetadataExtractor" class="headerlink" title="MetadataExtractor"></a>MetadataExtractor</h2><p>响应者必须解释元数据。 <a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/CompositeMetadata.md">复合元数据</a>允许独立格式化的元数据值（例如，用于路由，安全性和跟踪），每个元数据值都有自己的mime类型。 应用程序需要一种配置要支持的元数据MIME类型的方法，以及一种访问提取值的方法。</p>
<p><code>MetadataExtractor</code>是一种协议，用于获取序列化的元数据并返回解码的名称/值对，然后可以按名称对标题进行访问，例如通过带注释的处理程序方法中的<code>@Header</code>进行访问。</p>
<p>可以给<code>DefaultMetadataExtractor</code>解码器实例以解码元数据。 开箱即用，它具有对<a target="_blank" rel="noopener" href="https://github.com/rsocket/rsocket/blob/master/Extensions/Routing.md">“message/x.rsocket.routing.v0”</a>的内置支持，它可以解码为<code>String</code>并保存在“ route”键下。 对于任何其他mime类型，您需要提供一个<code>Decoder</code>并注册mime类型，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultMetadataExtractor extractor = <span class="keyword">new</span> DefaultMetadataExtractor(metadataDecoders);</span><br><span class="line">extractor.metadataToExtract(fooMimeType, Foo.class, &quot;foo&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.metadataToExtract</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> extractor = DefaultMetadataExtractor(metadataDecoders)</span><br><span class="line">extractor.metadataToExtract&lt;Foo&gt;(fooMimeType, <span class="string">&quot;foo&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>复合元数据很好地结合了独立的元数据值。 但是，请求者可能不支持复合元数据，或者可以选择不使用它。 为此，<code>DefaultMetadataExtractor</code>可能需要自定义逻辑以将解码后的值映射到输出映射。 这是将JSON用于元数据的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DefaultMetadataExtractor extractor = <span class="keyword">new</span> DefaultMetadataExtractor(metadataDecoders);</span><br><span class="line">extractor.metadataToExtract(</span><br><span class="line">    MimeType.valueOf(<span class="string">&quot;application/vnd.myapp.metadata+json&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ParameterizedTypeReference&lt;Map&lt;String,String&gt;&gt;() &#123;&#125;,</span><br><span class="line">    (jsonMap, outputMap) -&gt; &#123;</span><br><span class="line">        outputMap.putAll(jsonMap);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.metadataToExtract</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> extractor = DefaultMetadataExtractor(metadataDecoders)</span><br><span class="line">extractor.metadataToExtract&lt;Map&lt;String, String&gt;&gt;(MimeType.valueOf(<span class="string">&quot;application/vnd.myapp.metadata+json&quot;</span>)) &#123; jsonMap, outputMap -&gt;</span><br><span class="line">    outputMap.putAll(jsonMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>RSocketStrategies</code>配置<code>MetadataExtractor</code>时，可以让<code>RSocketStrategies.Builder</code>使用配置的解码器创建提取器，并简单地使用回调自定义注册，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RSocketStrategies strategies = RSocketStrategies.builder()</span><br><span class="line">    .metadataExtractorRegistry(registry -&gt; &#123;</span><br><span class="line">        registry.metadataToExtract(fooMimeType, Foo.class, &quot;foo&quot;);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.messaging.rsocket.metadataToExtract</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> strategies = RSocketStrategies.builder()</span><br><span class="line">        .metadataExtractorRegistry &#123; registry: MetadataExtractorRegistry -&gt;</span><br><span class="line">            registry.metadataToExtract&lt;Foo&gt;(fooMimeType, <span class="string">&quot;foo&quot;</span>)</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>
<h1 id="Reactive库"><a href="#Reactive库" class="headerlink" title="Reactive库"></a>Reactive库</h1><p><code>spring-webflux</code>依赖于<code>reactor-core</code>并在内部使用它来组成异步逻辑并提供 Reactive Streams 支持。通常，WebFlux API return <code>Flux</code>或<code>Mono</code>(因为它们在内部使用)并且宽松地接受任何 Reactive Streams <code>Publisher</code> implementation 作为输入。 <code>Flux</code>与<code>Mono</code>的使用很重要，因为它有助于表达基数 - 例如，是否需要单个或多个异步值，这对于做出决策是必不可少的(例如，在编码或解码 HTTP 消息时)。</p>
<p>对于带注释的控制器，WebFlux 透明地适应 application 选择的 reactive library。这是在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html">ReactiveAdapterRegistry</a>的帮助下完成的，它为 reactive library 和其他异步类型提供了可插入的支持。注册表具有 built-in 支持 RxJava 和<code>CompletableFuture</code>，但您也可以注册其他人。</p>
<p>对于功能 API(例如<a href="#功能Endpoints">功能 Endpoints</a>，<code>WebClient</code>和其他)，WebFlux API 的一般规则适用 - <code>Flux</code>和<code>Mono</code>作为 return 值，Reactive Streams <code>Publisher</code>作为输入。当提供<code>Publisher</code>(无论是自定义还是来自另一个 reactive library)时，它只能被视为具有未知语义的流(0..N)。但是，如果语义已知，则可以使用<code>Flux</code>或<code>Mono.from(Publisher)</code>包装它，而不是传递原始<code>Publisher</code>。</p>
<p>对于 example，给定不是<code>Mono</code>，Jackson JSON 消息 writer 需要多个值。如果媒体类型意味着无限流(对于 example，<code>application/json+stream</code>)，则会单独写入和刷新值。否则，将值缓冲到列表中并呈现为 JSON array。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/" rel="prev" title="SpringFramework官方文档翻译-Servlet Stack上的Web">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-Servlet Stack上的Web
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/" rel="next" title="SpringFramework官方文档翻译-集成">
      SpringFramework官方文档翻译-集成 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringWebFlux"><span class="nav-number">1.</span> <span class="nav-text">SpringWebFlux</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E2%80%9CReactive%E2%80%9D"><span class="nav-number">1.1.1.</span> <span class="nav-text">定义“Reactive”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReactiveAPI"><span class="nav-number">1.1.2.</span> <span class="nav-text">ReactiveAPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">编程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E7%94%A8%E6%80%A7"><span class="nav-number">1.1.4.</span> <span class="nav-text">适用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.5.</span> <span class="nav-text">服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">1.1.6.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91Model"><span class="nav-number">1.1.7.</span> <span class="nav-text">并发Model</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactive%E6%A0%B8%E5%BF%83"><span class="nav-number">1.2.</span> <span class="nav-text">Reactive核心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HttpHandler"><span class="nav-number">1.2.1.</span> <span class="nav-text">HttpHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebHandlerAPI"><span class="nav-number">1.2.2.</span> <span class="nav-text">WebHandlerAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84bean%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">特殊的bean类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebHandlerAPI%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">WebHandlerAPI表单数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multipart%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">Multipart数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91Headers"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">转发Headers</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.2.3.</span> <span class="nav-text">过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">CORS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.2.4.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">编解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Jackson-JSON"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Jackson-JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">表单数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multipart"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">Multipart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Streaming"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Streaming</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataBuffer"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">DataBuffer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Logging"><span class="nav-number">1.2.6.</span> <span class="nav-text">Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97Id"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">日志Id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">敏感数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DispatcherHandler"><span class="nav-number">1.3.</span> <span class="nav-text">DispatcherHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84Bean%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">特殊的Bean类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebFlux%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.2.</span> <span class="nav-text">WebFlux配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Processing"><span class="nav-number">1.3.3.</span> <span class="nav-text">Processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="nav-number">1.3.4.</span> <span class="nav-text">结果处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exceptions"><span class="nav-number">1.3.5.</span> <span class="nav-text">Exceptions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.3.6.</span> <span class="nav-text">View解析器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Handling"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">Handling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">内容协商</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.4.</span> <span class="nav-text">带注解的控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Controller%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.1.</span> <span class="nav-text">Controller注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-number">1.4.2.</span> <span class="nav-text">请求映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URI%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">URI模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pattern%E6%AF%94%E8%BE%83"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Pattern比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">可消费的媒体类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E7%94%9F%E4%BA%A7%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">可生产的媒体类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8CHeaders"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">参数和Headers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%A4%B4-OPTIONS"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">HTTP头,OPTIONS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">自定义注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E6%B3%A8%E5%86%8C"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">显式注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.3.</span> <span class="nav-text">处理程序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95Arguments"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">方法Arguments</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Return%E5%80%BC"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">Return值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E9%87%8F"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">矩阵变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestParam"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">@RequestParam</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestHeader%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">RequestHeader注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CookieValue%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">CookieValue注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ModelAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">ModelAttribute注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SessionAttributes%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.9.</span> <span class="nav-text">SessionAttributes注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SessionAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.10.</span> <span class="nav-text">SessionAttribute注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.11.</span> <span class="nav-text">RequestAttribute注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MultipartContent"><span class="nav-number">1.4.3.12.</span> <span class="nav-text">MultipartContent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RequestBody%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.13.</span> <span class="nav-text">RequestBody注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HttpEntity"><span class="nav-number">1.4.3.14.</span> <span class="nav-text">HttpEntity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ResponseBody%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.3.15.</span> <span class="nav-text">ResponseBody注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ResponseEntity"><span class="nav-number">1.4.3.16.</span> <span class="nav-text">ResponseEntity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JacksonJSON"><span class="nav-number">1.4.3.17.</span> <span class="nav-text">JacksonJSON</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Jackson-Views"><span class="nav-number">1.4.3.17.1.</span> <span class="nav-text">Jackson Views</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Model"><span class="nav-number">1.4.4.</span> <span class="nav-text">Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataBinder"><span class="nav-number">1.4.5.</span> <span class="nav-text">DataBinder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86Exceptions"><span class="nav-number">1.4.6.</span> <span class="nav-text">管理Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#REST-API%E5%BC%82%E5%B8%B8"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">REST-API异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ControllerAdvice"><span class="nav-number">1.4.7.</span> <span class="nav-text">ControllerAdvice</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7Endpoints"><span class="nav-number">1.5.</span> <span class="nav-text">功能性Endpoints</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HandlerFunction"><span class="nav-number">1.5.2.</span> <span class="nav-text">HandlerFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerRequest"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">ServerRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServerResponse"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">ServerResponse</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HandlerClasses"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">HandlerClasses</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RouterFunction"><span class="nav-number">1.5.3.</span> <span class="nav-text">RouterFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E8%A8%80"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Routes"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">Routes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97Routes"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">嵌套Routes</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.5.4.</span> <span class="nav-text">运行服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.5.</span> <span class="nav-text">过滤处理程序函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URI%E9%93%BE%E6%8E%A5"><span class="nav-number">1.6.</span> <span class="nav-text">URI链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UriComponents"><span class="nav-number">1.6.1.</span> <span class="nav-text">UriComponents</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UriBuilder"><span class="nav-number">1.6.2.</span> <span class="nav-text">UriBuilder</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI%E7%BC%96%E7%A0%81"><span class="nav-number">1.6.3.</span> <span class="nav-text">URI编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CORS-1"><span class="nav-number">1.7.</span> <span class="nav-text">CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Processing-1"><span class="nav-number">1.7.2.</span> <span class="nav-text">Processing</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CrossOrigin%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.7.3.</span> <span class="nav-text">CrossOrigin注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="nav-number">1.7.4.</span> <span class="nav-text">全局配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.7.5.</span> <span class="nav-text">CORS过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E5%AE%89%E5%85%A8"><span class="nav-number">1.8.</span> <span class="nav-text">Web安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View%E6%8A%80%E6%9C%AF"><span class="nav-number">1.9.</span> <span class="nav-text">View技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thymeleaf"><span class="nav-number">1.9.1.</span> <span class="nav-text">Thymeleaf</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FreeMarker"><span class="nav-number">1.9.2.</span> <span class="nav-text">FreeMarker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#View%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">View配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FreeMarker%E9%85%8D%E7%BD%AE"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">FreeMarker配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">表单处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%AE%8F"><span class="nav-number">1.9.2.3.1.</span> <span class="nav-text">绑定宏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E5%AE%8F"><span class="nav-number">1.9.2.3.2.</span> <span class="nav-text">表单宏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E8%A7%86%E5%9B%BE"><span class="nav-number">1.9.3.</span> <span class="nav-text">脚本视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9C%80%E6%B1%82"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">脚本模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON%E5%92%8CXML"><span class="nav-number">1.9.4.</span> <span class="nav-text">JSON和XML</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="nav-number">1.10.</span> <span class="nav-text">HTTP缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CacheControl"><span class="nav-number">1.10.1.</span> <span class="nav-text">CacheControl</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.10.2.</span> <span class="nav-text">控制器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">1.10.3.</span> <span class="nav-text">静态资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebFlux%E9%85%8D%E7%BD%AE-1"><span class="nav-number">1.11.</span> <span class="nav-text">WebFlux配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E7%94%A8WebFlux%E9%85%8D%E7%BD%AE"><span class="nav-number">1.11.1.</span> <span class="nav-text">启用WebFlux配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebFlux%E9%85%8D%E7%BD%AEAPI"><span class="nav-number">1.11.2.</span> <span class="nav-text">WebFlux配置API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">1.11.3.</span> <span class="nav-text">转换，格式化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">1.11.4.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ContentType%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.11.5.</span> <span class="nav-text">ContentType解析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%B6%88%E6%81%AF%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.11.6.</span> <span class="nav-text">HTTP消息编解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.11.7.</span> <span class="nav-text">视图解析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-1"><span class="nav-number">1.11.8.</span> <span class="nav-text">静态资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="nav-number">1.11.9.</span> <span class="nav-text">路径匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.11.10.</span> <span class="nav-text">高级配置模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-2"><span class="nav-number">1.12.</span> <span class="nav-text">HTTP&#x2F;2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebClient"><span class="nav-number">2.</span> <span class="nav-text">WebClient</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MaxInMemorySize"><span class="nav-number">2.1.1.</span> <span class="nav-text">MaxInMemorySize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReactorNetty"><span class="nav-number">2.1.2.</span> <span class="nav-text">ReactorNetty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B6%85%E6%97%B6"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">超时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jetty"><span class="nav-number">2.1.3.</span> <span class="nav-text">Jetty</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#retrieve"><span class="nav-number">2.2.</span> <span class="nav-text">retrieve()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exchange"><span class="nav-number">2.3.</span> <span class="nav-text">exchange()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="nav-number">2.4.</span> <span class="nav-text">请求体</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE-1"><span class="nav-number">2.4.1.</span> <span class="nav-text">表单数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multipart%E6%95%B0%E6%8D%AE-1"><span class="nav-number">2.4.2.</span> <span class="nav-text">Multipart数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">Client过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">同步使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">2.7.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebSockets"><span class="nav-number">3.</span> <span class="nav-text">WebSockets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocket%E7%AE%80%E4%BB%8B"><span class="nav-number">3.1.</span> <span class="nav-text">WebSocket简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E4%B8%8EWebSocket"><span class="nav-number">3.1.1.</span> <span class="nav-text">HTTP与WebSocket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8WebSockets"><span class="nav-number">3.1.2.</span> <span class="nav-text">何时使用WebSockets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSocketAPI"><span class="nav-number">3.2.</span> <span class="nav-text">WebSocketAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocketHandler"><span class="nav-number">3.2.2.</span> <span class="nav-text">WebSocketHandler</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataBuffer-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">DataBuffer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E4%BA%A4%E6%8D%A2"><span class="nav-number">3.2.4.</span> <span class="nav-text">信号交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">3.2.5.</span> <span class="nav-text">服务器配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS-2"><span class="nav-number">3.2.6.</span> <span class="nav-text">CORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Client"><span class="nav-number">3.2.7.</span> <span class="nav-text">Client</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Testing"><span class="nav-number">4.</span> <span class="nav-text">Testing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RSocket"><span class="nav-number">5.</span> <span class="nav-text">RSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E8%A7%88"><span class="nav-number">5.1.</span> <span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.1.1.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">Java实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E6%94%AF%E6%8C%81"><span class="nav-number">5.1.3.</span> <span class="nav-text">Spring支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RSocketRequester"><span class="nav-number">5.2.</span> <span class="nav-text">RSocketRequester</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client-Requester"><span class="nav-number">5.2.1.</span> <span class="nav-text">Client Requester</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%AE%BE%E7%BD%AE"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">连接设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Responders"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">Client Responders</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">高级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Server-Requester"><span class="nav-number">5.2.2.</span> <span class="nav-text">Server Requester</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Requests"><span class="nav-number">5.2.3.</span> <span class="nav-text">Requests</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%93%8D%E5%BA%94%E8%80%85"><span class="nav-number">5.3.</span> <span class="nav-text">带注解的响应者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E8%80%85"><span class="nav-number">5.3.1.</span> <span class="nav-text">服务器响应者</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Client-Responders-1"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">Client Responders</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageMapping"><span class="nav-number">5.3.2.</span> <span class="nav-text">@MessageMapping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConnectMapping"><span class="nav-number">5.3.3.</span> <span class="nav-text">@ConnectMapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MetadataExtractor"><span class="nav-number">5.4.</span> <span class="nav-text">MetadataExtractor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reactive%E5%BA%93"><span class="nav-number">6.</span> <span class="nav-text">Reactive库</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/";
    this.page.title = "SpringFramework官方文档翻译-Web on Reactive Stack";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
