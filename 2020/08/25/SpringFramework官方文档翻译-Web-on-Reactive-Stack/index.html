<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Web on Reactive Stack1. Spring WebFluxSpring Framework，Spring Web MVC 中包含的原始 web framework 对于 Servlet API 和 Servlet 容器是 purpose-built。 bb framework，Spring WebFlux，后来在 version 5.0 中添加了。它完全 non-blocking">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-Web on Reactive Stack">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Web on Reactive Stack1. Spring WebFluxSpring Framework，Spring Web MVC 中包含的原始 web framework 对于 Servlet API 和 Servlet 容器是 purpose-built。 bb framework，Spring WebFlux，后来在 version 5.0 中添加了。它完全 non-blocking">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg">
<meta property="article:published_time" content="2020-08-25T00:35:41.000Z">
<meta property="article:modified_time" content="2020-08-25T00:57:05.822Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-Web on Reactive Stack | Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-Web on Reactive Stack
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-25 08:35:41 / 修改时间：08:57:05" itemprop="dateCreated datePublished" datetime="2020-08-25T08:35:41+08:00">2020-08-25</time>
            </span>

          
            <span id="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/" class="post-meta-item leancloud_visitors" data-flag-title="SpringFramework官方文档翻译-Web on Reactive Stack" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Web-on-Reactive-Stack"><a href="#Web-on-Reactive-Stack" class="headerlink" title="Web on Reactive Stack"></a>Web on Reactive Stack</h1><h2 id="1-Spring-WebFlux"><a href="#1-Spring-WebFlux" class="headerlink" title="1. Spring WebFlux"></a>1. Spring WebFlux</h2><p>Spring Framework，Spring Web MVC 中包含的原始 web framework 对于 Servlet API 和 Servlet 容器是 purpose-built。 bb framework，Spring WebFlux，后来在 version 5.0 中添加了。它完全 non-blocking，支持<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/">Reactive Streams</a>背压，并在 Netty，Undertow 和 Servlet 3.1 容器等服务器上运行。</p>
<p>两个 web 框架在 Spring Framework 中并排反映其源模块(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>)和 co-exist 的名称。每个模块都是可选的。 Applications 可以使用一个或另一个模块，或者在某些情况下，使用两个 - 例如，Spring MVC 控制器与 reactive <code>WebClient</code>。</p>
<a id="more"></a>

<h3 id="1-1-概观"><a href="#1-1-概观" class="headerlink" title="1.1. 概观"></a>1.1. 概观</h3><p>为什么创建 Spring WebFlux？</p>
<p>部分答案是需要 non-blocking web 堆栈来处理少量线程的并发性并使用较少的硬件资源进行扩展。 Servlet 3.1 确实为 non-blocking I/O 提供了 API。但是，使用它会导致远离 Servlet API 的 rest，其中 contracts 是同步的(<code>Filter</code>，<code>Servlet</code>)或阻塞的(<code>getParameter</code>，<code>getPart</code>)。这是一个新的 common API 作为任何 non-blocking 运行时的基础的动机。这很重要，因为服务器(例如 Netty)在 async，non-blocking 空间中是 well-established。</p>
<p>答案的另一部分是函数式编程。就像在 Java 5 中添加 annotations 创建了机会(例如带注释的 REST 控制器或单元测试)一样，在 Java 8 中添加 lambda 表达式为 Java 中的功能 API 创造了机会。这是 non-blocking applications 和 continuation-styleAPI(由<code>CompletableFuture</code>和<a target="_blank" rel="noopener" href="http://reactivex.io/">ReactiveX</a>推广)的恩惠，它允许异步逻辑的声明性组合。在 programming-model level，Java 8 启用 Spring WebFlux 以提供功能 web endpoints 以及带注释的控制器。</p>
<h4 id="1-1-1-定义“Reactive”"><a href="#1-1-1-定义“Reactive”" class="headerlink" title="1.1.1. 定义“Reactive”"></a>1.1.1. 定义“Reactive”</h4><p>我们触及“non-blocking”和“功能性”但是 reactive 是什么意思？</p>
<p>术语“reactive”指的是围绕对变化做出反应的编程模型 - 对 I/O events 做出反应的网络组件，对鼠标 events 做出反应的 UI 控制器等。从这个意义上讲，non-blocking 是 reactive，因为我们现在处于一种模式，即在操作完成或数据可用时对通知作出反应。</p>
<p>我们在 Spring 团队中还有另一个重要的机制是“reactive”，这就是 non-blocking 背压。在同步，命令式 code 中，阻塞 calls 是一种自然形式的背压，迫使调用者等待。在 non-blocking code 中，控制 events 的速率变得很重要，这样快速的 producer 就不会压倒它的目的地。</p>
<p>Reactive Streams 是一个<a target="_blank" rel="noopener" href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification">小规格</a>(在 Java 9 中也是<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html">采用</a>)，用于定义具有背压的异步组件之间的交互。对于 example，data repository(充当<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html">出版者</a>)可以生成 HTTP 服务器(充当<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html">订户</a>)然后可以写入响应的数据。 Reactive Streams 的主要目的是让订阅者控制发布者生成数据的速度或速度。</p>
<blockquote>
<p><strong>常见问题：如果出版商不能放慢速度怎么办？</strong> Reactive Streams 的目的只是建立机制和边界。如果发布者不能减速，则必须决定是缓冲，丢弃还是失败。</p>
</blockquote>
<h4 id="1-1-2-Reactive-API"><a href="#1-1-2-Reactive-API" class="headerlink" title="1.1.2. Reactive API"></a>1.1.2. Reactive API</h4><p>Reactive Streams 在互操作性方面发挥着重要作用。它对 libraries 和基础架构组件很感兴趣，但作为 application API 不太有用，因为它太 low-level。 Applications 需要一个 higher-level 和更丰富的功能 API 来组成异步逻辑 - 类似于 Java 8 <code>Stream</code> API，但不仅仅是集合。这是 reactive libraries 扮演的角色。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/reactor/reactor">反应堆</a>是 Spring WebFlux 的 reactive library 选择。它提供<a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">单</a>和<a target="_blank" rel="noopener" href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">助焊剂</a> API 类型，通过与 ReactiveX <a target="_blank" rel="noopener" href="http://reactivex.io/documentation/operators.html">operators 的词汇</a>对齐的一组丰富的 operators 来处理 0..1(<code>Mono</code>)和 0..N(<code>Flux</code>)的数据序列。 Reactor 是 Reactive Streams library，因此，它的所有 operators 都支持 non-blocking 背压。 Reactor 非常关注 server-side Java。它是与 Spring 密切合作开发的。</p>
<p>WebFlux 要求 Reactor 作为核心依赖项，但它可以通过 Reactive Streams 与其他 reactive libraries 互操作。作为一般规则，WebFlux API 接受普通<code>Publisher</code>作为输入，在内部使其适应 Reactor 类型，使用它，并返回<code>Flux</code>或<code>Mono</code>作为输出。因此，您可以传递任何<code>Publisher</code>作为输入，并且可以对输出应用操作，但是您需要调整输出以与另一个 reactive library 一起使用。只要可行(对于 example，带注释的控制器)，WebFlux 就会透明地适应 RxJava 或其他 reactive library 的使用。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">Reactive Libraries</a>。</p>
<h4 id="1-1-3-编程模型"><a href="#1-1-3-编程模型" class="headerlink" title="1.1.3. 编程模型"></a>1.1.3. 编程模型</h4><p><code>spring-web</code>模块包含作为 Spring WebFlux 基础的 reactive 基础，包括 HTTP 抽象，Reactive Streams <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">适配器</a>用于支持的服务器，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">编解码器</a>，以及与 Servlet API 相当但具有 non-blocking contracts 的核<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">WebHandler API</a>。</p>
<p>在此基础上，Spring WebFlux 提供了两种编程模型的选择：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-controller">带注释的控制器</a>：与 Spring MVC 一致，并基于<code>spring-web</code>模块的相同注释。 Spring MVC 和 WebFlux 控制器都支持 reactive(Reactor 和 RxJava)return 类型，因此，要区分它们并不容易。一个值得注意的区别是 WebFlux 还支持 reactive <code>@RequestBody</code> arguments。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-fn">功能 Endpoints</a>：Lambda-based，轻量级和函数式编程 model。您可以将此视为一个小的 library 或一组实用程序，application 可以用它来路由和处理请求。与带注释的控制器的最大区别在于，application 负责从头到尾的请求处理，而不是通过 annotations 声明意图并被回调。</li>
</ul>
<h4 id="1-1-4-适用性"><a href="#1-1-4-适用性" class="headerlink" title="1.1.4. 适用性"></a>1.1.4. 适用性</h4><p>Spring MVC 或 WebFlux？</p>
<p>这是一个自然而然的问题，但却是一个不合理的二分法。实际上，两者共同努力扩大可用选项的范围。两者的设计是为了保持连续性和一致性，它们可以并排使用，每一方的反馈都有利于双方。下图显示了两者之间的关系，它们在 common 中的含义以及每个对象的唯一性：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/spring-mvc-and-webflux-venn.jpg" alt="spring mvc 和 webflux venn"></p>
<p>我们建议您考虑以下具体要点：</p>
<ul>
<li>如果你有一个工作正常的 Spring MVC application，则无需更改。命令式编程是编写，理解和调试 code 的最简单方法。您有 libraries 的最大选择，因为从历史上看，大多数都是阻塞的。</li>
<li>如果您已经在购买 non-blocking web 堆栈，Spring WebFlux 提供与此空间中的其他人相同的执行 model 优势，并且还提供服务器选择(Netty，Tomcat，Jetty，Undertow 和 Servlet 3.1 容器)，这是一种编程选择 models(带注释的控制器和函数 web endpoints)，以及 reactive libraries(Reactor，RxJava 或其他)的选择。</li>
<li>如果您对使用 Java 8 lambdas 或 Kotlin 的轻量级，功能 web framework 感兴趣，可以使用 Spring WebFlux 功能 web endpoints。对于较小的应用程序或微服务而言，这也是一个不错的选择，其需求较少，可以从更高的透明度和控制中受益。</li>
<li>在微服务 architecture 中，您可以将 applications 与 Spring MVC 或 Spring WebFlux 控制器或 Spring WebFlux 功能 endpoints 混合使用。在两个框架中支持相同的 annotation-based 编程 model 使得更容易 re-use 知识，同时也为正确的 job 选择正确的工具。</li>
<li>评估 application 的一种简单方法是检查其依赖关系。如果您要使用阻塞持久性 API(JPA，JDBC)或网络 API，则 Spring MVC 至少是 common 体系结构的最佳选择。 Reactor 和 RxJava 在单独的线程上执行阻塞 calls 在技术上是可行的，但你不会充分利用 non-blocking web 堆栈。</li>
<li>如果你有 Spring MVC application 与 calls 到 remote 服务，请尝试 reactive <code>WebClient</code>。您可以直接从 Spring MVC 控制器方法 return reactive 类型(Reactor，RxJava，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">或其他</a>)。每次呼叫的延迟或 calls 之间的相互依赖性越大，其益处就越大。 Spring MVC 控制器也可以调用其他 reactive 组件。</li>
<li>如果你有一个庞大的团队，请记住转向 non-blocking，功能和声明性编程时的陡峭学习曲线。在没有完整切换的情况下启动的实用方法是使用 reactive <code>WebClient</code>。除此之外，从小处着手衡量效益。我们希望，对于广泛的应用，这种转变是不必要的。如果您不确定要查找哪些好处，请首先了解 non-blocking I/O 如何工作(对于示例，single-threaded Node.js 上的并发)及其效果。</li>
</ul>
<h4 id="1-1-5-服务器"><a href="#1-1-5-服务器" class="headerlink" title="1.1.5. 服务器"></a>1.1.5. 服务器</h4><p>Tomcat，Jetty，Servlet 3.1 容器以及_Net和 Undertow 等 non-Servlet 运行时支持 Spring WebFlux。所有服务器都适用于 low-level，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">common API</a>，以便跨服务器支持 higher-level <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-programming-models">编程模型</a>。</p>
<p>Spring WebFlux 没有启动或停止服务器的 built-in 支持。但是，很容易从 Spring configuration 中应用程序，和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">运行</a>以及 code 的几行 lines。</p>
<p>Spring Boot 有一个自动执行这些步骤的 WebFlux starter。默认情况下，starter 使用 Netty，但通过更改 Maven 或 Gradle 依赖项可以轻松切换到 Tomcat，Jetty 或 Undertow。 Spring Boot 默认为 Netty，因为它在异步 non-blocking 空间中使用得更广泛，让 client 和服务器共享资源。</p>
<p>Tomcat 和 Jetty 可以与 Spring MVC 和 WebFlux 一起使用。但请记住，它们的使用方式非常不同。 Spring MVC 依赖于 Servlet 阻塞 I/O，并允许 applications 在需要时直接使用 Servlet API。 Spring WebFlux 依赖 Servlet 3.1 non-blocking I/O 并在 low-level 适配器后面使用 Servlet API，不会公开直接使用。</p>
<p>对于 Undertow，Spring WebFlux 直接使用 Undertow API 而不使用 Servlet API。</p>
<h4 id="1-1-6-性能"><a href="#1-1-6-性能" class="headerlink" title="1.1.6. 性能"></a>1.1.6. 性能</h4><p>Performance 具有许多特征和含义。 Reactive 和 non-blocking 通常不会使 applications run 更快。在某些情况下，它们可以(例如，如果使用<code>WebClient</code>在 parallel 中执行 remote calls)。总的来说，non-blocking 方式需要做更多的工作，并且可以稍微增加所需的处理时间。</p>
<p>reactive 和 non-blocking 的 key 预期好处是能够使用少量固定数量的线程进行扩展，而不是 memory。这使得 applications 在负载下更具弹性，因为它们以更可预测的方式扩展。但是，为了观察这些好处，您需要有一些延迟(包括慢速和不可预测的网络混合 I/O)。这就是 reactive 堆栈开始显示其优势的地方，差异可能是戏剧性的。</p>
<h4 id="1-1-7-并发-Model"><a href="#1-1-7-并发-Model" class="headerlink" title="1.1.7. 并发 Model"></a>1.1.7. 并发 Model</h4><p>Spring MVC 和 Spring WebFlux 都支持带注释的控制器，但并发 model 和阻塞和线程的默认假设存在 key 差异。</p>
<p>在 Spring MVC(和 servlet applications)中，假设 applications 可以阻塞当前线程(例如，remote calls)，因此，servlet 容器使用大型线程池来吸收请求期间的潜在阻塞处理。</p>
<p>在 Spring WebFlux(以及一般的 non-blocking 服务器)中，假设 applications 不会阻塞，因此 non-blocking 服务器使用一个小的 fixed-size 线程池(event loop workers)来处理请求。</p>
<blockquote>
<p>“缩放”和“少量线程”听起来可能相互矛盾，但永远不会阻塞当前线程(并依赖于回调)意味着您不需要额外的线程，因为没有阻塞 calls 吸收。</p>
</blockquote>
<p>调用阻止 API</p>
<p>如果你确实需要使用阻止 library 怎么办？ Reactor 和 RxJava 都提供<code>publishOn</code> operator 来继续处理不同的线程。这意味着有一个简单的逃生舱口。但请记住，阻塞 API 不适合这种并发 model。</p>
<p>可变 State</p>
<p>在 Reactor 和 RxJava 中，您通过 operators 声明逻辑，并且在运行时，形成 reactive 管道，其中数据在不同阶段按顺序处理。这样做的好处是它可以使 applications 免于必须保护 mutable state，因为该管道中的 application code 永远不会同时被调用。</p>
<p>Threading Model</p>
<p>您希望在服务器上看到哪些线程运行 Spring WebFlux？</p>
<ul>
<li>在“vanilla”Spring WebFlux 服务器上(例如，没有数据访问或其他可选依赖项)，您可以期望服务器有一个线程，而其他几个用于请求处理(通常与 CPU 核心数一样多)。但是，Servlet 容器可能以更多线程开始(对于示例，Tomcat 上为 10)，以支持 servlet(阻塞)I/O 和 servlet 3.1(non-blocking)I/O 用法。</li>
<li>reactive <code>WebClient</code>以 event 循环样式运行。因此，您可以看到与此相关的少量固定数量的处理线程(对于 example，<code>reactor-http-nio-</code>与 Reactor Netty 连接器)。但是，如果 Reactor Netty 同时用于 client 和 server，则默认情况下两者共享 event 循环资源。</li>
<li>Reactor 和 RxJava 提供线程池抽象，称为调度程序，与<code>publishOn</code> operator 一起使用，用于将处理切换到不同的线程池。调度程序具有建议特定并发策略的名称 - 例如，“ parallel”(对于 CPU-bound 使用有限数量的线程工作)或“elastic”(对于具有大量线程的 I/O-bound 工作)。如果你看到这样的线程，这意味着一些 code 正在使用特定的线程池<code>Scheduler</code>策略。</li>
<li>数据访问 libraries 和其他第三方依赖项也可以创建和使用自己的线程。</li>
</ul>
<p>配置</p>
<p>Spring Framework 不支持启动和停止<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config">服务器</a>。要为服务器配置 threading model，需要使用 server-specific configuration API，或者，如果使用 Spring Boot，请检查每个服务器的 Spring Boot configuration 选项。你可以直接<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">配置</a> <code>WebClient</code>。对于所有其他 libraries，请参阅其各自的文档。</p>
<h3 id="1-2-Reactive-Core"><a href="#1-2-Reactive-Core" class="headerlink" title="1.2. Reactive Core"></a>1.2. Reactive Core</h3><p><code>spring-web</code>模块包含以下对 reactive web applications 的基础支持：</p>
<ul>
<li>对于服务器请求处理，有两个级别的支持。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-server-choice">HttpHandler</a>：用于 HTTP 请求处理的基本 contract non-blocking I/O 和 Reactive Streams 背压，以及 Reactor Netty，Undertow，Tomcat，Jetty 和任何 Servlet 3.1 容器的适配器。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-client-builder">WebHandler API</a>：稍高的 level，general-purpose web API 用于请求处理，在此基础上构建了具体的编程模型，如带注释的控制器和功能 endpoints。</li>
<li>对于 client 方面，有一个基本的<code>ClientHttpConnector</code> contract 来执行带有 non-blocking I/O 和 Reactive Streams 背压的 HTTP 请求，以及<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a>和 reactive <a target="_blank" rel="noopener" href="https://github.com/jetty-project/jetty-reactive-httpclient">Jetty HtpClient</a>的适配器。 applications 中使用的较高 level <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">Web 客户端</a>建立在这个基本的 contract 上。</li>
<li>对于 client 和 server，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">编解码器</a>用于序列化和反序列化 HTTP 请求和响应内容。</li>
</ul>
<h4 id="1-2-1-的-HttpHandler"><a href="#1-2-1-的-HttpHandler" class="headerlink" title="1.2.1. 的 HttpHandler"></a>1.2.1. 的 HttpHandler</h4><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/server/reactive/HttpHandler.html">HttpHandler</a>是一个简单的 contract，它有一个方法来处理请求和响应。它是故意最小的，它的主要目的是成为不同 HTTP 服务器 API 的最小抽象。</p>
<p>以下 table 描述了支持的服务器 API：</p>
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>使用的服务器 API</th>
<th>Reactive Streams 支持</th>
</tr>
</thead>
<tbody><tr>
<td>Netty</td>
<td>Netty API</td>
<td><a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a></td>
</tr>
<tr>
<td>Undertow</td>
<td>Undertow API</td>
<td>spring-web：Undertow to Reactive Streams bridge</td>
</tr>
<tr>
<td>Tomcat</td>
<td>Servlet 3.1 non-blocking I/O; Tomcat API 读写 ByteBuffers vs byte [98]</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
<tr>
<td>码头</td>
<td>Servlet 3.1 non-blocking I/O; Jetty API 写 ByteBuffers vs byte [99]</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
<tr>
<td>Servlet 3.1 容器</td>
<td>Servlet 3.1 non-blocking I/O</td>
<td>spring-web：Servlet 3.1 non-blocking I/O 到 Reactive Streams bridge</td>
</tr>
</tbody></table>
<p>以下 table 描述了服务器依赖性(另请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/What's-New-in-the-Spring-Framework">支持的版本</a>)：</p>
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>Group id</th>
<th>Artifact name</th>
</tr>
</thead>
<tbody><tr>
<td>反应堆 Netty</td>
<td>io.projectreactor.netty</td>
<td>reactor-netty</td>
</tr>
<tr>
<td>Undertow</td>
<td>io.undertow</td>
<td>undertow-core</td>
</tr>
<tr>
<td>Tomcat</td>
<td>org.apache.tomcat.embed</td>
<td>tomcat-embed-core</td>
</tr>
<tr>
<td>码头</td>
<td>org.eclipse.jetty</td>
<td>jetty-server，jetty-servlet</td>
</tr>
</tbody></table>
<p>下面的 code 片段显示了对每个服务器 API 使用<code>HttpHandler</code>适配器：</p>
<p><strong>反应堆 Netty</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler &#x3D; ...</span><br><span class="line">ReactorHttpHandlerAdapter adapter &#x3D; new ReactorHttpHandlerAdapter(handler);</span><br><span class="line">HttpServer.create(host, port).newHandler(adapter).block();</span><br></pre></td></tr></table></figure>

<p><strong>暗潮</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler &#x3D; ...</span><br><span class="line">UndertowHttpHandlerAdapter adapter &#x3D; new UndertowHttpHandlerAdapter(handler);</span><br><span class="line">Undertow server &#x3D; Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>

<p><strong>_</strong>的 Tomcat</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler &#x3D; ...</span><br><span class="line">Servlet servlet &#x3D; new TomcatHttpHandlerAdapter(handler);</span><br><span class="line"></span><br><span class="line">Tomcat server &#x3D; new Tomcat();</span><br><span class="line">File base &#x3D; new File(System.getProperty(&quot;java.io.tmpdir&quot;));</span><br><span class="line">Context rootContext &#x3D; server.addContext(&quot;&quot;, base.getAbsolutePath());</span><br><span class="line">Tomcat.addServlet(rootContext, &quot;main&quot;, servlet);</span><br><span class="line">rootContext.addServletMappingDecoded(&quot;&#x2F;&quot;, &quot;main&quot;);</span><br><span class="line">server.setHost(host);</span><br><span class="line">server.setPort(port);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>

<p><strong>码头</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HttpHandler handler &#x3D; ...</span><br><span class="line">Servlet servlet &#x3D; new JettyHttpHandlerAdapter(handler);</span><br><span class="line"></span><br><span class="line">Server server &#x3D; new Server();</span><br><span class="line">ServletContextHandler contextHandler &#x3D; new ServletContextHandler(server, &quot;&quot;);</span><br><span class="line">contextHandler.addServlet(new ServletHolder(servlet), &quot;&#x2F;&quot;);</span><br><span class="line">contextHandler.start();</span><br><span class="line"></span><br><span class="line">ServerConnector connector &#x3D; new ServerConnector(server);</span><br><span class="line">connector.setHost(host);</span><br><span class="line">connector.setPort(port);</span><br><span class="line">server.addConnector(connector);</span><br><span class="line">server.start();</span><br></pre></td></tr></table></figure>

<p><strong>Servlet 3.1 容器</strong></p>
<p>要将 WAR 部署到任何 Servlet 3.1 容器，可以在 WAR 中扩展并包含<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/adapter/AbstractReactiveWebInitializer.html">AbstractReactiveWebInitializer</a>。 class 用<code>ServletHttpHandlerAdapter</code>包装<code>HttpHandler</code>并将其注册为<code>Servlet</code>。</p>
<h4 id="1-2-2-WebHandler-API"><a href="#1-2-2-WebHandler-API" class="headerlink" title="1.2.2. WebHandler API"></a>1.2.2. WebHandler API</h4><p><code>org.springframework.web.server</code>包构建在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-client">HttpHandler</a> contract 上，以提供 general-purpose web API，用于通过多个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebExceptionHandler.html">WebExceptionHandler</a>，多个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebFilter.html">网页过滤</a>和一个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/WebHandler.html">WebHandler</a> component 链处理请求。链可以与<code>WebHttpHandlerBuilder</code>放在一起，只需指向 Spring <code>ApplicationContext</code>，其中组件是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">auto-detected</a>，and/or，通过向构建器注册组件。</p>
<p>虽然<code>HttpHandler</code>有一个简单的目标来抽象使用不同的 HTTP 服务器，但<code>WebHandler</code> API 旨在提供 web applications 中常用的更广泛的 features 集合，例如：</p>
<ul>
<li>用户 session 属性。</li>
<li>请求属性。</li>
<li>已解决请求的<code>Locale</code>或<code>Principal</code>。</li>
<li>访问已分析和缓存的表单数据。</li>
<li>multipart 数据的抽象。</li>
<li>和更多..</li>
</ul>
<h5 id="特殊的-bean-类型"><a href="#特殊的-bean-类型" class="headerlink" title="特殊的 bean 类型"></a>特殊的 bean 类型</h5><p>table 下面的 table 列出了<code>WebHttpHandlerBuilder</code>可以在 Spring ApplicationContext 中的组件，或者可以直接用它注册的组件：</p>
<table>
<thead>
<tr>
<th>Bean name</th>
<th>Bean 类型</th>
<th>计数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><any></td>
<td><code>WebExceptionHandler</code></td>
<td>0..N</td>
<td>为<code>WebFilter</code>实例链和目标<code>WebHandler</code>提供 exceptions 的处理。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">Exceptions</a>。</td>
</tr>
<tr>
<td><any></td>
<td><code>WebFilter</code></td>
<td>0..N</td>
<td>将拦截样式逻辑应用于过滤器链的 rest 和目标<code>WebHandler</code>之前和之后。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api-special-beans">过滤器</a>。</td>
</tr>
<tr>
<td><code>webHandler</code></td>
<td><code>WebHandler</code></td>
<td>1</td>
<td>请求的处理程序。</td>
</tr>
<tr>
<td><code>webSessionManager</code></td>
<td><code>WebSessionManager</code></td>
<td>0..1</td>
<td>通过<code>ServerWebExchange</code>上的方法公开的<code>WebSession</code>实例的 manager。 <code>DefaultWebSessionManager</code>默认情况下。</td>
</tr>
<tr>
<td><code>serverCodecConfigurer</code></td>
<td><code>ServerCodecConfigurer</code></td>
<td>0..1</td>
<td>用于访问<code>HttpMessageReader</code>实例以解析表单数据和 multipart 数据，然后通过<code>ServerWebExchange</code>上的方法公开。 <code>ServerCodecConfigurer.create()</code>默认情况下。</td>
</tr>
<tr>
<td><code>localeContextResolver</code></td>
<td><code>LocaleContextResolver</code></td>
<td>0..1</td>
<td>通过<code>ServerWebExchange</code>上的方法暴露<code>LocaleContext</code>的解析器。 <code>AcceptHeaderLocaleContextResolver</code>默认情况下。</td>
</tr>
<tr>
<td><code>forwardedHeaderTransformer</code></td>
<td><code>ForwardedHeaderTransformer</code></td>
<td>0..1</td>
<td>用于处理转发类型 headers，可以通过提取和删除它们或仅删除它们。默认情况下不使用。</td>
</tr>
</tbody></table>
<h5 id="表格数据"><a href="#表格数据" class="headerlink" title="表格数据"></a>表格数据</h5><p><code>ServerWebExchange</code>公开以下方法来访问表单数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, String&gt;&gt; getFormData();</span><br></pre></td></tr></table></figure>

<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader</code>将表单数据(<code>application/x-www-form-urlencoded</code>)解析为<code>MultiValueMap</code>。默认情况下，<code>FormHttpMessageReader</code>配置为由<code>ServerCodecConfigurer</code> bean 使用(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-exception-handler">Web Handler API</a>)。</p>
<h5 id="Multipart-数据"><a href="#Multipart-数据" class="headerlink" title="Multipart 数据"></a>Multipart 数据</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-filters">与 Spring MVC 相同</a></p>
<p><code>ServerWebExchange</code>公开以下方法来访问 multipart 数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; getMultipartData();</span><br></pre></td></tr></table></figure>

<p><code>DefaultServerWebExchange</code>使用配置的<code>HttpMessageReader&lt;MultiValueMap&lt;String, Part&gt;&gt;</code>将<code>multipart/form-data</code>内容解析为<code>MultiValueMap</code>。目前，<a target="_blank" rel="noopener" href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>是唯一受支持的 third-party library，也是我们知道的_解析 multipart 请求的唯一 library。它通过<code>ServerCodecConfigurer</code> bean 启用(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">Web Handler API</a>)。</p>
<p>要以流方式解析 multipart 数据，您可以使用从<code>HttpMessageReader&lt;Part&gt;</code>返回的<code>Flux&lt;Part&gt;</code>。例如，在带注释的控制器中，使用<code>@RequestPart</code>意味着按 name 对@相比之下，您可以使用<code>@RequestBody</code>将内容解码为<code>Flux&lt;Part&gt;</code>而无需收集到<code>MultiValueMap</code>。</p>
<h5 id="转发-Headers"><a href="#转发-Headers" class="headerlink" title="转发 Headers"></a>转发 Headers</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart">与 Spring MVC 相同</a></p>
<p>当请求通过代理(例如负载平衡器)时，host， port 和 scheme 可能会发生变化，从 client 的角度来看，这使得创建指向正确的 host，port 和 scheme 的链接成为一种挑战。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可用于提供有关原始请求的信息的<code>Forwarded</code> HTTP 标头。还有其他 non-standard headers，包括<code>X-Forwarded-Host</code>，<code>X-Forwarded-Port</code>，<code>X-Forwarded-Proto</code>，<code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderTransformer</code>是一个 component，它根据转发的 headers 修改请求的 host，port 和 scheme，然后删除那些 headers。您可以将其声明为</p>
<p>转发的 headers 有安全注意事项，因为 application 无法知道 headers 是由代理按预期添加还是由恶意 client 添加。这就是为什么应该配置信任边界的代理来删除来自外部的不受信任的转发流量。您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderTransformer</code>，在这种情况下，它会删除但不使用_header。</p>
<blockquote>
<p>在 5.1 <code>ForwardedHeaderFilter</code>被弃用并被<code>ForwardedHeaderTransformer</code>取代，因此在创建交换之前可以更早地处理转发的 headers。如果仍然配置了过滤器，则将其从过滤器列表中取出，而使用<code>ForwardedHeaderTransformer</code>。</p>
</blockquote>
<h4 id="1-2-3-过滤器"><a href="#1-2-3-过滤器" class="headerlink" title="1.2.3. 过滤器"></a>1.2.3. 过滤器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-web-handler-api">与 Spring MVC 相同</a></p>
<p>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#filters-forwarded-headers">WebHandler API</a>中，您可以使用<code>WebFilter</code>在过滤器处理链的 rest 和目标<code>WebHandler</code>之前和之后应用 interception-style 逻辑。当使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api-special-beans">WebFlux 配置</a>时，注册<code>WebFilter</code>就像将它声明为 Spring bean 和(可选)通过在 bean 声明上使用<code>@Order</code>或通过实现<code>Ordered</code>来表示优先级一样简单。</p>
<h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 通过控制器上的 annotations 为 CORS configuration 提供 fine-grained 支持。但是，当您将其与 Spring Security 一起使用时，我们建议依赖 built-in <code>CorsFilter</code>，必须在 Spring Security 的过滤器链之前进行排序。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">CORS</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config">CORS WebFilter</a>部分。</p>
<h4 id="1-2-4-Exceptions"><a href="#1-2-4-Exceptions" class="headerlink" title="1.2.4. Exceptions"></a>1.2.4. Exceptions</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-cors">与 Spring MVC 相同</a></p>
<p>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors">WebHandler API</a>中，您可以使用<code>WebExceptionHandler</code>来处理<code>WebFilter</code>实例链和目标<code>WebHandler</code>中的 exceptions。当使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors-webfilter">WebFlux 配置</a>时，注册<code>WebExceptionHandler</code>就像将它声明为 Spring bean 和(可选)通过在 bean 声明上使用<code>@Order</code>或通过实现<code>Ordered</code>来表示优先级一样简单。</p>
<p>以下 table 描述了可用的<code>WebExceptionHandler</code> implementations：</p>
<table>
<thead>
<tr>
<th>Exception Handler</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ResponseStatusExceptionHandler</code></td>
<td>通过设置对 exception 的 HTTP 状态 code 的响应来提供对<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/ResponseStatusException.html">ResponseStatusException</a>类型的 exceptions 的处理。</td>
</tr>
<tr>
<td><code>WebFluxResponseStatusExceptionHandler</code></td>
<td><code>ResponseStatusExceptionHandler</code>的扩展，也可以确定任何 exception 上<code>@ResponseStatus</code> annotation 的 HTTP 状态 code。 此处理程序在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-customer-servlet-container-error-page">WebFlux 配置</a>中声明。</td>
</tr>
</tbody></table>
<h4 id="1-2-5-编解码器"><a href="#1-2-5-编解码器" class="headerlink" title="1.2.5. 编解码器"></a>1.2.5. 编解码器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-web-handler-api">与 Spring MVC 相同</a></p>
<p><code>spring-web</code>和<code>spring-core</code>模块支持使用 Reactive Streams 背压通过 non-blocking I/O 序列化和反序列化高级 level objects 的字节内容。以下描述了这种支持：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/codec/Encoder.html">编码器</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/codec/Decoder.html">解码器</a>是低 level contracts 来编码和解码独立于 HTTP 的内容。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageReader.html">HttpMessageReader</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/codec/HttpMessageWriter.html">HttpMessageWriter</a>是 contracts 来编码和解码 HTTP 消息内容。</li>
<li>可以用<code>EncoderHttpMessageWriter</code>包装以使其适用于 web application，而<code>Decoder</code>可以用<code>DecoderHttpMessageReader</code>包装。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/buffer/DataBuffer.html">DataBuffer</a>抽象不同的字节缓冲区表示(e.g. Netty <code>ByteBuf</code>，<code>java.nio.ByteBuffer</code>，etc.)并且是所有编解码器都可以工作的。有关此 topic 的更多信息，请参阅“Spring Core”部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-config">数据缓冲区和编解码器</a>。</li>
</ul>
<p><code>spring-core</code>模块提供<code>byte[]</code>，<code>ByteBuffer</code>，<code>DataBuffer</code>，<code>Resource</code>和<code>String</code>编码器和解码器 implementations。 <code>spring-web</code>模块提供 Jackson JSON，Jackson Smile，JAXB2，Protocol Buffers 和其他编码器和解码器以及 web-only HTTP message reader 和 writer implementations，用于表单数据，multipart 内容，server-sent events 等。</p>
<p><code>ClientCodecConfigurer</code>和<code>ServerCodecConfigurer</code>通常用于配置和自定义要在 application 中使用的编解码器。请参阅有关配置<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config">HTTP 消息编解码器</a>的部分。</p>
<h5 id="Jackson-JSON"><a href="#Jackson-JSON" class="headerlink" title="Jackson JSON"></a>Jackson JSON</h5><p>当 Jackson library 存在时，都支持 JSON 和二进制 JSON(<a target="_blank" rel="noopener" href="https://github.com/FasterXML/smile-format-specification">微笑</a>)。</p>
<p><code>Jackson2Decoder</code>的工作原理如下：</p>
<ul>
<li>Jackson 的异步，non-blocking 解析器用于将字节块流聚合到<code>TokenBuffer</code>中，每个字节块代表一个 JSON object。</li>
<li>每个<code>TokenBuffer</code>都传递给 Jackson 的<code>ObjectMapper</code>以创建更高的 level object。</li>
<li>解码到 single-value 发布者(e.g. <code>Mono</code>)时，有一个<code>TokenBuffer</code>。</li>
<li>当解码为 multi-value 发布者(e.g. <code>Flux</code>)时，只要收到完全形成的 object 的足够字节，每个<code>TokenBuffer</code>就会传递给<code>ObjectMapper</code>。输入内容可以是 JSON array，如果 content-type 是“application/stream json”，则为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a>。</li>
</ul>
<p><code>Jackson2Encoder</code>的工作原理如下：</p>
<ul>
<li>对于单个 value 发布者(e.g. <code>Mono</code>)，只需通过<code>ObjectMapper</code>序列化它。</li>
<li>对于具有“application/json”的 multi-value 发布者，默认情况下使用<code>Flux#collectToList()</code>收集值，然后序列化生成的集合。</li>
<li>对于具有流媒体类型(如<code>application/stream+json</code>或<code>application/stream+x-jackson-smile</code>)的 multi-value 发布者，使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JSON_streaming">line-delimited JSON</a>格式单独编码，写入和刷新每个 value。</li>
<li>对于 SSE，每 event 调用<code>Jackson2Encoder</code>并刷新输出以确保无延迟地传递。</li>
</ul>
<blockquote>
<p>默认情况下，<code>Jackson2Encoder</code>和<code>Jackson2Decoder</code>都不支持<code>String</code>类型的元素。相反，默认假设是 string 或 strings 序列表示由<code>CharSequenceEncoder</code>呈现的序列化 JSON 内容。如果您需要从<code>Flux&lt;String&gt;</code>渲染 JSON array，请使用<code>Flux#collectToList()</code>并编码<code>Mono&lt;List&lt;String&gt;&gt;</code>。</p>
</blockquote>
<h5 id="表格数据-1"><a href="#表格数据-1" class="headerlink" title="表格数据"></a>表格数据</h5><p><code>FormHttpMessageReader</code>和<code>FormHttpMessageWriter</code>支持解码和编码“application/x-www-form-urlencoded”内容。</p>
<p>在通常需要从多个位置访问表单内容的服务器端，<code>ServerWebExchange</code>提供了一个专用的<code>getFormData()</code>方法，该方法通过<code>FormHttpMessageReader</code>解析内容，然后缓存结果以便重复访问。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#rest-message-conversion">WebHandler API</a>部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#databuffers">表格数据</a>。</p>
<p>使用<code>getFormData()</code>后，将无法再从请求正文中读取原始原始内容。出于这个原因，预期应用程序将始终通过<code>ServerWebExchange</code>来访问缓存的表单数据，而不是从原始请求正文中读取。</p>
<h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h5><p><code>MultipartHttpMessageReader</code>和<code>MultipartHttpMessageWriter</code>支持解码和编码“multipart/form-data”内容。反过来<code>MultipartHttpMessageReader</code>委托给另一个<code>HttpMessageReader</code>实际解析为<code>Flux&lt;Part&gt;</code>然后简单地将部分收集到<code>MultiValueMap</code>。目前<a target="_blank" rel="noopener" href="https://github.com/synchronoss/nio-multipart">Synchronoss NIO Multipart</a>用于实际解析。</p>
<p>在可能需要从多个位置访问 multipart 表单内容的服务器端，<code>ServerWebExchange</code>提供了一个专用的<code>getMultipartData()</code>方法，该方法通过<code>MultipartHttpMessageReader</code>解析内容，然后缓存结果以便重复访问。请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-message-codecs">WebHandler API</a>部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-form-data">Multipart 数据</a>。</p>
<p>使用<code>getMultipartData()</code>后，将无法再从请求正文中读取原始原始内容。出于这个原因，applications 必须始终使用<code>getMultipartData()</code>重复，map-like 访问部分，或者依赖<code>SynchronossPartHttpMessageReader</code>来</p>
<h5 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-web-handler-api">与 Spring MVC 相同</a></p>
<p>当流式传输到 HTTP 响应时(对于 example，<code>text/event-stream</code>，<code>application/stream+json</code>)，定期发送数据非常重要，以便可以更快地可靠地检测断开的客户端。这样的发送可以是 comment-only，空的 SSE event 或任何其他有效充当心跳的“no-op”数据。</p>
<h5 id="DataBuffer"><a href="#DataBuffer" class="headerlink" title="DataBuffer"></a>DataBuffer</h5><p><code>DataBuffer</code>是 WebFlux 中字节缓冲区的表示。 reference 的 Spring 核心部分在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-multipart">数据缓冲区和编解码器</a>部分有更多内容。要理解的 key 要点是在像 Netty 这样的服务器上，字节缓冲区被池化并且 reference 计数，并且必须在被消耗时释放以避免 memory 泄漏。</p>
<p>WebFlux applications 通常不需要关心这些问题，除非它们直接使用或生成数据缓冲区，而不是依赖于编解码器与更高级别的 objects 进行转换。或者除非他们选择创建自定义编解码器。对于此类情况，请查看<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-web-handler-api">数据缓冲区和编解码器</a>中的信息，尤其是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-async-http-streaming">使用 DataBuffer</a>部分。</p>
<h4 id="1-2-6-Logging"><a href="#1-2-6-Logging" class="headerlink" title="1.2.6. Logging"></a>1.2.6. Logging</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#databuffers">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 中的 DEBUG level logging 设计为紧凑，最小和 human-friendly。它侧重于高 value 位信息，这些信息对于仅在调试特定问题时有用的其他信息一次又一次有用。</p>
<p>TRACE level logging 通常遵循与 DEBUG 相同的原则(对于 example 也不应该是一个 firehose)，但可以用于调试任何问题。此外，一些 log 消息可能在 TRACE vs DEBUG 中显示不同的 level 细节。</p>
<p>好 logging 来自使用日志的经验。如果您发现任何不符合既定目标的事件，请告诉我们。</p>
<h5 id="Log-Id"><a href="#Log-Id" class="headerlink" title="Log Id"></a>Log Id</h5><p>在 WebFlux 中，可以在多个线程上执行单个请求，并且线程 ID 对于关联属于特定请求的 log 消息没有用。这就是为什么 WebFlux log 消息默认以 request-specific ID 为前缀。</p>
<p>在服务器端，log ID 存储在<code>ServerWebExchange</code>属性(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/server/ServerWebExchange.html#databuffers">LOG_ID_ATTRIBUTE</a>)中，而基于该 ID 的完全格式化的前缀可从<code>ServerWebExchange#getLogPrefix()</code>获得。在<code>WebClient</code>侧，log ID 存储在<code>ClientRequest</code>属性(<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/function/client/ClientRequest.html#databuffers-using">LOG_ID_ATTRIBUTE</a>)中，而完全格式化的前缀可从<code>ClientRequest#logPrefix()</code>获得。</p>
<h5 id="敏感数据"><a href="#敏感数据" class="headerlink" title="敏感数据"></a>敏感数据</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-logging">与 Spring MVC 相同</a></p>
<p><code>DEBUG</code>和<code>TRACE</code> logging 可以 log 敏感信息。这就是默认情况下屏蔽表单参数和 headers 的原因，您必须完全显式启用它们的 logging。</p>
<p>followig example 显示了如何为 server-side 请求执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">class MyConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) &#123;</span><br><span class="line">        configurer.defaultCodecs().enableLoggingRequestDetails(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何为 client-side 请求执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;ClientCodecConfigurer&gt; consumer &#x3D; configurer -&gt;</span><br><span class="line">        configurer.defaultCodecs().enableLoggingRequestDetails(true);</span><br><span class="line"></span><br><span class="line">WebClient webClient &#x3D; WebClient.builder()</span><br><span class="line">        .exchangeStrategies(ExchangeStrategies.builder().codecs(consumer).build())</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<h3 id="1-3-DispatcherHandler"><a href="#1-3-DispatcherHandler" class="headerlink" title="1.3. DispatcherHandler"></a>1.3. DispatcherHandler</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#LOG_ID_ATTRIBUTE">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 与 Spring MVC 类似，是围绕前端控制器 pattern 设计的，其中中心<code>WebHandler</code>，<code>DispatcherHandler</code>为请求处理提供了共享算法，而实际工作则由可配置的委托组件执行。这个 model 非常灵活，支持各种工作流程。</p>
<p><code>DispatcherHandler</code>从 Spring configuration 中发现它需要的委托组件。它也被设计为 Spring bean 本身，并实现<code>ApplicationContextAware</code>以访问运行它的 context。如果声明的</p>
<p>WebFlux application 中的 Spring configuration 通常包含：</p>
<ul>
<li><code>DispatcherHandler</code>与 bean name，<code>webHandler</code></li>
<li><code>WebFilter</code>和<code>WebExceptionHandler</code> beans</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#LOG_ID_ATTRIBUTE">DispatcherHandler 特殊 beans</a></li>
<li>其他</li>
</ul>
<p>_conf赋予<code>WebHttpHandlerBuilder</code>以 build 处理链，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context &#x3D; ...</span><br><span class="line">HttpHandler handler &#x3D; WebHttpHandlerBuilder.applicationContext(context);</span><br></pre></td></tr></table></figure>

<p>结果<code>HttpHandler</code>准备好与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-logging-sensitive-data">服务器适配器</a>一起使用。</p>
<h4 id="1-3-1-特殊的-Bean-类型"><a href="#1-3-1-特殊的-Bean-类型" class="headerlink" title="1.3.1. 特殊的 Bean 类型"></a>1.3.1. 特殊的 Bean 类型</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet">与 Spring MVC 相同</a></p>
<p><code>DispatcherHandler</code>委托特殊的 beans 来处理请求并呈现适当的响应。 “special beans”是指实现 WebFlux framework contracts 的 Spring-managed <code>Object</code>实例。那些通常带有 built-in contracts，但您可以自定义它们的 properties，扩展它们或替换它们。</p>
<p>以下 table lists 列出<code>DispatcherHandler</code>检测到的特殊 beans。请注意，在较低的 level 处还检测到一些其他 beans(请参阅 Web Handler API 中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api">特殊的 bean 类型</a>)。</p>
<table>
<thead>
<tr>
<th>Bean 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>HandlerMapping</code></td>
<td>将请求映射到处理程序。映射基于某些标准，其详细信息因<code>HandlerMapping</code> implementation - 带注释的控制器，简单的 URL pattern 映射等而异。 主<code>HandlerMapping</code> __mplement 为<code>RequestMappingHandlerMapping</code>用于<code>@RequestMapping</code>注释方法，<code>RouterFunctionMapping</code>用于功能端点 routes，<code>SimpleUrlHandlerMapping</code>用于显式注册 URI 路径模式和<code>WebHandler</code>实例。</td>
</tr>
<tr>
<td><code>HandlerAdapter</code></td>
<td>无论实际调用处理程序如何，都帮助<code>DispatcherHandler</code>调用映射到请求的处理程序。例如，调用带注释的控制器需要解析 annotations。 <code>HandlerAdapter</code>的主要目的是保护<code>DispatcherHandler</code>免受这些细节的影响。</td>
</tr>
<tr>
<td><code>HandlerResultHandler</code></td>
<td>处理处理程序调用的结果并完成响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-special-bean-types">结果处理</a>。</td>
</tr>
</tbody></table>
<h4 id="1-3-2-WebFlux-配置"><a href="#1-3-2-WebFlux-配置" class="headerlink" title="1.3.2. WebFlux 配置"></a>1.3.2. WebFlux 配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-httphandler">与 Spring MVC 相同</a></p>
<p>Applications 可以声明 process 请求所需的基础结构 beans(列在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-servlet-special-bean-types">Web Handler API</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api-special-beans">DispatcherHandler</a>下)。但是，在大多数情况下，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-resulthandling">WebFlux 配置</a>是最好的起点。它声明了所需的 beans 并提供了一个 higher-level configuration 回调 API 来自定义它。</p>
<blockquote>
<p>Spring Boot 依赖于 WebFlux 配置来配置 Spring WebFlux，还提供了许多额外的方便选项。</p>
</blockquote>
<h4 id="1-3-3-处理"><a href="#1-3-3-处理" class="headerlink" title="1.3.3. 处理"></a>1.3.3. 处理</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet-config">与 Spring MVC 相同</a></p>
<p><code>DispatcherHandler</code>处理请求如下：</p>
<ul>
<li>要求每个<code>HandlerMapping</code>找到匹配的处理程序，并使用第一个 match。</li>
<li>如果找到一个处理程序，它将通过适当的<code>HandlerAdapter</code>执行，它将 return value 从执行中公开为<code>HandlerResult</code>。</li>
<li>通过直接写入响应或使用视图进行渲染，<code>HandlerResult</code>被赋予适当的<code>HandlerResultHandler</code>以完成处理。</li>
</ul>
<h4 id="1-3-4-结果处理"><a href="#1-3-4-结果处理" class="headerlink" title="1.3.4. 结果处理"></a>1.3.4. 结果处理</h4><p>从处理程序的调用到<code>HandlerAdapter</code>的 return value 被包装为<code>HandlerResult</code>，以及一些额外的 context，并传递给声称支持它的第一个<code>HandlerResultHandler</code>。以下 table 显示了可用的<code>HandlerResultHandler</code> __mplementations，所有这些都在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-web-handler-api-special-beans">WebFlux 配置</a>中声明：</p>
<table>
<thead>
<tr>
<th>结果处理程序类型</th>
<th>Return 值</th>
<th>默认 Order</th>
</tr>
</thead>
<tbody><tr>
<td><code>ResponseEntityResultHandler</code></td>
<td><code>ResponseEntity</code>，通常来自<code>@Controller</code>个实例。</td>
<td>0</td>
</tr>
<tr>
<td><code>ServerResponseResultHandler</code></td>
<td><code>ServerResponse</code>，通常来自功能 endpoints。</td>
<td>0</td>
</tr>
<tr>
<td><code>ResponseBodyResultHandler</code></td>
<td>处理<code>@ResponseBody</code>方法或<code>@RestController</code> classes 中的 return 值。</td>
<td>100</td>
</tr>
<tr>
<td><code>ViewResolutionResultHandler</code></td>
<td><code>CharSequence</code>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/View.html">视图</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/ui/Model.html">模型</a>，<code>Map</code>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a>或任何其他<code>Object</code>被视为 model 属性。 另见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-special-bean-types">查看分辨率</a>。</td>
<td><code>Integer.MAX_VALUE</code></td>
</tr>
</tbody></table>
<h4 id="1-3-5-Exceptions"><a href="#1-3-5-Exceptions" class="headerlink" title="1.3.5. Exceptions"></a>1.3.5. Exceptions</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config">与 Spring MVC 相同</a></p>
<p>从<code>HandlerAdapter</code>返回的<code>HandlerResult</code>可以基于某些 handler-specific 机制公开函数以进行错误处理。在以下情况下调用此错误 function：</p>
<ul>
<li>处理程序(用于 example，<code>@Controller</code>)调用失败。</li>
<li>通过<code>HandlerResultHandler</code>处理处理程序 return value 失败。</li>
</ul>
<p>错误 function 可以将响应(对于 example，更改为错误状态)更改为 long，因为错误信号发生在从处理程序返回的 reactive 类型生成任何数据项之前。</p>
<p>这是<code>@Controller</code> classes 中<code>@ExceptionHandler</code>方法的支持方式。相比之下，Spring MVC 中对它的支持是建立在<code>HandlerExceptionResolver</code>上的。这通常无关紧要。但是，请记住，在 WebFlux 中，您不能使用<code>@ControllerAdvice</code>来处理在选择处理程序之前发生的 exceptions。</p>
<p>另请参阅“Annotated Controller”部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-servlet-sequence">管理 Exceptions</a>或 WebHandler API 部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config">Exceptions</a>。</p>
<h4 id="1-3-6-查看分辨率"><a href="#1-3-6-查看分辨率" class="headerlink" title="1.3.6. 查看分辨率"></a>1.3.6. 查看分辨率</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-viewresolution">与 Spring MVC 相同</a></p>
<p>视图分辨率允许使用 HTML 模板和 model 呈现给浏览器，而无需将您与特定的视图技术联系起来。在 Spring WebFlux 中，视图解析通过专用的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-exceptionhandlers">HandlerResultHandler</a>支持，该<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-controller-exceptions">HandlerResultHandler</a>使用<code>ViewResolver</code>实例将 String(表示逻辑视图 name)map 映射到<code>View</code>实例。然后使用<code>View</code>来呈现响应。</p>
<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-exception-handler">与 Spring MVC 相同</a></p>
<p>传递给<code>ViewResolutionResultHandler</code>的<code>HandlerResult</code>包含来自处理程序的 return value 和包含在请求处理期间添加的属性的 model。 return value 将作为以下之一处理：</p>
<ul>
<li><code>String</code>，<code>CharSequence</code>：要通过已配置的<code>ViewResolver</code> __mplement 列表解析为<code>View</code>的逻辑视图 name。</li>
<li><code>void</code>：根据请求路径选择默认视图 name，减去前导和尾部斜杠，并将其解析为<code>View</code>。如果未提供视图 name(对于 example，返回 model 属性)或 async return value(对于 example，<code>Mono</code>已完成为空)，也会发生相同的情况。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/Rendering.html">渲染</a>：用于视图解析方案的 API。使用 code 完成浏览 IDE 中的选项。</li>
<li><code>Model</code>，<code>Map</code>：要添加到请求的 model 的额外 model 属性。</li>
<li>任何其他：任何其他 return value(由简单类型除外，由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-viewresolver">BeanUtils 的#isSimpleProperty</a>确定)被视为要添加到 model 的 model 属性。除非存在处理程序方法<code>@ModelAttribute</code> annotation，否则属性 name 是使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html">公约</a>从 class name 派生的。</li>
</ul>
<p>model 可以包含异步，reactive 类型(对于 example，来自 Reactor 或 RxJava)。在渲染之前，<code>AbstractView</code>将此类 model 属性解析为具体值并更新 model。 Single-value reactive 类型被解析为单个 value 或没有 value(如果为空)，而 multi-value reactive 类型(对于 example，<code>Flux&lt;T&gt;</code>)被收集并解析为<code>List&lt;T&gt;</code>。</p>
<p>配置视图分辨率就像在 Spring configuration 中添加<code>ViewResolutionResultHandler</code> bean 一样简单。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-resulthandling">WebFlux 配置</a>提供专用的 configuration API 以进行视图分辨率。</p>
<p>有关与 Spring WebFlux 集成的视图技术的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-handling">查看技术</a>。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#isSimpleProperty-java.lang.Class-">与 Spring MVC 相同</a></p>
<p>视图 name 中的特殊<code>redirect:</code>前缀允许您执行重定向。 <code>UrlBasedViewResolver</code>(和 sub-classes)将此识别为需要重定向的指令。视图 name 的 rest 是重定向 URL。</p>
<p>净效果与控制器返回<code>RedirectView</code>或<code>Rendering.redirectTo(&quot;abc&quot;).build()</code>相同，但现在控制器本身可以按逻辑视图名称操作。视图 name(例如<code>redirect:/some/resource</code>)与当前 application 相关，而视图 name(例如<code>redirect:http://example.com/arbitrary/path</code>)重定向到绝对 URL。</p>
<h5 id="内容谈判"><a href="#内容谈判" class="headerlink" title="内容谈判"></a>内容谈判</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-view-resolvers">与 Spring MVC 相同</a></p>
<p><code>ViewResolutionResultHandler</code>支持内容 negotiation。它将请求媒体类型与每个选定的<code>View</code>支持的媒体类型进行比较。使用支持所请求媒体 type(s 的第一个<code>View</code>。</p>
<p>在 order 中支持 JSON 和 XML 等媒体类型，Spring WebFlux 提供<code>HttpMessageWriterView</code>，这是一个特殊的<code>View</code>，通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view">HttpMessageWriter</a>呈现。通常，您可以通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-redirecting-redirect-prefix">WebFlux Configuration</a>将它们配置为默认视图。如果它们匹配所请求的媒体类型，则始终选择并使用默认视图。</p>
<h3 id="1-4-带注释的控制器"><a href="#1-4-带注释的控制器" class="headerlink" title="1.4. 带注释的控制器"></a>1.4. 带注释的控制器</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multiple-representations">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 提供 annotation-based 编程 model，其中<code>@Controller</code>和<code>@RestController</code>组件使用 annotations 来表达请求映射，请求输入，处理 exceptions 等。带注释的控制器具有灵活的方法签名，不必扩展 base classes，也不必实现特定的接口。</p>
<p>以下清单显示了一个基本的 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String handle() &#123;</span><br><span class="line">        return &quot;Hello WebFlux&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的 example 中，该方法返回一个<code>String</code>以写入响应主体。</p>
<h4 id="1-4-1-Controller"><a href="#1-4-1-Controller" class="headerlink" title="1.4.1. @Controller"></a>1.4.1. @Controller</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-codecs">与 Spring MVC 相同</a></p>
<p>您可以使用标准的 Spring bean 定义来定义 controller beans。 <code>@Controller</code>构造型允许 auto-detection 并与 Spring 一般支持对齐，以检测 classpath 中的<code>@Component</code> classes 和 auto-registering bean 定义。它还充当带注释的 class 的构造型，表明它作为 web component 的角色。</p>
<p>要启用 auto-detection 这样的<code>@Controller</code> beans，可以将 component 扫描添加到 Java configuration 中，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;org.example.web&quot;) (1)</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>扫描<code>org.example.web</code>包。</td>
</tr>
</tbody></table>
<p><code>@RestController</code>是一个<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-config-view-resolvers">撰写 annotation</a>本身 meta-annotated，<code>@Controller</code>和<code>@ResponseBody</code>，表示一个控制器，其每个方法都继承 type-level <code>@ResponseBody</code> 注释，因此，直接写入响应主体，而不是视图分辨率，并使用 HTML 模板进行渲染。</p>
<h4 id="1-4-2-请求映射"><a href="#1-4-2-请求映射" class="headerlink" title="1.4.2. 请求映射"></a>1.4.2. 请求映射</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-controller">与 Spring MVC 相同</a></p>
<p><code>@RequestMapping</code> annotation 用于 map 对控制器方法的请求。它具有 match 的各种属性，包括 URL，HTTP 方法，请求参数，headers 和媒体类型。您可以在 class level 中使用它来表示共享映射，或者在方法 level 中使用它来缩小到特定的端点映射。</p>
<p>还有<code>@RequestMapping</code>的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>前面提到的注释是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-controller">自定义注释</a>，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。在同一 time，class level 仍然需要<code>@RequestMapping</code>来表示共享映射。</p>
<p>以下 example 使用类型和方法 level 映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;persons&quot;)</span><br><span class="line">class PersonController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Person getPerson(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    @ResponseStatus(HttpStatus.CREATED)</span><br><span class="line">    public void add(@RequestBody Person person) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="URI-模式"><a href="#URI-模式" class="headerlink" title="URI 模式"></a>URI 模式</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-meta-annotations">与 Spring MVC 相同</a></p>
<p>您可以使用 glob 模式和通配符 map 请求：</p>
<ul>
<li><code>?</code>匹配一个字符</li>
<li><code>*</code>匹配路径段中的零个或多个字符</li>
<li><code>**</code> 匹配零个或多个路径段</li>
</ul>
<p>您还可以声明 URI 变量并使用<code>@PathVariable</code>访问它们的值，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在 class 和方法级别声明 URI 变量，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;) (1)</span><br><span class="line">public class OwnerController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;) (2)</span><br><span class="line">    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>Class-level URI 映射。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Method-level URI 映射。</td>
</tr>
</tbody></table>
<p>URI 变量会自动转换为适当的类型，或者引发<code>TypeMismatchException</code>。默认情况下支持简单类型(<code>int</code>，<code>long</code>，<code>Date</code>等)，您可以注册对任何其他数据类型的支持。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestmapping">类型转换</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestmapping-composed">DataBinder</a>。</p>
<p>URI 变量可以显式命名(对于 example，<code>@PathVariable(&quot;customId&quot;)</code>)，但是如果名称相同则可以保留该详细信息，并使用调试信息或使用 Java 8 上的<code>-parameters</code>编译器 flag 编译 code。</p>
<p>语法<code>&#123;*varName&#125;</code>声明一个 URI 变量，该变量匹配零个或多个剩余路径段。对于 example <code>/resources/&#123;*path&#125;</code>匹配所有 files <code>/resources/</code>，<code>&quot;path&quot;</code>变量捕获完整的相对路径。</p>
<p>语法<code>&#123;varName:regex&#125;</code>声明了一个 URI 变量，其正则表达式的语法为：<code>&#123;varName:regex&#125;</code>。对于 example，给定<code>/spring-web-3.0.5 .jar</code>的 URL，以下方法将提取 name，version 和文件扩展名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;&quot;)</span><br><span class="line">public void handle(@PathVariable String version, @PathVariable String ext) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>URI 路径模式还可以嵌入<code>$&#123;…&#125;</code>占位符，这些占位符在启动时通过<code>PropertyPlaceHolderConfigurer</code>针对本地，系统，环境和其他 property 源进行解析。例如，您可以使用它来基于某些外部 configuration 参数化基本 URL。</p>
<blockquote>
<p>Spring WebFlux 使用<code>PathPattern</code>和<code>PathPatternParser</code>进行 URI 路径匹配支持。这两个 classes 都位于<code>spring-web</code>中，并且明确设计用于 web applications 中的 HTTP URL paths，其中在运行时匹配大量 URI 路径模式。</p>
</blockquote>
<p>Spring WebFlux 不支持后缀 pattern 匹配 - 与 Spring MVC 不同，其中<code>/person</code>等映射也与<code>/person.*</code>匹配。对于 URL-based content negotiation，如果需要，我们建议使用查询参数，该参数更简单，更明确，并且不易受基于 URL 路径的攻击。</p>
<h5 id="Pattern-比较"><a href="#Pattern-比较" class="headerlink" title="Pattern 比较"></a>Pattern 比较</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-uri-templates">与 Spring MVC 相同</a></p>
<p>当多个模式匹配 URL 时，必须对它们进行比较以找到最佳的 match。这是通过<code>PathPattern.SPECIFICITY_COMPARATOR</code>完成的，它会查找更具体的模式。</p>
<p>对于每个 pattern，根据 URI 变量和通配符的数量计算得分，其中 URI 变量得分低于通配符。总得分较低的 pattern 获胜。如果两个模式具有相同的分数，则选择的时间越长。</p>
<p>Catch-all 个模式(对于 example，<code>**</code>，<code>&#123;*varName&#125;</code>)将从评分中排除，并始终排在最后。如果两个模式都是 catch-all，则选择的时间越长。</p>
<h5 id="耗材介质类型"><a href="#耗材介质类型" class="headerlink" title="耗材介质类型"></a>耗材介质类型</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-typeconversion">与 Spring MVC 相同</a></p>
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(path &#x3D; &quot;&#x2F;pets&quot;, consumes &#x3D; &quot;application&#x2F;json&quot;)</span><br><span class="line">public void addPet(@RequestBody Pet pet) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>consumemes 属性还支持否定表达式 - 对于 example，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何 content type。</p>
<p>您可以在 class level 声明共享的<code>consumes</code>属性。但是，与大多数其他请求映射属性不同，当在 class level 中使用时，method-level <code>consumes</code>属性会覆盖而不是扩展 class-level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量 - 对于 example，<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h5 id="可生产的媒体类型"><a href="#可生产的媒体类型" class="headerlink" title="可生产的媒体类型"></a>可生产的媒体类型</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-initbinder">与 Spring MVC 相同</a></p>
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表缩小请求映射，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path &#x3D; &quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;, produces &#x3D; &quot;application&#x2F;json;charset&#x3D;UTF-8&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Pet getPet(@PathVariable String petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>媒体类型可以指定字符集。支持否定表达式 - 例如，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何 content type。</p>
<blockquote>
<p>对于 JSON content type，即使<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7159#mvc-ann-requestmapping-pattern-comparison">RFC7159</a>明确指出“没有为此注册定义 charset 参数”，也应指定 UTF-8 <code>charset</code>，因为某些浏览器要求它正确解释 UTF-8 特殊字符。</p>
</blockquote>
<p>您可以在 class level 声明共享的<code>produces</code>属性。但是，与大多数其他请求映射属性不同，当在 class level 中使用时，method-level <code>produces</code>属性会覆盖而不是扩展 class level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量 - e.g. <code>APPLICATION_JSON_UTF8_VALUE</code>，<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h5 id="参数和-Headers"><a href="#参数和-Headers" class="headerlink" title="参数和 Headers"></a>参数和 Headers</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-consumes">与 Spring MVC 相同</a></p>
<p>您可以根据查询参数条件缩小请求映射。您可以测试是否存在查询参数(<code>myParam</code>)，缺少(<code>!myParam</code>)或特定 value(<code>myParam=myValue</code>)。以下示例测试带有 value 的参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path &#x3D; &quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;, params &#x3D; &quot;myParam&#x3D;myValue&quot;) (1)</span><br><span class="line">public void findPet(@PathVariable String petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>检查<code>myParam</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody></table>
<p>您也可以使用相同的请求标头条件，如下面的 example 显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path &#x3D; &quot;&#x2F;pets&quot;, headers &#x3D; &quot;myHeader&#x3D;myValue&quot;) (1)</span><br><span class="line">public void findPet(@PathVariable String petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>检查<code>myHeader</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody></table>
<h5 id="HTTP-HEAD，OPTIONS"><a href="#HTTP-HEAD，OPTIONS" class="headerlink" title="HTTP HEAD，OPTIONS"></a>HTTP HEAD，OPTIONS</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-produces">与 Spring MVC 相同</a></p>
<p><code>@GetMapping</code>和<code>@RequestMapping(method=HttpMethod.GET)</code>透明地支持 HTTP HEAD 以进行请求映射。控制器方法无需更改。应用于<code>HttpHandler</code>服务器适配器的响应 wrapper 确保将<code>Content-Length</code>标头设置为写入的字节数，而不实际写入响应。</p>
<p>默认情况下，通过将<code>Allow</code>响应标头设置为具有匹配 URL 模式的所有<code>@RequestMapping</code>方法中列出的 HTTP 方法列表来处理 HTTP OPTIONS。</p>
<p>对于没有 HTTP 方法声明的<code>@RequestMapping</code>，<code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。控制器方法应始终声明支持的 HTTP 方法(对于 example，使用 HTTP 方法特定的变体 - <code>@GetMapping</code>，<code>@PostMapping</code>等)。</p>
<p>您可以将<code>@RequestMapping</code>方法显式 map 到 HTTP HEAD 和 HTTP OPTIONS，但在 common 情况下这不是必需的。</p>
<h5 id="自定义注释"><a href="#自定义注释" class="headerlink" title="自定义注释"></a>自定义注释</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#section-11">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 支持使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-requestmapping-params-and-headers">撰写注释</a>进行请求映射。这些是注释本身 meta-annotated 与<code>@RequestMapping</code>并且用于重新声明<code>@RequestMapping</code>属性的子集(或全部)以及更窄，更具体的目的。</p>
<p><code>@GetMapping</code>，<code>@PostMapping</code>，<code>@PutMapping</code>，<code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。它们是提供的，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。如果您需要_notample of annotations，请查看如何声明它们。</p>
<p>Spring WebFlux 还支持具有自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要 sub-classing <code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并 return 您自己的<code>RequestCondition</code>。</p>
<h5 id="明确注册"><a href="#明确注册" class="headerlink" title="明确注册"></a>明确注册</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-head-options">与 Spring MVC 相同</a></p>
<p>您可以以编程方式注册 Handler 方法，这些方法可用于动态注册或高级案例，例如不同 URL 下的同一处理程序的不同实例。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) (1)</span><br><span class="line">            throws NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        RequestMappingInfo info &#x3D; RequestMappingInfo</span><br><span class="line">                .paths(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;).methods(RequestMethod.GET).build(); (2)</span><br><span class="line"></span><br><span class="line">        Method method &#x3D; UserHandler.class.getMethod(&quot;getUser&quot;, Long.class); (3)</span><br><span class="line"></span><br><span class="line">        mapping.registerMapping(info, handler, method); (4)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>Inject 目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>准备请求映射元数据。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>添加注册。</td>
</tr>
</tbody></table>
<h4 id="1-4-3-处理程序方法"><a href="#1-4-3-处理程序方法" class="headerlink" title="1.4.3. 处理程序方法"></a>1.4.3. 处理程序方法</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-composed">与 Spring MVC 相同</a></p>
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从一系列受支持的控制器方法 arguments 和 return 值中进行选择。</p>
<h5 id="方法-Arguments"><a href="#方法-Arguments" class="headerlink" title="方法 Arguments"></a>方法 Arguments</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#beans-meta-annotations">与 Spring MVC 相同</a></p>
<p>以下 table 显示支持的控制器方法 arguments。</p>
<p>arguments 支持 Reactive 类型(Reactor，RxJava，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestmapping-registration">或其他</a>)，需要阻塞 I/O(对于 example，读取请求主体)才能解析。这在“描述”列中标记。 活动类型不适用于不需要阻止的 arguments。</p>
<p>JDK 1.8 的<code>java.util.Optional</code>作为方法参数与 annotations 一起被支持，该注释具有<code>required</code>属性(对于 example，<code>@RequestParam</code>，<code>@RequestHeader</code>和其他)并且等同于<code>required=false</code>。</p>
<table>
<thead>
<tr>
<th>控制器方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ServerWebExchange</code></td>
<td>访问 HTTP 请求和响应，请求和 session 属性，<code>checkNotModified</code>方法等的完整<code>ServerWebExchange</code> - 容器。</td>
</tr>
<tr>
<td><code>ServerHttpRequest</code> , <code>ServerHttpResponse</code></td>
<td>访问 HTTP 请求或响应。</td>
</tr>
<tr>
<td><code>WebSession</code></td>
<td>访问 session。除非添加属性，否则这不会强制启动新的 session。支持 reactive 类型。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>当前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code> implementation class。支持 reactive 类型。</td>
</tr>
<tr>
<td><code>org.springframework.http.HttpMethod</code></td>
<td>请求的 HTTP 方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求 locale，由最具体的<code>LocaleResolver</code>可用 - 确定 - 生效，配置为<code>LocaleResolver</code>/<code>LocaleContextResolver</code>。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td>与当前请求关联的 time zone，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问 URI 模板变量。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-methods">URI 模式</a>。</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td>用于访问 URI 路径段中的 name-value 对。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-arguments">矩阵变量</a>。</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数。参数值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">@RequestParam</a>。 请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。请参阅本 table 后面的“任何其他参数”。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求 headers。标头值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestmapping-uri-templates">@RequestHeader</a>。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>访问 cookies。 Cookie 值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-matrix-variables">@CookieValue</a>。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求正文。使用<code>HttpMessageReader</code>实例将正文内容转换为声明的方法参数类型。支持 reactive 类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestparam">@RequestBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td>用于访问请求 headers 和 body。正文用<code>HttpMessageReader</code>实例转换。支持 reactive 类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestheader">HttpEntity</a>。</td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>用于访问<code>multipart/form-data</code>请求中的部分。支持 reactive 类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-cookievalue">Multipart Content</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestbody">Multipart 数据</a>。</td>
</tr>
<tr>
<td><code>java.util.Map</code>，<code>org.springframework.ui.Model</code>和<code>org.springframework.ui.ModelMap</code>。</td>
<td>用于访问 HTML 控制器中使用的 model，并作为视图呈现的一部分向模板公开。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>用于访问 model 中的现有属性(如果不存在则实例化)，并应用数据 binding 和验证。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-httpentity">@ModelAttribute</a>以及<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-multipart-forms">模型</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-multipart">DataBinder</a>。 请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。请参阅本 table 后面的“任何其他参数”。</td>
</tr>
<tr>
<td><code>Errors</code> , <code>BindingResult</code></td>
<td>用于从命令 object(即<code>@ModelAttribute</code>参数)的验证和数据 binding 访问错误或从验证<code>@RequestBody</code>或<code>@RequestPart</code>参数的错误。必须在经过验证的方法参数之后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td>
</tr>
<tr>
<td><code>SessionStatus</code> class-level <code>@SessionAttributes</code></td>
<td>用于标记表单处理完成，它触发通过 class-level <code>@SessionAttributes</code> 注释声明的 session 属性的清除。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-modelattrib-method-args">@SessionAttributes</a>。</td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td>用于准备相对于当前请求的 host， port，scheme 和 path 的 URL。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-modelattrib-methods">URI 链接</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何 session 属性 - 与 session 属性存储在 session 中的 model 属性相反。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-initbinder">@SessionAttribute</a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-sessionattributes">@RequestAttribute</a>。</td>
</tr>
<tr>
<td>任何其他论点</td>
<td>如果方法参数与上述任何一个都不匹配，则默认情况下，如果它是一个简单类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-uri-building">BeanUtils 的#isSimpleProperty</a>确定)，则为<code>@RequestParam</code>，否则为<code>@ModelAttribute</code>。</td>
</tr>
</tbody></table>
<h5 id="Return-值"><a href="#Return-值" class="headerlink" title="Return 值"></a>Return 值</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-sessionattribute">与 Spring MVC 相同</a></p>
<p>以下 table 显示支持的控制器方法 return 值。请注意，libraries 中的 reactive 类型(如 Reactor，RxJava，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestattrib">或其他</a>)通常支持所有 return 值。</p>
<table>
<thead>
<tr>
<th>控制器方法 return value</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@ResponseBody</code></td>
<td>return value 通过<code>HttpMessageWriter</code>实例编码并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#isSimpleProperty-java.lang.Class-">@ResponseBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code> , <code>ResponseEntity&lt;B&gt;</code></td>
<td>return value 指定完整响应，包括 HTTP headers，主体通过<code>HttpMessageWriter</code>实例编码并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-return-types">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>HttpHeaders</code></td>
<td>用 headers 返回响应，没有正文。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code>实例解析并与隐式 model 一起使用的视图 name - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(描述为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">前</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>一个<code>View</code>实例，用于与隐式 model 一起呈现 - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(描述为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-responsebody">前</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式 model 的属性，其中 view name 基于请求路径隐式确定。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到 model 的属性，其中 view name 基于请求路径隐式确定。 请注意<code>@ModelAttribute</code>是可选的。请参阅本 table 后面的“任何其他 return value”。</td>
</tr>
<tr>
<td><code>Rendering</code></td>
<td>model 和视图渲染方案的 API。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>具有<code>void</code>，可能是异步(对于 example，<code>Mono&lt;Void&gt;</code>)， return 类型(或<code>null</code> return value)的方法被认为已完全处理了响应，如果它还具有<code>ServerHttpResponse</code>，<code>ServerWebExchange</code>参数或<code>@ResponseStatus</code> 注释。如果控制器进行了正 ETag 或<code>lastModified</code>时间戳检查，则同样也是 true。 // TODO：有关详情，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-responseentity">控制器</a>。 如果上面的 none 是 true，则<code>void</code> return 类型也可以为 REST 控制器指示“无响应主体”或为 HTML 控制器指定默认视图 name 选择。</td>
</tr>
<tr>
<td><code>Flux&lt;ServerSentEvent&gt;</code>，<code>Observable&lt;ServerSentEvent&gt;</code>或其他 reactive 类型</td>
<td>发出 server-sent events。当只需要写入数据时，可以省略<code>ServerSentEvent</code> wrapper(但是，必须通过<code>produces</code>属性在映射中请求或声明<code>text/event-stream</code>)。</td>
</tr>
<tr>
<td>任何其他 return value</td>
<td>如果 return value 与上述任何一个都不匹配，则默认情况下，它被视为 view name，如果它是<code>String</code>或<code>void</code>(默认视图 name 选择适用)，或者作为 model 属性添加到 model ，除非它是一个简单的类型，由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-viewresolution-handling">BeanUtils 的#isSimpleProperty</a>确定，在这种情况下它仍然没有得到解决。</td>
</tr>
</tbody></table>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-viewresolution-handling">与 Spring MVC 相同</a></p>
<p>一些带注释的控制器方法 arguments 表示 String-based 请求输入(对于 example，<code>@RequestParam</code>，<code>@RequestHeader</code>，<code>@PathVariable</code>，<code>@MatrixVariable</code>和<code>@CookieValue</code>)，如果参数声明为<code>String</code>以外的其他类型，则可能需要进行类型转换。</p>
<p>对于此类情况，将根据配置的转换器自动应用类型转换。默认情况下，支持简单类型(例如<code>int</code>，<code>long</code>，<code>Date</code>和其他)。可以通过<code>WebDataBinder</code>(参见[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-caching-etag-lastmodified">mvc-ann-initbinder]</a>)或通过<code>FormattingConversionService</code>(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#isSimpleProperty-java.lang.Class-">Spring 字段格式</a>)注册<code>Formatters</code>来自定义类型转换。</p>
<h5 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-typeconversion">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3986#mvc-ann-initbinder">RFC 3986</a>讨论路径段中的 name-value 对。在 Spring WebFlux 中，我们将它们称为基于 Tim Berners-Lee 的<a target="_blank" rel="noopener" href="https://www.w3.org/DesignIssues/MatrixURIs.html">“老帖子”</a>的“矩阵变量”，但它们也可以称为 URI 路径参数。</p>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔 - 对于 example，<code>&quot;/cars;color=red,green;year=2012&quot;</code>。也可以通过重复的变量名来指定多个值 - 对于 example，<code>&quot;color=red;color=green;color=blue&quot;</code>。</p>
<p>与 Spring MVC 不同，在 WebFlux 中，URL 中矩阵变量的存在与否不会影响请求映射。换句话说，您不需要使用 URI 变量来屏蔽变量内容。也就是说，如果要从控制器方法访问矩阵变量，则需要将 URI 变量添加到期望矩阵变量的路径段中。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; petId &#x3D;&#x3D; 42</span><br><span class="line">    &#x2F;&#x2F; q &#x3D;&#x3D; 11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鉴于所有路径段都可以包含矩阵变量，您有时可能需要消除矩阵变量所在的路径变量的歧义，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;owners&#x2F;42;q&#x3D;11&#x2F;pets&#x2F;21;q&#x3D;22</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(</span><br><span class="line">        @MatrixVariable(name&#x3D;&quot;q&quot;, pathVar&#x3D;&quot;ownerId&quot;) int q1,</span><br><span class="line">        @MatrixVariable(name&#x3D;&quot;q&quot;, pathVar&#x3D;&quot;petId&quot;) int q2) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; q1 &#x3D;&#x3D; 11</span><br><span class="line">    &#x2F;&#x2F; q2 &#x3D;&#x3D; 22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以定义矩阵变量，可以将其定义为可选，并指定默认 value，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(@MatrixVariable(required&#x3D;false, defaultValue&#x3D;&quot;1&quot;) int q) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; q &#x3D;&#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要获取所有矩阵变量，请使用<code>MultiValueMap</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;owners&#x2F;42;q&#x3D;11;r&#x3D;12&#x2F;pets&#x2F;21;q&#x3D;22;s&#x3D;23</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(</span><br><span class="line">        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,</span><br><span class="line">        @MatrixVariable(pathVar&#x3D;&quot;petId&quot;&quot;) MultiValueMap&lt;String, String&gt; petMatrixVars) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]</span><br><span class="line">    &#x2F;&#x2F; petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#format">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestParam</code> annotation 将查询参数绑定到控制器中的方法参数。以下 code 代码段显示了用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;pets&quot;)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123; (1)</span><br><span class="line">        Pet pet &#x3D; this.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(&quot;pet&quot;, pet);</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestParam</code>。</td>
</tr>
</tbody></table>
<blockquote>
<p>Servlet API“请求参数”概念将查询参数，表单数据和多部分合并为一个。但是，在 WebFlux 中，每个都通过<code>ServerWebExchange</code>单独访问。虽然<code>@RequestParam</code>仅绑定到查询参数，但您可以使用 data binding 将查询参数，表单数据和多部分应用于<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-matrix-variables">命令 object</a>。</p>
</blockquote>
<p>默认情况下，需要使用<code>@RequestParam</code> annotation 的方法参数，但您可以通过将<code>@RequestParam</code>的 flag 设置为<code>false</code>或通过<code>java.util.Optional</code> wrapper 声明参数来指定方法参数是可选的。</p>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#section-3.3">mvc-ann-typeconversion]</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>参数上声明<code>@RequestParam</code> annotation 时，map 将填充所有查询参数。</p>
<p>请注意，使用<code>@RequestParam</code>是可选的 - 例如，设置其属性。默认情况下，任何属于简单 value 类型的参数(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-ann-requestparam">BeanUtils 的#isSimpleProperty</a>确定)并且未被任何其他参数解析器解析的视图都被视为使用<code>@RequestParam</code>进行注释。</p>
<h5 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-modelattrib-method-args">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestHeader</code> annotation 将请求标头绑定到控制器中的方法参数。</p>
<p>以下 example 显示了带有 headers 的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:8080</span><br><span class="line">Accept                  text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9</span><br><span class="line">Accept-Language         fr,en-gb;q&#x3D;0.7,en;q&#x3D;0.3</span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.7</span><br><span class="line">Keep-Alive              300</span><br></pre></td></tr></table></figure>

<p>以下 example 获取<code>Accept-Encoding</code>和<code>Keep-Alive</code> headers 的 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;demo&quot;)</span><br><span class="line">public void handle(</span><br><span class="line">        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, (1)</span><br><span class="line">        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; (2)</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>获取<code>Accept-Encoging</code>标头的 value。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>获取<code>Keep-Alive</code>标头的 value。</td>
</tr>
</tbody></table>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-typeconversion">mvc-ann-typeconversion]</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>，<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code> annotation 时，map 将填充所有标题值。</p>
<blockquote>
<p>Built-in 支持可用于将 comma-separated string 转换为 array 或 strings 集合或类型转换系统已知的其他类型。对于 example，使用<code>@RequestHeader(&quot;Accept&quot;)</code>注释的方法参数可以是<code>String</code>类型，但也可以是<code>String[]</code>或<code>List&lt;String&gt;</code>。</p>
</blockquote>
<h5 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#isSimpleProperty-java.lang.Class-">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@CookieValue</code> annotation 将 HTTP cookie 的 value 绑定到控制器中的方法参数。</p>
<p>以下 example 显示了一个带有 cookie 的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSESSIONID&#x3D;415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure>

<p>以下 code sample 演示了如何获取 cookie value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;demo&quot;)</span><br><span class="line">public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>获取 cookie value。</td>
</tr>
</tbody></table>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见[<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestheader">mvc-ann-typeconversion]</a>。</p>
<h5 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-typeconversion">与 Spring MVC 相同</a></p>
<p>您可以在方法参数上使用<code>@ModelAttribute</code> annotation 来从 model 访问属性，或者如果不存在则将其实例化。 model 属性还覆盖了查询参数和表单字段的值，其名称为 match 到字段名称。这称为数据 binding，它使您不必处理解析和转换单个查询参数和表单字段。以下 example 绑定<code>Pet</code>的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@ModelAttribute Pet pet) &#123; &#125; (1)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>绑定<code>Pet</code>的实例。</td>
</tr>
</tbody></table>
<p>前面的 example 中的<code>Pet</code>实例解析如下：</p>
<ul>
<li>如果已经通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-cookievalue">模型</a>添加了 model。</li>
<li>从 HTTP session 到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-typeconversion">@SessionAttributes</a>。</li>
<li>从默认构造函数的调用。</li>
<li>从“主构造函数”调用 arguments match 查询参数或表单字段。参数名称通过字节码中的 JavaBeans <code>@ConstructorProperties</code>或 runtime-retained 参数名称确定。</li>
</ul>
<p>获取 model 属性实例后，将应用数据 binding。 <code>WebExchangeDataBinder</code> class 将查询参数和表单字段的名称与目标<code>Object</code>上的字段名称相匹配。在必要时应用类型转换后填充匹配字段。有关数据 binding(和验证)的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-modelattrib-method-args">验证</a>。有关自定义数据 binding 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-modelattrib-methods">DataBinder</a>。</p>
<p>数据绑定可能导致错误。默认情况下，会引发<code>WebExchangeBindException</code>，但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加<code>BindingResult</code>参数，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123; (1)</span><br><span class="line">    if (result.hasErrors()) &#123;</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>添加<code>BindingResult</code>。</td>
</tr>
</tbody></table>
<p>您可以在数据 binding 之后通过添加<code>javax.validation.Valid</code> annotation 或 Spring 的<code>@Validated</code> annotation 自动应用验证(另请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-ann-sessionattributes">Bean 验证</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validation">Spring 验证</a>)。以下 example 使用<code>@Valid</code> annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123; (1)</span><br><span class="line">    if (result.hasErrors()) &#123;</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>在 model 属性参数上使用<code>@Valid</code>。</td>
</tr>
</tbody></table>
<p>与 Spring MVC 不同，Spring WebFlux 支持 model 中的 reactive 类型 - 对于 example，<code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code>。您可以使用或不使用 reactive 类型 wrapper 声明<code>@ModelAttribute</code>参数，并且如果需要，它将相应地解析为实际的 value。但是，请注意，要使用<code>BindingResult</code>参数，必须在没有 reactive 类型 wrapper 的情况下声明<code>@ModelAttribute</code>参数，如前所示。或者，您可以通过 reactive 类型处理任何错误，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public Mono&lt;String&gt; processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Mono&lt;Pet&gt; petMono) &#123;</span><br><span class="line">    return petMono</span><br><span class="line">        .flatMap(pet -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;)</span><br><span class="line">        .onErrorResume(ex -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，使用<code>@ModelAttribute</code>是可选的 - 例如，设置其属性。默认情况下，任何不是简单 value 类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#webflux-ann-initbinder">BeanUtils 的#isSimpleProperty</a>确定)并且未被任何其他参数解析器解析的参数都被视为使用<code>@ModelAttribute</code>进行注释。</p>
<h5 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#validation-beanvalidation">与 Spring MVC 相同</a></p>
<p><code>@SessionAttributes</code>用于在请求之间<code>WebSession</code>中存储 model 属性。它是 type-level annotation，声明特定控制器使用的 session 属性。这通常列出 model 属性的名称或 model 属性的类型，这些属性应该透明地存储在 session 中以供后续访问请求使用。</p>
<p>考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@SessionAttributes(&quot;pet&quot;) (1)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttributes</code> annotation。</td>
</tr>
</tbody></table>
<p>在第一个请求中，当 model 的 model 属性被添加到 model 时，它会自动提升并保存在<code>WebSession</code>中。它保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@SessionAttributes(&quot;pet&quot;) (1)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;pets&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String handle(Pet pet, BindingResult errors, SessionStatus status) &#123; (2)</span><br><span class="line">        if (errors.hasErrors) &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">            status.setComplete();</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttributes</code> annotation。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>SessionStatus</code>变量。</td>
</tr>
</tbody></table>
<h5 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="@SessionAttribute"></a>@SessionAttribute</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#validation">与 Spring MVC 相同</a></p>
<p>如果需要访问全局管理的 pre-existing session 属性(即，在控制器外部 - 对于 example，通过过滤器)并且可能存在或不存在，则可以在方法参数上使用<code>@SessionAttribute</code> annotation，如下所示 example 说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@SessionAttribute User user) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttribute</code>。</td>
</tr>
</tbody></table>
<p>对于需要添加或删除 session 属性的用例，请考虑将<code>WebSession</code>注入控制器方法。</p>
<p>要在 session 中临时存储 model 属性作为控制器工作流的一部分，请考虑使用<code>SessionAttributes</code>，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#isSimpleProperty-java.lang.Class-">@SessionAttributes</a>中所述。</p>
<h5 id="RequestAttribute"><a href="#RequestAttribute" class="headerlink" title="@RequestAttribute"></a>@RequestAttribute</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattributes">与 Spring MVC 相同</a></p>
<p>与<code>@SessionAttribute</code>类似，您可以使用<code>@RequestAttribute</code> annotation 访问之前创建的 pre-existing 请求属性(对于 example，通过<code>WebFilter</code>)，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestAttribute Client client) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestAttribute</code>。</td>
</tr>
</tbody></table>
<h5 id="Multipart-Content"><a href="#Multipart-Content" class="headerlink" title="Multipart Content"></a>Multipart Content</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattribute">与 Spring MVC 相同</a></p>
<p>如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-sessionattributes">Multipart 数据</a>中所述，<code>ServerWebExchange</code>提供对 multipart 内容的访问。在控制器中处理文件上载表单(对于 example，从浏览器)的最佳方法是通过数据绑定到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestattrib">命令 object</a>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyForm &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private MultipartFile file;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;form&quot;)</span><br><span class="line">    public String handleFormUpload(MyForm form, BindingResult errors) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以在 RESTful 服务方案中从 non-browser clients 提交 multipart 请求。以下 example 使用文件和 JSON：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;someUrl</span><br><span class="line">Content-Type: multipart&#x2F;mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;meta-data&quot;</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file-data&quot;; filename&#x3D;&quot;file.properties&quot;</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>@RequestPart</code>访问各个部分，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestPart(&quot;meta-data&quot;) Part metadata, (1)</span><br><span class="line">        @RequestPart(&quot;file-data&quot;) FilePart file) &#123; (2)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>@RequestPart</code>获取文件。</td>
</tr>
</tbody></table>
<p>要反序列化原始部件内容(对于 example，为 JSON - 类似于<code>@RequestBody</code>)，您可以声明具体目标<code>Object</code>，而不是<code>Part</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestPart(&quot;meta-data&quot;) MetaData metadata) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestPart</code>获取元数据。</td>
</tr>
</tbody></table>
<p>您可以使用<code>@RequestPart</code>与<code>javax.validation.Valid</code>或 Spring 的<code>@Validated</code> annotation 组合，这会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code>，这会转换为 400(<code>BAD_REQUEST</code>)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@Valid @RequestPart(&quot;meta-data&quot;) MetaData metadata, (1)</span><br><span class="line">        BindingResult result) &#123; (2)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@Valid</code> 注释。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>BindingResult</code>参数。</td>
</tr>
</tbody></table>
<p>要将所有 multipart 数据作为<code>MultiValueMap</code>访问，您可以使用<code>@RequestBody</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestBody Mono&lt;MultiValueMap&lt;String, Part&gt;&gt; parts) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestBody</code>。</td>
</tr>
</tbody></table>
<p>要以流方式顺序访问 multipart 数据，您可以使用<code>@RequestBody</code>而不是<code>Flux&lt;Part&gt;</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestBody Flux&lt;Part&gt; parts) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestBody</code>。</td>
</tr>
</tbody></table>
<h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart-forms">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@RequestBody</code> annotation 将请求主体读取并反序列化为<code>Object</code>到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-multipart">HttpMessageReader</a>。以下 example 使用<code>@RequestBody</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(@RequestBody Account account) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与 Spring MVC 不同，在 WebFlux 中，<code>@RequestBody</code>方法参数支持 reactive 类型和完全 non-blocking 读取和(client-to-server)流式传输。以下 example 使用<code>Mono</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(@RequestBody Mono&lt;Account&gt; account) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-modelattrib-method-args">WebFlux 配置</a>的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestbody">HTTP 消息编解码器</a>选项来配置或自定义消息 readers。</p>
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.Valid</code>或 Spring 的<code>@Validated</code> annotation 结合使用，这会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>WebExchangeBindException</code>，这会转换为 400(<code>BAD_REQUEST</code>)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误。以下 example 使用<code>BindingResult</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(@Valid @RequestBody Account account, BindingResult result) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="HttpEntity"><a href="#HttpEntity" class="headerlink" title="HttpEntity"></a>HttpEntity</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-codecs">与 Spring MVC 相同</a></p>
<p><code>HttpEntity</code>与使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-message-codecs">@RequestBody</a>或多或少完全相同，但它基于一个容器 object，它暴露了 request headers 和 body。以下 example 使用<code>HttpEntity</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(HttpEntity&lt;Account&gt; entity) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config">与 Spring MVC 相同</a></p>
<p>您可以在方法上使用<code>@ResponseBody</code> annotation 通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-httpentity">HttpMessageWriter</a>将 return 序列化到响应正文。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Account handle() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class level 也支持<code>@ResponseBody</code>，在这种情况下，它由所有控制器方法继承。这是<code>@RestController</code>的效果，它只不过标有<code>@Controller</code>和<code>@ResponseBody</code>。</p>
<p><code>@ResponseBody</code>支持 reactive 类型，这意味着您可以 return Reactor 或 RxJava 类型，并将它们生成的异步值呈现给响应。有关其他详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-requestbody">流</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-responsebody">JSON 渲染</a>。</p>
<p>您可以将<code>@ResponseBody</code>方法与 JSON 序列化视图结合使用。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">Jackson JSON</a>。</p>
<p>您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs-streaming">WebFlux 配置</a>的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs-jackson">HTTP 消息编解码器</a>选项来配置或自定义消息编写。</p>
<h5 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-jackson">与 Spring MVC 相同</a></p>
<p><code>ResponseEntity</code>就像<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-message-codecs">@ResponseBody</a>但有状态和 headers。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;something&quot;)</span><br><span class="line">public ResponseEntity&lt;String&gt; handle() &#123;</span><br><span class="line">    String body &#x3D; ... ;</span><br><span class="line">    String etag &#x3D; ... ;</span><br><span class="line">    return ResponseEntity.ok().eTag(etag).build(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WebFlux 支持使用单个 value <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config">reactive 类型</a>为主体生成<code>ResponseEntity</code>异步，and/or 单和 multi-valuereactive 类型。</p>
<h5 id="Jackson-JSON-1"><a href="#Jackson-JSON-1" class="headerlink" title="Jackson JSON"></a>Jackson JSON</h5><p>Spring 支持 Jackson JSON library。</p>
<h6 id="Jackson-序列化视图"><a href="#Jackson-序列化视图" class="headerlink" title="Jackson 序列化视图"></a>Jackson 序列化视图</h6><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responseentity">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 为<a target="_blank" rel="noopener" href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson 的序列化视图</a>提供 built-in 支持，允许只渲染<code>Object</code>中所有字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，可以使用 Jackson 的<code>@JsonView</code> annotation 来激活序列化视图 class，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    @JsonView(User.WithoutPasswordView.class)</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return new User(&quot;eric&quot;, &quot;7!jd#h23&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public interface WithoutPasswordView &#123;&#125;;</span><br><span class="line">    public interface WithPasswordView extends WithoutPasswordView &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @JsonView(WithoutPasswordView.class)</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return this.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @JsonView(WithPasswordView.class)</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@JsonView</code>允许 array 视图 classes，但每个控制器方法只能指定一个。如果需要激活多个视图，请使用复合接口。</p>
</blockquote>
<h4 id="1-4-4-模型"><a href="#1-4-4-模型" class="headerlink" title="1.4.4. 模型"></a>1.4.4. 模型</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-responsebody">与 Spring MVC 相同</a></p>
<p>您可以使用<code>@ModelAttribute</code> annotation：</p>
<ul>
<li>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">方法论证</a> in <code>@RequestMapping</code>方法中，从 model 创建或访问 Object 并通过<code>WebDataBinder</code>将其绑定到请求。</li>
<li>作为<code>@Controller</code>或<code>@ControllerAdvice</code> classes 中的 method-level annotation，帮助在任何<code>@RequestMapping</code>方法调用之前初始化 model。</li>
<li>在<code>@RequestMapping</code>方法上将 return value 标记为 model 属性。</li>
</ul>
<p>本节讨论<code>@ModelAttribute</code>方法，或前面列表中的第二个 item。控制器可以有任意数量的<code>@ModelAttribute</code>方法。所有这些方法都在同一控制器中的<code>@RequestMapping</code>方法之前调用。也可以通过<code>@ControllerAdvice</code>在控制器之间共享<code>@ModelAttribute</code>方法。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-jackson">控制器建议</a>部分。</p>
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的 arguments(除了<code>@ModelAttribute</code>本身以及与请求体相关的任何事物)。</p>
<p>以下 example 使用<code>@ModelAttribute</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public void populateModel(@RequestParam String number, Model model) &#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    &#x2F;&#x2F; add more ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下 example 仅添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public Account addAccount(@RequestParam String number) &#123;</span><br><span class="line">    return accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果未明确指定 name，则会根据类型选择默认 name，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>的 javadoc 中所述。您始终可以使用重载的<code>addAttribute</code>方法或<code>@ModelAttribute</code>上的 name 属性(对于 return value)分配显式 name。</p>
</blockquote>
<p>与 Spring MVC 不同，Spring WebFlux 显式支持 model 中的 reactive 类型(对于 example，<code>Mono&lt;Account&gt;</code>或<code>io.reactivex.Single&lt;Account&gt;</code>)。如果在没有 wrapper 的情况下声明<code>@ModelAttribute</code>参数，则可以在<code>@RequestMapping</code>调用的 time 处将此类异步 model 属性透明地解析(并且 model 更新)为其实际值，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public void addAccount(@RequestParam String number) &#123;</span><br><span class="line">    Mono&lt;Account&gt; accountMono &#x3D; accountRepository.findAccount(number);</span><br><span class="line">    model.addAttribute(&quot;account&quot;, accountMono);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public String handle(@ModelAttribute Account account, BindingResult errors) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，具有 reactive 类型 wrapper 的任何 model 属性在视图呈现之前被解析为其实际值(并且 model 已更新)。</p>
<p>您还可以在<code>@RequestMapping</code>方法上使用<code>@ModelAttribute</code>作为 method-level annotation，在这种情况下，<code>@RequestMapping</code>方法的 return value 将被解释为 model 属性。这通常不是必需的，因为它是 HTML 控制器中的默认行为，除非 return value 是<code>String</code>否则将被解释为 view name。 <code>@ModelAttribute</code>还可以帮助自定义 model 属性 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ModelAttribute(&quot;myAccount&quot;)</span><br><span class="line">public Account handle() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    return account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-4-5-DataBinder"><a href="#1-4-5-DataBinder" class="headerlink" title="1.4.5. DataBinder"></a>1.4.5. DataBinder</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-modelattrib-methods">与 Spring MVC 相同</a></p>
<p><code>@Controller</code>或<code>@ControllerAdvice</code> classes 可以有<code>@InitBinder</code>方法来初始化<code>WebDataBinder</code>的实例。反过来，这些用于：</p>
<ul>
<li>将请求参数(即表单数据或查询)绑定到 model object。</li>
<li>将<code>String</code> -based 请求值(例如请求参数，路径变量，headers，cookies 等)转换为控制器方法 arguments 的目标类型。</li>
<li>在呈现 HTML 表单时将 model object 值格式化为<code>String</code>值。</li>
</ul>
<p><code>@InitBinder</code>方法可以注册 controller-specific <code>java.bean.PropertyEditor</code>或 Spring <code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-modelattrib-method-args">WebFlux Java configuration</a>在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>类型。</p>
<p><code>@InitBinder</code>方法支持许多与<code>@RequestMapping</code>方法相同的 arguments，但<code>@ModelAttribute</code>(命令 object)arguments 除外。通常，它们使用<code>WebDataBinder</code>参数声明，用于注册，以及<code>void</code> return value。以下 example 使用<code>@InitBinder</code> annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FormController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder (1)</span><br><span class="line">    public void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        dateFormat.setLenient(false);</span><br><span class="line">        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>使用<code>@InitBinder</code> annotation。</td>
</tr>
</tbody></table>
<p>或者，当通过共享<code>FormattingConversionService</code>使用<code>Formatter</code> -based 设置时，您可以使用相同的方法并注册 controller-specific <code>Formatter</code>实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FormController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder</span><br><span class="line">    protected void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        binder.addCustomFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;)); (1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>添加自定义格式化程序(在本例中为<code>DateFormatter</code>)。</td>
</tr>
</tbody></table>
<h4 id="1-4-6-管理-Exceptions"><a href="#1-4-6-管理-Exceptions" class="headerlink" title="1.4.6. 管理 Exceptions"></a>1.4.6. 管理 Exceptions</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-controller-advice">与 Spring MVC 相同</a></p>
<p><code>@Controller</code>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-initbinder">@ControllerAdvice</a> classes 可以有<code>@ExceptionHandler</code>方法来处理来自控制器方法的 exceptions。以下 example 包含这样的处理程序方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SimpleController &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler (1)</span><br><span class="line">    public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>声明<code>@ExceptionHandler</code>：</td>
</tr>
</tbody></table>
<p>exception 可以对传播的 top-level exception(也就是抛出的直接<code>IOException</code>)进行匹配，或者对wrapper exception 中的直接原因进行匹配(对于 example，包裹在<code>IllegalStateException</code>中)。</p>
<p>对于匹配 exception 类型，最好将目标 exception 声明为方法参数，如前面的 example 所示。或者，annotation 声明可以将 exception 类型缩小为 match。我们通常建议在参数签名中尽可能具体，并在<code>@ControllerAdvice</code>上使用相应的 order 优先声明主根 exception 映射。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-conversion">MVC 部分</a>。</p>
<blockquote>
<p>WebFlux 中的<code>@ExceptionHandler</code>方法支持与<code>@RequestMapping</code>方法相同的 arguments 和 return 值方法，以及请求 body-和<code>@ModelAttribute</code> -related 方法 arguments 的 exception。</p>
</blockquote>
<p>方法支持<em>Sp</em> _FF 中的<code>@ExceptionHandler</code>方法。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-exceptionhandler">DispatcherHandler</a>。</p>
<h5 id="REST-API-exceptions"><a href="#REST-API-exceptions" class="headerlink" title="REST API exceptions"></a>REST API exceptions</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-controller-advice">与 Spring MVC 相同</a></p>
<p>REST 服务的 common 要求是在响应正文中包含错误详细信息。 Spring Framework 不会自动执行此操作，因为响应正文中错误详细信息的表示形式为 application-specific。但是，<code>@RestController</code>可以使用<code>@ExceptionHandler</code>方法和<code>ResponseEntity</code> return value 来设置响应的状态和正文。此类方法也可以在<code>@ControllerAdvice</code> classes 中声明，以便全局应用它们。</p>
<blockquote>
<p>请注意，Spring WebFlux 没有 Spring MVC <code>ResponseEntityExceptionHandler</code>的等效项，因为 WebFlux 仅引发<code>ResponseStatusException</code>(或其子类)，并且不需要将它们转换为 HTTP 状态 code。</p>
</blockquote>
<h4 id="1-4-7-控制器建议"><a href="#1-4-7-控制器建议" class="headerlink" title="1.4.7. 控制器建议"></a>1.4.7. 控制器建议</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-exceptionhandler">与 Spring MVC 相同</a></p>
<p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于声明它们的<code>@Controller</code> class(或 class 层次结构)。如果您希望此类方法更全局地应用(跨控制器)，则可以在标有<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>的 class 中声明它们。</p>
<p><code>@ControllerAdvice</code>标有<code>@Component</code>，这意味着这样的 classes 可以通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-dispatcher-handler">component 扫描</a>注册为 Spring beans。 <code>@RestControllerAdvice</code>也是 meta-annotation 标有<code>@ControllerAdvice</code>和<code>@ResponseBody</code>，这实质上意味着通过消息转换(与视图分辨率或模板渲染相比)将<code>@ExceptionHandler</code>方法呈现给响应主体。</p>
<p>在启动时，<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法的基础结构 classes 检测<code>@ControllerAdvice</code>类型的 Spring beans 并在运行时应用它们的方法。 _ <strong>全局<code>@ExceptionHandler</code>方法(来自<code>@ControllerAdvice</code>)在</strong>本地之后(来自<code>@Controller</code>)应用**.相比之下，_<strong>全局<code>@ModelAttribute</code>和<code>@InitBinder</code>方法在</strong>本地之前应用**。</p>
<p>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求(即所有控制器)，但您可以通过 annotation 上的属性将其缩小到控制器的子集，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Target all Controllers annotated with @RestController</span><br><span class="line">@ControllerAdvice(annotations &#x3D; RestController.class)</span><br><span class="line">public class ExampleAdvice1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers within specific packages</span><br><span class="line">@ControllerAdvice(&quot;org.example.controllers&quot;)</span><br><span class="line">public class ExampleAdvice2 &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers assignable to specific classes</span><br><span class="line">@ControllerAdvice(assignableTypes &#x3D; &#123;ControllerInterface.class, AbstractController.class&#125;)</span><br><span class="line">public class ExampleAdvice3 &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>前面的 selectors 在运行时进行评估，如果您广泛使用它们，可能会对 performance 产生负面影响。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html">@ControllerAdvice</a> javadoc。</p>
<h3 id="1-5-功能-Endpoints"><a href="#1-5-功能-Endpoints" class="headerlink" title="1.5. 功能 Endpoints"></a>1.5. 功能 Endpoints</h3><p>Spring WebFlux 包含 WebFlux.fn，一个轻量级函数式编程 model，其中函数用于 route 和处理请求，contracts 是为不变性而设计的。它是 annotation-based 编程 model 的替代品，但是在相同的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-rest-exceptions">Reactive Core</a>基础上运行。</p>
<h4 id="1-5-1-概观"><a href="#1-5-1-概观" class="headerlink" title="1.5.1. 概观"></a>1.5.1. 概观</h4><p>在 WebFlux.fn 中，HTTP 请求使用<code>HandlerFunction</code>：函数处理，该函数接受<code>ServerRequest</code>并返回延迟的<code>ServerResponse</code>(i.e .<code>Mono&lt;ServerResponse&gt;</code>)。作为响应 object 的请求都具有不可变的 contracts，它提供对 HTTP 请求和响应的 JDK 8-friendly 访问。 <code>HandlerFunction</code>相当于 annotation-based 编程 model 中<code>@RequestMapping</code>方法的主体。</p>
<p>传入的请求被路由到处理程序 function，其中<code>RouterFunction</code>：功能需要<code>ServerRequest</code>并返回延迟的<code>HandlerFunction</code>(i.e.<code>Mono&lt;HandlerFunction&gt;</code>)。当 router function 匹配时，返回一个 handler function;否则是一个空的单声道。 <code>RouterFunction</code>相当于<code>@RequestMapping</code> annotation，但主要区别在于 router 函数不仅提供数据，还提供行为。</p>
<p><code>RouterFunctions.route()</code>提供了一个便于创建 router 的 router 构建器，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line">import static org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line">import static org.springframework.web.reactive.function.server.RouterFunctions.route;</span><br><span class="line"></span><br><span class="line">PersonRepository repository &#x3D; ...</span><br><span class="line">PersonHandler handler &#x3D; new PersonHandler(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .GET(&quot;&#x2F;person&#x2F;&#123;id&#125;&quot;, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">    .GET(&quot;&#x2F;person&quot;, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">    .POST(&quot;&#x2F;person&quot;, handler::createPerson)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">public class PersonHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>RouterFunction</code>的一种方法是将其转换为<code>HttpHandler</code>并通过 built-in <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-controller-advice">服务适配器</a>之一安装它：</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<p>大多数 applications 可以通过 WebFlux Java configuration 运行，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#beans-java-instantiating-container-scan">运行服务器</a>。</p>
<h4 id="1-5-2-HandlerFunction"><a href="#1-5-2-HandlerFunction" class="headerlink" title="1.5.2. HandlerFunction"></a>1.5.2. HandlerFunction</h4><p><code>ServerRequest</code>和<code>ServerResponse</code>是不可变接口，提供对 HTTP 请求和响应的 JDK 8-friendly 访问。请求和响应都对身体流提供了<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/">Reactive Streams</a>背压。请求体用 Reactor <code>Flux</code>或<code>Mono</code>表示。响应正文用任何 Reactive Streams <code>Publisher</code>表示，包括<code>Flux</code>和<code>Mono</code>。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-spring-web">Reactive Libraries</a>。</p>
<h5 id="ServerRequest"><a href="#ServerRequest" class="headerlink" title="ServerRequest"></a>ServerRequest</h5><p><code>ServerRequest</code>提供对 HTTP 方法，URI，headers 和查询参数的访问，同时通过<code>body</code>方法提供对正文的访问。</p>
<p>以下 example 将请求正文提取到<code>Mono&lt;String&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; string &#x3D; request.bodyToMono(String.class);</span><br></pre></td></tr></table></figure>

<p>以下 example 将主体提取到<code>Flux&lt;Person&gt;</code>，其中<code>Person</code> objects 从某些序列化形式(如 JSON 或 XML)解码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Person&gt; people &#x3D; request.bodyToFlux(Person.class);</span><br></pre></td></tr></table></figure>

<p>前面的示例是使用更通用的<code>ServerRequest.body(BodyExtractor)</code>的快捷方式，它接受<code>BodyExtractor</code>功能策略接口。实用程序 class <code>BodyExtractors</code>提供对许多实例的访问。例如，前面的例子也可以写成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; string &#x3D; request.body(BodyExtractors.toMono(String.class));</span><br><span class="line">Flux&lt;Person&gt; people &#x3D; request.body(BodyExtractors.toFlux(Person.class));</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何访问表单数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, String&gt; map &#x3D; request.body(BodyExtractors.toFormData());</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何将 multipart 数据作为 map 访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;MultiValueMap&lt;String, Part&gt; map &#x3D; request.body(BodyExtractors.toMultipartData());</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何以流方式访问多个部分，一个在 time 时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Part&gt; parts &#x3D; request.body(BodyExtractos.toParts());</span><br></pre></td></tr></table></figure>

<h5 id="ServerResponse"><a href="#ServerResponse" class="headerlink" title="ServerResponse"></a>ServerResponse</h5><p><code>ServerResponse</code>提供对 HTTP 响应的访问，因为它是不可变的，所以您可以使用<code>build</code>方法来创建它。您可以使用构建器来设置响应状态，添加响应_header 或提供正文。以下 example 使用 JSON 内容创建 200(OK)响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; person &#x3D; ...</span><br><span class="line">ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(person, Person.class);</span><br></pre></td></tr></table></figure>

<p>以下 example 显示了如何使用<code>Location</code>标头 build 201(CREATED)响应并且没有正文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI location &#x3D; ...</span><br><span class="line">ServerResponse.created(location).build();</span><br></pre></td></tr></table></figure>

<h5 id="Handler-Classes"><a href="#Handler-Classes" class="headerlink" title="Handler Classes"></a>Handler Classes</h5><p>我们可以将 handler function 编写为 lambda，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HandlerFunction&lt;ServerResponse&gt; helloWorld &#x3D;</span><br><span class="line">  request -&gt; ServerResponse.ok().body(fromObject(&quot;Hello World&quot;));</span><br></pre></td></tr></table></figure>

<p>这很方便，但在 application 中我们需要多个函数，多个内联 lambda 可能会变得混乱。因此，将相关的处理函数组合成一个处理程序 class 是很有用的，它在 annotation-based application 中具有与<code>@Controller</code>类似的作用。对于 example，以下 class 公开 reactive <code>Person</code> repository：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line">import static org.springframework.web.reactive.function.ServerResponse.ok;</span><br><span class="line">import static org.springframework.web.reactive.function.BodyInserters.fromObject;</span><br><span class="line"></span><br><span class="line">public class PersonHandler &#123;</span><br><span class="line"></span><br><span class="line">    private final PersonRepository repository;</span><br><span class="line"></span><br><span class="line">    public PersonHandler(PersonRepository repository) &#123;</span><br><span class="line">        this.repository &#x3D; repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; listPeople(ServerRequest request) &#123; (1)</span><br><span class="line">        Flux&lt;Person&gt; people &#x3D; repository.allPeople();</span><br><span class="line">        return ok().contentType(APPLICATION_JSON).body(people, Person.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; createPerson(ServerRequest request) &#123; (2)</span><br><span class="line">        Mono&lt;Person&gt; person &#x3D; request.bodyToMono(Person.class);</span><br><span class="line">        return ok().build(repository.savePerson(person));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Mono&lt;ServerResponse&gt; getPerson(ServerRequest request) &#123; (3)</span><br><span class="line">        int personId &#x3D; Integer.valueOf(request.pathVariable(&quot;id&quot;));</span><br><span class="line">        return repository.getPerson(personId)</span><br><span class="line">            .flatMap(person -&gt; ok().contentType(APPLICATION_JSON).body(fromObject(person)))</span><br><span class="line">            .switchIfEmpty(ServerResponse.notFound().build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>listPeople</code>是一个 handler function，它将 repository 中找到的所有<code>Person</code> objects 作为 JSON 返回。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td><code>createPerson</code>是一个处理程序 function，它存储请求体中包含的新<code>Person</code>。请注意<code>PersonRepository.savePerson(Person)</code>返回<code>Mono&lt;Void&gt;</code>：一个空<code>Mono</code>，当该人从请求中读取并存储时，它会发出完成信号。因此，我们使用<code>build(Publisher&lt;Void&gt;)</code>方法在收到完成信号时(即保存<code>Person</code>时)发送响应。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>getPerson</code>是一个 handler function，它返回一个由<code>id</code> path 变量标识的人。我们从 repository 中检索<code>Person</code>并创建一个 JSON 响应(如果找到它)。如果找不到，我们使用<code>switchIfEmpty(Mono&lt;T&gt;)</code>来_retret 404 Not Found 响应。</td>
</tr>
</tbody></table>
<h4 id="1-5-3-RouterFunction"><a href="#1-5-3-RouterFunction" class="headerlink" title="1.5.3. RouterFunction"></a>1.5.3. RouterFunction</h4><p>Router 函数用于将请求路由到相应的<code>HandlerFunction</code>。通常，您不会自己编写 router 函数，而是使用<code>RouterFunctions</code> utility class 上的方法创建一个。 <code>RouterFunctions.route()</code>(无参数)为 creating router function 提供 fluent 构建器，而<code>RouterFunctions.route(RequestPredicate, HandlerFunction)</code>提供了创建 router 的直接方法。</p>
<p>通常，建议使用<code>route()</code>构建器，因为它为典型的映射方案提供了方便的 short-cuts，而不需要 hard-to-discover 静态导入。例如，router function 构建器提供方法<code>GET(String, HandlerFunction)</code>来为 GET 请求创建映射;和<code>POST(String, HandlerFunction)</code>用于 POST。</p>
<p>除了 HTTP method-based 映射之外，route 构建器还提供了一种在映射到请求时引入其他谓词的方法。对于每个 HTTP 方法，都有一个重载变量，它将<code>RequestPredicate</code>作为参数，但可以表示其他约束。</p>
<h5 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h5><p>您可以编写自己的<code>RequestPredicate</code>，但<code>RequestPredicates</code>实用程序 class 根据请求路径，HTTP 方法，content-type 等提供常用的 implementations。以下 example 使用请求谓词来基于<code>Accept</code>标头创建约束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; RouterFunctions.route()</span><br><span class="line">    .GET(&quot;&#x2F;hello-world&quot;, accept(MediaType.TEXT_PLAIN),</span><br><span class="line">        request -&gt; Response.ok().body(fromObject(&quot;Hello World&quot;)));</span><br></pre></td></tr></table></figure>

<p>您可以使用以下命令组合多个请求谓词：</p>
<ul>
<li><code>RequestPredicate.and(RequestPredicate)</code> - 两者都必须 match。</li>
<li><code>RequestPredicate.or(RequestPredicate)</code> - 要么 match。</li>
</ul>
<p>来自<code>RequestPredicates</code>的许多谓词都是由组成的。例如，<code>RequestPredicates.GET(String)</code>由<code>RequestPredicates.method(HttpMethod)</code>和<code>RequestPredicates.path(String)</code>组成。上面显示的 example 也使用两个请求谓词，因为构建器在内部使用<code>RequestPredicates.GET</code>，并使用<code>accept</code>谓词组合它。</p>
<h5 id="Routes"><a href="#Routes" class="headerlink" title="Routes"></a>Routes</h5><p>order 函数在 order 中计算：如果第一个 route 不匹配，则计算第二个，依此类推。因此，在通用之前声明更具体的 routes 是有意义的。请注意，此行为与 annotation-based programming model 不同，后者会自动选择“最具体”的控制器方法。</p>
<p>使用 router function 构建器时，所有已定义的 routes 都组成一个从<code>build()</code>返回的<code>RouterFunction</code>。还有其他方法可以组合多个 router 函数：</p>
<ul>
<li>在<code>RouterFunctions.route()</code>构建器上<code>add(RouterFunction)</code></li>
<li><code>RouterFunction.and(RouterFunction)</code></li>
<li><code>RouterFunction.andRoute(RequestPredicate, HandlerFunction)</code> - 嵌套<code>RouterFunctions.route()</code>的<code>RouterFunction.and()</code>快捷方式。</li>
</ul>
<p>以下 example 显示了四个 routes 的组成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.http.MediaType.APPLICATION_JSON;</span><br><span class="line">import static org.springframework.web.reactive.function.server.RequestPredicates.*;</span><br><span class="line"></span><br><span class="line">PersonRepository repository &#x3D; ...</span><br><span class="line">PersonHandler handler &#x3D; new PersonHandler(repository);</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; otherRoute &#x3D; ...</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .GET(&quot;&#x2F;person&#x2F;&#123;id&#125;&quot;, accept(APPLICATION_JSON), handler::getPerson) (1)</span><br><span class="line">    .GET(&quot;&#x2F;person&quot;, accept(APPLICATION_JSON), handler::listPeople) (2)</span><br><span class="line">    .POST(&quot;&#x2F;person&quot;, handler::createPerson) (3)</span><br><span class="line">    .add(otherRoute) (4)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>带有与 JSON 匹配的<code>Accept</code>标头的<code>GET /person/&#123;id&#125;</code>被路由到<code>PersonHandler.getPerson</code></td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>带有与 JSON 匹配的<code>Accept</code>标头的<code>GET /person</code>被路由到<code>PersonHandler.listPeople</code></td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>没有附加谓词的<code>POST /person</code>被映射到<code>PersonHandler.createPerson</code>，和</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><code>otherRoute</code>是在其他地方创建的 router function，并添加到构建的 route 中。</td>
</tr>
</tbody></table>
<h5 id="嵌套-Routes"><a href="#嵌套-Routes" class="headerlink" title="嵌套 Routes"></a>嵌套 Routes</h5><p>对于一组 router 函数来说，共享谓词(例如共享路径)是 common。在上面的 example 中，共享谓词将是与<code>/person</code>匹配的路径谓词，由三个 routes 使用。使用 annotations 时，您可以使用 maps 到<code>/person</code>的 type-level <code>@RequestMapping</code> 注释来删除此重复项。在 WebFlux.fn 中，可以通过 router function 构建器上的<code>path</code>方法共享路径谓词。例如，通过使用嵌套的 routes，可以通过以下方式改进上述 example 的最后几行行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .path(&quot;&#x2F;person&quot;, builder -&gt; builder</span><br><span class="line">        .GET(&quot;&#x2F;&#123;id&#125;&quot;, accept(APPLICATION_JSON), handler::getPerson)</span><br><span class="line">        .GET(&quot;&quot;, accept(APPLICATION_JSON), handler::listPeople)</span><br><span class="line">        .POST(&quot;&#x2F;person&quot;, handler::createPerson))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>请注意，<code>path</code>的第二个参数是一个 consumer，它接受一个 router 构建器。</p>
<p>尽管 path-based 嵌套是最常见的，但您可以使用构建器上的<code>nest</code>方法嵌套在任何类型的谓词上。以上仍然包含共享<code>Accept</code> -header 谓词形式的一些重复。我们可以通过<code>nest</code>方法和<code>accept</code>一起使用来进一步改进：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .path(&quot;&#x2F;person&quot;, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(&quot;&#x2F;&#123;id&#125;&quot;, handler::getPerson)</span><br><span class="line">            .GET(&quot;&quot;, handler::listPeople))</span><br><span class="line">        .POST(&quot;&#x2F;person&quot;, handler::createPerson))</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h4 id="1-5-4-运行服务器"><a href="#1-5-4-运行服务器" class="headerlink" title="1.5.4. 运行服务器"></a>1.5.4. 运行服务器</h4><p>你如何在 HTTP 服务器中运行 router function？一个简单的选项是使用以下方法之一将 router function 转换为<code>HttpHandler</code>：</p>
<ul>
<li><code>RouterFunctions.toHttpHandler(RouterFunction)</code></li>
<li><code>RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies)</code></li>
</ul>
<p>然后，您可以使用返回的<code>HttpHandler</code>与多个服务器适配器一起使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">HttpHandler</a>来执行 server-specific 指令。</p>
<p>Spring Boot 也使用的一个更典型的选项是通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-fn-running">WebFlux 配置</a>运行<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-reactive-libraries">DispatcherHandler</a> -based，它使用 Spring configuration 来声明 process 请求所需的组件。 WebFlux Java configuration 声明以下基础结构组件以支持功能 endpoints：</p>
<ul>
<li><code>RouterFunctionMapping</code>：在 Spring configuration 中检测一个或多个<code>RouterFunction&lt;?&gt;</code> beans，通过<code>RouterFunction.andOther</code>和 routes 请求将它们组合到生成的组合<code>RouterFunction</code>中。</li>
<li><code>HandlerFunctionAdapter</code>：简单的适配器，允许<code>DispatcherHandler</code>调用映射到请求的<code>HandlerFunction</code>。</li>
<li><code>ServerResponseResultHandler</code>：通过调用<code>ServerResponse</code>的<code>writeTo</code>方法处理调用<code>HandlerFunction</code>的结果。</li>
</ul>
<p>前面的组件允许函数 endpoints 适合<code>DispatcherHandler</code>请求处理生命周期，并且(可能)与带注释的控制器并行运行(如果有的话)。它也是 Spring Boot WebFlux starter 启用功能 endpoints 的方式。</p>
<p>以下 example 显示了 WebFlux Java configuration(有关如何运行它，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-httphandler">DispatcherHandler</a>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RouterFunction&lt;?&gt; routerFunctionA() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RouterFunction&lt;?&gt; routerFunctionB() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) &#123;</span><br><span class="line">        &#x2F;&#x2F; configure message conversion...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; configure CORS...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; configure view resolution for HTML rendering...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-5-过滤处理程序功能"><a href="#1-5-5-过滤处理程序功能" class="headerlink" title="1.5.5. 过滤处理程序功能"></a>1.5.5. 过滤处理程序功能</h4><p>您可以使用 routing function 构建器上的<code>before</code>，<code>after</code>或<code>filter</code>方法过滤处理函数。使用 annotations，您可以使用<code>@ControllerAdvice</code>，<code>ServletFilter</code>或两者来实现类似的功能。过滤器将应用于构建器构建的所有 routes。这意味着嵌套的 routes 中定义的过滤器不适用于“top-level”routes。例如，请考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .path(&quot;&#x2F;person&quot;, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(&quot;&#x2F;&#123;id&#125;&quot;, handler::getPerson)</span><br><span class="line">            .GET(&quot;&quot;, handler::listPeople)</span><br><span class="line">            .before(request -&gt; ServerRequest.from(request) (1)</span><br><span class="line">                .header(&quot;X-RequestHeader&quot;, &quot;Value&quot;)</span><br><span class="line">                .build()))</span><br><span class="line">        .POST(&quot;&#x2F;person&quot;, handler::createPerson))</span><br><span class="line">    .after((request, response) -&gt; logResponse(response)) (2)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>添加自定义请求标头的<code>before</code>过滤器仅应用于两个 GET routes。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>记录响应的<code>after</code>过滤器将应用于所有 routes，包括嵌套的 routes。</td>
</tr>
</tbody></table>
<p>router 构建器上的<code>filter</code>方法采用<code>HandlerFilterFunction</code>：函数，它接受<code>ServerRequest</code>和<code>HandlerFunction</code>并返回<code>ServerResponse</code>。 handler function 参数表示链中的下一个元素。这通常是路由到的处理程序，但如果应用了多个，它也可以是另一个过滤器。</p>
<p>现在我们可以为 route 添加一个简单的安全过滤器，假设我们有<code>SecurityManager</code>可以确定是否允许特定路径。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager securityManager &#x3D; ...</span><br><span class="line"></span><br><span class="line">RouterFunction&lt;ServerResponse&gt; route &#x3D; route()</span><br><span class="line">    .path(&quot;&#x2F;person&quot;, b1 -&gt; b1</span><br><span class="line">        .nest(accept(APPLICATION_JSON), b2 -&gt; b2</span><br><span class="line">            .GET(&quot;&#x2F;&#123;id&#125;&quot;, handler::getPerson)</span><br><span class="line">            .GET(&quot;&quot;, handler::listPeople))</span><br><span class="line">        .POST(&quot;&#x2F;person&quot;, handler::createPerson))</span><br><span class="line">    .filter((request, next) -&gt; &#123;</span><br><span class="line">        if (securityManager.allowAccessTo(request.path())) &#123;</span><br><span class="line">            return next.handle(request);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            return ServerResponse.status(UNAUTHORIZED).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>前面的 example 演示了调用<code>next.handle(ServerRequest)</code>是可选的。我们只允许在允许访问时执行 handler function。</p>
<p>除了在 router function 构建器上使用<code>filter</code>方法之外，还可以通过<code>RouterFunction.filter(HandlerFilterFunction)</code>将过滤器应用于现有的 router function。</p>
<blockquote>
<p>功能 endpoints 的 CORS 支持通过专用的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-dispatcher-handler">CorsWebFilter</a>提供。</p>
</blockquote>
<h3 id="1-6-URI-链接"><a href="#1-6-URI-链接" class="headerlink" title="1.6. URI 链接"></a>1.6. URI 链接</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config">与 Spring MVC 相同</a></p>
<p>本节介绍 Spring Framework 中可用于准备 URI 的各种选项。</p>
<h4 id="1-6-1-UriComponents"><a href="#1-6-1-UriComponents" class="headerlink" title="1.6.1. UriComponents"></a>1.6.1. UriComponents</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>有助于使用变量从 URI 模板中构建 URI，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)  (1)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)  (2)</span><br><span class="line">        .encode() (3)</span><br><span class="line">        .build(); (4)</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriComponents.expand(&quot;Westin&quot;, &quot;123&quot;).toUri();  (5)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>带有 URI 模板的静态工厂方法。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>添加或替换 URI 组件。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>请求编码 URI 模板和 URI 变量。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Build a <code>UriComponents</code>。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>展开变量并获取<code>URI</code>。</td>
</tr>
</tbody></table>
<p>前面的 example 可以合并为一个链并用<code>buildAndExpand</code>缩短，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .encode()</span><br><span class="line">        .buildAndExpand(&quot;Westin&quot;, &quot;123&quot;)</span><br><span class="line">        .toUri();</span><br></pre></td></tr></table></figure>

<p>您可以通过直接转到 URI(这意味着编码)来进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>

<p>您可以使用完整的 URI 模板进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;?q&#x3D;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="1-6-2-UriBuilder"><a href="#1-6-2-UriBuilder" class="headerlink" title="1.6.2. UriBuilder"></a>1.6.2. UriBuilder</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-dispatcher-handler">UriComponentsBuilder</a>实现<code>UriBuilder</code>。您可以使用<code>UriBuilderFactory</code>创建<code>UriBuilder</code>。 <code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置(例如基本 URL，编码首选项和其他详细信息)从 URI 模板中构建 URI。</p>
<p>您可以使用<code>UriBuilderFactory</code>配置<code>RestTemplate</code>和<code>WebClient</code>以自定义 URI 的准备。 <code>DefaultUriBuilderFactory</code>是<code>UriBuilderFactory</code>的默认_impleration，它在内部使用<code>UriComponentsBuilder</code>并公开共享 configuration 选项。</p>
<p>以下 example 显示了如何配置<code>RestTemplate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="line"></span><br><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.org&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate &#x3D; new RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br></pre></td></tr></table></figure>

<p>以下 example 配置<code>WebClient</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="line"></span><br><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.org&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">WebClient client &#x3D; WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>

<p>此外，您还可以直接使用<code>DefaultUriBuilderFactory</code>。它类似于使用<code>UriComponentsBuilder</code>但是，它不是静态工厂方法，而是一个包含 configuration 和 preferences 的实际实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.com&quot;;</span><br><span class="line">DefaultUriBuilderFactory uriBuilderFactory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriBuilderFactory.uriString(&quot;&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="1-6-3-URI-编码"><a href="#1-6-3-URI-编码" class="headerlink" title="1.6.3. URI 编码"></a>1.6.3. URI 编码</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
<ul>
<li>首先<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#webflux-cors-webfilter">UriComponentsBuilder#encode()</a>：Pre-encodes URI 模板，然后在扩展时严格编码 URI 变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#mvc-uri-building">UriComponents#encode()</a>：扩展 URI 变量后对 URI 组件进行编码。</li>
</ul>
<p>这两个选项都使用转义的八位字节替换 non-ASCII 和非法字符。但是，第一个选项还会替换出现在 URI 变量中的保留含义的字符。</p>
<blockquote>
<p>考虑“;”，这在路径中是合法的但具有保留意义。第一个选项取代“;”在 URI 变量中使用“％3B”但在 URI 模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p>
</blockquote>
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将 URI 变量视为完全编码的不透明数据，而选项 2 仅在 URI 变量故意包含保留字符时才有用。</p>
<p>以下 example 使用第一个选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;&quot;)</span><br><span class="line">            .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">            .encode()</span><br><span class="line">            .buildAndExpand(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br><span class="line">            .toUri();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Result is &quot;&#x2F;hotel%20list&#x2F;New%20York?q&#x3D;foo%2Bbar&quot;</span><br></pre></td></tr></table></figure>

<p>您可以通过直接转到 URI(这意味着编码)来缩短前面的 example，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;&quot;)</span><br><span class="line">            .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">            .build(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br></pre></td></tr></table></figure>

<p>您可以使用完整的 URI 模板进一步缩短它，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;?q&#x3D;&#123;q&#125;&quot;)</span><br><span class="line">            .build(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br></pre></td></tr></table></figure>

<p><code>WebClient</code>和<code>RestTemplate</code>通过<code>UriBuilderFactory</code>策略在内部扩展和编码 URI 模板。两者都可以配置自定义策略。如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.com&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl)</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Customize the RestTemplate..</span><br><span class="line">RestTemplate restTemplate &#x3D; new RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Customize the WebClient..</span><br><span class="line">WebClient client &#x3D; WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>

<p><code>DefaultUriBuilderFactory</code> implementation 在内部使用<code>UriComponentsBuilder</code>来扩展和编码 URI 模板。作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
<ul>
<li><code>TEMPLATE_AND_VALUES</code>：使用<code>UriComponentsBuilder#encode()</code>(对应于前面列表中的第一个选项)pre-encode URI 模板，并在扩展时严格编码 URI 变量。</li>
<li><code>VALUES_ONLY</code>：不对 URI 模板进行编码，而是在将 URI 变量扩展到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对 URI 变量应用严格编码。</li>
<li><code>URI_COMPONENTS</code>：使用<code>UriComponents#encode()</code>(对应于前面列表中的第二个选项)，在扩展 URI 变量后对 URI component value 进行编码。</li>
<li><code>NONE</code>：未应用编码。</li>
</ul>
<p>出于历史原因和向后兼容性，<code>RestTemplate</code>设置为<code>EncodingMode.URI_COMPONENTS</code>。 <code>WebClient</code>依赖于<code>DefaultUriBuilderFactory</code>中的默认 value，它在 5.0.x 中从<code>EncodingMode.URI_COMPONENTS</code>更改为 5.1 中的<code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p>
<h3 id="1-7-CORS"><a href="#1-7-CORS" class="headerlink" title="1.7. CORS"></a>1.7. CORS</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#web-uricomponents">与 Spring MVC 相同</a></p>
<p>Spring WebFlux 允许您处理 CORS(Cross-Origin 资源共享)。本节介绍如何执行此操作。</p>
<h4 id="1-7-1-介绍"><a href="#1-7-1-介绍" class="headerlink" title="1.7.1. 介绍"></a>1.7.1. 介绍</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#encode--">与 Spring MVC 相同</a></p>
<p>出于安全原因，浏览器禁止 AJAX calls 到当前源之外的资源。例如，您可以将您的银行帐户放在一个标签中，将 evil.com 放在另一个标签中。来自 evil.com 的脚本不应该使用您的凭据向您的银行 API 发出 AJAX 请求 - 例如，从您的帐户中提取资金！</p>
<p>Cross-Origin 资源共享(CORS)是由<a target="_blank" rel="noopener" href="https://caniuse.com/#encode--">大多数浏览器</a>实现的<a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">W3C 规范</a>，它允许您指定授权的 cross-domain 请求类型，而不是使用基于 IFRAME 或 JSONP 的安全性较低且功能较弱的变通方法。</p>
<h4 id="1-7-2-处理"><a href="#1-7-2-处理" class="headerlink" title="1.7.2. 处理"></a>1.7.2. 处理</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-cors">与 Spring MVC 相同</a></p>
<p>CORS 规范区分了预检，简单和实际请求。要了解 CORS 的工作原理，您可以阅读<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>等许多其他内容，或者查看规范以获取更多详细信息。</p>
<p>Spring WebFlux <code>HandlerMapping</code> implementations 为 CORS 提供 built-in 支持。成功将请求映射到处理程序后，<code>HandlerMapping</code>检查给定请求和处理程序的 CORS configuration 并采取进一步操作。直接处理预检请求，同时拦截，验证简单和实际的 CORS 请求，并设置所需的 CORS 响应头。</p>
<p>在 order 中启用 cross-origin 请求(即，<code>Origin</code>标头存在且与请求的 host 不同)，您需要有一些显式声明的 CORS configuration。如果未找到匹配的 CORS configuration，则拒绝预检请求。没有 CORS headers 被添加到简单和实际 CORS 请求的响应中，因此浏览器拒绝它们。</p>
<p>每个<code>HandlerMapping</code>可以_11单独使用 URL pattern-based <code>CorsConfiguration</code>映射。在大多数情况下，applications 使用 WebFlux Java configuration 来声明这样的映射，这会导致单个 global map 传递给所有<code>HadlerMappping</code> __mplement。</p>
<p>您可以将<code>HandlerMapping</code> level 上的 global CORS configuration 与更多 fine-grained，handler-level CORS configuration 结合使用。对于 example，带注释的控制器可以使用 class-或 method-level <code>@CrossOrigin</code> 注释(其他处理程序可以实现<code>CorsConfigurationSource</code>)。</p>
<p>组合 global 和 local configuration 的规则通常是加法的 - 例如，所有 global 和所有本地起源。对于只能接受单个 value 的属性，例如<code>allowCredentials</code>和<code>maxAge</code>，本地会覆盖 global value。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#mvc-cors-intro">CorsConfiguration#combine(CorsConfiguration)</a>。</p>
<blockquote>
<p>要从源中了解更多信息或进行高级自定义，请参阅：</p>
</blockquote>
<ul>
<li><code>CorsConfiguration</code></li>
<li><code>CorsProcessor</code>和<code>DefaultCorsProcessor</code></li>
<li><code>AbstractHandlerMapping</code></li>
</ul>
<h4 id="1-7-3-CrossOrigin"><a href="#1-7-3-CrossOrigin" class="headerlink" title="1.7.3. @CrossOrigin"></a>1.7.3. @CrossOrigin</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#feat=cors">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html">@CrossOrigin</a> annotation 在带注释的控制器方法上启用 cross-origin 请求，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Void&gt; remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>@CrossOrigin</code>允许：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li>控制器方法映射到的所有 HTTP 方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它会建立一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的时候使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<p>class level 也支持<code>@CrossOrigin</code>，并且由所有方法继承。以下 example 指定某个域并_set <code>maxAge</code>到一小时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins &#x3D; &quot;http:&#x2F;&#x2F;domain2.com&quot;, maxAge &#x3D; 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Void&gt; remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在 class 和方法 level 中使用<code>@CrossOrigin</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(maxAge &#x3D; 3600) (1)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin(&quot;http:&#x2F;&#x2F;domain2.com&quot;) (2)</span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Account&gt; retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Mono&lt;Void&gt; remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>在 class level 上使用<code>@CrossOrigin</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>在 level 方法中使用<code>@CrossOrigin</code>。</td>
</tr>
</tbody></table>
<h4 id="1-7-4-Global-Configuration"><a href="#1-7-4-Global-Configuration" class="headerlink" title="1.7.4. Global Configuration"></a>1.7.4. Global Configuration</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-cors-processing">与 Spring MVC 相同</a></p>
<p>除了 fine-grained，controller method-level configuration 之外，您可能还想定义一些 global CORS configuration。您可以在任何<code>HandlerMapping</code>上单独设置 URL-based <code>CorsConfiguration</code>映射。但是，大多数 applications 都使用 WebFlux Java configuration 来实现这一点。</p>
<p>默认情况下 global configuration 启用以下内容：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li><code>GET</code>，<code>HEAD</code>和<code>POST</code>方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它会建立一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的时候使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<p>要在 WebFlux Java configuration 中启用 CORS，可以使用<code>CorsRegistry</code>回调，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;api&#x2F;**&quot;)</span><br><span class="line">            .allowedOrigins(&quot;http:&#x2F;&#x2F;domain2.com&quot;)</span><br><span class="line">            .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)</span><br><span class="line">            .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)</span><br><span class="line">            .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)</span><br><span class="line">            .allowCredentials(true).maxAge(3600);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Add more mappings...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-5-CORS-WebFilter"><a href="#1-7-5-CORS-WebFilter" class="headerlink" title="1.7.5. CORS WebFilter"></a>1.7.5. CORS WebFilter</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#setCorsConfigurations-java.util.Map-">与 Spring MVC 相同</a></p>
<p>您可以通过 built-in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/reactive/CorsWebFilter.html">CorsWebFilter</a>应用 CORS 支持，这非常适合<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#combine-org.springframework.web.cors.CorsConfiguration-">功能 endpoints</a>。</p>
<p>要配置过滤器，可以声明<code>CorsWebFilter</code> bean 并将<code>CorsConfigurationSource</code>传递给其构造函数，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">CorsWebFilter corsFilter() &#123;</span><br><span class="line"></span><br><span class="line">    CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Possibly...</span><br><span class="line">    &#x2F;&#x2F; config.applyPermitDefaultValues()</span><br><span class="line"></span><br><span class="line">    config.setAllowCredentials(true);</span><br><span class="line">    config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;domain1.com&quot;);</span><br><span class="line">    config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">    config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">    UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">    source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">    return new CorsWebFilter(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-Web-安全"><a href="#1-8-Web-安全" class="headerlink" title="1.8. Web 安全"></a>1.8. Web 安全</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-cors-controller">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security/">Spring Security</a>项目支持保护 web applications 免受恶意攻击。请参阅 Spring Security reference 文档，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-cors-global">WebFlux 安全</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-cors-filter">WebFlux 测试支持</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-fn">CSRF 保护</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-web-security">安全响应 Headers</a></li>
</ul>
<h3 id="1-9-查看技术"><a href="#1-9-查看技术" class="headerlink" title="1.9. 查看技术"></a>1.9. 查看技术</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#jc-webflux">与 Spring MVC 相同</a></p>
<p>在 Spring WebFlux 中使用视图技术是可插拔的。您是否决定使用 Thymeleaf，FreeMarker 或其他一些视图技术主要是配置更改的问题。本章介绍与 Spring WebFlux 集成的视图技术。我们假设您已经熟悉<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#test-webflux">查看分辨率</a>。</p>
<h4 id="1-9-1-Thymeleaf"><a href="#1-9-1-Thymeleaf" class="headerlink" title="1.9.1. Thymeleaf"></a>1.9.1. Thymeleaf</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#csrf">与 Spring MVC 相同</a></p>
<p>Thymeleaf 是一个现代的 server-side Java 模板引擎，它强调自然的 HTML 模板，可以通过 double-clicking 在浏览器中预览，这对于 UI 模板的独立工作非常有用(例如，设计者)，而不需要运行服务器。 Thymeleaf 提供了广泛的 features，并且积极开发和维护。有关更完整的介绍，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
<p>与 Spring WebFlux 的 Thymeleaf integration 由 Thymeleaf 项目管理。 configuration 涉及一些 bean 声明，例如<code>SpringResourceTemplateResolver</code>，<code>SpringWebFluxTemplateEngine</code>和<code>ThymeleafReactiveViewResolver</code>。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/documentation.html">Thymeleaf Spring</a>和 WebFlux integration <a target="_blank" rel="noopener" href="http://forum.thymeleaf.org/Thymeleaf-3-0-8-JUST-PUBLISHED-td4030687.html">公告</a>。</p>
<h4 id="1-9-2-FreeMarker"><a href="#1-9-2-FreeMarker" class="headerlink" title="1.9.2. FreeMarker"></a>1.9.2. FreeMarker</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#headers">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="http://www.freemarker.org/">Apache FreeMarker</a>是一个模板引擎，用于生成从 HTML 到电子邮件和其他人的任何类型的文本输出。 Spring Framework 有一个 built-in integration 用于将 Spring WebFlux 与 FreeMarker 模板一起使用。</p>
<h5 id="查看-Configuration"><a href="#查看-Configuration" class="headerlink" title="查看 Configuration"></a>查看 Configuration</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何将 FreeMarker 配置为视图技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.freemarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Configure FreeMarker...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer &#x3D; new FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(&quot;classpath:&#x2F;templates&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您的模板需要存储在<code>FreeMarkerConfigurer</code>指定的目录中，如前面的 example 所示。给定前面的 configuration，如果控制器返回视图 name，<code>welcome</code>，解析器将查找<code>classpath:/templates/freemarker/welcome.ftl</code>模板。</p>
<h5 id="FreeMarker-Configuration"><a href="#FreeMarker-Configuration" class="headerlink" title="FreeMarker Configuration"></a>FreeMarker Configuration</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-viewresolution">与 Spring MVC 相同</a></p>
<p>您可以通过在<code>FreeMarkerConfigurer</code> bean 上设置相应的 bean properties，将 FreeMarker 的“设置”和“SharedVariables”直接传递给 FreeMarker <code>Configuration</code> object(由 Spring 管理)。 <code>freemarkerSettings</code> property 需要<code>java.util.Properties</code> object，而<code>freemarkerVariables</code> property 需要<code>java.util.Map</code>。以下 example 显示了如何使用<code>FreeMarkerConfigurer</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        Map&lt;String, Object&gt; variables &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        variables.put(&quot;xml_escape&quot;, new XmlEscape());</span><br><span class="line"></span><br><span class="line">        FreeMarkerConfigurer configurer &#x3D; new FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(&quot;classpath:&#x2F;templates&quot;);</span><br><span class="line">        configurer.setFreemarkerVariables(variables);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关适用于<code>Configuration</code> object 的设置和变量的详细信息，请参阅 FreeMarker 文档。</p>
<h4 id="1-9-3-脚本视图"><a href="#1-9-3-脚本视图" class="headerlink" title="1.9.3. 脚本视图"></a>1.9.3. 脚本视图</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view-thymeleaf">与 Spring MVC 相同</a></p>
<p>Spring Framework 有一个 built-in integration，可以使用 Spring WebFlux 和任何可以在<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java 脚本引擎上运行的模板 library。以下 table 显示了我们在不同脚本引擎上测试的模板 libraries：</p>
<table>
<thead>
<tr>
<th>脚本 Library</th>
<th>脚本引擎</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://handlebarsjs.com/">把手</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mustache.github.io/">胡子</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://facebook.github.io/react/">应对</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.embeddedjs.com/">EJS</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.stuartellis.eu/articles/erb/">ERB</a></td>
<td><a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/string.html#mvc-view-freemarker">String 模板</a></td>
<td><a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin 脚本模板</a></td>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/">Kotlin</a></td>
</tr>
</tbody></table>
<blockquote>
<p>集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。</p>
</blockquote>
<h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view-freemarker-contextconfig">与 Spring MVC 相同</a></p>
<p>您需要在 classpath 上安装脚本引擎，其详细信息因脚本引擎而异：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a> JavaScript 引擎随 Java 8 一起提供。强烈建议使用最新的更新版本。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a>作为 Ruby 支持的依赖项。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a>作为 Python 支持的依赖项。</li>
<li>应为 Kotlin 脚本支持添加<code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和包含<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code> line 的<code>META-INF/services/javax.script.ScriptEngineFactory</code>文件。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">这个 example</a>。</li>
</ul>
<p>你需要有脚本模板 library。对 Javascript 执行此操作的一种方法是通过<a target="_blank" rel="noopener" href="http://www.webjars.org/">WebJars</a>。</p>
<h5 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-views-freemarker">与 Spring MVC 相同</a></p>
<p>您可以声明<code>ScriptTemplateConfigurer</code> bean 来指定要使用的脚本引擎，要加载的脚本 files，要调用渲染模板的 function，等等。以下 example 使用 Mustache 模板和 Nashorn JavaScript 引擎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ScriptTemplateConfigurer configurer() &#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer &#x3D; new ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(&quot;nashorn&quot;);</span><br><span class="line">        configurer.setScripts(&quot;mustache.js&quot;);</span><br><span class="line">        configurer.setRenderObject(&quot;Mustache&quot;);</span><br><span class="line">        configurer.setRenderFunction(&quot;render&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用以下参数调用<code>render</code> function：</p>
<ul>
<li><code>String template</code>：模板内容</li>
<li><code>Map model</code>：视图 model</li>
<li><code>RenderingContext renderingContext</code>：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html">RenderingContext</a>可以访问 application context，locale，模板加载器和 URL(自 5.0 以来)</li>
</ul>
<p><code>Mustache.render()</code>本身与此签名兼容，因此您可以直接调用它。</p>
<p>如果您的模板技术需要一些自定义，您可以提供实现自定义 render function 的脚本。例如，<a target="_blank" rel="noopener" href="http://handlebarsjs.com/">Handlerbars</a>需要在使用它们之前编译模板，并且需要<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polyfill">填充工具</a> in order 来模拟 server-side 脚本引擎中不可用的某些浏览器工具。以下 example 显示了如何设置自定义 render function：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ScriptTemplateConfigurer configurer() &#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer &#x3D; new ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(&quot;nashorn&quot;);</span><br><span class="line">        configurer.setScripts(&quot;polyfill.js&quot;, &quot;handlebars.js&quot;, &quot;render.js&quot;);</span><br><span class="line">        configurer.setRenderFunction(&quot;render&quot;);</span><br><span class="line">        configurer.setSharedEngine(false);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将 non-thread-safe property 设置为<code>false</code>是必需的，因为 non-thread-safe 脚本引擎的模板 libraries 不是为并发而设计的，例如 Handlebars 或 Nactorn 上的 React running。在这种情况下，由于<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8076099">这个 bug</a>，需要 Java 8u60 或更高版本。</p>
</blockquote>
<p><code>polyfill.js</code>仅定义 Handlebars 正确运行所需的<code>window</code> object，如下面的代码段所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var window &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这个基本的<code>render.js</code> implementation 在使用之前编译模板。 production ready implementation 还应该 store 并重用缓存的模板或 pre-compiled 模板。这可以在脚本端完成，也可以完成所需的任何自定义(管理 example 的模板引擎 configuration)。以下 example 显示了如何编译模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render(template, model) &#123;</span><br><span class="line">    var compiledTemplate &#x3D; Handlebars.compile(template);</span><br><span class="line">    return compiledTemplate(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看 Spring Framework 单元测试，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/java/org/springframework/web/reactive/result/view/script">Java</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux/src/test/resources/org/springframework/web/reactive/result/view/script">资源</a>，了解更多 configuration 示例。</p>
<h4 id="1-9-4-JSON-和-XML"><a href="#1-9-4-JSON-和-XML" class="headerlink" title="1.9.4. JSON 和 XML"></a>1.9.4. JSON 和 XML</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view-script">与 Spring MVC 相同</a></p>
<p>出于<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#template-strings">内容谈判</a>目的，根据 client 请求的 content type，能够在使用 HTML 模板或其他格式(如 JSON 或 XML)呈现 model 之间进行交替是很有用的。为了支持这样做，Spring WebFlux 提供<code>HttpMessageWriterView</code>，您可以使用它来插入<code>spring-web</code>中的任何可用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-view-script-dependencies">编解码器</a>，例如<code>Jackson2JsonEncoder</code>，<code>Jackson2SmileEncoder</code>或<code>Jaxb2XmlEncoder</code>。</p>
<p>与其他视图技术不同，<code>HttpMessageWriterView</code>不需要<code>ViewResolver</code>，而是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-view-script-integrate">配置</a>作为默认视图。您可以配置一个或多个此类默认视图，包装不同的<code>HttpMessageWriter</code>实例或<code>Encoder</code>实例。匹配请求的 content type 的那个在运行时使用。</p>
<p>在大多数情况下，model 包含多个属性。要确定要序列化的序列，可以使用 model 属性的 name 配置<code>HttpMessageWriterView</code>以用于呈现。如果 model 只包含一个属性，则使用该属性。</p>
<h3 id="1-10-HTTP-缓存"><a href="#1-10-HTTP-缓存" class="headerlink" title="1.10. HTTP 缓存"></a>1.10. HTTP 缓存</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view-jackson">与 Spring MVC 相同</a></p>
<p>HTTP 缓存可以显着改善 web application 的 performance。 HTTP 缓存围绕<code>Cache-Control</code>响应头和随后的条件请求 headers，例如<code>Last-Modified</code>和<code>ETag</code>。 <code>Cache-Control</code>建议私有(对于 example，浏览器)和 public(对于 example，代理)缓存如何缓存和 re-use 响应。如果内容未更改，<code>ETag</code>标头用于生成条件请求，该请求可能导致 304(NOT_MODIFIED)没有正文。 <code>ETag</code>可以被视为<code>Last-Modified</code>标题的更复杂的继承者。</p>
<p>本节介绍 Spring WebFlux 中可用的 HTTP 缓存相关选项。</p>
<h4 id="1-10-1-CacheControl"><a href="#1-10-1-CacheControl" class="headerlink" title="1.10.1. CacheControl"></a>1.10.1. CacheControl</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-multiple-representations">与 Spring MVC 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/CacheControl.html">CacheControl</a>支持配置与<code>Cache-Control</code>标头相关的设置，并且在许多地方被接受为参数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">控制器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-view-resolvers">静态资源</a></li>
</ul>
<p>虽然<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234#mvc-caching">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用了一种使用 case-oriented 方法，该方法专注于 common 场景，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Cache for an hour - &quot;Cache-Control: max-age&#x3D;3600&quot;</span><br><span class="line">CacheControl ccCacheOneHour &#x3D; CacheControl.maxAge(1, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevent caching - &quot;Cache-Control: no-store&quot;</span><br><span class="line">CacheControl ccNoStore &#x3D; CacheControl.noStore();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Cache for ten days in public and private caches,</span><br><span class="line">&#x2F;&#x2F; public caches should not transform the response</span><br><span class="line">&#x2F;&#x2F; &quot;Cache-Control: max-age&#x3D;864000, public, no-transform&quot;</span><br><span class="line">CacheControl ccCustom &#x3D; CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</span><br></pre></td></tr></table></figure>

<h4 id="1-10-2-控制器"><a href="#1-10-2-控制器" class="headerlink" title="1.10.2. 控制器"></a>1.10.2. 控制器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-caching-cachecontrol">与 Spring MVC 相同</a></p>
<p>控制器可以添加对 HTTP 缓存的显式支持。我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>value 需要先计算才能与条件请求 headers 进行比较。控制器可以将<code>ETag</code>和<code>Cache-Control</code>设置添加到<code>ResponseEntity</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;book&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">    Book book &#x3D; findBook(id);</span><br><span class="line">    String version &#x3D; book.getVersion();</span><br><span class="line"></span><br><span class="line">    return ResponseEntity</span><br><span class="line">            .ok()</span><br><span class="line">            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))</span><br><span class="line">            .eTag(version) &#x2F;&#x2F; lastModified is also available</span><br><span class="line">            .body(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果与条件请求 headers 的比较表明内容未更改，则前面的 example 将使用空主体发送 304(NOT_MODIFIED)响应。否则，<code>ETag</code>和<code>Cache-Control</code> headers 将添加到响应中。</p>
<p>您还可以在控制器中对条件请求 headers 进行检查，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping</span><br><span class="line">public String myHandleMethod(ServerWebExchange exchange, Model model) &#123;</span><br><span class="line"></span><br><span class="line">    long eTag &#x3D; ... (1)</span><br><span class="line"></span><br><span class="line">    if (exchange.checkNotModified(eTag)) &#123;</span><br><span class="line">        return null; (2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(...); (3)</span><br><span class="line">    return &quot;myViewName&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>Application-specific 计算。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>响应已设置为 304(NOT_MODIFIED)。没有进一步处理。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>继续请求处理。</td>
</tr>
</tbody></table>
<p>有三种变体可用于检查针对<code>eTag</code>值，<code>lastModified</code>值或两者的条件请求。对于条件<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为 304(NOT_MODIFIED)。对于条件<code>POST</code>，<code>PUT</code>和<code>DELETE</code>，您可以将响应设置为 409(PRECONDITION_FAILED)以防止并发修改。</p>
<h4 id="1-10-3-静态资源"><a href="#1-10-3-静态资源" class="headerlink" title="1.10.3. 静态资源"></a>1.10.3. 静态资源</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-caching-etag-lastmodified">与 Spring MVC 相同</a></p>
<p>您应该使用<code>Cache-Control</code>和条件响应 headers 为静态资源提供最佳的 performance。请参阅有关配置<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-caching-static-resources">静态资源</a>的部分。</p>
<h3 id="1-11-WebFlux-配置"><a href="#1-11-WebFlux-配置" class="headerlink" title="1.11. WebFlux 配置"></a>1.11. WebFlux 配置</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#section-5.2.2">与 Spring MVC 相同</a></p>
<p>WebFlux Java configuration 声明了使用带注释的控制器或函数 endpoints 处理请求所需的组件，并且它提供了一个 API 来自定义 configuration。这意味着您不需要了解 Java configuration 创建的底层 beans。但是，如果您想了解它们，可以在<code>WebFluxConfigurationSupport</code>中查看它们，或者阅读更多关于它们在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-caching-etag-lastmodified">特殊的 Bean 类型</a>中的内容。</p>
<p>对于 configuration API 中未提供的更高级自定义，您可以通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-caching-static-resources">高级配置模式</a>完全控制 configuration。</p>
<h4 id="1-11-1-启用-WebFlux-配置"><a href="#1-11-1-启用-WebFlux-配置" class="headerlink" title="1.11.1. 启用 WebFlux 配置"></a>1.11.1. 启用 WebFlux 配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-static-resources">与 Spring MVC 相同</a></p>
<p>您可以在 Java 配置中使用<code>@EnableWebFlux</code> annotation，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面的 example 注册了一些 Spring WebFlux <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config">基础设施 beans</a>并适应了 classpath 上可用的依赖项 - 适用于 JSON，XML 和其他。</p>
<h4 id="1-11-2-WebFlux-配置-API"><a href="#1-11-2-WebFlux-配置-API" class="headerlink" title="1.11.2. WebFlux 配置 API"></a>1.11.2. WebFlux 配置 API</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-special-bean-types">与 Spring MVC 相同</a></p>
<p>在 Java configuration 中，您可以实现<code>WebFluxConfigurer</code>接口，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Implement configuration methods...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-3-转换，格式化"><a href="#1-11-3-转换，格式化" class="headerlink" title="1.11.3. 转换，格式化"></a>1.11.3. 转换，格式化</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-advanced-java">与 Spring MVC 相同</a></p>
<p>默认情况下，会安装<code>Number</code>和<code>Date</code>类型的格式化程序，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code> 注释的支持。如果 class 路径中存在 Joda-Time，则还会安装对 Joda-Time 格式 library 的完全支持。</p>
<p>以下 example 显示了如何注册自定义格式化程序和转换器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关何时使用<code>FormatterRegistrar</code> implementations 的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-config-enable">FormatterRegistrar SPI</a>和<code>FormattingConversionServiceFactoryBean</code>。</p>
</blockquote>
<h4 id="1-11-4-验证"><a href="#1-11-4-验证" class="headerlink" title="1.11.4. 验证"></a>1.11.4. 验证</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-webflux-special-bean-types">与 Spring MVC 相同</a></p>
<p>默认情况下，如果 class 路径上存在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-config-customize">Bean 验证</a>(对于 example，Hibernate Validator)，则<code>LocalValidatorFactoryBean</code>将注册为 global <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-config-conversion">验证器</a>，以便在<code>@Controller</code> method arguments 上与<code>@Valid</code>和<code>Validated</code>一起使用。</p>
<p>在 Java configuration 中，您可以自定义 global <code>Validator</code>实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Validator getValidator(); &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，您还可以在本地注册<code>Validator</code> implementations，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder</span><br><span class="line">    protected void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        binder.addValidators(new FooValidator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果需要在某处注入<code>LocalValidatorFactoryBean</code>，请创建 bean 并在 order 中使用<code>@Primary</code>标记它以避免与 MVC 配置中声明的冲突。</p>
</blockquote>
<h4 id="1-11-5-Content-Type-解析器"><a href="#1-11-5-Content-Type-解析器" class="headerlink" title="1.11.5. Content Type 解析器"></a>1.11.5. Content Type 解析器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#format-FormatterRegistrar-SPI">与 Spring MVC 相同</a></p>
<p>您可以配置 Spring WebFlux 如何从请求中确定<code>@Controller</code>实例的请求媒体类型。默认情况下，仅选中<code>Accept</code>标头，但您也可以启用查询 parameter-based 策略。</p>
<p>以下 example 显示了如何自定义请求的 content type 解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-6-HTTP-消息编解码器"><a href="#1-11-6-HTTP-消息编解码器" class="headerlink" title="1.11.6. HTTP 消息编解码器"></a>1.11.6. HTTP 消息编解码器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-validation">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何自定义读取和写入请求和响应主体的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ServerCodecConfigurer</code>提供了一组默认的 readers 和 writers。您可以使用它来添加更多 readers 和 writers，自定义默认值，或完全替换默认值。</p>
<p>对于 Jackson JSON 和 XML，请考虑使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html">Jackson2ObjectMapperBuilder</a>，它使用以下方法自定义 Jackson 的默认 properties：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#validation-beanvalidation-overview">DeserializationFeature.FAIL_ON_UNKNOWNPROPERTIES</a>已禁用。</li>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#validator">MapperFeature.DEFAULT_VIEW_INCLUSION</a>已禁用。</li>
</ul>
<p>如果在 classpath 上检测到以下 well-known 模块，它还会自动注册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>：支持 Java 7 类型，如<code>java.nio.file.Path</code>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>：支持 Joda-Time 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>：支持 Java 8 Date 和 Time API 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>：支持其他 Java 8 类型，例如<code>Optional</code>。</li>
</ul>
<h4 id="1-11-7-查看解析器"><a href="#1-11-7-查看解析器" class="headerlink" title="1.11.7. 查看解析器"></a>1.11.7. 查看解析器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-content-negotiation">与 Spring MVC 相同</a></p>
<p>以下 example 显示了如何配置视图分辨率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ViewResolverRegistry</code>具有 Spring Framework 集成的视图技术的快捷方式。以下 example 使用 FreeMarker(还需要配置基础 FreeMarker 视图技术)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.freeMarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Configure Freemarker...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer &#x3D; new FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(&quot;classpath:&#x2F;templates&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您还可以插入任何<code>ViewResolver</code> implementation，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        ViewResolver resolver &#x3D; ... ;</span><br><span class="line">        registry.viewResolver(resolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要支持<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-message-converters">内容谈判</a>并通过视图解析(除了 HTML)呈现其他格式，您可以基于<code>HttpMessageWriterView</code> implementation 配置一个或多个默认视图，该视图接受来自<code>spring-web</code>的任何可用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#FAIL_ON_UNKNOWN_PROPERTIES">编解码器</a>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.freeMarker();</span><br><span class="line"></span><br><span class="line">        Jackson2JsonEncoder encoder &#x3D; new Jackson2JsonEncoder();</span><br><span class="line">        registry.defaultViews(new HttpMessageWriterView(encoder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关与 Spring WebFlux 集成的视图技术的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#DEFAULT_VIEW_INCLUSION">查看技术</a>。</p>
<h4 id="1-11-8-静态资源"><a href="#1-11-8-静态资源" class="headerlink" title="1.11.8. 静态资源"></a>1.11.8. 静态资源</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-view-resolvers">与 Spring MVC 相同</a></p>
<p>此选项提供了一种从<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/Resource.html">资源</a> -based 位置列表中提供静态资源的便捷方法。</p>
<p>在下一个示例中，给定以<code>/resources</code>开头的请求，相对路径用于在 classpath 上查找和提供相对于<code>/static</code>的静态资源。资源的使用期限为 one-year，以确保最大程度地使用浏览器缓存并减少浏览器发出的 HTTP 请求。还会评估<code>Last-Modified</code>标头，如果存在，则返回<code>304</code> status code。以下列表显示了 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;resources&#x2F;**&quot;)</span><br><span class="line">            .addResourceLocations(&quot;&#x2F;public&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;)</span><br><span class="line">            .setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>资源处理程序还支持<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceResolver.html">ResourceResolver</a> __mplementations 和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/resource/ResourceTransformer.html">ResourceTransformer</a> __mplementations 链，可用于创建工具链以使用优化的资源。</p>
<p>您可以根据从内容计算的 MD5 哈希，固定的 application version 或其他信息，将<code>VersionResourceResolver</code>用于版本化资源 URL。对于一些值得注意的 exceptions(例如与模块加载器一起使用的 JavaScript 资源)，<code>ContentVersionStrategy</code>(MD5 哈希)是一个不错的选择。</p>
<p>以下 example 显示了如何在 Java configuration 中使用<code>VersionResourceResolver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;resources&#x2F;**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;&#x2F;public&#x2F;&quot;)</span><br><span class="line">                .resourceChain(true)</span><br><span class="line">                .addResolver(new VersionResourceResolver().addContentVersionStrategy(&quot;&#x2F;**&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以使用<code>ResourceUrlProvider</code>来 rewrite URL 并应用完整的解析器和变换器链(对于 example，为 insert 版本)。 WebFlux configuration 提供<code>ResourceUrlProvider</code>，以便可以将其注入其他人。</p>
<p>与 Spring MVC 不同，目前，在 WebFlux 中，没有办法透明地编写静态资源 URL，因为没有可以使用 non-blocking 链解析器和变换器的视图技术。仅提供本地资源时，解决方法是直接使用<code>ResourceUrlProvider</code>(对于 example，通过自定义元素)和阻止。</p>
<p>请注意，当同时使用<code>EncodedResourceResolver</code>(对于 example，Gzip，Brotli 编码)和<code>VersionedResourceResolver</code>时，必须在该 order 中注册它们，以确保始终基于未编码的文件可靠地计算 content-based 版本。</p>
<p><code>WebJarsResourceResolver</code>也通过<code>WebJarsResourceResolver</code>支持，并在 class 路径上存在<code>org.webjars:webjars-locator</code>时自动注册。解析器可以 re-write URL 包含 jar 的 version，也可以匹配到没有版本的传入 URL(对于 example，<code>/jquery/jquery.min.js</code>到<code>/jquery/1.2.0/jquery.min.js</code>)。</p>
<h4 id="1-11-9-路径匹配"><a href="#1-11-9-路径匹配" class="headerlink" title="1.11.9. 路径匹配"></a>1.11.9. 路径匹配</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-multiple-representations">与 Spring MVC 相同</a></p>
<p>您可以自定义与路径匹配相关的选项。有关各个选项的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/config/PathMatchConfigurer.html">PathMatchConfigurer</a> javadoc。以下 example 显示了如何使用<code>PathMatchConfigurer</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebFlux</span><br><span class="line">public class WebConfig implements WebFluxConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseCaseSensitiveMatch(true)</span><br><span class="line">            .setUseTrailingSlashMatch(false)</span><br><span class="line">            .addPathPrefix(&quot;&#x2F;api&quot;,</span><br><span class="line">                    HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Spring WebFlux 依赖于名为<code>RequestPath</code>的请求路径的解析表示，用于访问已解码的路径段值，并删除分号内容(即路径或矩阵变量)。这意味着，与 Spring MVC 不同，您无需指示是否解码请求路径，也不需要删除分号内容以进行路径匹配。</p>
</blockquote>
<p>Spring WebFlux 也不支持后缀 pattern 匹配，不像 Spring MVC，我们也不再依赖它。</p>
<h4 id="1-11-10-高级配置模式"><a href="#1-11-10-高级配置模式" class="headerlink" title="1.11.10. 高级配置模式"></a>1.11.10. 高级配置模式</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-codecs">与 Spring MVC 相同</a></p>
<p><code>@EnableWebFlux</code>进口<code>DelegatingWebFluxConfiguration</code>：</p>
<ul>
<li>为 WebFlux applications 提供默认的 Spring configuration</li>
<li>检测并委托<code>WebFluxConfigurer</code> implementations 来自定义 configuration。</li>
</ul>
<p>对于高级模式，您可以删除<code>@EnableWebFlux</code>并直接从<code>DelegatingWebFluxConfiguration</code>扩展而不是实现<code>WebFluxConfigurer</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig extends DelegatingWebFluxConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您可以在<code>WebConfig</code>中保留现有方法，但现在您也可以从 base class 覆盖 bean 声明，并且在 classpath 上仍然有任意数量的其他<code>WebMvcConfigurer</code> __mplement。</p>
<h3 id="1-12-HTTP-2"><a href="#1-12-HTTP-2" class="headerlink" title="1.12. HTTP/2"></a>1.12. HTTP/2</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-view">与 Spring MVC 相同</a></p>
<p>Servlet 4 容器需要支持 HTTP/2，而 Spring Framework 5 与 Servlet API 兼容 4.从编程 model 的角度来看，没有特定的 applications 需要做的事情。但是，有一些与 server configuration 相关的注意事项。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 维基页面</a>。</p>
<p>目前，Spring WebFlux 不支持 HTTP/2 与 Netty。也没有支持以编程方式将资源推送到 client。</p>
<h2 id="2-WebClient"><a href="#2-WebClient" class="headerlink" title="2. WebClient"></a>2. WebClient</h2><p>Spring WebFlux 包含 reactive，non-blocking <code>WebClient</code>用于 HTTP 请求。 client 有一个函数式 fluent API，其中 reactive 类型用于声明性组合，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-static-resources">Reactive Libraries</a>。 WebFlux client 和服务器依赖相同的 non-blocking <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-path-matching">编解码器</a>来编码和解码请求和响应内容。</p>
<p>内部<code>WebClient</code>委托给 HTTP client library。默认情况下，它使用<a target="_blank" rel="noopener" href="https://github.com/reactor/reactor-netty">反应堆 Netty</a>，Jetty <a target="_blank" rel="noopener" href="https://github.com/jetty-project/jetty-reactive-httpclient">reactive HtpClient</a>有 built-in 支持，其他可以通过<code>ClientHttpConnector</code>插入。</p>
<h3 id="2-1-组态"><a href="#2-1-组态" class="headerlink" title="2.1. 组态"></a>2.1. 组态</h3><p>创建<code>WebClient</code>的最简单方法是通过一个静态工厂方法：</p>
<ul>
<li><code>WebClient.create()</code></li>
<li><code>WebClient.create(String baseUrl)</code></li>
</ul>
<p>上述方法使用 Reactor Netty <code>HttpClient</code>和默认设置，并期望<code>io.projectreactor.netty:reactor-netty</code>在 classpath 上。</p>
<p>您还可以将<code>WebClient.builder()</code>与其他选项一起使用：</p>
<ul>
<li><code>uriBuilderFactory</code>：自定义<code>UriBuilderFactory</code>以用作基本 URL。</li>
<li>每个请求都<code>defaultHeader</code>：Headers。</li>
<li><code>defaultCookie</code>：Cookies 为每个请求。</li>
<li><code>defaultRequest</code>：<code>Consumer</code>来自定义每个请求。</li>
<li><code>filter</code>：Client 过滤每个请求。</li>
<li><code>exchangeStrategies</code>：HTTP 消息 reader/writer 自定义。</li>
<li><code>clientConnector</code>：HTTP client library 设置。</li>
</ul>
<p>以下 example 配置<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestmapping-suffix-pattern-match">HTTP 编解码器</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExchangeStrategies strategies &#x3D; ExchangeStrategies.builder()</span><br><span class="line">            .codecs(configurer -&gt; &#123;</span><br><span class="line">                &#x2F;&#x2F; ...</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    WebClient client &#x3D; WebClient.builder()</span><br><span class="line">            .exchangeStrategies(strategies)</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<p>构建后，<code>WebClient</code>实例是不可变的。但是，您可以克隆它并 build 修改后的副本而不会影响原始实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WebClient client1 &#x3D; WebClient.builder()</span><br><span class="line">            .filter(filterA).filter(filterB).build();</span><br><span class="line"></span><br><span class="line">    WebClient client2 &#x3D; client1.mutate()</span><br><span class="line">            .filter(filterC).filter(filterD).build();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; client1 has filterA, filterB</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; client2 has filterA, filterB, filterC, filterD</span><br></pre></td></tr></table></figure>

<h4 id="2-1-1-反应堆-Netty"><a href="#2-1-1-反应堆-Netty" class="headerlink" title="2.1.1. 反应堆 Netty"></a>2.1.1. 反应堆 Netty</h4><p>要自定义 Reactor Netty 设置，只需提供 pre-configured <code>HttpClient</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient &#x3D; HttpClient.create().secure(sslSpec -&gt; ...);</span><br><span class="line"></span><br><span class="line">    WebClient webClient &#x3D; WebClient.builder()</span><br><span class="line">            .clientConnector(new ReactorClientHttpConnector(httpClient))</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>

<h5 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h5><p>默认情况下，<code>HttpClient</code>参与<code>reactor.netty.http.HttpResources</code>中保存的 global Reactor Netty 资源，包括 event 循环线程和连接池。这是推荐的模式，因为固定的共享资源是 event 循环并发的首选。在这种模式下， global 资源保持 active，直到 process 退出。</p>
<p>如果服务器与 process 同步，则通常不需要显式关闭。但是，如果服务器可以启动或停止 in-process(对于示例，Spring MVC application 部署为 WAR)，您可以使用<code>globalResources=true</code>(默认值)声明类型为<code>ReactorResourceFactory</code>的 Spring-managed bean，以确保关闭 Reactor Netty global 资源当 Spring <code>ApplicationContext</code>关闭时，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public ReactorResourceFactory reactorResourceFactory() &#123;</span><br><span class="line">        return new ReactorResourceFactory();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>您也可以选择不参与 global Reactor Netty 资源。但是，在此模式下，您需要确保所有 Reactor Netty client 和服务器实例都使用共享资源，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public ReactorResourceFactory resourceFactory() &#123;</span><br><span class="line">        ReactorResourceFactory factory &#x3D; new ReactorResourceFactory();</span><br><span class="line">        factory.setGlobalResources(false); (1)</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebClient webClient() &#123;</span><br><span class="line"></span><br><span class="line">        Function&lt;HttpClient, HttpClient&gt; mapper &#x3D; client -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; Further customizations...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ClientHttpConnector connector &#x3D;</span><br><span class="line">                new ReactorClientHttpConnector(resourceFactory(), mapper); (2)</span><br><span class="line"></span><br><span class="line">        return WebClient.builder().clientConnector(connector).build(); (3)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>创建独立于 global 资源的资源。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将<code>ReactorClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>将连接器插入<code>WebClient.Builder</code>。</td>
</tr>
</tbody></table>
<h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p>配置连接超时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.channel.ChannelOption;</span><br><span class="line"></span><br><span class="line">HttpClient httpClient &#x3D; HttpClient.create()</span><br><span class="line">        .tcpConfiguration(client -&gt;</span><br><span class="line">                client.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000));</span><br></pre></td></tr></table></figure>

<p>配置读 and/or 写超时值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import io.netty.handler.timeout.ReadTimeoutHandler;</span><br><span class="line">import io.netty.handler.timeout.WriteTimeoutHandler;</span><br><span class="line"></span><br><span class="line">HttpClient httpClient &#x3D; HttpClient.create()</span><br><span class="line">        .tcpConfiguration(client -&gt;</span><br><span class="line">                client.doOnConnected(conn -&gt; conn</span><br><span class="line">                        .addHandlerLast(new ReadTimeoutHandler(10))</span><br><span class="line">                        .addHandlerLast(new WriteTimeoutHandler(10))));</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-码头"><a href="#2-1-2-码头" class="headerlink" title="2.1.2. 码头"></a>2.1.2. 码头</h4><p>以下 example 显示了如何自定义 Jetty <code>HttpClient</code>设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HttpClient httpClient &#x3D; new HttpClient();</span><br><span class="line">    httpClient.setCookieStore(...);</span><br><span class="line">    ClientHttpConnector connector &#x3D; new JettyClientHttpConnector(httpClient);</span><br><span class="line"></span><br><span class="line">    WebClient webClient &#x3D; WebClient.builder().clientConnector(connector).build();</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>HttpClient</code>创建自己的资源(<code>Executor</code>，<code>ByteBufferPool</code>，<code>Scheduler</code>)，这些资源在 process 退出或<code>stop()</code>被调用之前保持 active。</p>
<p>您可以在 Jetty client(和服务器)的多个实例之间共享资源，并通过声明类型<code>JettyResourceFactory</code>的 Spring-managed bean 来确保在关闭 Spring <code>ApplicationContext</code>时关闭资源，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">    public JettyResourceFactory resourceFactory() &#123;</span><br><span class="line">        return new JettyResourceFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebClient webClient() &#123;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;HttpClient&gt; customizer &#x3D; client -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; Further customizations...</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        ClientHttpConnector connector &#x3D;</span><br><span class="line">                new JettyClientHttpConnector(resourceFactory(), customizer); (1)</span><br><span class="line"></span><br><span class="line">        return WebClient.builder().clientConnector(connector).build(); (2)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>将<code>JettyClientHttpConnector</code>构造函数与资源工厂一起使用。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将连接器插入<code>WebClient.Builder</code>。</td>
</tr>
</tbody></table>
<h3 id="2-2-retrieve"><a href="#2-2-retrieve" class="headerlink" title="2.2. retrieve()"></a>2.2. retrieve()</h3><p><code>retrieve()</code>方法是获取响应主体并对其进行解码的最简单方法。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WebClient client &#x3D; WebClient.create(&quot;http:&#x2F;&#x2F;example.org&quot;);</span><br><span class="line"></span><br><span class="line">    Mono&lt;Person&gt; result &#x3D; client.get()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Person.class);</span><br></pre></td></tr></table></figure>

<p>您还可以获取从响应中解码的 objects 流，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Quote&gt; result &#x3D; client.get()</span><br><span class="line">            .uri(&quot;&#x2F;quotes&quot;).accept(MediaType.TEXT_EVENT_STREAM)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToFlux(Quote.class);</span><br></pre></td></tr></table></figure>

<p>默认情况下，具有 4xx 或 5xx 状态代码的响应会导致<code>WebClientResponseException</code>或其某个 HTTP 状态特定 sub-classes，例如<code>WebClientResponseException.BadRequest</code>，<code>WebClientResponseException.NotFound</code>等。您还可以使用<code>onStatus</code>方法自定义生成的 exception，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; result &#x3D; client.get()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .onStatus(HttpStatus::is4xxServerError, response -&gt; ...)</span><br><span class="line">            .onStatus(HttpStatus::is5xxServerError, response -&gt; ...)</span><br><span class="line">            .bodyToMono(Person.class);</span><br></pre></td></tr></table></figure>

<p>当使用<code>onStatus</code>时，如果预期响应具有内容，则<code>onStatus</code>回调应该使用它。如果没有，内容将自动耗尽，以确保释放资源。</p>
<h3 id="2-3-exchange"><a href="#2-3-exchange" class="headerlink" title="2.3. exchange()"></a>2.3. exchange()</h3><p><code>exchange()</code>方法提供比<code>retrieve</code>方法更多的控制。以下 example 等同于<code>retrieve()</code>，但也提供对<code>ClientResponse</code>的访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; result &#x3D; client.get()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(response -&gt; response.bodyToMono(Person.class));</span><br></pre></td></tr></table></figure>

<p>在此 level 中，您还可以创建一个完整的<code>ResponseEntity</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;ResponseEntity&lt;Person&gt;&gt; result &#x3D; client.get()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON)</span><br><span class="line">            .exchange()</span><br><span class="line">            .flatMap(response -&gt; response.toEntity(Person.class));</span><br></pre></td></tr></table></figure>

<p>请注意(与<code>retrieve()</code>不同)，<code>exchange()</code>，4xx 和 5xx 响应没有自动错误信号。您必须检查状态 code 并决定如何继续。</p>
<blockquote>
<p>使用<code>exchange()</code>时，必须始终使用<code>ClientResponse</code>的任何<code>body</code>或<code>toEntity</code>方法来确保释放资源并避免 HTTP 连接池的潜在问题。如果没有预期的响应内容，您可以使用<code>bodyToMono(Void.class)</code>。但是，如果响应确实包含内容，则连接将关闭，并且不会放回池中。</p>
</blockquote>
<h3 id="2-4-请求机构"><a href="#2-4-请求机构" class="headerlink" title="2.4. 请求机构"></a>2.4. 请求机构</h3><p>请求正文可以从<code>Object</code>编码，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Person&gt; personMono &#x3D; ... ;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .body(personMono, Person.class)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<p>您还可以编写一个 objects 流，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Person&gt; personFlux &#x3D; ... ;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id)</span><br><span class="line">            .contentType(MediaType.APPLICATION_STREAM_JSON)</span><br><span class="line">            .body(personFlux, Person.class)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<p>或者，如果您有实际的 value，则可以使用<code>syncBody</code>快捷方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; ... ;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;persons&#x2F;&#123;id&#125;&quot;, id)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">            .syncBody(person)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-1-表格数据"><a href="#2-4-1-表格数据" class="headerlink" title="2.4.1. 表格数据"></a>2.4.1. 表格数据</h4><p>要发送表单数据，您可以提供<code>MultiValueMap&lt;String, String&gt;</code>作为正文。请注意，<code>FormHttpMessageWriter</code>会自动将内容设置为<code>application/x-www-form-urlencoded</code>。以下 example 显示了如何使用<code>MultiValueMap&lt;String, String&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; formData &#x3D; ... ;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;path&quot;, id)</span><br><span class="line">            .syncBody(formData)</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<p>您还可以使用<code>BodyInserters</code>提供表单数据 in-line，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.web.reactive.function.BodyInserters.*;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;path&quot;, id)</span><br><span class="line">            .body(fromFormData(&quot;k1&quot;, &quot;v1&quot;).with(&quot;k2&quot;, &quot;v2&quot;))</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-Multipart-数据"><a href="#2-4-2-Multipart-数据" class="headerlink" title="2.4.2. Multipart 数据"></a>2.4.2. Multipart 数据</h4><p>要发送 multipart 数据，您需要提供<code>MultiValueMap&lt;String, ?&gt;</code>，其值为表示部件内容的<code>Object</code>实例或表示部件的内容和_header 的<code>HttpEntity</code>实例。 <code>MultipartBodyBuilder</code>提供了一个方便的 API 来准备 multipart 请求。以下 example 显示了如何创建<code>MultiValueMap&lt;String, ?&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder &#x3D; new MultipartBodyBuilder();</span><br><span class="line">    builder.part(&quot;fieldPart&quot;, &quot;fieldValue&quot;);</span><br><span class="line">    builder.part(&quot;filePart&quot;, new FileSystemResource(&quot;...logo.png&quot;));</span><br><span class="line">    builder.part(&quot;jsonPart&quot;, new Person(&quot;Jason&quot;));</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, HttpEntity&lt;?&gt;&gt; parts &#x3D; builder.build();</span><br></pre></td></tr></table></figure>

<p>在大多数情况下，您不必为每个零件指定<code>Content-Type</code>。 content type 是根据所选的<code>HttpMessageWriter</code>自动确定的，以便序列化它，如果是<code>Resource</code>，则根据文件扩展名自动确定。如有必要，您可以通过其中一个重载的构建器<code>part</code>方法显式提供<code>MediaType</code>以用于每个部件。</p>
<p>准备好<code>MultiValueMap</code>后，将其传递给<code>WebClient</code>的最简单方法是通过<code>syncBody</code>方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder &#x3D; ...;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;path&quot;, id)</span><br><span class="line">            .syncBody(builder.build())</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code> value，它也可以表示常规表单数据(即<code>application/x-www-form-urlencoded</code>)，则无需将<code>Content-Type</code>设置为<code>multipart/form-data</code>。使用<code>MultipartBodyBuilder</code>时始终如此，这确保了<code>HttpEntity</code> wrapper。</p>
<p>作为<code>MultipartBodyBuilder</code>的替代，您还可以通过 built-in <code>BodyInserters</code>提供 multipart 内容 inline-style，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import static org.springframework.web.reactive.function.BodyInserters.*;</span><br><span class="line"></span><br><span class="line">    Mono&lt;Void&gt; result &#x3D; client.post()</span><br><span class="line">            .uri(&quot;&#x2F;path&quot;, id)</span><br><span class="line">            .body(fromMultipartData(&quot;fieldPart&quot;, &quot;value&quot;).with(&quot;filePart&quot;, resource))</span><br><span class="line">            .retrieve()</span><br><span class="line">            .bodyToMono(Void.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-5-Client-过滤器"><a href="#2-5-Client-过滤器" class="headerlink" title="2.5. Client 过滤器"></a>2.5. Client 过滤器</h3><p>您可以通过<code>WebClient.Builder</code> in order 注册 client 过滤器(<code>ExchangeFilterFunction</code>)来拦截和修改请求，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WebClient client &#x3D; WebClient.builder()</span><br><span class="line">        .filter((request, next) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            ClientRequest filtered &#x3D; ClientRequest.from(request)</span><br><span class="line">                    .header(&quot;foo&quot;, &quot;bar&quot;)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            return next.exchange(filtered);</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>这可用于 cross-cutting 问题，例如身份验证。以下 example 使用过滤器通过静态工厂方法进行基本身份验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; static import of ExchangeFilterFunctions.basicAuthentication</span><br><span class="line"></span><br><span class="line">WebClient client &#x3D; WebClient.builder()</span><br><span class="line">        .filter(basicAuthentication(&quot;user&quot;, &quot;password&quot;))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<p>过滤器全局应用于每个请求。要更改特定请求的过滤器行为，您可以向<code>ClientRequest</code>添加请求属性，然后链中的所有过滤器都可以访问这些属性，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WebClient client &#x3D; WebClient.builder()</span><br><span class="line">        .filter((request, next) -&gt; &#123;</span><br><span class="line">            Optional&lt;Object&gt; usr &#x3D; request.attribute(&quot;myAttribute&quot;);</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">client.get().uri(&quot;http:&#x2F;&#x2F;example.org&#x2F;&quot;)</span><br><span class="line">        .attribute(&quot;myAttribute&quot;, &quot;...&quot;)</span><br><span class="line">        .retrieve()</span><br><span class="line">        .bodyToMono(Void.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>您还可以复制现有的<code>WebClient</code>，插入新过滤器，或删除已注册的过滤器。以下 example，在索引 0 处插入基本身份验证筛选器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; static import of ExchangeFilterFunctions.basicAuthentication</span><br><span class="line"></span><br><span class="line">WebClient client &#x3D; webClient.mutate()</span><br><span class="line">        .filters(filterList -&gt; &#123;</span><br><span class="line">            filterList.add(0, basicAuthentication(&quot;user&quot;, &quot;password&quot;));</span><br><span class="line">        &#125;)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>

<h3 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6. 测试"></a>2.6. 测试</h3><p>要测试使用<code>WebClient</code>的 code，可以使用 mock web 服务器，例如<a target="_blank" rel="noopener" href="https://github.com/square/okhttp#mvc-config-advanced-java">OkHttp MockWebServer</a>。要查看其使用的 example，请查看 Spring Framework 测试套件中的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webflux/src/test/java/org/springframework/web/reactive/function/client/WebClientIntegrationTests.java">WebClientIntegrationTests</a>或 OkHttp repository 中的<a target="_blank" rel="noopener" href="https://github.com/square/okhttp/tree/master/samples/static-server">static-server</a> sample。</p>
<h2 id="3-WebSockets"><a href="#3-WebSockets" class="headerlink" title="3. WebSockets"></a>3. WebSockets</h2><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-http2">与 Servlet 堆栈中的相同</a></p>
<p>reference 文档的这一部分涵盖了对 reactive-stack WebSocket 消息传递的支持。</p>
<h3 id="3-1-WebSocket-简介"><a href="#3-1-WebSocket-简介" class="headerlink" title="3.1. WebSocket 简介"></a>3.1. WebSocket 简介</h3><p>WebSocket 协议<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准方法，可以通过单个 TCP 连接在 client 和服务器之间建立 full-duplex，two-way 通信 channel。它是来自 HTTP 的不同 TCP 协议，但设计为使用端口 80 和 443 并允许 re-use 现有防火墙规则通过 HTTP 工作。</p>
<p>WebSocket 交互以 HTTP 请求开始，该 HTTP 请求使用 HTTP <code>Upgrade</code>标头进行升级，或者在这种情况下，切换到 WebSocket 协议。以下 example 显示了这样的交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;spring-websocket-portfolio&#x2F;portfolio HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade: websocket (1)</span><br><span class="line">Connection: Upgrade (2)</span><br><span class="line">Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp, v11.stomp</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td><code>Upgrade</code>标题。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</tbody></table>
<p>具有 WebSocket 支持的服务器返回类似于以下内容的输出，而不是通常的 200 状态 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols (1)</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>协议切换</td>
</tr>
</tbody></table>
<p>成功握手后，HTTP 升级请求所基于的 TCP socket 将保持打开状态，以便 client 和服务器继续发送和接收消息。</p>
<p>有关 WebSockets 如何工作的完整介绍超出了本文档的范围。请参阅 RFC 6455，HTML5 的 WebSocket 章节，或者 Web 上的任何介绍和教程。</p>
<p>请注意，如果 WebSocket 服务器在 web 服务器(e.g. nginx)后面运行，则可能需要将其配置为将 WebSocket 升级请求传递到 WebSocket 服务器。同样，如果 application 在云环境中运行，请检查与 WebSocket 支持相关的云提供程序的说明。</p>
<h4 id="3-1-1-HTTP-与-WebSocket"><a href="#3-1-1-HTTP-与-WebSocket" class="headerlink" title="3.1.1. HTTP 与 WebSocket"></a>3.1.1. HTTP 与 WebSocket</h4><p>尽管 WebSocket 被设计为 HTTP-compatible 并以 HTTP 请求开始，但重要的是要理解这两种协议会导致非常不同的体系结构和 application 编程模型。</p>
<p>在 HTTP 和 REST 中，application 被建模为多个 URL。要与 application 进行交互，clients 访问这些 URL，request-response 样式。 Servers 根据 HTTP URL，方法和 headers 将请求路由到相应的处理程序。</p>
<p>相比之下，在 WebSockets 中，初始连接通常只有一个 URL。随后，所有 application 消息都在同一 TCP 连接上流动。这指向一个完全不同的异步，event-driven，messaging architecture。</p>
<p>WebSocket 也是一种 low-level 传输协议，与 HTTP 不同，它不对消息内容规定任何语义。这意味着除非 client 和服务器就消息语义达成一致，否则无法对路由进行 route 或 process。</p>
<p>WebSocket clients 和服务器可以通过 HTTP 握手请求上的<code>Sec-WebSocket-Protocol</code>标头协商使用 higher-level，消息传递协议(对于 example，STOMP)。如果没有，他们需要提出自己的惯例。</p>
<h4 id="3-1-2-何时使用-WebSockets"><a href="#3-1-2-何时使用-WebSockets" class="headerlink" title="3.1.2. 何时使用 WebSockets"></a>3.1.2. 何时使用 WebSockets</h4><p>WebSockets 可以使 web 页面成为动态和交互式的。但是，在许多情况下，Ajax 和 HTTP 流式传输或 long 轮询的组合可以提供简单有效的解决方案。</p>
<p>例如，新闻，邮件和社交订阅源需要动态更新，但每隔几分钟就可以完全正常更新。另一方面，协作，游戏和财务应用程序需要更接近 real-time。</p>
<p>仅延迟不是决定因素。如果消息量相对较低(例如，监视网络故障)，HTTP 流式传输或轮询可以提供有效的解决方案。它是低延迟，高频率和高容量的组合，是使用 WebSocket 的最佳选择。</p>
<p>还要记住，在 Internet 上，超出控制范围的限制性代理可能会阻止 WebSocket 交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭 long-lived 连接，这些连接显示为 idle。这意味着在防火墙内部使用 WebSocket 进行内部应用比使用面向公众的应用程序更直接。</p>
<h3 id="3-2-WebSocket-API"><a href="#3-2-WebSocket-API" class="headerlink" title="3.2. WebSocket API"></a>3.2. WebSocket API</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-reactive-libraries">与 Servlet 堆栈中的相同</a></p>
<p>Spring Framework 提供了一个 WebSocket API，您可以使用它来编写处理 WebSocket 消息的 client-和 server-side applications。</p>
<h4 id="3-2-1-服务器"><a href="#3-2-1-服务器" class="headerlink" title="3.2.1. 服务器"></a>3.2.1. 服务器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-codecs">与 Servlet 堆栈中的相同</a></p>
<p>要创建 WebSocket 服务器，可以先创建<code>WebSocketHandler</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.reactive.socket.WebSocketHandler;</span><br><span class="line">import org.springframework.web.reactive.socket.WebSocketSession;</span><br><span class="line"></span><br><span class="line">public class MyWebSocketHandler implements WebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; handle(WebSocketSession session) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，您可以将其映射到 URL 并添加<code>WebSocketHandlerAdapter</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">static class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HandlerMapping handlerMapping() &#123;</span><br><span class="line">        Map&lt;String, WebSocketHandler&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;&#x2F;path&quot;, new MyWebSocketHandler());</span><br><span class="line"></span><br><span class="line">        SimpleUrlHandlerMapping mapping &#x3D; new SimpleUrlHandlerMapping();</span><br><span class="line">        mapping.setUrlMap(map);</span><br><span class="line">        mapping.setOrder(-1); &#x2F;&#x2F; before annotated controllers</span><br><span class="line">        return mapping;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandlerAdapter handlerAdapter() &#123;</span><br><span class="line">        return new WebSocketHandlerAdapter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-WebSocketHandler"><a href="#3-2-2-WebSocketHandler" class="headerlink" title="3.2.2. WebSocketHandler"></a>3.2.2. WebSocketHandler</h4><p><code>WebSocketHandler</code>的<code>handle</code>方法接受<code>WebSocketSession</code>并返回<code>Mono&lt;Void&gt;</code>以指示 session 的 application 处理何时完成。 session 通过两个流处理，一个用于入站消息，一个用于出站消息。以下 table 描述了处理流的两种方法：</p>
<table>
<thead>
<tr>
<th><code>WebSocketSession</code>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Flux&lt;WebSocketMessage&gt; receive()</code></td>
<td>提供对入站消息流的访问，并在关闭连接时完成。</td>
</tr>
<tr>
<td><code>Mono&lt;Void&gt; send(Publisher&lt;WebSocketMessage&gt;)</code></td>
<td>获取传出消息的源，写入消息，并返回在源完成并写入完成时完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody></table>
<p><code>WebSocketHandler</code>必须将入站和出站流组成一个统一的流，并返回反映该流完成的<code>Mono&lt;Void&gt;</code>。根据 application 要求，统一流程在以下情况下完成：</p>
<ul>
<li>入站或出站消息流完成。</li>
<li>入站流完成(即连接已关闭)，而出站流是无限的。</li>
<li>在选定的点上，通过<code>WebSocketSession</code>的<code>close</code>方法。</li>
</ul>
<p>当入站和出站消息流组合在一起时，无需检查连接是否打开，因为 Reactive Streams 信号终止活动。入站流接收完成或错误信号，并且出站流接收取消信号。</p>
<p>处理程序的最基本的 implementation 是处理入站流的。以下 example 显示了这样的 implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ExampleHandler implements WebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; handle(WebSocketSession session) &#123;</span><br><span class="line">        return session.receive()            (1)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...                  (2)</span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...                  (3)</span><br><span class="line">                &#125;)</span><br><span class="line">                .then();                    (4)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>访问入站邮件流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>对每条消息做点什么。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>执行使用消息内容的嵌套异步操作。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>返回收到完成后完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody></table>
<blockquote>
<p>对于嵌套的异步操作，您可能需要在使用池数据缓冲区的基础服务器上调用<code>message.retain()</code>(对于 example， Netty)。否则，可能在您有机会读取数据之前释放数据缓冲区。有关更多背景信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-codecs">数据缓冲区和编解码器</a>。</p>
</blockquote>
<p>以下 implementation 组合了入站和出站流：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ExampleHandler implements WebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; handle(WebSocketSession session) &#123;</span><br><span class="line"></span><br><span class="line">        Flux&lt;WebSocketMessage&gt; output &#x3D; session.receive()               (1)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;)</span><br><span class="line">                .map(value -&gt; session.textMessage(&quot;Echo &quot; + value));    (2)</span><br><span class="line"></span><br><span class="line">        return session.send(output);                                    (3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>创建出站消息，生成组合流。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>当我们继续接收时，返回未完成的<code>Mono&lt;Void&gt;</code>。</td>
</tr>
</tbody></table>
<p>入站和出站流可以是独立的，只有完成才能连接，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ExampleHandler implements WebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; handle(WebSocketSession session) &#123;</span><br><span class="line"></span><br><span class="line">        Mono&lt;Void&gt; input &#x3D; session.receive()                                (1)</span><br><span class="line">                .doOnNext(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;)</span><br><span class="line">                .concatMap(message -&gt; &#123;</span><br><span class="line">                    &#x2F;&#x2F; ...</span><br><span class="line">                &#125;)</span><br><span class="line">                .then();</span><br><span class="line"></span><br><span class="line">        Flux&lt;String&gt; source &#x3D; ... ;</span><br><span class="line">        Mono&lt;Void&gt; output &#x3D; session.send(source.map(session::textMessage)); (2)</span><br><span class="line"></span><br><span class="line">        return Mono.zip(input, output).then();                              (3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>处理入站消息流。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>发送外发邮件。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>加入流并返回，当流结束时完成。</td>
</tr>
</tbody></table>
<h4 id="3-2-3-的-DataBuffer"><a href="#3-2-3-的-DataBuffer" class="headerlink" title="3.2.3. 的 DataBuffer"></a>3.2.3. 的 DataBuffer</h4><p><code>DataBuffer</code>是 WebFlux 中字节缓冲区的表示。 reference 的 Spring 核心部分在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mockwebserver">数据缓冲区和编解码器</a>部分有更多内容。要理解的 key 要点是在像 Netty 这样的服务器上，字节缓冲区被池化并且 reference 计数，并且必须在被消耗时释放以避免 memory 泄漏。</p>
<p>当在 Netty 上运行时，applications 必须使用<code>DataBufferUtils.retain(dataBuffer)</code>，如果他们希望保持 order 中的输入数据缓冲区以确保它们不被释放，并且随后在消耗缓冲区时使用<code>DataBufferUtils.release(dataBuffer)</code>。</p>
<h4 id="3-2-4-握手"><a href="#3-2-4-握手" class="headerlink" title="3.2.4. 握手"></a>3.2.4. 握手</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket">与 Servlet 堆栈中的相同</a></p>
<p><code>WebSocketHandlerAdapter</code>委托给<code>WebSocketService</code>。默认情况下，这是<code>HandshakeWebSocketService</code>的一个实例，它对 WebSocket 请求执行基本检查，然后对正在使用的服务器使用<code>RequestUpgradeStrategy</code>。目前，对于 Reactor Netty，Tomcat，Jetty 和 Undertow 有 built-in 支持。</p>
<p><code>HandshakeWebSocketService</code>公开<code>sessionAttributePredicate</code> property，允许设置<code>Predicate&lt;String&gt;</code>从<code>WebSession</code>中提取属性，并将它们插入到<code>WebSocketSession</code>的属性中。</p>
<h4 id="3-2-5-服务器配置"><a href="#3-2-5-服务器配置" class="headerlink" title="3.2.5. 服务器配置"></a>3.2.5. 服务器配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-server">与 Servlet 堆栈中的相同</a></p>
<p>每个服务器的<code>RequestUpgradeStrategy</code>公开了可用于底层 WebSocket 引擎的 WebSocket-related configuration 选项。在 Tomcat 上 running 时，以下 example sets WebSocket 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">static class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandlerAdapter handlerAdapter() &#123;</span><br><span class="line">        return new WebSocketHandlerAdapter(webSocketService());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketService webSocketService() &#123;</span><br><span class="line">        TomcatRequestUpgradeStrategy strategy &#x3D; new TomcatRequestUpgradeStrategy();</span><br><span class="line">        strategy.setMaxSessionIdleTimeout(0L);</span><br><span class="line">        return new HandshakeWebSocketService(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查服务器的升级策略以查看可用的选项。目前，只有 Tomcat 和 Jetty 公开了这样的选项。</p>
<h4 id="3-2-6-CORS"><a href="#3-2-6-CORS" class="headerlink" title="3.2.6. CORS"></a>3.2.6. CORS</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-server-handler">与 Servlet 堆栈中的相同</a></p>
<p>配置 CORS 并限制对 WebSocket 端点的访问的最简单方法是让<code>WebSocketHandler</code>实现<code>CorsConfigurationSource</code>和@如果您不能这样做，您还可以在<code>SimpleUrlHandler</code>上设置<code>corsConfigurations</code> property 以通过 URL pattern 指定 CORS 设置。如果同时指定了两者，则使用<code>CorsConfiguration</code>上的<code>combine</code>方法将它们组合在一起。</p>
<h4 id="3-2-7-客户"><a href="#3-2-7-客户" class="headerlink" title="3.2.7. 客户"></a>3.2.7. 客户</h4><p>Spring WebFlux 为 Reactor Netty，Tomcat，Jetty，Undertow 和标准 Java(即 JSR-356)提供<code>WebSocketClient</code>抽象和 implementations。</p>
<blockquote>
<p>Tomcat client 实际上是标准 Java 的扩展，在<code>WebSocketSession</code>处理中具有一些额外的功能，以利用 Tomcat-specific API 来暂停接收消息以获得背压。</p>
</blockquote>
<p>要启动 WebSocket session，您可以创建 client 的实例并使用其<code>execute</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WebSocketClient client &#x3D; new ReactorNettyWebSocketClient();</span><br><span class="line"></span><br><span class="line">URI url &#x3D; new URI(&quot;ws:&#x2F;&#x2F;localhost:8080&#x2F;path&quot;);</span><br><span class="line">client.execute(url, session -&gt;</span><br><span class="line">        session.receive()</span><br><span class="line">                .doOnNext(System.out::println)</span><br><span class="line">                .then());</span><br></pre></td></tr></table></figure>

<p>某些客户端(例如 Jetty)实现<code>Lifecycle</code>，需要先停止并启动它们才能使用它们。所有 clients 都具有与底层 WebSocket client 的 configuration 相关的构造函数选项。</p>
<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h2><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#databuffers">在 Spring MVC 中也是如此</a></p>
<p><code>spring-test</code>模块提供了<code>ServerHttpRequest</code>，<code>ServerHttpResponse</code>和<code>ServerWebExchange</code>的 mock implementations。有关 mock objects 的讨论，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#databuffers">Spring Web Reactive</a>。</p>
<p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#websocket-server-handshake">WebTestClient</a>建立在这些 mock 请求和响应 objects 的基础上，以支持在没有 HTTP 服务器的情况下测试 WebFlux applications。您也可以使用<code>WebTestClient</code>进行 end-to-end integration 测试。</p>
<h2 id="5-Reactive-Libraries"><a href="#5-Reactive-Libraries" class="headerlink" title="5. Reactive Libraries"></a>5. Reactive Libraries</h2><p><code>spring-webflux</code>依赖于<code>reactor-core</code>并在内部使用它来组成异步逻辑并提供 Reactive Streams 支持。通常，WebFlux API return <code>Flux</code>或<code>Mono</code>(因为它们在内部使用)并且宽松地接受任何 Reactive Streams <code>Publisher</code> implementation 作为输入。 <code>Flux</code>与<code>Mono</code>的使用很重要，因为它有助于表达基数 - 例如，是否需要单个或多个异步值，这对于做出决策是必不可少的(例如，在编码或解码 HTTP 消息时)。</p>
<p>对于带注释的控制器，WebFlux 透明地适应 application 选择的 reactive library。这是在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/ReactiveAdapterRegistry.html">ReactiveAdapterRegistry</a>的帮助下完成的，它为 reactive library 和其他异步类型提供了可插入的支持。注册表具有 built-in 支持 RxJava 和<code>CompletableFuture</code>，但您也可以注册其他人。</p>
<p>对于功能 API(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#websocket-server-runtime-configuration">功能 Endpoints</a>，<code>WebClient</code>和其他)，WebFlux API 的一般规则适用 - <code>Flux</code>和<code>Mono</code>作为 return 值，Reactive Streams <code>Publisher</code>作为输入。当提供<code>Publisher</code>(无论是自定义还是来自另一个 reactive library)时，它只能被视为具有未知语义的流(0..N)。但是，如果语义已知，则可以使用<code>Flux</code>或<code>Mono.from(Publisher)</code>包装它，而不是传递原始<code>Publisher</code>。</p>
<p>对于 example，给定不是<code>Mono</code>，Jackson JSON 消息 writer 需要多个值。如果媒体类型意味着无限流(对于 example，<code>application/json+stream</code>)，则会单独写入和刷新值。否则，将值缓冲到列表中并呈现为 JSON array。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/" rel="prev" title="SpringFramework官方文档翻译-Servlet Stack上的Web">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-Servlet Stack上的Web
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/" rel="next" title="SpringFramework官方文档翻译-集成">
      SpringFramework官方文档翻译-集成 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Web-on-Reactive-Stack"><span class="nav-number">1.</span> <span class="nav-text">Web on Reactive Stack</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Spring-WebFlux"><span class="nav-number">1.1.</span> <span class="nav-text">1. Spring WebFlux</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E6%A6%82%E8%A7%82"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1. 概观</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1-%E5%AE%9A%E4%B9%89%E2%80%9CReactive%E2%80%9D"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1.1.1. 定义“Reactive”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2-Reactive-API"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">1.1.2. Reactive API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">1.1.3. 编程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-4-%E9%80%82%E7%94%A8%E6%80%A7"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">1.1.4. 适用性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-5-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">1.1.5. 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-6-%E6%80%A7%E8%83%BD"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">1.1.6. 性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-7-%E5%B9%B6%E5%8F%91-Model"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">1.1.7. 并发 Model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Reactive-Core"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2. Reactive Core</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1-%E7%9A%84-HttpHandler"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">1.2.1. 的 HttpHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-WebHandler-API"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">1.2.2. WebHandler API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84-bean-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">特殊的 bean 类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">表格数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipart-%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.2.2.3.</span> <span class="nav-text">Multipart 数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91-Headers"><span class="nav-number">1.1.2.2.4.</span> <span class="nav-text">转发 Headers</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">1.2.3. 过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CORS"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">CORS</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4-Exceptions"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">1.2.4. Exceptions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-5-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">1.2.5. 编解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Jackson-JSON"><span class="nav-number">1.1.2.5.1.</span> <span class="nav-text">Jackson JSON</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE-1"><span class="nav-number">1.1.2.5.2.</span> <span class="nav-text">表格数据</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipart"><span class="nav-number">1.1.2.5.3.</span> <span class="nav-text">Multipart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%81%E5%AA%92%E4%BD%93"><span class="nav-number">1.1.2.5.4.</span> <span class="nav-text">流媒体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DataBuffer"><span class="nav-number">1.1.2.5.5.</span> <span class="nav-text">DataBuffer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-6-Logging"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">1.2.6. Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Log-Id"><span class="nav-number">1.1.2.6.1.</span> <span class="nav-text">Log Id</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.2.6.2.</span> <span class="nav-text">敏感数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-DispatcherHandler"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3. DispatcherHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-%E7%89%B9%E6%AE%8A%E7%9A%84-Bean-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.3.1. 特殊的 Bean 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2-WebFlux-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.3.2. WebFlux 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3-%E5%A4%84%E7%90%86"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">1.3.3. 处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4-%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">1.3.4. 结果处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5-Exceptions"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">1.3.5. Exceptions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-6-%E6%9F%A5%E7%9C%8B%E5%88%86%E8%BE%A8%E7%8E%87"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">1.3.6. 查看分辨率</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86"><span class="nav-number">1.1.3.6.1.</span> <span class="nav-text">处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">1.1.3.6.2.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E8%B0%88%E5%88%A4"><span class="nav-number">1.1.3.6.3.</span> <span class="nav-text">内容谈判</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%B8%A6%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4. 带注释的控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-Controller"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">1.4.1. @Controller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-2-%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">1.4.2. 请求映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URI-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">URI 模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pattern-%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.4.2.2.</span> <span class="nav-text">Pattern 比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%80%97%E6%9D%90%E4%BB%8B%E8%B4%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.4.2.3.</span> <span class="nav-text">耗材介质类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E7%94%9F%E4%BA%A7%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.4.2.4.</span> <span class="nav-text">可生产的媒体类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8C-Headers"><span class="nav-number">1.1.4.2.5.</span> <span class="nav-text">参数和 Headers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP-HEAD%EF%BC%8COPTIONS"><span class="nav-number">1.1.4.2.6.</span> <span class="nav-text">HTTP HEAD，OPTIONS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A"><span class="nav-number">1.1.4.2.7.</span> <span class="nav-text">自定义注释</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%8E%E7%A1%AE%E6%B3%A8%E5%86%8C"><span class="nav-number">1.1.4.2.8.</span> <span class="nav-text">明确注册</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">1.4.3. 处理程序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-Arguments"><span class="nav-number">1.1.4.3.1.</span> <span class="nav-text">方法 Arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Return-%E5%80%BC"><span class="nav-number">1.1.4.3.2.</span> <span class="nav-text">Return 值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.4.3.3.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.4.3.4.</span> <span class="nav-text">矩阵变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestParam"><span class="nav-number">1.1.4.3.5.</span> <span class="nav-text">@RequestParam</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestHeader"><span class="nav-number">1.1.4.3.6.</span> <span class="nav-text">@RequestHeader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CookieValue"><span class="nav-number">1.1.4.3.7.</span> <span class="nav-text">@CookieValue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ModelAttribute"><span class="nav-number">1.1.4.3.8.</span> <span class="nav-text">@ModelAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionAttributes"><span class="nav-number">1.1.4.3.9.</span> <span class="nav-text">@SessionAttributes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionAttribute"><span class="nav-number">1.1.4.3.10.</span> <span class="nav-text">@SessionAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestAttribute"><span class="nav-number">1.1.4.3.11.</span> <span class="nav-text">@RequestAttribute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipart-Content"><span class="nav-number">1.1.4.3.12.</span> <span class="nav-text">Multipart Content</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestBody"><span class="nav-number">1.1.4.3.13.</span> <span class="nav-text">@RequestBody</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpEntity"><span class="nav-number">1.1.4.3.14.</span> <span class="nav-text">HttpEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResponseBody"><span class="nav-number">1.1.4.3.15.</span> <span class="nav-text">@ResponseBody</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResponseEntity"><span class="nav-number">1.1.4.3.16.</span> <span class="nav-text">ResponseEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Jackson-JSON-1"><span class="nav-number">1.1.4.3.17.</span> <span class="nav-text">Jackson JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Jackson-%E5%BA%8F%E5%88%97%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.4.3.17.1.</span> <span class="nav-text">Jackson 序列化视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">1.4.4. 模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-DataBinder"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">1.4.5. DataBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-6-%E7%AE%A1%E7%90%86-Exceptions"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">1.4.6. 管理 Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#REST-API-exceptions"><span class="nav-number">1.1.4.6.1.</span> <span class="nav-text">REST API exceptions</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-7-%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.1.4.7.</span> <span class="nav-text">1.4.7. 控制器建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%8A%9F%E8%83%BD-Endpoints"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5. 功能 Endpoints</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E6%A6%82%E8%A7%82"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1.5.1. 概观</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-HandlerFunction"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">1.5.2. HandlerFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServerRequest"><span class="nav-number">1.1.5.2.1.</span> <span class="nav-text">ServerRequest</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServerResponse"><span class="nav-number">1.1.5.2.2.</span> <span class="nav-text">ServerResponse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handler-Classes"><span class="nav-number">1.1.5.2.3.</span> <span class="nav-text">Handler Classes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-3-RouterFunction"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">1.5.3. RouterFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%93%E8%AF%8D"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">谓词</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Routes"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">Routes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97-Routes"><span class="nav-number">1.1.5.3.3.</span> <span class="nav-text">嵌套 Routes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-4-%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">1.5.4. 运行服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-5-%E8%BF%87%E6%BB%A4%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">1.5.5. 过滤处理程序功能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-URI-%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6. URI 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-1-UriComponents"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">1.6.1. UriComponents</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-2-UriBuilder"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">1.6.2. UriBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-URI-%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">1.6.3. URI 编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-CORS"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.7. CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">1.7.1. 介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-2-%E5%A4%84%E7%90%86"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">1.7.2. 处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-3-CrossOrigin"><span class="nav-number">1.1.7.3.</span> <span class="nav-text">1.7.3. @CrossOrigin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-4-Global-Configuration"><span class="nav-number">1.1.7.4.</span> <span class="nav-text">1.7.4. Global Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-5-CORS-WebFilter"><span class="nav-number">1.1.7.5.</span> <span class="nav-text">1.7.5. CORS WebFilter</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-Web-%E5%AE%89%E5%85%A8"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.8. Web 安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-%E6%9F%A5%E7%9C%8B%E6%8A%80%E6%9C%AF"><span class="nav-number">1.1.9.</span> <span class="nav-text">1.9. 查看技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-1-Thymeleaf"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">1.9.1. Thymeleaf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-2-FreeMarker"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">1.9.2. FreeMarker</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-Configuration"><span class="nav-number">1.1.9.2.1.</span> <span class="nav-text">查看 Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FreeMarker-Configuration"><span class="nav-number">1.1.9.2.2.</span> <span class="nav-text">FreeMarker Configuration</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-%E8%84%9A%E6%9C%AC%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">1.9.3. 脚本视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A6%81%E6%B1%82"><span class="nav-number">1.1.9.3.1.</span> <span class="nav-text">要求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.9.3.2.</span> <span class="nav-text">脚本模板</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-JSON-%E5%92%8C-XML"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">1.9.4. JSON 和 XML</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-HTTP-%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.10.</span> <span class="nav-text">1.10. HTTP 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-1-CacheControl"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">1.10.1. CacheControl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-2-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">1.10.2. 控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">1.10.3. 静态资源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-WebFlux-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.11.</span> <span class="nav-text">1.11. WebFlux 配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-1-%E5%90%AF%E7%94%A8-WebFlux-%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.11.1.</span> <span class="nav-text">1.11.1. 启用 WebFlux 配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-2-WebFlux-%E9%85%8D%E7%BD%AE-API"><span class="nav-number">1.1.11.2.</span> <span class="nav-text">1.11.2. WebFlux 配置 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-3-%E8%BD%AC%E6%8D%A2%EF%BC%8C%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">1.1.11.3.</span> <span class="nav-text">1.11.3. 转换，格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-4-%E9%AA%8C%E8%AF%81"><span class="nav-number">1.1.11.4.</span> <span class="nav-text">1.11.4. 验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-5-Content-Type-%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.11.5.</span> <span class="nav-text">1.11.5. Content Type 解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-6-HTTP-%E6%B6%88%E6%81%AF%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">1.1.11.6.</span> <span class="nav-text">1.11.6. HTTP 消息编解码器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-7-%E6%9F%A5%E7%9C%8B%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.11.7.</span> <span class="nav-text">1.11.7. 查看解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-8-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.11.8.</span> <span class="nav-text">1.11.8. 静态资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-9-%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="nav-number">1.1.11.9.</span> <span class="nav-text">1.11.9. 路径匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-10-%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.11.10.</span> <span class="nav-text">1.11.10. 高级配置模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-HTTP-2"><span class="nav-number">1.1.12.</span> <span class="nav-text">1.12. HTTP&#x2F;2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-WebClient"><span class="nav-number">1.2.</span> <span class="nav-text">2. WebClient</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%BB%84%E6%80%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. 组态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%8F%8D%E5%BA%94%E5%A0%86-Netty"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1. 反应堆 Netty</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B5%84%E6%BA%90"><span class="nav-number">1.2.1.1.1.</span> <span class="nav-text">资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E6%97%B6"><span class="nav-number">1.2.1.1.2.</span> <span class="nav-text">超时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E7%A0%81%E5%A4%B4"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2. 码头</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-retrieve"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2. retrieve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-exchange"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3. exchange()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E8%AF%B7%E6%B1%82%E6%9C%BA%E6%9E%84"><span class="nav-number">1.2.4.</span> <span class="nav-text">2.4. 请求机构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">2.4.1. 表格数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-Multipart-%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">2.4.2. Multipart 数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-Client-%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.2.5.</span> <span class="nav-text">2.5. Client 过滤器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.6.</span> <span class="nav-text">2.6. 测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-WebSockets"><span class="nav-number">1.3.</span> <span class="nav-text">3. WebSockets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-WebSocket-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1. WebSocket 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-HTTP-%E4%B8%8E-WebSocket"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1. HTTP 与 WebSocket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-WebSockets"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2. 何时使用 WebSockets</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-WebSocket-API"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2. WebSocket API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1. 服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-WebSocketHandler"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2. WebSocketHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-%E7%9A%84-DataBuffer"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3. 的 DataBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E6%8F%A1%E6%89%8B"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">3.2.4. 握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">1.3.2.5.</span> <span class="nav-text">3.2.5. 服务器配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-CORS"><span class="nav-number">1.3.2.6.</span> <span class="nav-text">3.2.6. CORS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-%E5%AE%A2%E6%88%B7"><span class="nav-number">1.3.2.7.</span> <span class="nav-text">3.2.7. 客户</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%B5%8B%E8%AF%95"><span class="nav-number">1.4.</span> <span class="nav-text">4.测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Reactive-Libraries"><span class="nav-number">1.5.</span> <span class="nav-text">5. Reactive Libraries</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"2VnxHgjEtfnE32vEU7kSwp7u-gzGzoHsz","app_key":"C31JOMiTW1vAVoeT7ece3Gts","server_url":null,"security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/";
    this.page.title = "SpringFramework官方文档翻译-Web on Reactive Stack";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
