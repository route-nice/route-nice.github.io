<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="集成Remoting 和 Web Services with SpringSpring features integration classes 用于远程支持各种技术。远程支持简化了 remote-enabled 服务的开发，由您的常规(Spring)POJO 实现。目前，Spring 支持以下远程技术：  远程方法调用(RMI)：通过使用RmiProxyFactoryBean和RmiServic">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-集成">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="集成Remoting 和 Web Services with SpringSpring features integration classes 用于远程支持各种技术。远程支持简化了 remote-enabled 服务的开发，由您的常规(Spring)POJO 实现。目前，Spring 支持以下远程技术：  远程方法调用(RMI)：通过使用RmiProxyFactoryBean和RmiServic">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-25T00:43:32.000Z">
<meta property="article:modified_time" content="2020-08-31T02:26:45.418Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-集成 | Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-集成
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 08:43:32" itemprop="dateCreated datePublished" datetime="2020-08-25T08:43:32+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-31 10:26:45" itemprop="dateModified" datetime="2020-08-31T10:26:45+08:00">2020-08-31</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-集成/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h1><h2 id="Remoting-和-Web-Services-with-Spring"><a href="#Remoting-和-Web-Services-with-Spring" class="headerlink" title="Remoting 和 Web Services with Spring"></a>Remoting 和 Web Services with Spring</h2><p>Spring features integration classes 用于远程支持各种技术。远程支持简化了 remote-enabled 服务的开发，由您的常规(Spring)POJO 实现。目前，Spring 支持以下远程技术：</p>
<ul>
<li><strong>远程方法调用(RMI)</strong>：通过使用<code>RmiProxyFactoryBean</code>和<code>RmiServiceExporter</code>，Spring 支持传统的 RMI(带有<code>java.rmi.Remote</code>接口和<code>java.rmi.RemoteException</code>)和通过 RMI 调用程序(带有任何 Java 接口)的透明远程处理。</li>
<li><strong>Spring 的 HTTP 调用程序</strong>：Spring 提供了一种特殊的远程处理策略，允许通过 HTTP 进行 Java 序列化，支持任何 Java 接口(如 RMI 调用程序所做的那样)。相应的支持 classes 是<code>HttpInvokerProxyFactoryBean</code>和<code>HttpInvokerServiceExporter</code>。</li>
<li><strong>Hessian</strong>：通过使用 Spring 的<code>HessianProxyFactoryBean</code>和<code>HessianServiceExporter</code>，您可以通过 Caucho 提供的轻量级二进制 HTTP-based 协议透明地公开您的服务。</li>
<li><strong>JAX-WS</strong>：Spring 通过 JAX-WS(JAX-RPC 的后继，如 Java EE 5 和 Java 6 中引入)为 web services 提供远程支持。</li>
<li><strong>JMS</strong>：通过<code>JmsInvokerServiceExporter</code>和<code>JmsInvokerProxyFactoryBean</code> classes 支持使用 JMS 作为底层协议进行远程处理。</li>
<li><strong>AMQP</strong>：Spring AMQP 项目支持使用 AMQP 作为基础协议进行远程处理。</li>
</ul>
<a id="more"></a>
<p>在讨论 Spring 的远程处理功能时，我们使用以下域 model 和相应的服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Account implements Serializable&#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public String getName()&#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public interface AccountService &#123;</span><br><span class="line"></span><br><span class="line">    public void insertAccount(Account account);</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; getAccounts(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; the implementation doing nothing at the moment</span><br><span class="line">public class AccountServiceImpl implements AccountService &#123;</span><br><span class="line"></span><br><span class="line">    public void insertAccount(Account acc) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Account&gt; getAccounts(String name) &#123;</span><br><span class="line">        &#x2F;&#x2F; do something...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本节首先使用 RMI 将服务公开给 remote client，然后再谈谈使用 RMI 的缺点。然后继续使用 Hessian 作为协议的 example。</p>
<h3 id="使用-RMI-公开服务"><a href="#使用-RMI-公开服务" class="headerlink" title="使用 RMI 公开服务"></a>使用 RMI 公开服务</h3><p>通过使用 Spring 对 RMI 的支持，您可以透明地通过 RMI 基础结构公开您的服务。完成此设置后，除了没有标准支持 security context 传播或 remote transaction 传播之外，您基本上都具有类似于 remote EJB 的 configuration。当您使用 RMI 调用程序时，Spring 会为此类附加调用 context 提供挂钩，因此您可以插入安全框架或自定义安全凭证。</p>
<h4 id="使用RmiServiceExporter导出服务"><a href="#使用RmiServiceExporter导出服务" class="headerlink" title="使用RmiServiceExporter导出服务"></a>使用RmiServiceExporter导出服务</h4><p>使用<code>RmiServiceExporter</code>，我们可以将 AccountService object 的接口公开为 RMI object。在传统的 RMI 服务的情况下，可以使用<code>RmiProxyFactoryBean</code>或通过普通 RMI 访问接口。 <code>RmiServiceExporter</code>明确支持通过 RMI 调用者公开任何 non-RMI 服务。</p>
<p>我们首先要在 Spring 容器中设置我们的服务。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;example.AccountServiceImpl&quot;&gt;</span><br><span class="line">    &lt;!-- any additional properties, maybe a DAO? --&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>接下来，我们必须使用<code>RmiServiceExporter</code>来公开我们的服务。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.remoting.rmi.RmiServiceExporter&quot;&gt;</span><br><span class="line">    &lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceName&quot; value&#x3D;&quot;AccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;service&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- defaults to 1099 --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;registryPort&quot; value&#x3D;&quot;1199&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，我们覆盖了 RMI 注册表的 port。通常，您的 application 服务器还维护一个 RMI 注册表，明智的做法是不干扰那个。此外，service name 用于绑定服务。因此，在前面的 example 中，服务绑定在<code>&#39;rmi://HOST:1199/AccountService&#39;</code>。我们稍后使用此 URL 链接到 client 端的服务。</p>
<blockquote>
<p><code>servicePort</code> property 已被省略(默认为 0)。这意味着匿名 port 用于与服务通信。</p>
</blockquote>
<h4 id="在-Client-中链接服务"><a href="#在-Client-中链接服务" class="headerlink" title="在 Client 中链接服务"></a>在 Client 中链接服务</h4><p>我们的 client 是一个简单的 object，它使用<code>AccountService</code>来管理帐户，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleObject &#123;</span><br><span class="line"></span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    public void setAccountService(AccountService accountService) &#123;</span><br><span class="line">        this.accountService &#x3D; accountService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; additional methods using the accountService</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要链接 client 上的服务，我们创建一个单独的 Spring 容器，以包含以下简单的 object 和连接 configuration 位的服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;example.SimpleObject&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;accountService&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;org.springframework.remoting.rmi.RmiProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot; value&#x3D;&quot;rmi:&#x2F;&#x2F;HOST:1199&#x2F;AccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>这就是我们在 client 上支持 remote 帐户服务所需要做的全部工作。 Spring 透明地创建一个调用者并通过<code>RmiServiceExporter</code>远程启用帐户服务。在 client，我们使用<code>RmiProxyFactoryBean</code>链接它。</p>
<h3 id="使用Hessian通过HTTP远程调用服务"><a href="#使用Hessian通过HTTP远程调用服务" class="headerlink" title="使用Hessian通过HTTP远程调用服务"></a>使用Hessian通过HTTP远程调用服务</h3><p>Hessian 提供二进制 HTTP-based 远程协议。它由 Caucho 开发，您可以在<a target="_blank" rel="noopener" href="http://www.caucho.com/">http://www.caucho.com</a>找到有关 Hessian 本身的更多信息。</p>
<h4 id="为Hessian连接DispatcherServlet"><a href="#为Hessian连接DispatcherServlet" class="headerlink" title="为Hessian连接DispatcherServlet"></a>为Hessian连接DispatcherServlet</h4><p>Hessian 通过 HTTP 进行通信，并使用自定义 servlet 进行通信。通过使用 Spring 的<code>DispatcherServlet</code>原则(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/webmvc.html#mvc-servlet">[webmvc#mvc-servlet]</a>)，我们可以连接这样的 servlet 来公开你的服务。首先，我们必须在 application 中创建一个新的 servlet，如下面的摘录<code>web.xml</code>所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>remoting<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>remoting<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/remoting/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果您熟悉 Spring 的<code>DispatcherServlet</code>原则，您可能知道现在必须在<code>WEB-INF</code>目录中创建一个名为<code>remoting-servlet.xml</code>的 Spring 容器配置资源(在 servlet 的 name 之后)。 application context 将在下一节中使用。</p>
<p>或者，考虑使用 Spring 更简单的<code>HttpRequestHandlerServlet</code>。这样做可以将 remote 导出器定义嵌入到根 application context 中(默认情况下，在<code>WEB-INF/applicationContext.xml</code>中)，单个 servlet 定义指向特定的导出器 beans。在这种情况下，每个 servlet name 都需要 match 其目标导出器的 bean name。</p>
<h4 id="使用HessianServiceExporter公开你的Beans"><a href="#使用HessianServiceExporter公开你的Beans" class="headerlink" title="使用HessianServiceExporter公开你的Beans"></a>使用HessianServiceExporter公开你的Beans</h4><p>在新创建的名为<code>remoting-servlet.xml</code>的 application context 中，我们创建一个<code>HessianServiceExporter</code>来 export 我们的服务，如下面的 example 所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- any additional properties, maybe a DAO? --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;/AccountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.remoting.caucho.HessianServiceExporter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example.AccountService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在我们已准备好在 client 中链接服务。没有指定显式的处理程序映射(将 map 请求 URL 映射到服务上)，因此我们使用了<code>BeanNameUrlHandlerMapping</code>。因此，服务在包含<code>DispatcherServlet</code>实例的映射(如前面定义)中通过 bean name 指示的 URL 导出：<code>http://HOST:8080/remoting/AccountService</code>。</p>
<p>或者，您可以在根 application context 中创建<code>HessianServiceExporter</code>(对于 example，在<code>WEB-INF/applicationContext.xml</code>中)，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name&#x3D;&quot;accountExporter&quot; class&#x3D;&quot;org.springframework.remoting.caucho.HessianServiceExporter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;service&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在后一种情况下，您应该在<code>web.xml</code>中为此导出器定义相应的 servlet，并使用相同的最终结果：导出器将映射到<code>/remoting/AccountService</code>处的请求路径。请注意，servlet name 需要 match 目标导出器的 bean name。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;accountExporter&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;accountExporter&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;remoting&#x2F;AccountService&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在Client上链接服务"><a href="#在Client上链接服务" class="headerlink" title="在Client上链接服务"></a>在Client上链接服务</h4><p>通过使用<code>HessianProxyFactoryBean</code>，我们可以在 client 中链接服务。同样的原则适用于 RMI example。我们创建一个单独的 bean 工厂或 application context 并通过使用<code>AccountService</code>来管理帐户，提及以下 beans，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;example.SimpleObject&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;accountService&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;org.springframework.remoting.caucho.HessianProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot; value&#x3D;&quot;http:&#x2F;&#x2F;remotehost:8080&#x2F;remoting&#x2F;AccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="将HTTP基本身份验证应用于通过Hessian公开的服务"><a href="#将HTTP基本身份验证应用于通过Hessian公开的服务" class="headerlink" title="将HTTP基本身份验证应用于通过Hessian公开的服务"></a>将HTTP基本身份验证应用于通过Hessian公开的服务</h4><p>Hessian 的一个优点是我们可以轻松应用 HTTP 基本身份验证，因为这两个协议都是 HTTP-based。对于 example，可以通过使用<code>web.xml</code> security features 应用正常的 HTTP 服务器安全性机制。通常，您无需在此处使用 per-user 安全凭证。相反，您可以使用在<code>HessianProxyFactoryBean</code> level(类似于 JDBC <code>DataSource</code>)中定义的共享凭据，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;interceptors&quot; ref&#x3D;&quot;authorizationInterceptor&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;authorizationInterceptor&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;authorizedRoles&quot; value&#x3D;&quot;administrator,operator&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，我们明确提到了<code>BeanNameUrlHandlerMapping</code>并设置了一个拦截器，只允许管理员和 operators 调用 application context 中提到的 beans。</p>
<blockquote>
<p>前面的 example 没有显示灵活的安全基础结构。有关安全性的更多选项，请查看<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security/">http://projects.spring.io/spring-security/</a>处的 Spring Security 项目。</p>
</blockquote>
<h3 id="使用HTTPInvokers公开服务"><a href="#使用HTTPInvokers公开服务" class="headerlink" title="使用HTTPInvokers公开服务"></a>使用HTTPInvokers公开服务</h3><p>与 Hessian 相反，Spring HTTP 调用者都是轻量级协议，它们使用自己的瘦身序列化机制，并使用标准的 Java 序列化机制通过 HTTP 公开服务。如果您的 arguments 和 return 类型是无法使用 Hessian 使用的序列化机制序列化的复杂类型，那么这具有巨大的优势(当您选择远程处理技术时，请参阅下一节以了解更多注意事项)。</p>
<p>在引擎盖下，Spring 使用 JDK 提供的标准工具或 Apache <code>HttpComponents</code>来执行 HTTP calls。如果您需要更高级和 easier-to-use 功能，请使用后者。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://hc.apache.org/httpcomponents-client-ga/">hc.apache.org/httpcomponents-client-ga/</a>。</p>
<blockquote>
<p>请注意由于不安全的 Java 反序列化导致的漏洞：在反序列化 step 期间，操作的输入流可能导致服务器上不需要的 code 执行。因此，不要将 HTTP 调用者 endpoints 暴露给不受信任的 clients。相反，只在您自己的服务之间公开它们。通常，我们强烈建议您使用任何其他消息格式(例如 JSON)。</p>
</blockquote>
<p>如果您担心由于 Java 序列化导致的安全漏洞，请考虑核心 JVM level 上的 general-purpose 序列化过滤机制，该机制最初是为 JDK 9 开发的，但同时又向后移植到 JDK 8,7 和 6。见<a target="_blank" rel="noopener" href="https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a和[http://openjdk.java.net/jeps/290](https://openjdk.java.net/jeps/290)。">https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a和[http://openjdk.java.net/jeps/290](https://openjdk.java.net/jeps/290)。</a></p>
<h4 id="公开服务Object"><a href="#公开服务Object" class="headerlink" title="公开服务Object"></a>公开服务Object</h4><p>为服务 object 设置 HTTP 调用程序基础结构非常类似于使用 Hessian 执行相同操作的方式。由于 Hessian 支持提供<code>HessianServiceExporter</code>，Spring 的 HttpInvoker 支持提供<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>。</p>
<p>要在 Spring Web MVC <code>DispatcherServlet</code>中公开<code>AccountService</code>(前面提到过)，需要在调度程序的 application context 中使用以下 configuration，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name&#x3D;&quot;&#x2F;AccountService&quot; class&#x3D;&quot;org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;service&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>这样的导出器定义通过<code>DispatcherServlet</code>实例的标准映射工具公开，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#remoting-caucho-protocols">关于黑森州的部分</a>中所述。</p>
<p>或者，您可以在根 application context 中创建<code>HttpInvokerServiceExporter</code>(对于 example，在<code>&#39;WEB-INF/applicationContext.xml&#39;</code>中)，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name&#x3D;&quot;accountExporter&quot; class&#x3D;&quot;org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;service&quot; ref&#x3D;&quot;accountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>此外，您可以在<code>web.xml</code>中为此导出器定义相应的 servlet，其中 servlet name 与目标导出器的 bean name 匹配，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;accountExporter&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;accountExporter&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;remoting&#x2F;AccountService&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<h4 id="在Client中链接服务"><a href="#在Client中链接服务" class="headerlink" title="在Client中链接服务"></a>在Client中链接服务</h4><p>同样，来自 client 的服务链接非常类似于使用 Hessian 时的方式。通过使用代理，Spring 可以将 calls 转换为指向导出服务的 URL 的 HTTP POST 请求。以下 example 显示了如何配置此安排：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;httpInvokerProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://remotehost:8080/remoting/AccountService&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;example.AccountService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如前所述，您可以选择要使用的 HTTP client。默认情况下，<code>HttpInvokerProxy</code>使用 JDK 的 HTTP 功能，但您也可以通过设置<code>httpInvokerRequestExecutor</code> property 来使用 Apache <code>HttpComponents</code> client。以下 example 显示了如何执行此操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;httpInvokerRequestExecutor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.remoting.httpinvoker.HttpComponentsHttpInvokerRequestExecutor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="网页服务"><a href="#网页服务" class="headerlink" title="网页服务"></a>网页服务</h3><p>Spring 提供对标准 Java web services API 的完全支持：</p>
<ul>
<li>使用 JAX-WS 公开 web services</li>
<li>使用 JAX-WS 访问 web services</li>
</ul>
<p>除了 Spring Core 中 JAX-WS 的库存支持外，Spring 产品组合还 features <a target="_blank" rel="noopener" href="http://www.springframework.org/spring-ws">Spring Web Services</a>，这是 contract-first，document-driven web services 的解决方案 - 强烈建议用于 building modern，future-proof web services。</p>
<h4 id="使用JAX-WS公开基于Servlet的WebServices"><a href="#使用JAX-WS公开基于Servlet的WebServices" class="headerlink" title="使用JAX-WS公开基于Servlet的WebServices"></a>使用JAX-WS公开基于Servlet的WebServices</h4><p>Spring 为 JAX-WS servlet 端点 implementations 提供了方便的 base class：<code>SpringBeanAutowiringSupport</code>。为了公开我们的<code>AccountService</code>，我们扩展 Spring 的<code>SpringBeanAutowiringSupport</code> class 并在这里实现我们的业务逻辑，通常将调用委托给业务层。我们使用 Spring 的<code>@Autowired</code> annotation 来表达对 Spring-managed beans 的依赖。以下 example 显示了扩展<code>SpringBeanAutowiringSupport</code>的 class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * JAX-WS compliant AccountService implementation that simply delegates</span><br><span class="line"> * to the AccountService implementation in the root web application context.</span><br><span class="line"> *</span><br><span class="line"> * This wrapper class is necessary because JAX-WS requires working with dedicated</span><br><span class="line"> * endpoint classes. If an existing service needs to be exported, a wrapper that</span><br><span class="line"> * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through</span><br><span class="line"> * the @Autowired annotation) is the simplest JAX-WS compliant way.</span><br><span class="line"> *</span><br><span class="line"> * This is the class registered with the server-side JAX-WS implementation.</span><br><span class="line"> * In the case of a Java EE 5 server, this would simply be defined as a servlet</span><br><span class="line"> * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting</span><br><span class="line"> * accordingly. The servlet name usually needs to match the specified WS service name.</span><br><span class="line"> *</span><br><span class="line"> * The web service engine manages the lifecycle of instances of this class.</span><br><span class="line"> * Spring bean references will just be wired in here.</span><br><span class="line"> *&#x2F;</span><br><span class="line">import org.springframework.web.context.support.SpringBeanAutowiringSupport;</span><br><span class="line"></span><br><span class="line">@WebService(serviceName&#x3D;&quot;AccountService&quot;)</span><br><span class="line">public class AccountServiceEndpoint extends SpringBeanAutowiringSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService biz;</span><br><span class="line"></span><br><span class="line">    @WebMethod</span><br><span class="line">    public void insertAccount(Account acc) &#123;</span><br><span class="line">        biz.insertAccount(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @WebMethod</span><br><span class="line">    public Account[] getAccounts(String name) &#123;</span><br><span class="line">        return biz.getAccounts(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的<code>AccountServiceEndpoint</code>需要在与 Spring context 相同的 web application 中运行，以允许访问 Spring 的工具。默认情况下，在 Java EE 5 环境中使用 JAX-WS servlet 端点部署的标准 contract 就是这种情况。有关详细信息，请参阅各种 Java EE 5 web service 教程。</p>
<h4 id="使用JAX-WS导出独立的WebServices"><a href="#使用JAX-WS导出独立的WebServices" class="headerlink" title="使用JAX-WS导出独立的WebServices"></a>使用JAX-WS导出独立的WebServices</h4><p>Oracle JDK 附带的 built-in JAX-WS 提供程序通过使用 JDK 中包含的 built-in HTTP 服务器支持 web services 的曝光。 Spring 的<code>SimpleJaxWsServiceExporter</code>检测 Spring application context 中的所有<code>@WebService</code> -annotated beans 并通过默认的 JAX-WS 服务器(JDK HTTP 服务器)导出它们。</p>
<p>在这种情况下，端点实例被定义和管理为 Spring beans 本身。它们在 JAX-WS 引擎中注册，但它们的生命周期取决于 Spring application context。这意味着您可以将 Spring 功能(例如显式依赖项注入)应用于端点实例。通过<code>@Autowired</code>注入 Annotation-driven 也可以。以下 example 显示了如何定义这些 beans：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;baseAddress&quot;</span> <span class="attr">value</span>=<span class="string">&quot;http://localhost:8080/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountServiceEndpoint&quot;</span> <span class="attr">class</span>=<span class="string">&quot;example.AccountServiceEndpoint&quot;</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>AccountServiceEndpoint</code>可以但不必从 Spring 的<code>SpringBeanAutowiringSupport</code>派生，因为此 example 中的端点是完全 Spring-managed bean。这意味着端点 implementation 可以如下(没有声明任何超类 - 并且仍然遵循 Spring 的<code>@Autowired</code> configuration annotation)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@WebService(serviceName&#x3D;&quot;AccountService&quot;)</span><br><span class="line">public class AccountServiceEndpoint &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService biz;</span><br><span class="line"></span><br><span class="line">    @WebMethod</span><br><span class="line">    public void insertAccount(Account acc) &#123;</span><br><span class="line">        biz.insertAccount(acc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @WebMethod</span><br><span class="line">    public List&lt;Account&gt; getAccounts(String name) &#123;</span><br><span class="line">        return biz.getAccounts(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-3-使用-JAX-WS-RI-的-Spring-支持导出-Web-Services"><a href="#1-4-3-使用-JAX-WS-RI-的-Spring-支持导出-Web-Services" class="headerlink" title="1.4.3. 使用 JAX-WS RI 的 Spring 支持导出 Web Services"></a>1.4.3. 使用 JAX-WS RI 的 Spring 支持导出 Web Services</h4><p>Oracle 的 JAX-WS RI 是作为 GlassFish 项目的一部分开发的，它将 Spring 支持作为其 JAX-WS Commons _project 的一部分。这允许将 JAX-WS endpoints 定义为 Spring-managed beans，类似于<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#remoting-web-services-jaxws-export-standalone">上一节</a>中讨论的独立模式 - 但在 Servlet 环境中这是 time。</p>
<blockquote>
<p>这在 Java EE 5 环境中不可移植。它主要用于 non-EE 环境，例如 Tomcat，它将 JAX-WS RI 作为 web application 的一部分嵌入。</p>
</blockquote>
<p>与导出 servlet-based endpoints 的标准样式的不同之处在于端点实例本身的生命周期由 Spring 管理，并且<code>web.xml</code>中只定义了一个 JAX-WS servlet。使用标准 Java EE 5 样式(如前所示)，每个服务端点都有一个 servlet 定义，每个端点通常委托给 Spring beans(通过使用<code>@Autowired</code>，如前所示)。</p>
<p>有关设置和使用方式的详细信息，请参阅<a target="_blank" rel="noopener" href="https://jax-ws-commons.java.net/spring/。">https://jax-ws-commons.java.net/spring/。</a></p>
<h4 id="1-4-4-使用-JAX-WS-访问-Web-Services"><a href="#1-4-4-使用-JAX-WS-访问-Web-Services" class="headerlink" title="1.4.4. 使用 JAX-WS 访问 Web Services"></a>1.4.4. 使用 JAX-WS 访问 Web Services</h4><p>Spring 提供了两个工厂 beans 来创建 JAX-WS web service 代理，即<code>LocalJaxWsServiceFactoryBean</code>和<code>JaxWsPortProxyFactoryBean</code>。前者只能返回 JAX-WS 服务 class 供我们使用。后者是 full-fledged version，可以 return 实现我们的业务服务接口的代理。在下面的示例中，我们使用<code>JaxWsPortProxyFactoryBean</code>为<code>AccountService</code>端点创建代理(再次)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountWebService&quot; class&#x3D;&quot;org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;example.AccountService&quot;&#x2F;&gt; (1)</span><br><span class="line">    &lt;property name&#x3D;&quot;wsdlDocumentUrl&quot; value&#x3D;&quot;http:&#x2F;&#x2F;localhost:8888&#x2F;AccountServiceEndpoint?WSDL&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;namespaceUri&quot; value&#x3D;&quot;http:&#x2F;&#x2F;example&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceName&quot; value&#x3D;&quot;AccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;portName&quot; value&#x3D;&quot;AccountServiceEndpointPort&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>serviceInterface</code>是 clients 使用的业务接口。</td>
</tr>
</tbody>
</table>
</div>
<p><code>wsdlDocumentUrl</code>是 WSDL 文件的 URL。 Spring 在启动 time 时需要这个来创建 JAX-WS 服务。 <code>namespaceUri</code>对应于.wsdl 文件中的<code>targetNamespace</code>。 <code>serviceName</code>对应于.wsdl 文件中的服务 name。 <code>portName</code>对应于.wsdl 文件中的 port name。</p>
<p>访问 web service 很容易，因为我们有一个 bean 工厂，它将它公开为一个名为<code>AccountService</code>的接口。以下 example 显示了我们如何在 Spring 中连接它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;client&quot; class&#x3D;&quot;example.AccountClientImpl&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;property name&#x3D;&quot;service&quot; ref&#x3D;&quot;accountWebService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>从 client code，我们可以访问 web service，就像它是一个普通的 class 一样，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AccountClientImpl &#123;</span><br><span class="line"></span><br><span class="line">    private AccountService service;</span><br><span class="line"></span><br><span class="line">    public void setService(AccountService service) &#123;</span><br><span class="line">        this.service &#x3D; service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void foo() &#123;</span><br><span class="line">        service.insertAccount(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的内容略有简化，因为 JAX-WS 需要使用<code>@WebService</code>，<code>@SOAPBinding</code> etc annotations 注释端点接口和 implementation classes。这意味着您不能(轻松地)使用普通 Java 接口和 implementation classes 作为 JAX-WS endpoint artifacts;你需要先对它们进行相应的注释。有关这些要求的详细信息，请查看 JAX-WS 文档。</p>
</blockquote>
<h3 id="1-5-通过-JMS-公开服务"><a href="#1-5-通过-JMS-公开服务" class="headerlink" title="1.5. 通过 JMS 公开服务"></a>1.5. 通过 JMS 公开服务</h3><p>您还可以使用 JMS 作为底层通信协议透明地公开服务。 Spring Framework 中的 JMS 远程支持非常基础。它在<code>same thread</code>和 non-transactional <code>Session</code>中发送和接收。因此，吞吐量为 implementation-dependent。请注意，这些 single-threaded 和 non-transactional 约束仅适用于 Spring 的 JMS 远程支持。有关 Spring 对 JMS-based 消息传递的丰富支持的信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms">JMS(Java 消息服务)</a>。</p>
<p>服务器和 client 端都使用以下接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.foo;</span><br><span class="line"></span><br><span class="line">public interface CheckingAccountService &#123;</span><br><span class="line"></span><br><span class="line">    public void cancelAccount(Long accountId);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 server-side 上使用了上述接口的以下简单 implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.foo;</span><br><span class="line"></span><br><span class="line">public class SimpleCheckingAccountService implements CheckingAccountService &#123;</span><br><span class="line"></span><br><span class="line">    public void cancelAccount(Long accountId) &#123;</span><br><span class="line">        System.out.println(&quot;Cancelling account [&quot; + accountId + &quot;]&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 configuration 文件包含 client 和服务器上共享的 JMS-infrastructure beans：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;connectionFactory&quot; class&#x3D;&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;brokerURL&quot; value&#x3D;&quot;tcp:&#x2F;&#x2F;ep-t43:61616&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;queue&quot; class&#x3D;&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</span><br><span class="line">        &lt;constructor-arg value&#x3D;&quot;mmm&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-1-Server-side-Configuration"><a href="#1-5-1-Server-side-Configuration" class="headerlink" title="1.5.1. Server-side Configuration"></a>1.5.1. Server-side Configuration</h4><p>在服务器上，您需要公开使用<code>JmsInvokerServiceExporter</code>的服务 object，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;checkingAccountService&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jms.remoting.JmsInvokerServiceExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;com.foo.CheckingAccountService&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;service&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;com.foo.SimpleCheckingAccountService&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.jms.listener.SimpleMessageListenerContainer&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;destination&quot; ref&#x3D;&quot;queue&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;concurrentConsumers&quot; value&#x3D;&quot;3&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;checkingAccountService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">package com.foo;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Server &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new ClassPathXmlApplicationContext(new String[]&#123;&quot;com&#x2F;foo&#x2F;server.xml&quot;, &quot;com&#x2F;foo&#x2F;jms.xml&quot;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-2-Client-side-Configuration"><a href="#1-5-2-Client-side-Configuration" class="headerlink" title="1.5.2. Client-side Configuration"></a>1.5.2. Client-side Configuration</h4><p>client 只需要创建一个实现 agreed-upon 接口(<code>CheckingAccountService</code>)的 client-side 代理。</p>
<p>以下 example 定义 beans，您可以 inject 到其他 client-side objects(并且代理负责通过 JMS 将调用转发到 server-side object)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;checkingAccountService&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jms.remoting.JmsInvokerProxyFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;serviceInterface&quot; value&#x3D;&quot;com.foo.CheckingAccountService&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;queue&quot; ref&#x3D;&quot;queue&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line">package com.foo;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        ApplicationContext ctx &#x3D; new ClassPathXmlApplicationContext(</span><br><span class="line">                new String[] &#123;&quot;com&#x2F;foo&#x2F;client.xml&quot;, &quot;com&#x2F;foo&#x2F;jms.xml&quot;&#125;);</span><br><span class="line">        CheckingAccountService service &#x3D; (CheckingAccountService) ctx.getBean(&quot;checkingAccountService&quot;);</span><br><span class="line">        service.cancelAccount(new Long(10));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-AMQP"><a href="#1-6-AMQP" class="headerlink" title="1.6. AMQP"></a>1.6. AMQP</h3><p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/current/reference/html/_reference.html#remoting">Spring AMQP Reference Guide 的’Spring Remoting with AMQP’部分</a>。</p>
<blockquote>
<p>remote 接口未实现 Auto-detection</p>
</blockquote>
<p>remote 接口没有实现 auto-detection 实现接口的主要原因是避免为 remote 调用者打开太多门。目标 object 可能实现内部回调接口，例如<code>InitializingBean</code>或<code>DisposableBean</code>，这些接口不希望向调用者公开。</p>
<p>提供具有目标实现的所有接口的代理通常在本地情况下无关紧要。但是，当您 export 一个 remote 服务时，您应该公开一个特定的服务接口，其中包含用于 remote 使用的特定操作。除了内部回调接口，目标可能会实现多个业务接口，其中只有一个用于 remote 暴露。出于这些原因，我们需要指定这样的服务接口。</p>
<p>这在配置方便性和内部方法意外暴露的风险之间是 trade-off。始终指定服务接口不是太费力，并且使您在特定方法的受控暴露方面保持安全。</p>
<h3 id="1-7-选择技术时的注意事项"><a href="#1-7-选择技术时的注意事项" class="headerlink" title="1.7. 选择技术时的注意事项"></a>1.7. 选择技术时的注意事项</h3><p>这里介绍的每项技术都有其缺点。在选择技术时，您应该仔细考虑您的需求，您公开的服务以及您通过网络发送的对象。</p>
<p>使用 RMI 时，除非隧道传输 RMI 流量，否则无法通过 HTTP 协议访问 objects。 RMI 是一个相当协议，因为它支持 full-object 序列化，当您使用需要通过线路进行序列化的复杂数据 model 时，这很重要。但是，RMI-JRMP 与 Java clients 绑定。这是一个 Java-to-Java 远程解决方案。</p>
<p>如果你需要 HTTP-based 远程处理但是依赖于 Java 序列化，Spring 的 HTTP 调用程序是一个很好的选择。它与 RMI 调用程序共享基本基础结构，但使用 HTTP 作为传输。请注意，HTTP 调用程序不仅限于 Java-to-Java 远程处理，还包括 client 和服务器端的 Spring。 (后者也适用于 Spring 的 RMI 调用者 non-RMI interfaces.)</p>
<p>在异构环境中运行时，Hessian 可能会提供重要的 value，因为它们明确允许 non-Java clients。但是，non-Java 支持仍然有限。已知问题包括 Hibernate objects 与 lazily-initialized 集合的序列化。如果您有这样的数据 model，请考虑使用 RMI 或 HTTP 调用程序而不是 Hessian。</p>
<p>JMS 可用于提供服务集群，并让 JMS broker 负责负载平衡，发现和 auto-failover。默认情况下，Java 序列化用于 JMS 远程处理，但 JMS 提供程序可以使用不同的机制进行有线格式化，例如 XStream 允许服务器在其他技术中实现。</p>
<p>最后但并非最不重要的是，EJB 具有优于 RMI 的优势，因为它支持标准 role-based 身份验证和授权以及 remote transaction 传播。有可能让 RMI 调用者或 HTTP 调用者也支持安全 context 传播，尽管核心 Spring 不提供。 Spring 仅提供适当的挂钩，用于插入 third-party 或自定义解决方案。</p>
<h3 id="1-8-REST-Endpoints"><a href="#1-8-REST-Endpoints" class="headerlink" title="1.8. REST Endpoints"></a>1.8. REST Endpoints</h3><p>Spring Framework 为 Calls REST endpoints 提供了两种选择：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#rest-resttemplate">使用 RestTemplate</a>：原始的 Spring REST client，带有同步的模板方法 API。</li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-client">Web 客户端</a>：支持同步和异步以及流方案的 non-blocking，reactive 备选方案。</li>
</ul>
<blockquote>
<p>从 5.0 开始，non-blocking，reactive <code>WebClient</code>提供了<code>RestTemplate</code>的现代替代方案，同时有效地支持同步和异步以及流方案。 <code>RestTemplate</code>将在未来的 version 中弃用，并且不会在未来添加主要的新 features。</p>
</blockquote>
<h4 id="1-8-1-使用-RestTemplate"><a href="#1-8-1-使用-RestTemplate" class="headerlink" title="1.8.1. 使用 RestTemplate"></a>1.8.1. 使用 RestTemplate</h4><p><code>RestTemplate</code>提供了比 HTTP client libraries 更高的 level API。它使得在单个 line 中调用 REST endpoints 变得容易。它公开了以下重载方法组：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法 group</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getForObject</code></td>
<td>通过 GET 检索表示。</td>
</tr>
<tr>
<td><code>getForEntity</code></td>
<td>使用 GET 检索<code>ResponseEntity</code>(即 status，headers 和 body)。</td>
</tr>
<tr>
<td><code>headForHeaders</code></td>
<td>使用 HEAD 检索资源的所有 headers。</td>
</tr>
<tr>
<td><code>postForLocation</code></td>
<td>使用 POST 创建新资源，并从响应中返回<code>Location</code>标头。</td>
</tr>
<tr>
<td><code>postForObject</code></td>
<td>使用 POST 创建新资源并从响应中返回表示。</td>
</tr>
<tr>
<td><code>postForEntity</code></td>
<td>使用 POST 创建新资源并从响应中返回表示。</td>
</tr>
<tr>
<td><code>put</code></td>
<td>使用 PUT 创建或更新资源。</td>
</tr>
<tr>
<td><code>patchForObject</code></td>
<td>使用 PATCH 更新资源并从响应中返回表示。请注意，JDK <code>HttpURLConnection</code>不支持<code>PATCH</code>，但 Apache HttpComponents 和其他人一样。</td>
</tr>
<tr>
<td><code>delete</code></td>
<td>使用 DELETE 删除指定 URI 处的资源。</td>
</tr>
<tr>
<td><code>optionsForAllow</code></td>
<td>使用 ALLOW 检索资源的允许 HTTP 方法。</td>
</tr>
<tr>
<td><code>exchange</code></td>
<td>对前述方法的更广泛(且不那么自以为是)version，在需要时提供额外的灵活性。它接受<code>RequestEntity</code>(包括 HTTP 方法，URL，headers 和 body 作为输入)并返回<code>ResponseEntity</code>。 这些方法允许使用<code>ParameterizedTypeReference</code>而不是<code>Class</code>来指定具有泛型的响应类型。</td>
</tr>
<tr>
<td><code>execute</code></td>
<td>执行请求的最通用方式，通过回调接口完全控制请求准备和响应提取。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>默认构造函数使用<code>java.net.HttpURLConnection</code>来执行请求。您可以使用<code>ClientHttpRequestFactory</code>的 implementation 切换到不同的 HTTP library。以下是 built-in 支持：</p>
<ul>
<li>Apache HttpComponents</li>
<li>Netty</li>
<li>OkHttp</li>
</ul>
<p>对于 example，要切换到 Apache HttpComponents，您可以使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate template &#x3D; new RestTemplate(new HttpComponentsClientHttpRequestFactory());</span><br></pre></td></tr></table></figure>
<p>每个<code>ClientHttpRequestFactory</code>都公开特定于底层 HTTP client library 的 configuration 选项 - 用于 example，用于凭据，连接池和其他详细信息。</p>
<blockquote>
<p>请注意，HTTP 请求的<code>java.net</code> implementation 可以在访问表示错误的响应的状态(例如 401)时引发 exception。如果这是一个问题，请切换到另一个 HTTP client library。</p>
</blockquote>
<h5 id="URIs"><a href="#URIs" class="headerlink" title="URIs"></a>URIs</h5><p>许多<code>RestTemplate</code>方法接受 URI 模板和 URI 模板变量，可以是<code>String</code>变量参数，也可以是<code>Map&lt;String,String&gt;</code>。</p>
<p>以下 example 使用<code>String</code> variable 参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String result &#x3D; restTemplate.getForObject(</span><br><span class="line">        &quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&#x2F;bookings&#x2F;&#123;booking&#125;&quot;, String.class, &quot;42&quot;, &quot;21&quot;);</span><br></pre></td></tr></table></figure>
<p>以下 example 使用<code>Map&lt;String, String&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; vars &#x3D; Collections.singletonMap(&quot;hotel&quot;, &quot;42&quot;);</span><br><span class="line"></span><br><span class="line">String result &#x3D; restTemplate.getForObject(</span><br><span class="line">        &quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&#x2F;rooms&#x2F;&#123;hotel&#125;&quot;, String.class, vars);</span><br></pre></td></tr></table></figure>
<p>请记住，URI 模板会自动编码，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">restTemplate.getForObject(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotel list&quot;, String.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Results in request to &quot;http:&#x2F;&#x2F;example.com&#x2F;hotel%20list&quot;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>RestTemplate</code>的<code>uriTemplateHandler</code> property 来自定义 URI 的编码方式。或者，您可以准备<code>java.net.URI</code>并将其传递给接受<code>URI</code>的<code>RestTemplate</code>方法之一。</p>
<p>有关使用和编码 URI 的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-uri-building">URI 链接</a>。</p>
<h5 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h5><p>您可以使用<code>exchange()</code>方法指定 request headers，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String uriTemplate &#x3D; &quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;;</span><br><span class="line">URI uri &#x3D; UriComponentsBuilder.fromUriString(uriTemplate).build(42);</span><br><span class="line"></span><br><span class="line">RequestEntity&lt;Void&gt; requestEntity &#x3D; RequestEntity.get(uri)</span><br><span class="line">        .header((&quot;MyRequestHeader&quot;, &quot;MyValue&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;String&gt; response &#x3D; template.exchange(requestEntity, String.class);</span><br><span class="line"></span><br><span class="line">String responseHeader &#x3D; response.getHeaders().getFirst(&quot;MyResponseHeader&quot;);</span><br><span class="line">String body &#x3D; response.getBody();</span><br></pre></td></tr></table></figure>
<p>您可以通过_ret 的许多<code>RestTemplate</code>方法变体获取响应 headers。</p>
<h5 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h5><p>传递给<code>RestTemplate</code>方法并从<code>RestTemplate</code>方法返回的 Objects 在<code>HttpMessageConverter</code>的帮助下转换为原始内容和从原始内容转换。</p>
<p>在 POST 上，输入 object 被序列化到请求主体，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI location &#x3D; template.postForLocation(&quot;http:&#x2F;&#x2F;example.com&#x2F;people&quot;, person);</span><br></pre></td></tr></table></figure>
<p>您无需显式设置请求的 Content-Type 标头。在大多数情况下，您可以找到基于源<code>Object</code>类型的兼容消息转换器，并且所选消息转换器相应地设置 content type。如有必要，您可以使用<code>exchange</code>方法显式提供<code>Content-Type</code>请求标头，这反过来会影响选择的消息转换器。</p>
<p>在 GET 上，响应的主体被反序列化为输出<code>Object</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;example.com&#x2F;people&#x2F;&#123;id&#125;&quot;, Person.class, 42);</span><br></pre></td></tr></table></figure>
<p>请求的<code>Accept</code>标头不需要显式设置。在大多数情况下，可以根据预期的响应类型找到兼容的消息转换器，然后有助于填充<code>Accept</code>标头。如有必要，可以使用<code>exchange</code>方法显式提供<code>Accept</code>标头。</p>
<p>默认情况下，<code>RestTemplate</code>会注册所有 built-in <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#rest-message-conversion">消息转换器</a>，具体取决于 classpath 检查，这有助于确定存在哪些可选转换 libraries。您还可以将消息转换器设置为显式使用。</p>
<h5 id="消息转换"><a href="#消息转换" class="headerlink" title="消息转换"></a>消息转换</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs">与 Spring WebFlux 相同</a></p>
<p><code>spring-web</code>模块包含<code>HttpMessageConverter</code> contract，用于通过<code>InputStream</code>和<code>OutputStream</code>读取和写入 HTTP 请求和响应的主体。 实例用于 client 端(用于 example，在<code>RestTemplate</code>中)和服务器端(用于 example，在 Spring MVC REST 控制器中)。</p>
<p>framework 中提供了主要媒体(MIME)类型的具体 implementation，默认情况下，在 client 端注册<code>RestTemplate</code>，在服务器端注册<code>RequestMethodHandlerAdapter</code>(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-message-converters">配置消息转换器</a>)。</p>
<p><code>HttpMessageConverter</code>的 implementation 将在以下部分中介绍。对于所有转换器，使用默认媒体类型，但您可以通过设置<code>supportedMediaTypes</code> bean property 来覆盖它。以下 table 描述了每个 implementation：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MessageConverter</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>StringHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以从 HTTP 请求和响应中读取和写入<code>String</code>实例。默认情况下，此转换器支持所有文本媒体类型(<code>text/*</code>)并使用<code>Content-Type</code> <code>text/plain</code>进行写入。</td>
</tr>
<tr>
<td><code>FormHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以从 HTTP 请求和响应中读取和写入表单数据。默认情况下，此转换器读取和写入<code>application/x-www-form-urlencoded</code>媒体类型。表格数据从<code>MultiValueMap&lt;String, String&gt;</code>读取并写入.3_。</td>
</tr>
<tr>
<td><code>ByteArrayHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以从 HTTP 请求和响应中读取和写入字节数组。默认情况下，此转换器支持所有媒体类型(<code>*/*</code>)并使用<code>Content-Type</code> <code>application/octet-stream</code>进行写入。您可以通过设置<code>supportedMediaTypes</code> property 并覆盖<code>getContentType(byte[])</code>来覆盖它。</td>
</tr>
<tr>
<td><code>MarshallingHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以通过<code>org.springframework.oxm</code>包中使用 Spring 的<code>Marshaller</code>和<code>Unmarshaller</code>抽象来读写 XML。该转换器需要<code>Marshaller</code>和<code>Unmarshaller</code>才能使用。您可以通过构造函数或 bean properties 对它们进行注入。默认情况下，此转换器支持<code>text/xml</code>和<code>application/xml</code>。</td>
</tr>
<tr>
<td><code>MappingJackson2HttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以使用 Jackson 的<code>ObjectMapper</code>来读写 JSON。您可以根据需要通过使用 Jackson 提供的注释来自定义 JSON 映射。当您需要进一步控制时(对于需要为特定类型提供自定义 JSON serializers/deserializers 的情况)，您可以通过<code>ObjectMapper</code> property 注入自定义<code>ObjectMapper</code>。默认情况下，此转换器支持<code>application/json</code>。</td>
</tr>
<tr>
<td><code>MappingJackson2XmlHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以使用<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML</a>扩展名的<code>XmlMapper</code>来读写 XML。您可以根据需要通过使用 JAXB 或 Jackson 提供的注释来自定义 XML 映射。当您需要进一步控制时(对于需要为特定类型提供自定义 XML serializers/deserializers 的情况)，您可以通过<code>ObjectMapper</code> property 注入自定义<code>XmlMapper</code>。默认情况下，此转换器支持<code>application/xml</code>。</td>
</tr>
<tr>
<td><code>SourceHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以从 HTTP 请求和响应中读取和写入<code>javax.xml.transform.Source</code>。仅支持<code>DOMSource</code>，<code>SAXSource</code>和<code>StreamSource</code>。默认情况下，此转换器支持<code>text/xml</code>和<code>application/xml</code>。</td>
</tr>
<tr>
<td><code>BufferedImageHttpMessageConverter</code></td>
<td>一个<code>HttpMessageConverter</code> implementation，可以从 HTTP 请求和响应中读取和写入<code>java.awt.image.BufferedImage</code>。此转换器读取和写入 Java I/O API 支持的媒体类型。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Jackson-JSON-视图"><a href="#Jackson-JSON-视图" class="headerlink" title="Jackson JSON 视图"></a>Jackson JSON 视图</h5><p>您可以指定<a target="_blank" rel="noopener" href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson JSON 查看</a>仅序列化 object properties 的子集，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MappingJacksonValue value &#x3D; new MappingJacksonValue(new User(&quot;eric&quot;, &quot;7!jd#h23&quot;));</span><br><span class="line">value.setSerializationView(User.WithoutPasswordView.class);</span><br><span class="line"></span><br><span class="line">RequestEntity&lt;MappingJacksonValue&gt; requestEntity &#x3D;</span><br><span class="line">    RequestEntity.post(new URI(&quot;http:&#x2F;&#x2F;example.com&#x2F;user&quot;)).body(value);</span><br><span class="line"></span><br><span class="line">ResponseEntity&lt;String&gt; response &#x3D; template.exchange(requestEntity, String.class);</span><br></pre></td></tr></table></figure>
<h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h5><p>要发送 multipart 数据，您需要提供<code>MultiValueMap&lt;String, ?&gt;</code>，其值为表示部件内容的<code>Object</code>实例或表示部件的内容和_header 的<code>HttpEntity</code>实例。 <code>MultipartBodyBuilder</code>提供了一个方便的 API 来准备 multipart 请求，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder &#x3D; new MultipartBodyBuilder();</span><br><span class="line">    builder.part(&quot;fieldPart&quot;, &quot;fieldValue&quot;);</span><br><span class="line">    builder.part(&quot;filePart&quot;, new FileSystemResource(&quot;...logo.png&quot;));</span><br><span class="line">    builder.part(&quot;jsonPart&quot;, new Person(&quot;Jason&quot;));</span><br><span class="line"></span><br><span class="line">    MultiValueMap&lt;String, HttpEntity&lt;?&gt;&gt; parts &#x3D; builder.build();</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，您不必为每个零件指定<code>Content-Type</code>。 content type 是根据所选的<code>HttpMessageConverter</code>自动确定的，以便序列化它，如果是<code>Resource</code>，则根据文件扩展名自动确定。如有必要，您可以通过其中一个重载的构建器<code>part</code>方法显式提供<code>MediaType</code>以用于每个部件。</p>
<p>一旦<code>MultiValueMap</code>准备就绪，您可以将其传递给<code>RestTemplate</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MultipartBodyBuilder builder &#x3D; ...;</span><br><span class="line">    template.postForObject(&quot;http:&#x2F;&#x2F;example.com&#x2F;upload&quot;, builder.build(), Void.class);</span><br></pre></td></tr></table></figure>
<p>如果<code>MultiValueMap</code>包含至少一个非<code>String</code> value，它也可以表示常规表单数据(即<code>application/x-www-form-urlencoded</code>)，则无需将<code>Content-Type</code>设置为<code>multipart/form-data</code>。当您使用确保<code>HttpEntity</code> wrapper 的<code>MultipartBodyBuilder</code>时，情况总是如此。</p>
<h4 id="1-8-2-使用-AsyncRestTemplate-已弃用"><a href="#1-8-2-使用-AsyncRestTemplate-已弃用" class="headerlink" title="1.8.2. 使用 AsyncRestTemplate(已弃用)"></a>1.8.2. 使用 AsyncRestTemplate(已弃用)</h4><p><code>AsyncRestTemplate</code>已弃用。对于您可能考虑使用<code>AsyncRestTemplate</code>的所有用例，请改用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-client">Web 客户端</a>。</p>
<h2 id="2-Enterprise-JavaBeans-EJB-Integration"><a href="#2-Enterprise-JavaBeans-EJB-Integration" class="headerlink" title="2. Enterprise JavaBeans(EJB)Integration"></a>2. Enterprise JavaBeans(EJB)Integration</h2><p>作为一个轻量级容器，Spring 通常被认为是 EJB 的替代品。我们相信，对于许多(如果不是大多数)应用程序和用例，Spring 作为容器，结合其在 transactions，ORM 和 JDBC 访问领域的丰富支持功能，是比通过 EJB 实现等效功能更好的选择容器和 EJB。</p>
<p>但是，请务必注意，使用 Spring 不会阻止您使用 EJB。实际上，Spring 使得访问 EJB 以及在其中实现 EJB 和功能变得更加容易。此外，使用 Spring 访问 EJB 提供的服务允许稍后在本地 EJB，remote EJB 或 POJO(普通旧 Java object)变体之间切换这些服务的 implementation，而不必更改 client code。</p>
<p>在本章中，我们将了解 Spring 如何帮助您访问和实现 EJB。 Spring 在访问 stateless session beans(SLSB)时提供特定的 value，因此我们首先讨论这个 topic。</p>
<h3 id="2-1-访问-EJB"><a href="#2-1-访问-EJB" class="headerlink" title="2.1. 访问 EJB"></a>2.1. 访问 EJB</h3><p>本节介绍如何访问 EJB。</p>
<h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1. 概念"></a>2.1.1. 概念</h4><p>要在本地或 remote stateless session bean 上调用方法，client code 通常必须执行 JNDI 查找以获取(本地或 remote)EJB Home object，然后在该 object 上使用<code>create</code>方法调用来获取实际(local 或 remote) )EJB object。然后在 EJB 上调用一个或多个方法。</p>
<p>为避免重复 low-level code，许多 EJB applications 使用 Service Locator 和 Business Delegate 模式。这些比在整个 client code 中喷涂 JNDI 查找更好，但它们通常的 implementations 有明显的缺点：</p>
<ul>
<li>通常，使用 EJB 的 code 取决于 Service Locator 或 Business Delegate 单例，因此很难进行测试。</li>
<li>对于没有业务委托使用的服务定位器 pattern，application code 仍然需要在 EJB 主目录上调用<code>create()</code>方法并处理生成的 exceptions。因此，它仍然与 EJB API 和 EJB 编程 model 的复杂性联系在一起。</li>
<li>实现 Business Delegate pattern 通常会导致重大的 code 重复，我们必须编写许多在 EJB 上调用相同方法的方法。</li>
</ul>
<p>Spring 方法允许创建和使用代理 objects(通常在 Spring 容器内配置)，它们充当无代码业务委托。您不需要在 hand-coded Business Delegate 中编写另一个 Service Locator，另一个 JNDI 查找或重复方法，除非您在此类 code 中实际添加了实际 value。</p>
<h4 id="2-1-2-访问本地-SLSB"><a href="#2-1-2-访问本地-SLSB" class="headerlink" title="2.1.2. 访问本地 SLSB"></a>2.1.2. 访问本地 SLSB</h4><p>假设我们有一个需要使用本地 EJB 的 web 控制器。我们遵循最佳实践并使用 EJB 业务方法接口 pattern，以便 EJB 的本地接口扩展 non-EJB-specific 业务方法接口。我们将此业务方法称为接口<code>MyComponent</code>。以下 example 显示了这样的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MyComponent &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用业务方法接口 pattern 的主要原因之一是确保本地接口中的方法签名与 bean implementation class 之间的同步是自动的。另一个原因是它后来使我们更容易切换到服务的 POJO(普通的旧 Java object)implementation，如果有意义的话。我们还需要实现本地 home 接口并提供 implementation class 来实现<code>SessionBean</code>和<code>MyComponent</code>业务方法接口。现在，我们需要做的唯一 Java 编码将我们的 web 层控制器连接到 EJB implementation 是在控制器上公开类型为<code>MyComponent</code>的 setter 方法。这将 reference 保存为控制器中的实例变量。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private MyComponent myComponent;</span><br><span class="line"></span><br><span class="line">public void setMyComponent(MyComponent myComponent) &#123;</span><br><span class="line">    this.myComponent &#x3D; myComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们随后可以在控制器中的任何业务方法中使用此实例变量。现在，假设我们从 Spring 容器中获取控制器 object，我们可以(在相同的 context 中)配置<code>LocalStatelessSessionProxyFactoryBean</code>实例，即 EJB 代理 object。我们配置代理并使用以下 configuration 条目设置控制器的<code>myComponent</code> property：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myComponent&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;ejb&#x2F;myBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;businessInterface&quot; value&#x3D;&quot;com.mycom.MyComponent&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;myController&quot; class&#x3D;&quot;com.mycom.myController&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;myComponent&quot; ref&#x3D;&quot;myComponent&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>尽管你没有被迫使用 AOP 概念来享受结果，但很多工作都在幕后发生，由 Spring AOP framework 提供。 <code>myComponent</code> bean 定义为 EJB 创建代理，该代理实现业务方法接口。 EJB 本地主目录在启动时被缓存，因此只有一个 JNDI 查找。每次调用 EJB 时，代理都会调用本地 EJB 上的<code>classname</code>方法，并在 EJB 上调用相应的业务方法。</p>
<p><code>myController</code> bean 定义将控制器 class 的<code>myComponent</code> property 设置为 EJB 代理。</p>
<p>或者(并且最好在许多此类代理定义的情况下)，考虑在 Spring 的“jee”命名空间中使用<code>&lt;jee:local-slsb&gt;</code> configuration 元素。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:local-slsb id&#x3D;&quot;myComponent&quot; jndi-name&#x3D;&quot;ejb&#x2F;myBean&quot;</span><br><span class="line">        business-interface&#x3D;&quot;com.mycom.MyComponent&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;myController&quot; class&#x3D;&quot;com.mycom.myController&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;myComponent&quot; ref&#x3D;&quot;myComponent&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>这种 EJB 访问机制大大简化了 application code。 web 层 code(或其他 EJB client code)不依赖于 EJB 的使用。要用 POJO 或 mock object 或其他测试存根替换此 EJB reference，我们可以在不更改 Java code 的 line 的情况下更改<code>myComponent</code> bean 定义。另外，我们不必编写单个 line 的 JNDI 查找或其他 EJB 管道 code 作为我们的 application 的一部分。</p>
<p>实际应用程序中的基准和经验表明，这种方法的性能开销(涉及目标 EJB 的反射调用)很小，在典型使用中无法检测到。请记住，我们不希望将 fine-grained calls 设置为 EJB，因为在 application 服务器中存在与 EJB 基础结构相关的成本。</p>
<p>关于 JNDI 查找有一点需要注意。在 bean 容器中，这个 class 通常最好用作 singleton(没有理由将它作为原型)。但是，如果 bean 容器 pre-instantiates 单例(与各种 XML <code>ApplicationContext</code>变体一样)，如果在 EJB 容器加载目标 EJB 之前加载 bean 容器，则会出现问题。这是因为 JNDI 查找在此 class 的<code>init()</code>方法中执行，然后进行了缓存，但 EJB 尚未绑定到目标位置。解决方案是不要 pre-instantiate 这个工厂 object 但是要在第一次使用时创建它。在 XML 容器中，您可以使用<code>lazy-init</code>属性来控制它。</p>
<p>尽管对大多数 Spring 用户不感兴趣，但那些使用 EJB 编程的 AOP 工作的人可能希望查看<code>LocalSlsbInvokerInterceptor</code>。</p>
<h4 id="2-1-3-访问-Remote-SLSB"><a href="#2-1-3-访问-Remote-SLSB" class="headerlink" title="2.1.3. 访问 Remote SLSB"></a>2.1.3. 访问 Remote SLSB</h4><p>除了使用<code>SimpleRemoteStatelessSessionProxyFactoryBean</code>或<code>&lt;jee:remote-slsb&gt;</code> configuration 元素之外，访问 remote EJB 与访问本地 EJB 基本相同。当然，无论有没有 Spring，remote 调用语义都适用：对另一台计算机中另一台虚拟机中 object 上的方法的调用有时必须在使用场景和故障处理方面区别对待。</p>
<p>Spring 的 EJB client 支持比 non-Spring 方法增加了一个优势。通常，EJB client code 很容易在本地或远程调用 EJB 之间来回切换。这是因为 remote 接口方法必须声明它们抛出<code>RemoteException</code>，并且 client code 必须处理这个，而本地接口方法不需要。为需要移动到 remote EJB 的本地 EJB 编写的 Client code 通常必须进行修改以添加 remote exceptions 的处理，并且为需要移动到本地 EJB 的 remote EJB 编写的 client code 可以保持不变但是执行很多不必要的 remote exceptions 处理或被修改以删除该 code。使用 Spring remote EJB 代理，您可以不在业务方法接口中声明任何抛出的<code>RemoteException</code>并实现 EJB code，具有相同的 remote 接口(除了它会抛出<code>RemoteException</code>)，并依赖代理动态处理两个接口好像它们是相同的。也就是说，client code 不必处理已检查的<code>RemoteException</code> class。在 EJB 调用期间抛出的任何实际<code>RemoteException</code>都是 re-thrown 作为 non-checked <code>RemoteAccessException</code> class，它是<code>RuntimeException</code>的子类。然后，您可以在本地 EJB 或 remote EJB(甚至是普通的 Java object)implementation 之间随意切换目标服务，而无需知道或关注 client code。当然，这是可选的：没有什么能阻止你在业务界面中声明<code>RemoteException</code>。</p>
<h4 id="2-1-4-访问-EJB-2-x-SLSB-与-EJB-3-SLSB"><a href="#2-1-4-访问-EJB-2-x-SLSB-与-EJB-3-SLSB" class="headerlink" title="2.1.4. 访问 EJB 2.x SLSB 与 EJB 3 SLSB"></a>2.1.4. 访问 EJB 2.x SLSB 与 EJB 3 SLSB</h4><p>通过 Spring 访问 EJB 2.x Session Beans 和 EJB 3 Session Beans 在很大程度上是透明的。 Spring 的 EJB 访问器，包括<code>&lt;jee:local-slsb&gt;</code>和<code>&lt;jee:remote-slsb&gt;</code>工具，在运行时透明地适应实际的 component。如果找到(EJB 2.x 样式)，它们将处理 home 接口，或者如果没有可用的 home 接口，则执行直接 component 调用(EJB 3 样式)。</p>
<p>注意：对于 EJB 3 Session Beans，您也可以有效地使用<code>JndiObjectFactoryBean</code>/<code>&lt;jee:jndi-lookup&gt;</code>，因为那里公开了完全可用的 component references 用于普通 JNDI 查找。定义显式<code>&lt;jee:local-slsb&gt;</code>或<code>&lt;jee:remote-slsb&gt;</code>查找可提供一致且更明确的 EJB 访问配置。</p>
<h2 id="3-JMS-Java-消息服务"><a href="#3-JMS-Java-消息服务" class="headerlink" title="3. JMS(Java 消息服务)"></a>3. JMS(Java 消息服务)</h2><p>Spring 提供了一个 JMS integration framework，它简化了 JMS API 的使用，就像 Spring 的 integration 对 JDBC API 一样。</p>
<p>JMS 可以大致分为两个功能区域，即消息的生产和消费。 <code>JmsTemplate</code> class 用于消息 production 和同步消息接收。对于类似于 Java EE 的 message-driven bean 样式的异步接收，Spring 提供了许多可用于创建 Message-Driven POJO(MDP)的 message-listener 容器。 Spring 还提供了一种创建消息 listeners 的声明方式。</p>
<p><code>org.springframework.jms.core</code>包提供了使用 JMS 的核心功能。它包含 JMS 模板 classes，它通过处理资源的创建和释放来简化 JMS 的使用，就像<code>JdbcTemplate</code>对 JDBC 一样。 Spring 模板 classes 的设计原则 common 是提供帮助方法来执行 common 操作，并且为了更复杂的用法，将处理任务的本质委托给 user-implemented 回调接口。 JMS 模板遵循相同的设计。 classes 提供了各种方便的方法来发送消息，同步消耗消息，以及向用户公开 JMS session 和 messageproducer。</p>
<p><code>org.springframework.jms.support</code>包提供<code>JMSException</code>转换功能。转换将已检查的<code>JMSException</code>层次结构转换为未检查的 exceptions 的镜像层次结构。如果已检查的<code>javax.jms.JMSException</code>的任何 provider-specific 子类存在，则此 exception 将包含在未选中的<code>UncategorizedJmsException</code>中。</p>
<p><code>org.springframework.jms.support.converter</code>包提供<code>MessageConverter</code>抽象以在 Java objects 和 JMS 消息之间进行转换。</p>
<p><code>org.springframework.jms.support.destination</code>包提供了各种管理 JMS 目标的策略，例如为存储在 JNDI 中的目标提供服务定位器。</p>
<p><code>org.springframework.jms.annotation</code>包提供了必要的基础结构，通过使用<code>@JmsListener</code>来支持 annotation-driven listener endpoints。</p>
<p><code>org.springframework.jms.config</code>包为<code>jms</code>名称空间提供解析器 implementation，以及为配置 listener 容器和创建 listener endpoints 的 java config 支持。</p>
<p>最后，<code>org.springframework.jms.connection</code>包提供<code>ConnectionFactory</code>的_implement，适用于独立的 applications。它还包含一个 Spring 的<code>PlatformTransactionManager</code>实现 JMS(狡猾地命名为<code>JmsTransactionManager</code>)。这允许将 JMS 作为 transactional 资源无缝整合到 Spring 的 transaction management 机制中。</p>
<h3 id="3-1-使用-Spring-JMS"><a href="#3-1-使用-Spring-JMS" class="headerlink" title="3.1. 使用 Spring JMS"></a>3.1. 使用 Spring JMS</h3><p>本节介绍如何使用 Spring 的 JMS 组件。</p>
<h4 id="3-1-1-使用-JmsTemplate"><a href="#3-1-1-使用-JmsTemplate" class="headerlink" title="3.1.1. 使用 JmsTemplate"></a>3.1.1. 使用 JmsTemplate</h4><p><code>JmsTemplate</code> class 是 JMS 核心包中的中心 class。它简化了 JMS 的使用，因为它在发送或同步接收消息时处理资源的创建和释放。</p>
<p>使用<code>JmsTemplate</code>的 Code 只需要实现回调接口，为它们提供明确定义的 high-level contract。 <code>MessageCreator</code>回调接口在<code>JmsTemplate</code>中调用 code 提供<code>Session</code>时创建一条消息。为了允许更复杂地使用 JMS API，<code>SessionCallback</code>提供 JMS session，<code>ProducerCallback</code>提供<code>Session</code>和<code>MessageProducer</code>对。</p>
<p>JMS API 公开了两种类型的发送方法，一种采用传递模式，优先级，time-to-live 作为服务质量(QOS)参数，另一种不采用 QOS 参数并使用默认值。由于<code>JmsTemplate</code>有许多发送方法，因此设置 QOS 参数已作为 bean properties 公开，以避免重复发送方法的数量。同样，使用<code>setReceiveTimeout</code> property 设置同步 receive calls 的超时值。</p>
<p>一些 JMS 提供程序允许通过<code>ConnectionFactory</code>的 configuration 以管理方式设置默认 QOS 值。这会导致对<code>MessageProducer</code>实例的<code>send</code>方法(<code>send(Destination destination, Message message)</code>)的调用使用与 JMS 规范中指定的值不同的 QOS 默认值。在 order 中提供 QOS 值的一致 management，因此，<code>JmsTemplate</code>必须通过将 boolean property <code>isExplicitQosEnabled</code>设置为<code>true</code>来专门启用它自己的 QOS 值。</p>
<p>为方便起见，<code>JmsTemplate</code>还公开了一个基本的 request-reply 操作，该操作允许发送消息并等待作为操作的一部分创建的临时队列的回复。</p>
<blockquote>
<p>一旦配置，<code>JmsTemplate</code> class 的实例为 thread-safe。这很重要，因为这意味着您可以配置<code>JmsTemplate</code>的单个实例，然后安全地将此共享 reference 注入多个协作者。要清楚，<code>JmsTemplate</code>是有状态的，因为它维护的 reference，但是 state 不是会话 state。</p>
</blockquote>
<p>从 Spring Framework 4.1 开始，<code>JmsMessagingTemplate</code>构建在<code>JmsTemplate</code>之上，并提供与消息抽象的 integration - 即<code>org.springframework.messaging.Message</code>。这使您可以创建要以通用方式发送的消息。</p>
<h4 id="3-1-2-连接"><a href="#3-1-2-连接" class="headerlink" title="3.1.2. 连接"></a>3.1.2. 连接</h4><p><code>JmsTemplate</code>需要参考<code>ConnectionFactory</code>。 <code>ConnectionFactory</code>是 JMS 规范的一部分，并作为使用 JMS 的入口点。它被 client application 用作工厂来创建与 JMS 提供程序的连接，并封装各种 configuration 参数，其中许多是 vendor-specific，例如 SSL configuration 选项。</p>
<p>在 EJB 中使用 JMS 时，供应商提供 JMS 接口的 implementations，以便它们可以参与声明式 transaction management 并执行连接和会话池。在 order 中使用此 implementation，Java EE 容器通常要求您在 EJB 或 servlet 部署描述符中将 JMS 连接工厂声明为<code>resource-ref</code>。为了确保在 EJB 内部使用<code>JmsTemplate</code>这些 features，client application 应该确保它__seferences <code>ConnectionFactory</code>的托管 implementation。</p>
<h5 id="缓存消息传递资源"><a href="#缓存消息传递资源" class="headerlink" title="缓存消息传递资源"></a>缓存消息传递资源</h5><p>标准 API 涉及创建许多中间 objects。要发送消息，请执行以下“API”步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory-&gt;Connection-&gt;Session-&gt;MessageProducer-&gt;send</span><br></pre></td></tr></table></figure>
<p>在<code>ConnectionFactory</code>和<code>Send</code>操作之间，创建并销毁了三个中间 object。为了优化资源使用并提高 performance，Spring 提供了<code>ConnectionFactory</code>的两个 implementations。</p>
<h5 id="使用-SingleConnectionFactory"><a href="#使用-SingleConnectionFactory" class="headerlink" title="使用 SingleConnectionFactory"></a>使用 SingleConnectionFactory</h5><p>Spring 提供了<code>ConnectionFactory</code>接口的 implementation <code>SingleConnectionFactory</code>，它在所有<code>createConnection()</code> calls 上返回相同的<code>Connection</code>，并忽略 calls 到<code>close()</code>。这对于测试和独立环境非常有用，因此可以将相同的连接用于多个可以 span 任意数量的 transactions 的<code>JmsTemplate</code> calls。 <code>SingleConnectionFactory</code>对标准<code>ConnectionFactory</code>进行 reference，通常来自 JNDI。</p>
<h5 id="使用-CachingConnectionFactory"><a href="#使用-CachingConnectionFactory" class="headerlink" title="使用 CachingConnectionFactory"></a>使用 CachingConnectionFactory</h5><p><code>CachingConnectionFactory</code>扩展了<code>SingleConnectionFactory</code>的功能，并添加了<code>Session</code>，<code>MessageProducer</code>和<code>MessageConsumer</code>实例的缓存。初始高速缓存大小设置为<code>1</code>。您可以使用<code>sessionCacheSize</code> property 来增加缓存会话的数量。请注意，实际缓存会话的数量大于该数量，因为会话基于其确认模式进行缓存，因此当<code>sessionCacheSize</code>设置为 1 时，最多可以有四个缓存的 session 实例(每个确认模式一个)。 <code>MessageProducer</code>和<code>MessageConsumer</code>实例在其拥有的 session 中缓存，并在缓存时考虑生产者和使用者的唯一 properties。 MessageProducers 根据其目标进行缓存。 MessageConsumers 基于由目标，选择器，noLocal delivery flag 和持久订阅 name(如果 creating 持久消费者)组成的 key 进行缓存。</p>
<h4 id="3-1-3-目的地管理"><a href="#3-1-3-目的地管理" class="headerlink" title="3.1.3. 目的地管理"></a>3.1.3. 目的地管理</h4><p>作为<code>ConnectionFactory</code>实例的目标是 JMS 管理的 objects，您可以在 JNDI 中存储和检索它们。配置 Spring application context 时，可以使用 JNDI <code>JndiObjectFactoryBean</code> factory class 或<code>&lt;jee:jndi-lookup&gt;</code>对 object 的 references to JMS 目标执行依赖项注入。但是，如果 application 中存在大量目标，或者存在 JMS 提供程序特有的高级目标 management features，则此策略通常很麻烦。此类高级目标 management 的示例包括创建动态目标或支持目标的分层命名空间。 <code>JmsTemplate</code>将目标 name 的解析委托给实现<code>DestinationResolver</code>接口的 JMS 目标 object。 <code>DynamicDestinationResolver</code>是<code>JmsTemplate</code>使用的默认 implementation，适用于解析动态目标。还提供了<code>JndiDestinationResolver</code>作为 JNDI 中包含的目标的服务定位器，并且可选地回退到<code>DynamicDestinationResolver</code>中包含的行为。</p>
<p>通常，JMS application 中使用的目标仅在运行时已知，因此在部署 application 时无法通过管理方式创建。这通常是因为根据 well-known 命名约定在运行时创建目标的交互系统组件之间存在共享的 application 逻辑。尽管动态目标的创建不是 JMS 规范的一部分，但大多数供应商都提供了此功能。动态目标是使用 user-defined name 创建的，它将它们与临时目标区分开来，并且通常不在 JNDI 中注册。用于创建动态目标的 API 因提供商而异，因为与目标关联的 properties 为 vendor-specific。但是，供应商有时会做出一个简单的 implementation 选择，即忽略 JMS 规范中的警告，并使用方法<code>TopicSession</code> <code>createTopic(String topicName)</code>或<code>QueueSession</code> <code>createQueue(String queueName)</code>方法创建具有默认目标 properties 的新目标。根据供应商 implementation，<code>DynamicDestinationResolver</code>也可以创建物理目标，而不是仅解析一个。</p>
<p>boolean property <code>pubSubDomain</code>用于配置<code>JmsTemplate</code>，了解正在使用的 JMS 域。默认情况下，此 property 的 value 为 false，表示将使用 point-to-point 域<code>Queues</code>。此 property(由<code>JmsTemplate</code>使用)通过<code>DestinationResolver</code>接口的 implementations 确定动态目标解析的行为。</p>
<p>您还可以通过 property <code>defaultDestination</code>将<code>JmsTemplate</code>配置为默认目标。默认目标是发送和接收操作，不涉及特定目标。</p>
<h4 id="3-1-4-消息-Listener-容器"><a href="#3-1-4-消息-Listener-容器" class="headerlink" title="3.1.4. 消息 Listener 容器"></a>3.1.4. 消息 Listener 容器</h4><p>EJB 世界中 JMS 消息最常见的用途之一是驱动 message-driven beans(MDB)。 Spring 提供了一种解决方案，可以以不将用户绑定到 EJB 容器的方式创建 message-driven POJO(MDP)。 (有关 Spring 的 MDP support.)的详细介绍，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-asynchronousMessageReception">异步接收：Message-Driven POJO</a>自 Spring Framework 4.1 以来，端点方法可以用<code>@JmsListener</code>注释 - 有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-annotated">Annotation-driven Listener Endpoints</a>。</p>
<p>消息 listener 容器用于从 JMS 消息队列接收消息并驱动注入其中的<code>MessageListener</code>。 listener 容器负责消息接收的所有 threading 并将其分派到 listener 进行处理。消息 listener 容器是 MDP 和消息传递提供程序之间的中介，负责注册接收消息，参与 transactions，资源获取和释放，exception 转换等。这使您可以编写与接收消息(并可能响应消息)相关联的(可能是复杂的)业务逻辑，并将样板 JMS 基础结构问题委托给 framework。</p>
<p>有两个标准的 JMS 消息 listener 容器与 Spring 一起打包，每个容器都有其专门的 feature 集。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-mdp-simple">SimpleMessageListenerContainer 一样</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-mdp-default">使用 DefaultMessageListenerContainer</a></li>
</ul>
<h5 id="使用-SimpleMessageListenerContainer"><a href="#使用-SimpleMessageListenerContainer" class="headerlink" title="使用 SimpleMessageListenerContainer"></a>使用 SimpleMessageListenerContainer</h5><p>此消息 listener 容器是两种标准风格中较简单的一种。它在启动时创建固定数量的 JMS 会话和使用者，使用标准 JMS <code>MessageConsumer.setMessageListener()</code>方法注册 listener，并将其保留在 JMS 提供程序中以执行 listener 回调。此变体不允许动态调整运行时需求或参与外部管理的 transactions。 Compatibility-wise，它非常接近独立 JMS 规范的精神，但通常与 Java EE 的 JMS 限制不兼容。</p>
<blockquote>
<p>虽然<code>SimpleMessageListenerContainer</code>不允许参与外部管理的 transactions，但它确实支持本机 JMS transactions。要启用此 feature，可以将<code>sessionTransacted</code> flag 切换为<code>true</code>，或者在 XML 命名空间中将<code>acknowledge</code>属性设置为<code>transacted</code>。 _listener 抛出的异常然后导致回滚，并重新传递消息。或者，考虑使用<code>CLIENT_ACKNOWLEDGE</code>模式，它在 exception 的情况下也提供重新传递，但不使用事务<code>Session</code>实例，因此，不包括 transaction 协议中的任何其他<code>Session</code>操作(例如发送响应消息)。</p>
<p>默认的<code>AUTO_ACKNOWLEDGE</code>模式不提供适当的可靠性保证。 listener 执行失败时消息可能会丢失(因为提供程序在 listener 调用后自动确认每条消息，没有 exceptions 传播到提供程序)或者 listener 容器关闭时(可以通过设置<code>acceptMessagesWhileStopping</code> flag 来配置)。确保在可靠性需求的情况下使用事务处理会话(例如，用于可靠的队列处理和持久的 topic 订阅)。</p>
</blockquote>
<h5 id="使用-DefaultMessageListenerContainer"><a href="#使用-DefaultMessageListenerContainer" class="headerlink" title="使用 DefaultMessageListenerContainer"></a>使用 DefaultMessageListenerContainer</h5><p>在大多数情况下使用此消息 listener 容器。与<code>SimpleMessageListenerContainer</code>相比，此容器变体允许动态适应运行时需求，并且能够参与外部管理的 transactions。当配置<code>JtaTransactionManager</code>时，每个收到的消息都使用 XA transaction 注册。因此，处理可以利用 XA transaction 语义。这个 listener 容器在 JMS 提供程序的低要求，高级功能(例如参与外部管理的 transactions)和与 Java EE 环境的兼容性之间取得了良好的平衡。</p>
<p>您可以自定义容器的缓存 level。请注意，如果未启用缓存，则会为每个邮件接收创建新连接和新的 session。将此与高负载的 non-durable 订阅相结合可能会导致消息丢失。在这种情况下，请确保使用正确的缓存 level。</p>
<p>当 broker 关闭时，此容器还具有可恢复的功能。默认情况下，简单的<code>BackOff</code> implementation 每五秒重试一次。您可以为更多 fine-grained 恢复选项指定自定义<code>BackOff</code> implementation。有关 example，请参见 api-spring-framework/util/backoff/ExponentialBackOff.html [506]。</p>
<blockquote>
<p>与其兄弟(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-mdp-simple">SimpleMessageListenerContainer 一样</a>)一样，<code>DefaultMessageListenerContainer</code>支持本机 JMS transactions，并允许自定义确认模式。如果您的方案可行，强烈建议使用外部管理的 transactions - 也就是说，如果您在 JVM 死亡的情况下偶尔会出现重复消息。业务逻辑中的自定义重复消息检测步骤可以涵盖这种情况 - 例如，以业务实体存在检查或协议 table 检查的形式。任何此类安排都比替代方案更有效：使用 XA transaction(通过使用<code>JtaTransactionManager</code>配置<code>DefaultMessageListenerContainer</code>)来包装整个处理，以覆盖 JMS 消息的接收以及消息 listener 中业务逻辑的执行(包括数据库操作等)。</p>
<p>默认的<code>AUTO_ACKNOWLEDGE</code>模式不提供适当的可靠性保证。 listener 执行失败时消息可能会丢失(因为提供程序在 listener 调用后自动确认每条消息，没有 exceptions 传播到提供程序)或者 listener 容器关闭时(可以通过设置<code>acceptMessagesWhileStopping</code> flag 来配置)。确保在可靠性需求的情况下使用事务处理会话(例如，用于可靠的队列处理和持久的 topic 订阅)。</p>
</blockquote>
<h4 id="3-1-5-Transaction-Management"><a href="#3-1-5-Transaction-Management" class="headerlink" title="3.1.5. Transaction Management"></a>3.1.5. Transaction Management</h4><p>Spring 提供<code>JmsTransactionManager</code>来管理单个 JMS <code>ConnectionFactory</code>的 transactions。这使得 JMS applications 可以利用 Spring 的 managed-transaction features，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction">数据访问章节的 Transaction Management 部分</a>中所述。 <code>JmsTransactionManager</code>执行本地资源 transactions，_绑定从指定的<code>ConnectionFactory</code>到线程的 JMS Connection/Session 对。 <code>JmsTemplate</code>自动检测此类 transactional 资源并相应地对它们进行操作。</p>
<p>在 Java EE 环境中，<code>ConnectionFactory</code>池连接 Connection 和 Session 实例，因此这些资源可以跨 transactions 有效地重用。在独立环境中，在共享 JMS <code>Connection</code>中使用 Spring 的<code>SingleConnectionFactory</code>结果，每个 transaction 都有自己独立的<code>Session</code>。或者，考虑使用 provider-specific 池适配器，例如 ActiveMQ 的<code>PooledConnectionFactory</code> class。</p>
<p>您还可以将<code>JmsTemplate</code>与<code>JtaTransactionManager</code>和 XA-capable JMS <code>ConnectionFactory</code>一起使用来执行分布式 transactions。请注意，这需要使用 JTA transaction manager 以及正确的 XA-configured ConnectionFactory。 (检查您的 Java EE 服务器或 JMS 提供程序的 documentation.)</p>
<p>使用 JMS API 从<code>Connection</code>创建<code>Session</code>时，在托管和非托管 transactional 环境中重用 code 可能会造成混淆。这是因为 JMS API 只有一个工厂方法来创建<code>Session</code>，它需要 transaction 和 acknowledge 方式的值。在托管环境中，设置这些值是环境的 transactional 基础结构的责任，因此供应商的 wrapper 会忽略这些值到 JMS 连接。在非托管环境中使用<code>JmsTemplate</code>时，可以通过使用 properties <code>sessionTransacted</code>和<code>sessionAcknowledgeMode</code>来指定这些值。当与<code>JmsTemplate</code>一起使用时，模板总是被赋予 transactional JMS <code>Session</code>。</p>
<h3 id="3-2-发送消息"><a href="#3-2-发送消息" class="headerlink" title="3.2. 发送消息"></a>3.2. 发送消息</h3><p><code>JmsTemplate</code>包含许多发送消息的便捷方法。发送方法使用<code>javax.jms.Destination</code> object 指定目标，其他方法通过在 JNDI 查找中使用<code>String</code>指定目标。不带目标参数的<code>send</code>方法使用默认目标。</p>
<p>以下 example 使用<code>MessageCreator</code>回调从提供的<code>Session</code> object 创建文本消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import javax.jms.ConnectionFactory;</span><br><span class="line">import javax.jms.JMSException;</span><br><span class="line">import javax.jms.Message;</span><br><span class="line">import javax.jms.Queue;</span><br><span class="line">import javax.jms.Session;</span><br><span class="line"></span><br><span class="line">import org.springframework.jms.core.MessageCreator;</span><br><span class="line">import org.springframework.jms.core.JmsTemplate;</span><br><span class="line"></span><br><span class="line">public class JmsQueueSender &#123;</span><br><span class="line"></span><br><span class="line">    private JmsTemplate jmsTemplate;</span><br><span class="line">    private Queue queue;</span><br><span class="line"></span><br><span class="line">    public void setConnectionFactory(ConnectionFactory cf) &#123;</span><br><span class="line">        this.jmsTemplate &#x3D; new JmsTemplate(cf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setQueue(Queue queue) &#123;</span><br><span class="line">        this.queue &#x3D; queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void simpleSend() &#123;</span><br><span class="line">        this.jmsTemplate.send(this.queue, new MessageCreator() &#123;</span><br><span class="line">            public Message createMessage(Session session) throws JMSException &#123;</span><br><span class="line">                return session.createTextMessage(&quot;hello queue world&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，<code>JmsTemplate</code>是通过将 reference 传递给<code>ConnectionFactory</code>来构造的。作为替代方案，提供 zero-argument 构造函数和<code>connectionFactory</code>，可用于以 JavaBean 样式构造实例(使用<code>BeanFactory</code>或普通 Java code)。或者，考虑从 Spring 的<code>JmsGatewaySupport</code> convenience base class 派生，它为 JMS configuration 提供 pre-built bean properties。</p>
<p><code>send(String destinationName, MessageCreator creator)</code>方法允许您使用目标的 string name 发送消息。如果这些名称在 JNDI 中注册，则应将模板的<code>destinationResolver</code> property 设置为<code>JndiDestinationResolver</code>的实例。</p>
<p>如果您创建了<code>JmsTemplate</code>并指定了默认目标，则<code>send(MessageCreator c)</code>会向该目标发送一条消息。</p>
<h4 id="3-2-1-使用消息转换器"><a href="#3-2-1-使用消息转换器" class="headerlink" title="3.2.1. 使用消息转换器"></a>3.2.1. 使用消息转换器</h4><p>为了便于发送域 model objects，<code>JmsTemplate</code>具有各种发送方法，这些方法将 Java object 作为消息数据内容的参数。 <code>JmsTemplate</code>中的重载方法<code>convertAndSend()</code>和<code>receiveAndConvert()</code>方法将转换 process 委托给<code>MessageConverter</code>接口的实例。此接口定义了一个简单的 contract，用于在 Java objects 和 JMS 消息之间进行转换。默认的 implementation(<code>SimpleMessageConverter</code>)支持<code>String</code>和<code>TextMessage</code>，<code>byte[]</code>和<code>BytesMesssage</code>以及<code>java.util.Map</code>和<code>MapMessage</code>之间的转换。通过使用转换器，您和您的 application code 可以专注于通过 JMS 发送或接收的业务 object，而不关心它如何表示为 JMS 消息的细节。</p>
<p>沙箱当前包含<code>MapMessageConverter</code>，它使用反射在 JavaBean 和<code>MapMessage</code>之间进行转换。您可能自己实现的其他流行的 implementation 选择是使用现有 XML 编组软件包(例如 JAXB，Castor 或 XStream)来创建表示 object 的<code>TextMessage</code>的转换器。</p>
<p>为了适应无法一般封装在转换器 class 中的消息的 properties，headers 和 body 的设置，<code>MessagePostProcessor</code>接口允许您在转换之后但在发送之前访问该消息。以下 example 显示了在将<code>java.util.Map</code>转换为消息后如何修改消息头和 property：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void sendWithConversion() &#123;</span><br><span class="line">    Map map &#x3D; new HashMap();</span><br><span class="line">    map.put(&quot;Name&quot;, &quot;Mark&quot;);</span><br><span class="line">    map.put(&quot;Age&quot;, new Integer(47));</span><br><span class="line">    jmsTemplate.convertAndSend(&quot;testQueue&quot;, map, new MessagePostProcessor() &#123;</span><br><span class="line">        public Message postProcessMessage(Message message) throws JMSException &#123;</span><br><span class="line">            message.setIntProperty(&quot;AccountID&quot;, 1234);</span><br><span class="line">            message.setJMSCorrelationID(&quot;123-00001&quot;);</span><br><span class="line">            return message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这会产生以下形式的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MapMessage&#x3D;&#123;</span><br><span class="line">    Header&#x3D;&#123;</span><br><span class="line">        ... standard headers ...</span><br><span class="line">        CorrelationID&#x3D;&#123;123-00001&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Properties&#x3D;&#123;</span><br><span class="line">        AccountID&#x3D;&#123;Integer:1234&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Fields&#x3D;&#123;</span><br><span class="line">        Name&#x3D;&#123;String:Mark&#125;</span><br><span class="line">        Age&#x3D;&#123;Integer:47&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-使用-SessionCallback-和-ProducerCallback"><a href="#3-2-2-使用-SessionCallback-和-ProducerCallback" class="headerlink" title="3.2.2. 使用 SessionCallback 和 ProducerCallback"></a>3.2.2. 使用 SessionCallback 和 ProducerCallback</h4><p>虽然发送操作涵盖了许多 common 使用场景，但有时您可能希望在 JMS <code>Session</code>或<code>MessageProducer</code>上执行多个操作。 <code>SessionCallback</code>和<code>ProducerCallback</code>分别公开 JMS <code>Session</code>和<code>Session</code>/<code>MessageProducer</code>对。 <code>JmsTemplate</code>上的<code>execute()</code>方法执行这些回调方法。</p>
<h3 id="3-3-收到消息"><a href="#3-3-收到消息" class="headerlink" title="3.3. 收到消息"></a>3.3. 收到消息</h3><p>这描述了如何在 Spring 中使用 JMS 接收消息。</p>
<h4 id="3-3-1-同步接收"><a href="#3-3-1-同步接收" class="headerlink" title="3.3.1. 同步接收"></a>3.3.1. 同步接收</h4><p>虽然 JMS 通常与异步处理相关联，但您可以同步使用消息。重载的<code>receive(..)</code>方法提供此功能。在同步接收期间，调用线程将阻塞，直到消息可用。这可能是一个危险的操作，因为调用线程可能会被无限期地阻塞。 <code>receiveTimeout</code> property 指定接收方在放弃等待消息之前应该等待多长时间。</p>
<h4 id="3-3-2-异步接收：Message-Driven-POJO"><a href="#3-3-2-异步接收：Message-Driven-POJO" class="headerlink" title="3.3.2. 异步接收：Message-Driven POJO"></a>3.3.2. 异步接收：Message-Driven POJO</h4><blockquote>
<p>Spring 还通过使用<code>@JmsListener</code> annotation 支持 annotated-listener endpoints，并提供了一个开放的基础结构来以编程方式注册 endpoints。到目前为止，这是设置异步接收器的最便捷方式。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-annotated-support">启用 Listener Endpoint Annotations</a>。</p>
</blockquote>
<p>在 EJB 世界中类似于 Message-Driven Bean(MDB)的方式中，Message-Driven POJO(MDP)充当 JMS 消息的接收者。 MDP 上的一个限制(但请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-receiving-async-message-listener-adapter">使用 MessageListenerAdapter</a>)是它必须实现<code>javax.jms.MessageListener</code>接口。请注意，如果您的 POJO 在多个线程上收到消息，则确保 implementation 为 thread-safe 非常重要。</p>
<p>以下 example 显示了 MDP 的简单 implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import javax.jms.JMSException;</span><br><span class="line">import javax.jms.Message;</span><br><span class="line">import javax.jms.MessageListener;</span><br><span class="line">import javax.jms.TextMessage;</span><br><span class="line"></span><br><span class="line">public class ExampleListener implements MessageListener &#123;</span><br><span class="line"></span><br><span class="line">    public void onMessage(Message message) &#123;</span><br><span class="line">        if (message instanceof TextMessage) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(((TextMessage) message).getText());</span><br><span class="line">            &#125;</span><br><span class="line">            catch (JMSException ex) &#123;</span><br><span class="line">                throw new RuntimeException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must be of type TextMessage&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦实现了<code>MessageListener</code>，就可以 time 创建一个消息 listener 容器。</p>
<p>以下 example 显示了如何定义和配置 Spring 附带的消息 listener 容器之一(在本例中为<code>DefaultMessageListenerContainer</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;messageListener&quot; class&#x3D;&quot;jmsexample.ExampleListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- and this is the message listener container --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jmsContainer&quot; class&#x3D;&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;destination&quot; ref&#x3D;&quot;destination&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;messageListener&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>有关每个 implementation 支持的 features 的完整描述，请参阅各种消息 listener 容器的 Spring javadoc(所有这些容器都实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/listener/MessageListenerContainer.html">MessageListenerContainer</a>)。</p>
<h4 id="3-3-3-使用-SessionAwareMessageListener-接口"><a href="#3-3-3-使用-SessionAwareMessageListener-接口" class="headerlink" title="3.3.3. 使用 SessionAwareMessageListener 接口"></a>3.3.3. 使用 SessionAwareMessageListener 接口</h4><p><code>SessionAwareMessageListener</code>接口是一个 Spring-specific 接口，它为 JMS <code>MessageListener</code>接口提供类似的 contract，但也提供 message-handling 方法访问接收<code>Message</code>的 JMS <code>Session</code>。以下清单显示了<code>SessionAwareMessageListener</code>接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.jms.listener;</span><br><span class="line"></span><br><span class="line">public interface SessionAwareMessageListener &#123;</span><br><span class="line"></span><br><span class="line">    void onMessage(Message message, Session session) throws JMSException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您希望 MDP 能够响应任何收到的消息(通过使用<code>onMessage(Message, Session)</code>方法中提供的<code>Session</code>)，您可以选择让 MDP 实现此接口(优先于标准 JMS <code>MessageListener</code>接口)。 Spring 附带的所有消息 listener 容器 implementations 都支持实现<code>MessageListener</code>或<code>SessionAwareMessageListener</code>接口的 MDP。 实现<code>SessionAwareMessageListener</code>的类带有警告，然后通过接口将它们绑定到 Spring。是否使用它的选择完全取决于您作为 application 开发人员或架构师。</p>
<p>请注意<code>SessionAwareMessageListener</code>接口的<code>onMessage(..)</code>方法抛出<code>JMSException</code>。与标准 JMS <code>MessageListener</code>接口相比，使用<code>SessionAwareMessageListener</code>接口时，client code 负责处理任何抛出的 exceptions。</p>
<h4 id="3-3-4-使用-MessageListenerAdapter"><a href="#3-3-4-使用-MessageListenerAdapter" class="headerlink" title="3.3.4. 使用 MessageListenerAdapter"></a>3.3.4. 使用 MessageListenerAdapter</h4><p><code>MessageListenerAdapter</code> class 是 Spring 的异步消息支持中的最终 component。简而言之，它允许您将几乎任何 class 暴露为 MDP(尽管存在一些约束)。</p>
<p>请考虑以下接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageDelegate &#123;</span><br><span class="line"></span><br><span class="line">    void handleMessage(String message);</span><br><span class="line"></span><br><span class="line">    void handleMessage(Map message);</span><br><span class="line"></span><br><span class="line">    void handleMessage(byte[] message);</span><br><span class="line"></span><br><span class="line">    void handleMessage(Serializable message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，虽然接口既不扩展<code>MessageListener</code>也不扩展<code>SessionAwareMessageListener</code>接口，但您仍然可以使用<code>MessageListenerAdapter</code> class 将其用作 MDP。还要注意各种消息处理方法如何根据它们可以接收和处理的各种<code>Message</code>类型的内容进行强类型化。</p>
<p>现在考虑<code>MessageDelegate</code>接口的以下 implementation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultMessageDelegate implements MessageDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation elided for clarity...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别要注意<code>MessageDelegate</code>接口的前面 implementation(<code>DefaultMessageDelegate</code> class)根本没有 JMS 依赖。它真的是一个 POJO，我们可以通过以下 configuration 进入 MDP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;messageListener&quot; class&#x3D;&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;jmsexample.DefaultMessageDelegate&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;constructor-arg&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- and this is the message listener container... --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jmsContainer&quot; class&#x3D;&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;destination&quot; ref&#x3D;&quot;destination&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;messageListener&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>下一个 example 显示了另一个只能处理 JMS <code>TextMessage</code>消息的 MDP。请注意消息处理方法实际上是如何调用<code>receive</code>(<code>MessageListenerAdapter</code>中的消息处理方法的 name 默认为<code>handleMessage</code>)，但它是可配置的(正如您在本节后面所述)。另请注意<code>receive(..)</code>方法如何强类型化以接收和响应 JMS <code>TextMessage</code>消息。以下清单显示了<code>TextMessageDelegate</code>接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface TextMessageDelegate &#123;</span><br><span class="line"></span><br><span class="line">    void receive(TextMessage message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下清单显示了实现<code>TextMessageDelegate</code>接口的 class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultTextMessageDelegate implements TextMessageDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation elided for clarity...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，服务员<code>MessageListenerAdapter</code>的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;messageListener&quot; class&#x3D;&quot;org.springframework.jms.listener.adapter.MessageListenerAdapter&quot;&gt;</span><br><span class="line">    &lt;constructor-arg&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;jmsexample.DefaultTextMessageDelegate&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;constructor-arg&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultListenerMethod&quot; value&#x3D;&quot;receive&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- we don&#39;t want automatic message context extraction --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageConverter&quot;&gt;</span><br><span class="line">        &lt;null&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，如果<code>messageListener</code>收到<code>TextMessage</code>以外类型的 JMS <code>Message</code>，则抛出<code>IllegalStateException</code>(并随后吞下)。 <code>MessageListenerAdapter</code> class 的另一个功能是，如果处理程序方法返回 non-void value，则能够自动发回响应<code>Message</code>。考虑以下接口和 class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ResponsiveTextMessageDelegate &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; notice the return type...</span><br><span class="line">    String receive(TextMessage message);</span><br><span class="line">&#125;</span><br><span class="line">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate &#123;</span><br><span class="line">    &#x2F;&#x2F; implementation elided for clarity...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果将<code>DefaultResponsiveTextMessageDelegate</code>与<code>MessageListenerAdapter</code>结合使用，则从执行<code>&#39;receive(..)&#39;</code>方法返回的任何 non-null value(在默认 configuration 中)都会转换为<code>TextMessage</code>。然后将结果<code>TextMessage</code>发送到原始<code>Message</code>的 JMS <code>Reply-To</code> property 中定义的<code>Destination</code>(如果存在)或<code>MessageListenerAdapter</code>上的默认<code>Destination</code>(如果已配置)。如果没有找到<code>Destination</code>，则抛出<code>InvalidDestinationException</code>(请注意，不会吞下此 exception 并向上传播调用堆栈)。</p>
<h4 id="3-3-5-在-Transactions-中处理消息"><a href="#3-3-5-在-Transactions-中处理消息" class="headerlink" title="3.3.5. 在 Transactions 中处理消息"></a>3.3.5. 在 Transactions 中处理消息</h4><p>在 transaction 中调用消息 listener 只需要重新配置 listener 容器。</p>
<p>您可以通过 listener 容器定义上的<code>sessionTransacted</code> flag 激活本地资源 transactions。然后，每个消息 listener 调用都在 active JMS transaction 中运行，并且在 listener 执行失败的情况下回滚消息。发送响应消息(通过<code>SessionAwareMessageListener</code>)是同一本地 transaction 的一部分，但任何其他资源操作(例如数据库访问)都是独立运行的。这通常需要在 listener implementation 中检测重复的消息，以涵盖数据库处理已提交但消息处理无法提交的情况。</p>
<p>考虑以下 bean 定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jmsContainer&quot; class&#x3D;&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;destination&quot; ref&#x3D;&quot;destination&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;messageListener&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sessionTransacted&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>要参与外部管理的 transaction，您需要配置 transaction manager 并使用支持外部托管 transactions 的 listener 容器(通常为<code>DefaultMessageListenerContainer</code>)。</p>
<p>要为 XA transaction 参与配置消息 listener 容器，您需要配置<code>JtaTransactionManager</code>(默认情况下，委托给 Java EE 服务器的 transaction 子系统)。请注意，底层 JMS <code>ConnectionFactory</code>需要 XA-capable 并正确注册到您的 JTA transaction 协调器。 (检查您的 Java EE 服务器的 JNDI resources.)的配置这使得消息接收以及(对于 example)数据库访问成为同一 transaction 的一部分(具有统一提交语义，代价是 XA transaction log 开销)。</p>
<p>以下 bean 定义创建 transaction manager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>然后我们需要将它添加到我们早期的容器 configuration 中。容器负责 rest。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jmsContainer&quot; class&#x3D;&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;destination&quot; ref&#x3D;&quot;destination&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;messageListener&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;transactionManager&quot; ref&#x3D;&quot;transactionManager&quot;&#x2F;&gt; (1)</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>我们的 transaction manager。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-4-支持-JCA-消息-Endpoints"><a href="#3-4-支持-JCA-消息-Endpoints" class="headerlink" title="3.4. 支持 JCA 消息 Endpoints"></a>3.4. 支持 JCA 消息 Endpoints</h3><p>从 version 2.5 开始，Spring 还为 JCA-based <code>MessageListener</code>容器提供支持。 <code>JmsMessageEndpointManager</code>尝试从提供程序的<code>ResourceAdapter</code> class name 自动确定<code>ActivationSpec</code> class name。因此，通常可以提供 Spring 的通用<code>JmsActivationSpecConfig</code>，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.jms.listener.endpoint.JmsMessageEndpointManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceAdapter&quot; ref&#x3D;&quot;resourceAdapter&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;activationSpecConfig&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.jms.listener.endpoint.JmsActivationSpecConfig&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;destinationName&quot; value&#x3D;&quot;myQueue&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;myMessageListener&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用给定的<code>ActivationSpec</code> object 设置<code>JmsMessageEndpointManager</code>。 <code>ActivationSpec</code> object 也可能来自 JNDI 查找(使用<code>&lt;jee:jndi-lookup&gt;</code>)。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.jms.listener.endpoint.JmsMessageEndpointManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceAdapter&quot; ref&#x3D;&quot;resourceAdapter&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;activationSpec&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.apache.activemq.ra.ActiveMQActivationSpec&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;destination&quot; value&#x3D;&quot;myQueue&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;destinationType&quot; value&#x3D;&quot;javax.jms.Queue&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;messageListener&quot; ref&#x3D;&quot;myMessageListener&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>使用 Spring 的<code>ResourceAdapterFactoryBean</code>，您可以在本地配置目标<code>ResourceAdapter</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;resourceAdapter&quot; class&#x3D;&quot;org.springframework.jca.support.ResourceAdapterFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceAdapter&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.apache.activemq.ra.ActiveMQResourceAdapter&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;serverUrl&quot; value&#x3D;&quot;tcp:&#x2F;&#x2F;localhost:61616&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;workManager&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.jca.work.SimpleTaskWorkManager&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>指定的<code>WorkManager</code>也可以指向 environment-specific 线程池 - 通常通过<code>SimpleTaskWorkManager</code>实例的<code>asyncTaskExecutor</code> property。如果碰巧使用多个适配器，请考虑为所有<code>ResourceAdapter</code>实例定义共享线程池。</p>
<p>在某些环境(例如 WebLogic 9 或更高版本)中，您可以从 JNDI 获取整个<code>ResourceAdapter</code> object(通过使用<code>&lt;jee:jndi-lookup&gt;</code>)。然后 Spring-based 消息 listeners 可以与 server-hosted <code>ResourceAdapter</code>交互，后者也使用服务器的 built-in <code>WorkManager</code>。</p>
<p>有关更多详细信息，请参阅 javadoc 以获取<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsMessageEndpointManager.html">JmsMessageEndpointManager</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/JmsActivationSpecConfig.html">JmsActivationSpecConfig</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/support/ResourceAdapterFactoryBean.html">ResourceAdapterFactoryBean</a>。</p>
<p>Spring 还提供了一个与 JMS 无关的通用 JCA 消息端点 manager：<code>org.springframework.jca.endpoint.GenericMessageEndpointManager</code>。此 component 允许使用任何消息 listener 类型(例如 CCI <code>MessageListener</code>)和任何 provider-specific <code>ActivationSpec</code> object。请参阅 JCA 提供程序的文档以了解连接器的实际功能，并参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/endpoint/GenericMessageEndpointManager.html">GenericMessageEndpointManager</a> javadoc 以获取 Spring-specific configuration 详细信息。</p>
<blockquote>
<p>JCA-based 消息端点 management 与 EJB 2.1 Message-Driven Beans 非常类似。它使用相同的底层资源提供程序 contract。与 EJB 2.1 MDB 一样，您也可以在 Spring context 中使用 JCA 提供程序支持的任何消息 listener 接口。尽管如此，Spring 仍然为 JMS 提供了明确的“便利”支持，因为 JMS 是与 JCA 端点 management contract 一起使用的最常见的端点 API。</p>
</blockquote>
<h3 id="3-5-Annotation-driven-Listener-Endpoints"><a href="#3-5-Annotation-driven-Listener-Endpoints" class="headerlink" title="3.5. Annotation-driven Listener Endpoints"></a>3.5. Annotation-driven Listener Endpoints</h3><p>异步接收消息的最简单方法是使用带注释的 listener 端点基础结构。简而言之，它允许您将托管 bean 的方法公开为 JMS listener 端点。以下 example 显示了如何使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">    public void processOrder(String data) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面 example 的 idea 是，每当<code>javax.jms.Destination</code> <code>myDestination</code>上有消息可用时，相应地调用<code>processOrder</code>方法(在这种情况下，使用 JMS 消息的内容，类似于<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-receiving-async-message-listener-adapter">MessageListenerAdapter</a>提供的内容)。</p>
<p>带注释的端点基础结构通过使用<code>JmsListenerContainerFactory</code>为每个带注释的方法在后台创建消息 listener 容器。这样的容器没有针对 application context 注册，但可以通过使用<code>JmsListenerEndpointRegistry</code> bean 轻松定位以便管理。</p>
<blockquote>
<p><code>@JmsListener</code>是 Java 8 上的可重复 annotation，因此您可以通过向其添加额外的<code>@JmsListener</code>声明来使用相同的方法关联多个 JMS 目标。</p>
</blockquote>
<h4 id="3-5-1-启用-Listener-Endpoint-Annotations"><a href="#3-5-1-启用-Listener-Endpoint-Annotations" class="headerlink" title="3.5.1. 启用 Listener Endpoint Annotations"></a>3.5.1. 启用 Listener Endpoint Annotations</h4><p>要启用对<code>@JmsListener</code> 注释的支持，可以将<code>@EnableJms</code>添加到其中一个<code>@Configuration</code> classes 中，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJms</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory &#x3D; new DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        factory.setDestinationResolver(destinationResolver());</span><br><span class="line">        factory.setSessionTransacted(true);</span><br><span class="line">        factory.setConcurrency(&quot;3-10&quot;);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，基础结构会查找名为<code>jmsListenerContainerFactory</code>的 bean 作为工厂用于创建消息 listener 容器的源。在这种情况下(并忽略 JMS 基础结构设置)，您可以调用<code>processOrder</code>方法，其核心轮询大小为三个线程，最大池大小为十个线程。</p>
<p>您可以自定义 listener 容器工厂以用于每个 annotation，也可以通过实现<code>JmsListenerConfigurer</code>接口来配置显式默认值。仅当在没有特定容器工厂的情况下注册了至少一个端点时，才需要默认值。有关详细信息和示例，请参阅实现<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/annotation/JmsListenerConfigurer.html">JmsListenerConfigurer</a>的 classes 的 javadoc。</p>
<p>如果您更喜欢<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-namespace">XML configuration</a>，则可以使用<code>&lt;jms:annotation-driven&gt;</code>元素，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;jms:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;jmsListenerContainerFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jms.config.DefaultJmsListenerContainerFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;destinationResolver&quot; ref&#x3D;&quot;destinationResolver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sessionTransacted&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;concurrency&quot; value&#x3D;&quot;3-10&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-程序化端点注册"><a href="#3-5-2-程序化端点注册" class="headerlink" title="3.5.2. 程序化端点注册"></a>3.5.2. 程序化端点注册</h4><p><code>JmsListenerEndpoint</code>提供 JMS 端点的 model，负责为该 model 配置容器。除了<code>JmsListener</code> annotation 检测到的 endpoints 之外，基础结构还允许您以编程方式配置 endpoints。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJms</span><br><span class="line">public class AppConfig implements JmsListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        SimpleJmsListenerEndpoint endpoint &#x3D; new SimpleJmsListenerEndpoint();</span><br><span class="line">        endpoint.setId(&quot;myJmsEndpoint&quot;);</span><br><span class="line">        endpoint.setDestination(&quot;anotherQueue&quot;);</span><br><span class="line">        endpoint.setMessageListener(message -&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; processing</span><br><span class="line">        &#125;);</span><br><span class="line">        registrar.registerEndpoint(endpoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，我们使用了<code>SimpleJmsListenerEndpoint</code>，它提供了实际的<code>MessageListener</code>来调用。但是，您也可以 build 自己的端点变体来描述自定义调用机制。</p>
<p>请注意，您可以完全跳过<code>@JmsListener</code>的使用，并通过<code>JmsListenerConfigurer</code>以编程方式仅注册 endpoints。</p>
<h4 id="3-5-3-带注释的端点方法签名"><a href="#3-5-3-带注释的端点方法签名" class="headerlink" title="3.5.3. 带注释的端点方法签名"></a>3.5.3. 带注释的端点方法签名</h4><p>到目前为止，我们在端点中注入了一个简单的<code>String</code>，但它实际上可以有一个非常灵活的方法签名。在下面的示例中，我们将其编写为 inject <code>Order</code>并带有自定义标头：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyService &#123;</span><br><span class="line"></span><br><span class="line">    @JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">    public void processOrder(Order order, @Header(&quot;order_type&quot;) String orderType) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在 JMS listener endpoints 中输入的主要元素如下：</p>
<ul>
<li>原始<code>javax.jms.Message</code>或其任何子类(假设它与传入的消息类型匹配)。</li>
<li><code>javax.jms.Session</code>用于对本机 JMS API 的可选访问(对于 example，用于发送自定义回复)。</li>
<li><code>org.springframework.messaging.Message</code>表示传入的 JMS 消息。请注意，此消息包含自定义和标准 headers(由<code>JmsHeaders</code>定义)。</li>
<li><code>@Header</code> -annotated 方法 arguments 提取特定的头 value，包括标准的 JMS headers。</li>
<li>一个<code>@Headers</code> -annotated 参数，也必须可分配给<code>java.util.Map</code>才能访问所有 headers。</li>
<li>不是受支持类型(<code>Message</code>或<code>Session</code>)之一的 non-annotated 元素被视为有效负载。您可以通过使用<code>@Payload</code>注释参数来使其明确。您还可以通过添加额外的<code>@Valid</code>来启用验证。</li>
</ul>
<p>inject Spring <code>Message</code>抽象的能力对于从 transport-specific 消息中存储的所有信息中受益特别有用，而不依赖于 transport-specific API。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">public void processOrder(Message&lt;Order&gt; order) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>方法 arguments 的处理由<code>DefaultMessageHandlerMethodFactory</code>提供，您可以进一步自定义以支持其他方法 arguments。您也可以在那里自定义转换和验证支持。</p>
<p>例如，如果我们想在处理它之前确保我们的<code>Order</code>有效，我们可以使用<code>@Valid</code>注释有效负载并配置必要的验证器，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJms</span><br><span class="line">public class AppConfig implements JmsListenerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) &#123;</span><br><span class="line">        registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() &#123;</span><br><span class="line">        DefaultMessageHandlerMethodFactory factory &#x3D; new DefaultMessageHandlerMethodFactory();</span><br><span class="line">        factory.setValidator(myValidator());</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-4-回应管理"><a href="#3-5-4-回应管理" class="headerlink" title="3.5.4. 回应管理"></a>3.5.4. 回应管理</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-receiving-async-message-listener-adapter">MessageListenerAdapter</a>中的现有支持已经允许您的方法具有非<code>void</code> return 类型。在这种情况下，调用的结果封装在<code>javax.jms.Message</code>中，在原始消息的<code>JMSReplyTo</code>标头中指定的目标中或在 listener 上配置的默认目标中发送。您现在可以使用消息传递抽象的<code>@SendTo</code> annotation 来设置该默认目标。</p>
<p>假设我们的<code>processOrder</code>方法现在应该_ret ，我们可以编写它来自动发送响应，如下面的 example 显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public OrderStatus processOrder(Order order) &#123;</span><br><span class="line">    &#x2F;&#x2F; order processing</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果您有多个<code>@JmsListener</code> -annotated 方法，还可以将<code>@SendTo</code> annotation 放在 class level 上以共享默认回复目标。</p>
</blockquote>
<p>如果您需要以 transport-independent 方式设置其他 headers，则可以使用类似于以下的方法_ret</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">@SendTo(&quot;status&quot;)</span><br><span class="line">public Message&lt;OrderStatus&gt; processOrder(Order order) &#123;</span><br><span class="line">    &#x2F;&#x2F; order processing</span><br><span class="line">    return MessageBuilder</span><br><span class="line">            .withPayload(status)</span><br><span class="line">            .setHeader(&quot;code&quot;, 1234)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要在运行时计算响应目标，可以将响应封装在<code>JmsResponse</code>实例中，该实例还提供在运行时使用的目标。我们可以 rewrite 前面的 example 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@JmsListener(destination &#x3D; &quot;myDestination&quot;)</span><br><span class="line">public JmsResponse&lt;Message&lt;OrderStatus&gt;&gt; processOrder(Order order) &#123;</span><br><span class="line">    &#x2F;&#x2F; order processing</span><br><span class="line">    Message&lt;OrderStatus&gt; response &#x3D; MessageBuilder</span><br><span class="line">            .withPayload(status)</span><br><span class="line">            .setHeader(&quot;code&quot;, 1234)</span><br><span class="line">            .build();</span><br><span class="line">    return JmsResponse.forQueue(response, &quot;status&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，如果您需要为响应指定一些 QoS 值，例如优先级或生存的 time，则可以相应地配置<code>JmsListenerContainerFactory</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableJms</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() &#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory &#x3D; new DefaultJmsListenerContainerFactory();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory());</span><br><span class="line">        QosSettings replyQosSettings &#x3D; new QosSettings();</span><br><span class="line">        replyQosSettings.setPriority(2);</span><br><span class="line">        replyQosSettings.setTimeToLive(10000);</span><br><span class="line">        factory.setReplyQosSettings(replyQosSettings);</span><br><span class="line">        return factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-JMS-命名空间支持"><a href="#3-6-JMS-命名空间支持" class="headerlink" title="3.6. JMS 命名空间支持"></a>3.6. JMS 命名空间支持</h3><p>Spring 提供了一个 XML 命名空间，用于简化 JMS configuration。要使用 JMS 名称空间元素，您需要 reference JMS schema，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xmlns:jms&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms&quot; (1)</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">            http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms&#x2F;spring-jms.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>引用 JMS schema。</td>
</tr>
</tbody>
</table>
</div>
<p>命名空间由三个 top-level 元素组成：<annotation-driven/>，<listener-container/>和<jca-listener-container/>。 <annotation-driven/>允许使用annotation-driven listener endpoints。 <listener-container/>和<jca-listener-container/>定义共享 listener 容器 configuration，并且可以包含<listener/> child 元素。以下 example 显示了两个 listeners 的基本 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jms:listener-container&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.orders&quot; ref&#x3D;&quot;orderService&quot; method&#x3D;&quot;placeOrder&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.confirmations&quot; ref&#x3D;&quot;confirmationLogger&quot; method&#x3D;&quot;log&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;jms:listener-container&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 相当于创建两个不同的 listener 容器 bean 定义和两个不同的<code>MessageListenerAdapter</code> bean 定义，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-receiving-async-message-listener-adapter">使用 MessageListenerAdapter</a>所示。除了前面的 example 中显示的属性之外，<code>listener</code>元素还可以包含几个可选的元素。以下 table 描述了所有可用属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>id</code></td>
<td>托管 listener 容器的 bean name。如果未指定，则自动生成 bean name。</td>
</tr>
<tr>
<td><code>destination</code>(必填)</td>
<td>此 listener 的目标 name，通过<code>DestinationResolver</code>策略解析。</td>
</tr>
<tr>
<td><code>ref</code>(必填)</td>
<td>处理程序 object 的 bean name。</td>
</tr>
<tr>
<td><code>method</code></td>
<td>要调用的处理程序方法的 name。如果<code>ref</code>属性指向<code>MessageListener</code>或 Spring <code>SessionAwareMessageListener</code>，则可以省略此属性。</td>
</tr>
<tr>
<td><code>response-destination</code></td>
<td>要向其发送响应消息的默认响应目标的 name。这适用于请求消息不带<code>JMSReplyTo</code>字段的情况。此目标的类型由 listener-container 的<code>response-destination-type</code>属性确定。请注意，这仅适用于具有 return value 的 listener 方法，每个结果 object 都会转换为响应消息。</td>
</tr>
<tr>
<td><code>subscription</code></td>
<td>持久订阅的 name(如果有)。</td>
</tr>
<tr>
<td><code>selector</code></td>
<td>此 listener 的可选消息选择器。</td>
</tr>
<tr>
<td><code>concurrency</code></td>
<td>要为此 listener 启动的并发会话或使用者数。此值可以是指示最大数字的简单数字(对于 example，<code>5</code>)，也可以是指示较低和上限的范围(对于 example，<code>3-5</code>)。请注意，指定的最小值只是一个提示，可能在运行时被忽略。默认值是容器提供的 value。</td>
</tr>
</tbody>
</table>
</div>
<p><code>&lt;listener-container/&gt;</code>元素也接受几个可选属性。这允许自定义各种策略(例如_示例，<code>taskExecutor</code>和<code>destinationResolver</code>)以及基本 JMS 设置和资源 references。通过使用这些属性，您可以定义 highly-customized listener 容器，同时仍然可以从命名空间的便利性中受益。</p>
<p>您可以通过指定要通过<code>factory-id</code>属性公开的 bean 的<code>id</code>来自动将此类设置公开为<code>JmsListenerContainerFactory</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;jms:listener-container connection-factory&#x3D;&quot;myConnectionFactory&quot;</span><br><span class="line">        task-executor&#x3D;&quot;myTaskExecutor&quot;</span><br><span class="line">        destination-resolver&#x3D;&quot;myDestinationResolver&quot;</span><br><span class="line">        transaction-manager&#x3D;&quot;myTransactionManager&quot;</span><br><span class="line">        concurrency&#x3D;&quot;10&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.orders&quot; ref&#x3D;&quot;orderService&quot; method&#x3D;&quot;placeOrder&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.confirmations&quot; ref&#x3D;&quot;confirmationLogger&quot; method&#x3D;&quot;log&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;jms:listener-container&gt;</span><br></pre></td></tr></table></figure>
<p>以下 table 描述了所有可用属性。有关各个 properties 的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/listener/AbstractMessageListenerContainer.html">用 AbstractMessageListenerContainer</a>的 class-level javadoc 及其具体子类。 javadoc 还提供了 transaction 选择和消息重新传递方案的讨论。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>container-type</code></td>
<td>这个 listener 容器的类型。可用选项为<code>default</code>，<code>simple</code>，<code>default102</code>或<code>simple102</code>(默认选项为<code>default</code>)。</td>
</tr>
<tr>
<td><code>container-class</code></td>
<td>自定义 listener 容器 implementation class 作为完全限定的 class name。根据<code>container-type</code>属性，默认值为 Spring 的标准<code>DefaultMessageListenerContainer</code>或<code>SimpleMessageListenerContainer</code>。</td>
</tr>
<tr>
<td><code>factory-id</code></td>
<td>将此元素定义的设置公开为具有指定<code>id</code>的<code>JmsListenerContainerFactory</code>，以便它们可以与其他 endpoints 一起使用。</td>
</tr>
<tr>
<td><code>connection-factory</code></td>
<td>__ JMS <code>ConnectionFactory</code> bean 的引用(默认 bean name 是<code>connectionFactory</code>)。</td>
</tr>
<tr>
<td><code>task-executor</code></td>
<td>JMS listener 调用者的 Spring <code>TaskExecutor</code>的引用。</td>
</tr>
<tr>
<td><code>destination-resolver</code></td>
<td>用于解析 JMS <code>Destination</code>实例的<code>DestinationResolver</code>策略的引用。</td>
</tr>
<tr>
<td><code>message-converter</code></td>
<td>用于将 JMS 消息转换为 listener 方法 arguments 的<code>MessageConverter</code>策略的 reference。默认值为<code>SimpleMessageConverter</code>。</td>
</tr>
<tr>
<td><code>error-handler</code></td>
<td>策略的引用，用于处理在执行<code>MessageListener</code>期间可能发生的任何未捕获的 exceptions。</td>
</tr>
<tr>
<td><code>destination-type</code></td>
<td>此 listener 的 JMS 目标类型：<code>queue</code>，<code>topic</code>，<code>durableTopic</code>，<code>sharedTopic</code>或<code>sharedDurableTopic</code>。这可能会启用容器的<code>pubSubDomain</code>，<code>subscriptionDurable</code>和<code>subscriptionShared</code> properties。默认值为<code>queue</code>(禁用这三个 properties)。</td>
</tr>
<tr>
<td><code>response-destination-type</code></td>
<td>响应的 JMS 目标类型：<code>queue</code>或<code>topic</code>。默认值是<code>destination-type</code>属性的 value。</td>
</tr>
<tr>
<td><code>client-id</code></td>
<td>此 listener 容器的 JMS client ID。您必须在使用持久订阅时指定它。</td>
</tr>
<tr>
<td><code>cache</code></td>
<td>JMS 资源的缓存 level：<code>none</code>，<code>connection</code>，<code>session</code>，<code>consumer</code>或<code>auto</code>。默认情况下(<code>auto</code>)，cache level 实际上是<code>consumer</code>，除非指定了外部 transaction manager - 在这种情况下，有效默认值为<code>none</code>(假设 Java EE-style transaction management，其中给定的 ConnectionFactory 是 XA-aware 池)。</td>
</tr>
<tr>
<td><code>acknowledge</code></td>
<td>本机 JMS 确认模式：<code>auto</code>，<code>client</code>，<code>dups-ok</code>或<code>transacted</code>。 的值激活本地交易的<code>Session</code>。作为替代方法，您可以指定属性，稍后将在 table 中进行说明。默认值为<code>auto</code>。</td>
</tr>
<tr>
<td><code>transaction-manager</code></td>
<td>对外部<code>PlatformTransactionManager</code>的引用(通常是 XA-based transaction 协调器，例如 Spring 的<code>JtaTransactionManager</code>)。如果未指定，则使用本机确认(请参阅<code>acknowledge</code>属性)。</td>
</tr>
<tr>
<td><code>concurrency</code></td>
<td>每个 listener 启动的并发会话或使用者数。它可以是指示最大数字的简单数字(对于 example，<code>5</code>)，也可以是指示下限和上限的范围(对于 example，<code>3-5</code>)。请注意，指定的最小值只是一个提示，可能在运行时被忽略。默认值为<code>1</code>。在 topic listener 的情况下，或者如果队列 ordering 很重要，您应该将并发限制为<code>1</code>。考虑将其提升为一般队列。</td>
</tr>
<tr>
<td><code>prefetch</code></td>
<td>要加载到单个 session 中的最大消息数。请注意，提高此数字可能会导致并发消费者的饥饿。</td>
</tr>
<tr>
<td><code>receive-timeout</code></td>
<td>用于 receive calls 的超时(以毫秒为单位)。默认值为<code>1000</code>(一秒)。 <code>-1</code>表示没有超时。</td>
</tr>
<tr>
<td><code>back-off</code></td>
<td>指定用于计算恢复尝试之间间隔的<code>BackOff</code>实例。如果<code>BackOffExecution</code> implementation 返回<code>BackOffExecution#STOP</code>，则 listener 容器不会进一步尝试恢复。设置此 property 时，将忽略<code>recovery-interval</code> value。默认值为<code>FixedBackOff</code>，间隔为 5000 毫秒(即 5 秒)。</td>
</tr>
<tr>
<td><code>recovery-interval</code></td>
<td>指定恢复尝试之间的间隔(以毫秒为单位)。它提供了一种使用指定间隔创建<code>FixedBackOff</code>的便捷方法。有关更多恢复选项，请考虑指定<code>BackOff</code>实例。默认值为 5000 毫秒(即 5 秒)。</td>
</tr>
<tr>
<td><code>phase</code></td>
<td>此容器应开始和停止的生命周期阶段。 value 越低，此容器启动越早，后者停止。默认值为<code>Integer.MAX_VALUE</code>，表示容器尽可能晚启动并尽快停止。</td>
</tr>
</tbody>
</table>
</div>
<p>使用<code>jms</code> schema 支持配置 JCA-based listener 容器非常相似，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;jms:jca-listener-container resource-adapter&#x3D;&quot;myResourceAdapter&quot;</span><br><span class="line">        destination-resolver&#x3D;&quot;myDestinationResolver&quot;</span><br><span class="line">        transaction-manager&#x3D;&quot;myTransactionManager&quot;</span><br><span class="line">        concurrency&#x3D;&quot;10&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;jms:listener destination&#x3D;&quot;queue.orders&quot; ref&#x3D;&quot;myMessageListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;jms:jca-listener-container&gt;</span><br></pre></td></tr></table></figure>
<p>以下 table 描述了 JCA 变体的可用 configuration 选项：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>factory-id</code></td>
<td>将此元素定义的设置公开为具有指定<code>id</code>的<code>JmsListenerContainerFactory</code>，以便它们可以与其他 endpoints 一起使用。</td>
</tr>
<tr>
<td><code>resource-adapter</code></td>
<td>_JCA <code>ResourceAdapter</code> bean 的引用(默认 bean name 是<code>resourceAdapter</code>)。</td>
</tr>
<tr>
<td><code>activation-spec-factory</code></td>
<td>对<code>JmsActivationSpecFactory</code>的参考。缺省情况是自动检测 JMS 提供程序及其<code>ActivationSpec</code> class(请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/listener/endpoint/DefaultJmsActivationSpecFactory.html">DefaultJmsActivationSpecFactory</a>)。</td>
</tr>
<tr>
<td><code>destination-resolver</code></td>
<td>策略的参考用于解析 JMS <code>Destinations</code>。</td>
</tr>
<tr>
<td><code>message-converter</code></td>
<td>用于将 JMS 消息转换为 listener 方法 arguments 的<code>MessageConverter</code>策略的 reference。默认值为<code>SimpleMessageConverter</code>。</td>
</tr>
<tr>
<td><code>destination-type</code></td>
<td>此 listener 的 JMS 目标类型：<code>queue</code>，<code>topic</code>，<code>durableTopic</code>，<code>sharedTopic</code>。或<code>sharedDurableTopic</code>。这可能会启用容器的<code>pubSubDomain</code>，<code>subscriptionDurable</code>和<code>subscriptionShared</code> properties。默认值为<code>queue</code>(禁用这三个 properties)。</td>
</tr>
<tr>
<td><code>response-destination-type</code></td>
<td>响应的 JMS 目标类型：<code>queue</code>或<code>topic</code>。默认值是<code>destination-type</code>属性的 value。</td>
</tr>
<tr>
<td><code>client-id</code></td>
<td>此 listener 容器的 JMS client ID。在使用持久订阅时需要指定它。</td>
</tr>
<tr>
<td><code>acknowledge</code></td>
<td>本机 JMS 确认模式：<code>auto</code>，<code>client</code>，<code>dups-ok</code>或<code>transacted</code>。 的值激活本地交易的<code>Session</code>。作为替代方法，您可以指定稍后描述的<code>transaction-manager</code>属性。默认值为<code>auto</code>。</td>
</tr>
<tr>
<td><code>transaction-manager</code></td>
<td>_Spring <code>JtaTransactionManager</code>或<code>javax.transaction.TransactionManager</code>的引用，用于为每个传入消息启动 XA transaction。如果未指定，则使用本机确认(请参阅<code>acknowledge</code>属性)。</td>
</tr>
<tr>
<td><code>concurrency</code></td>
<td>每个 listener 启动的并发会话或使用者数。它可以是指示最大数字的简单数字(对于 example <code>5</code>)，也可以是指示下限和上限的范围(对于 example，<code>3-5</code>)。请注意，指定的最小值只是一个提示，在运行时通常会在使用 JCA listener 容器时被忽略。默认值为 1。</td>
</tr>
<tr>
<td><code>prefetch</code></td>
<td>要加载到单个 session 中的最大消息数。请注意，提高此数字可能会导致并发消费者的饥饿。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="4-JMX"><a href="#4-JMX" class="headerlink" title="4. JMX"></a>4. JMX</h2><p>Spring 中的 JMX(Java Management Extensions)支持提供了 features，使您可以轻松，透明地将 Spring application 集成到 JMX 基础结构中。</p>
<p>JMX？</p>
<p>本章不是 JMX 的介绍。它并不试图解释您为什么要使用 JMX。如果您是 JMX 的新手，请参阅本章末尾的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-resources">更多资源</a>。</p>
<p>具体来说，Spring 的 JMX 支持提供了四个核心 features：</p>
<ul>
<li>将任何 Spring bean 自动注册为 JMX MBean。</li>
<li>一种灵活的机制，用于控制 beans 的 management 接口。</li>
<li>MBean 在 remote，JSR-160 连接器上的声明性暴露。</li>
<li>本地和 remote MBean 资源的简单代理。</li>
</ul>
<p>这些 features 旨在在不将 application 组件耦合到 Spring 或 JMX 接口和 classes 的情况下工作。实际上，在大多数情况下，_ application classes 不需要知道 order 中的 Spring 或 JMX 以利用 Spring JMX features。</p>
<h3 id="4-1-将-Beans-导出到-JMX"><a href="#4-1-将-Beans-导出到-JMX" class="headerlink" title="4.1. 将 Beans 导出到 JMX"></a>4.1. 将 Beans 导出到 JMX</h3><p>Spring 的 JMX framework 中的核心 class 是<code>MBeanExporter</code>。此 class 负责获取 Spring beans 并使用 JMX <code>MBeanServer</code>注册它们。对于 example，请考虑以下 class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.jmx;</span><br><span class="line"></span><br><span class="line">public class JmxTestBean implements IJmxTestBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private boolean isSuperman;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dontExposeMe() &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要将此 bean 的 properties 和方法公开为 MBean 的属性和操作，可以在 configuration 文件中配置<code>MBeanExporter</code> class 的实例并传入 bean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;!-- this bean must not be lazily initialized if the exporting is to happen --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot; lazy-init&#x3D;&quot;false&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 configuration 片段中的相关 bean 定义是<code>exporter</code> bean。 <code>beans</code> property 告诉<code>MBeanExporter</code>究竟哪些 beans 必须导出到 JMX <code>MBeanServer</code>。在默认的 configuration 中，<code>beans</code> <code>Map</code>中每个条目的 key 用作相应条目 value 引用的 bean 的<code>ObjectName</code>。您可以更改此行为，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-naming">控制 Beans 的 ObjectName 实例</a>中所述。</p>
<p>通过此 configuration，<code>testBean</code> bean 在<code>ObjectName</code> <code>bean:name=testBean1</code>下显示为 MBean。默认情况下，bean 的所有<code>public</code> properties 都作为属性公开，并且所有<code>public</code>方法(从<code>Object</code> class 继承的方法除外)都作为操作公开。</p>
<blockquote>
<p><code>MBeanExporter</code>是<code>Lifecycle</code> bean(见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-processor">启动和关闭回调</a>)。默认情况下，MBean 在 application 生命周期中尽可能晚地导出。您可以通过设置<code>autoStartup</code> flag 来配置 export 发生的<code>phase</code>或禁用自动注册。</p>
</blockquote>
<h4 id="4-1-1-Creating-MBeanServer"><a href="#4-1-1-Creating-MBeanServer" class="headerlink" title="4.1.1. Creating MBeanServer"></a>4.1.1. Creating MBeanServer</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-exporting">前一节</a>中显示的 configuration 假定 application 在一个(且只有一个)<code>MBeanServer</code>已经 running 的环境中运行。在这种情况下，Spring 会尝试找到 running <code>MBeanServer</code>并在该服务器上注册 beans(如果有的话)。当 application 在具有自己的<code>MBeanServer</code>的容器(例如 Tomcat 或 IBM WebSphere)内运行时，此行为很有用。</p>
<p>但是，这种方法在独立环境中或在不提供<code>MBeanServer</code>的容器内运行时没有用处。要解决此问题，您可以通过在 configuration 中添加<code>org.springframework.jmx.support.MBeanServerFactoryBean</code> class 的实例来声明性地创建<code>MBeanServer</code>实例。您还可以通过将<code>MBeanExporter</code>实例的<code>server</code> property 的 value 设置为<code>MBeanServerFactoryBean</code>返回的<code>MBeanServer</code> value 来确保使用特定的<code>MBeanServer</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;mbeanServer&quot; class&#x3D;&quot;org.springframework.jmx.support.MBeanServerFactoryBean&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--</span><br><span class="line">    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;</span><br><span class="line">    this means that it must not be marked as lazily initialized</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;server&quot; ref&#x3D;&quot;mbeanServer&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，<code>MBeanServer</code>的一个实例由<code>MBeanServerFactoryBean</code>创建，并通过<code>server</code> property 提供给<code>MBeanExporter</code>。当您提供自己的<code>MBeanServer</code>实例时，<code>MBeanExporter</code>不会尝试找到 running <code>MBeanServer</code>并使用提供的<code>MBeanServer</code>实例。为了使其正常工作，您必须在 classpath 上使用 JMX implementation。</p>
<h4 id="4-1-2-重用现有的-MBeanServer"><a href="#4-1-2-重用现有的-MBeanServer" class="headerlink" title="4.1.2. 重用现有的 MBeanServer"></a>4.1.2. 重用现有的 MBeanServer</h4><p>如果未指定服务器，则<code>MBeanExporter</code>会尝试自动检测 running <code>MBeanServer</code>。这适用于大多数环境，其中只使用一个<code>MBeanServer</code>实例。但是，当存在多个实例时，导出程序可能会选择错误的服务器。在这种情况下，您应该使用<code>MBeanServer</code> <code>agentId</code>来指示要使用的实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;mbeanServer&quot; class&#x3D;&quot;org.springframework.jmx.support.MBeanServerFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!-- indicate to first look for a server --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;locateExistingServerIfPossible&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- search for the MBeanServer instance with the given agentId --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;agentId&quot; value&#x3D;&quot;MBeanServer_instance_agentId&gt;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;server&quot; ref&#x3D;&quot;mbeanServer&quot;&#x2F;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>对于现有<code>MBeanServer</code>具有通过查找方法检索的动态(或未知)<code>agentId</code>的平台或情况，应使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class-static-factory-method">factory-method</a>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;server&quot;&gt;</span><br><span class="line">            &lt;!-- Custom MBeanServerLocator --&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;platform.package.MBeanServerLocator&quot; factory-method&#x3D;&quot;locateMBeanServer&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- other beans here --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3-Lazily-初始化-MBean"><a href="#4-1-3-Lazily-初始化-MBean" class="headerlink" title="4.1.3. Lazily 初始化 MBean"></a>4.1.3. Lazily 初始化 MBean</h4><p>如果配置 bean 并且也配置为延迟初始化，则<code>MBeanExporter</code>不会 break 这个 contract 并避免实例化 bean。相反，它使用<code>MBeanServer</code>注册代理并推迟从容器中获取 bean，直到代理上的第一次调用发生。</p>
<h4 id="4-1-4-MBean-的自动注册"><a href="#4-1-4-MBean-的自动注册" class="headerlink" title="4.1.4. MBean 的自动注册"></a>4.1.4. MBean 的自动注册</h4><p>通过<code>MBeanExporter</code>导出并且已经是有效 MBean 的任何 beans 都会使用<code>MBeanServer</code>注册 as-is，而无需 Spring 的进一步干预。您可以通过将<code>autodetect</code> property 设置为<code>true</code>来使<code>MBeanExporter</code>自动检测到 MBean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;autodetect&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean name&#x3D;&quot;spring:mbean&#x3D;true&quot; class&#x3D;&quot;org.springframework.jmx.export.TestDynamicMBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，bean 已经是一个有效的 JMX MBean，并由 Spring 自动注册。默认情况下，为 JMX 注册自动检测的 bean 将 bean name 用作<code>ObjectName</code>。您可以覆盖此行为，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-naming">控制 Beans 的 ObjectName 实例</a>中所述。</p>
<h4 id="4-1-5-控制注册行为"><a href="#4-1-5-控制注册行为" class="headerlink" title="4.1.5. 控制注册行为"></a>4.1.5. 控制注册行为</h4><p>考虑 Spring <code>MBeanExporter</code>尝试使用<code>ObjectName</code> <code>bean:name=testBean1</code>向<code>MBeanServer</code>注册<code>MBean</code>的情况。如果<code>MBean</code>实例已经在同一个<code>ObjectName</code>下注册，则默认行为是失败(并抛出<code>InstanceAlreadyExistsException</code>)。</p>
<p>您可以准确控制使用<code>MBeanServer</code>注册时会发生什么。当注册 process 发现<code>MBean</code>已经在相同的<code>ObjectName</code>下注册时，Spring 的 JMX 支持允许三种不同的注册行为来控制注册行为。以下 table 总结了这些注册行为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>注册行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FAIL_ON_EXISTING</code></td>
<td>这是默认的注册行为。如果<code>MBean</code>实例已在相同的<code>ObjectName</code>下注册，则正在注册的<code>MBean</code>未注册，并且抛出<code>InstanceAlreadyExistsException</code>。现有的<code>MBean</code>不受影响。</td>
</tr>
<tr>
<td><code>IGNORE_EXISTING</code></td>
<td>如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则正在注册的<code>MBean</code>未注册。现有的<code>MBean</code>不受影响，并且不会抛出<code>Exception</code>。这在多个 applications 想要在共享<code>MBeanServer</code>中共享 common <code>MBean</code>的设置中很有用。</td>
</tr>
<tr>
<td><code>REPLACE_EXISTING</code></td>
<td>如果<code>MBean</code>实例已在同一<code>ObjectName</code>下注册，则先前注册的现有<code>MBean</code>将被取消注册，并且新<code>MBean</code>将在其位置注册(新<code>MBean</code>将有效替换先前的实例)。</td>
</tr>
</tbody>
</table>
</div>
<p>前面 table 中的值被定义为<code>RegistrationPolicy</code> class 上的枚举。如果要更改默认注册行为，则需要将<code>MBeanExporter</code>定义上的<code>registrationPolicy</code> property 的 value 设置为其中一个值。</p>
<p>以下 example 显示了如何从默认注册行为更改为<code>REPLACE_EXISTING</code>行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;registrationPolicy&quot; value&#x3D;&quot;REPLACE_EXISTING&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-控制-Beans-的-Management-接口"><a href="#4-2-控制-Beans-的-Management-接口" class="headerlink" title="4.2. 控制 Beans 的 Management 接口"></a>4.2. 控制 Beans 的 Management 接口</h3><p>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-exporting-registration-behavior">前一节</a>的 example 中，您几乎无法控制 bean 的 management 接口。每个导出的 bean 的所有<code>public</code> properties 和方法分别作为 JMX 属性和操作公开。要实际控制导出的 beans 的哪些 properties 和方法实际上作为 JMX 属性和操作公开，Spring JMX 提供了一个全面且可扩展的机制来控制 beans 的 management 接口。</p>
<h4 id="4-2-1-使用-MBeanInfoAssembler-接口"><a href="#4-2-1-使用-MBeanInfoAssembler-接口" class="headerlink" title="4.2.1. 使用 MBeanInfoAssembler 接口"></a>4.2.1. 使用 MBeanInfoAssembler 接口</h4><p>在幕后，<code>MBeanExporter</code>委托<code>org.springframework.jmx.export.assembler.MBeanInfoAssembler</code>接口的 implementation，负责定义公开的每个 bean 的 management 接口。默认 implementation <code>org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</code>定义了一个 management 接口，它公开了所有公共 properties 和方法(正如您在前面几节的示例中所看到的)。 Spring 提供了另外两个<code>MBeanInfoAssembler</code>接口的 implementations，它允许您使用 source-level 元数据或任意接口控制生成的 management 接口。</p>
<h4 id="4-2-2-使用-Source-level-元数据：Java-Annotations"><a href="#4-2-2-使用-Source-level-元数据：Java-Annotations" class="headerlink" title="4.2.2. 使用 Source-level 元数据：Java Annotations"></a>4.2.2. 使用 Source-level 元数据：Java Annotations</h4><p>通过使用<code>MetadataMBeanInfoAssembler</code>，您可以使用 source-level 元数据为 beans 定义 management 接口。元数据的读取由<code>org.springframework.jmx.export.metadata.JmxAttributeSource</code>接口封装。 Spring JMX 提供了一个使用 Java annotations 的默认 implementation，即<code>org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</code>。您必须使用<code>JmxAttributeSource</code>接口的 implementation 实例配置<code>MetadataMBeanInfoAssembler</code>才能正确功能(没有默认值)。</p>
<p>要将 export 标记为 export 到 JMX，您应该使用<code>ManagedResource</code> annotation 注释 bean class。必须使用<code>ManagedOperation</code> annotation 将要公开的每个方法标记为操作，并使用<code>ManagedAttribute</code> annotation 标记要显示的每个 property。标记 properties 时，可以省略 getter 或 setter 的 annotation 以分别创建 write-only 或 read-only 属性。</p>
<blockquote>
<p><code>ManagedResource</code> -annotated bean 必须是公共的，暴露操作或属性的方法也必须是公共的。</p>
</blockquote>
<p>以下 example 显示了我们在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-exporting-mbeanserver">Creating MBeanServer</a>中使用的<code>JmxTestBean</code> class 的带注释的 version：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.jmx;</span><br><span class="line"></span><br><span class="line">import org.springframework.jmx.export.annotation.ManagedResource;</span><br><span class="line">import org.springframework.jmx.export.annotation.ManagedOperation;</span><br><span class="line">import org.springframework.jmx.export.annotation.ManagedAttribute;</span><br><span class="line"></span><br><span class="line">@ManagedResource(</span><br><span class="line">        objectName&#x3D;&quot;bean:name&#x3D;testBean4&quot;,</span><br><span class="line">        description&#x3D;&quot;My Managed Bean&quot;,</span><br><span class="line">        log&#x3D;true,</span><br><span class="line">        logFile&#x3D;&quot;jmx.log&quot;,</span><br><span class="line">        currencyTimeLimit&#x3D;15,</span><br><span class="line">        persistPolicy&#x3D;&quot;OnUpdate&quot;,</span><br><span class="line">        persistPeriod&#x3D;200,</span><br><span class="line">        persistLocation&#x3D;&quot;foo&quot;,</span><br><span class="line">        persistName&#x3D;&quot;bar&quot;)</span><br><span class="line">public class AnnotationTestBean implements IJmxTestBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @ManagedAttribute(description&#x3D;&quot;The Age Attribute&quot;, currencyTimeLimit&#x3D;15)</span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ManagedAttribute(description&#x3D;&quot;The Name Attribute&quot;,</span><br><span class="line">            currencyTimeLimit&#x3D;20,</span><br><span class="line">            defaultValue&#x3D;&quot;bar&quot;,</span><br><span class="line">            persistPolicy&#x3D;&quot;OnUpdate&quot;)</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ManagedAttribute(defaultValue&#x3D;&quot;foo&quot;, persistPeriod&#x3D;300)</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ManagedOperation(description&#x3D;&quot;Add two numbers&quot;)</span><br><span class="line">    @ManagedOperationParameters(&#123;</span><br><span class="line">        @ManagedOperationParameter(name &#x3D; &quot;x&quot;, description &#x3D; &quot;The first number&quot;),</span><br><span class="line">        @ManagedOperationParameter(name &#x3D; &quot;y&quot;, description &#x3D; &quot;The second number&quot;)&#125;)</span><br><span class="line">    public int add(int x, int y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dontExposeMe() &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，您可以看到<code>JmxTestBean</code> class 标有<code>ManagedResource</code> annotation，并且此<code>ManagedResource</code> annotation 配置了一组 properties。这些 properties 可用于配置由<code>MBeanExporter</code>生成的 MBean 的各个方面，稍后将在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-interface-metadata-types">Source-level 元数据类型</a>中进行更详细的说明。</p>
<p><code>age</code>和<code>name</code> properties 都使用<code>ManagedAttribute</code> annotation 注释，但是在<code>age</code> property 的情况下，只标记了 getter。这会导致这两个 properties 作为属性包含在 management 接口中，但<code>age</code>属性为 read-only。</p>
<p>最后，<code>add(int, int)</code>方法标有<code>ManagedOperation</code>属性，而<code>dontExposeMe()</code>方法不标记。这会导致 management 接口在使用<code>MetadataMBeanInfoAssembler</code>时仅包含一个操作(<code>add(int, int)</code>)。</p>
<p>以下 configuration 显示了如何配置<code>MBeanExporter</code>以使用<code>MetadataMBeanInfoAssembler</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;assembler&quot; ref&#x3D;&quot;assembler&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;namingStrategy&quot; ref&#x3D;&quot;namingStrategy&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;autodetect&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;jmxAttributeSource&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- will create management interface using annotation metadata --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;assembler&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;attributeSource&quot; ref&#x3D;&quot;jmxAttributeSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- will pick up the ObjectName from the annotation --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;namingStrategy&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jmx.export.naming.MetadataNamingStrategy&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;attributeSource&quot; ref&#x3D;&quot;jmxAttributeSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.AnnotationTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，<code>MetadataMBeanInfoAssembler</code> bean 已配置了<code>AnnotationJmxAttributeSource</code> class 的实例，并通过汇编程序 property 传递给<code>MBeanExporter</code>。这就是为 Spring-exposed MBeans 利用 metadata-driven management 接口所需的全部内容。</p>
<h4 id="4-2-3-Source-level-元数据类型"><a href="#4-2-3-Source-level-元数据类型" class="headerlink" title="4.2.3. Source-level 元数据类型"></a>4.2.3. Source-level 元数据类型</h4><p>以下 table 描述了 Spring JMX 中可用的 source-level 元数据类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>目的</th>
<th>注解</th>
<th>注释类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>将<code>Class</code>的所有实例标记为 JMX 托管资源。</td>
<td><code>@ManagedResource</code></td>
<td>类</td>
</tr>
<tr>
<td>将方法标记为 JMX 操作。</td>
<td><code>@ManagedOperation</code></td>
<td>方法</td>
</tr>
<tr>
<td>将 getter 或 setter 标记为 JMX 属性的一半。</td>
<td><code>@ManagedAttribute</code></td>
<td>方法(只有 getter 和 setter)</td>
</tr>
<tr>
<td>定义操作参数的描述。</td>
<td><code>@ManagedOperationParameter</code>和<code>@ManagedOperationParameters</code></td>
<td>方法</td>
</tr>
</tbody>
</table>
</div>
<p>以下 table 描述了可用于这些 source-level 元数据类型的 configuration 参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>适用于</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ObjectName</code></td>
<td>由<code>MetadataNamingStrategy</code>用于确定受管资源的<code>ObjectName</code>。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>description</code></td>
<td>设置资源，属性或操作的友好描述。</td>
<td><code>ManagedResource</code>，<code>ManagedAttribute</code>，<code>ManagedOperation</code>或<code>ManagedOperationParameter</code></td>
</tr>
<tr>
<td><code>currencyTimeLimit</code></td>
<td>设置<code>currencyTimeLimit</code>描述符字段的 value。</td>
<td><code>ManagedResource</code>或<code>ManagedAttribute</code></td>
</tr>
<tr>
<td><code>defaultValue</code></td>
<td>设置<code>defaultValue</code>描述符字段的 value。</td>
<td><code>ManagedAttribute</code></td>
</tr>
<tr>
<td><code>log</code></td>
<td>设置<code>log</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>logFile</code></td>
<td>设置<code>logFile</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>persistPolicy</code></td>
<td>设置<code>persistPolicy</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>persistPeriod</code></td>
<td>设置<code>persistPeriod</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>persistLocation</code></td>
<td>设置<code>persistLocation</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>persistName</code></td>
<td>设置<code>persistName</code>描述符字段的 value。</td>
<td><code>ManagedResource</code></td>
</tr>
<tr>
<td><code>name</code></td>
<td>设置操作参数的 display name。</td>
<td><code>ManagedOperationParameter</code></td>
</tr>
<tr>
<td><code>index</code></td>
<td>设置操作参数的索引。</td>
<td><code>ManagedOperationParameter</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-2-4-使用-AutodetectCapableMBeanInfoAssembler-接口"><a href="#4-2-4-使用-AutodetectCapableMBeanInfoAssembler-接口" class="headerlink" title="4.2.4. 使用 AutodetectCapableMBeanInfoAssembler 接口"></a>4.2.4. 使用 AutodetectCapableMBeanInfoAssembler 接口</h4><p>为了进一步简化 configuration，Spring 包含<code>AutodetectCapableMBeanInfoAssembler</code>接口，它扩展了<code>MBeanInfoAssembler</code>接口以添加对 MBean 资源自动检测的支持。如果使用<code>AutodetectCapableMBeanInfoAssembler</code>的实例配置<code>MBeanExporter</code>，则允许对包含 beans 以“暴露”到 JMX 进行“投票”。</p>
<p><code>AutodetectCapableMBeanInfo</code>接口的唯一 implementation 是<code>MetadataMBeanInfoAssembler</code>，它投票包括任何用<code>ManagedResource</code>属性标记的 bean。在这种情况下，默认方法是使用 bean name 作为<code>ObjectName</code>，这将导致类似于以下的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;!-- notice how no &#39;beans&#39; are explicitly configured here --&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;autodetect&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;assembler&quot; ref&#x3D;&quot;assembler&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;assembler&quot; class&#x3D;&quot;org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;attributeSource&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，在前面的 configuration 中，没有 beans 传递给<code>MBeanExporter</code>。但是，<code>JmxTestBean</code>仍然是已注册的，因为它标有<code>ManagedResource</code>属性，<code>MetadataMBeanInfoAssembler</code>检测到这一点并投票包含它。这种方法的唯一问题是<code>JmxTestBean</code>的 name 现在具有商业意义。您可以通过更改<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-naming">控制 Beans 的 ObjectName 实例</a>中定义的<code>ObjectName</code>创建的默认行为来解决此问题。</p>
<h4 id="4-2-5-使用-Java-接口定义-Management-接口"><a href="#4-2-5-使用-Java-接口定义-Management-接口" class="headerlink" title="4.2.5. 使用 Java 接口定义 Management 接口"></a>4.2.5. 使用 Java 接口定义 Management 接口</h4><p>除了<code>MetadataMBeanInfoAssembler</code>之外，Spring 还包含<code>InterfaceBasedMBeanInfoAssembler</code>，它允许您根据接口集合中定义的方法集约束公开的方法和 properties。</p>
<p>尽管公开 MBean 的标准机制是使用接口和简单的命名 scheme，但<code>InterfaceBasedMBeanInfoAssembler</code>通过消除对命名约定的需要来扩展此功能，允许您使用多个接口并且不需要 beans 来实现 MBean 接口。</p>
<p>考虑以下接口，该接口用于为我们之前显示的<code>JmxTestBean</code> class 定义 management 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface IJmxTestBean &#123;</span><br><span class="line"></span><br><span class="line">    public int add(int x, int y);</span><br><span class="line"></span><br><span class="line">    public long myOperation();</span><br><span class="line"></span><br><span class="line">    public int getAge();</span><br><span class="line"></span><br><span class="line">    public void setAge(int age);</span><br><span class="line"></span><br><span class="line">    public void setName(String name);</span><br><span class="line"></span><br><span class="line">    public String getName();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此接口定义在 JMX MBean 上作为操作和属性公开的方法和 properties。以下 code 显示如何配置 Spring JMX 以将此接口用作 management 接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean5&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;assembler&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler&quot;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;managedInterfaces&quot;&gt;</span><br><span class="line">                    &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;&#x2F;value&gt;</span><br><span class="line">                &lt;&#x2F;property&gt;</span><br><span class="line">            &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，<code>InterfaceBasedMBeanInfoAssembler</code>被配置为在为任何 bean 构造 management 接口时使用<code>IJmxTestBean</code>接口。重要的是要理解<code>InterfaceBasedMBeanInfoAssembler</code>处理的 beans 不需要实现用于生成 JMX management 接口的接口。</p>
<p>在前面的例子中，<code>IJmxTestBean</code>接口用于构造所有 beans 的所有 management 接口。在许多情况下，这不是所需的行为，您可能希望为不同的 beans 使用不同的接口。在这种情况下，您可以通过<code>interfaceMappings</code> property 传递<code>InterfaceBasedMBeanInfoAssembler</code> <code>Properties</code>实例，其中每个条目的 key 是 bean name，每个条目的 value 是用于该 bean 的接口名称列表。</p>
<p>如果没有通过<code>managedInterfaces</code>或<code>interfaceMappings</code> properties 指定 management 接口，<code>InterfaceBasedMBeanInfoAssembler</code>将反映在 bean 上，并使用该 bean 实现的所有接口来创建 management 接口。</p>
<h4 id="4-2-6-使用-MethodNameBasedMBeanInfoAssembler"><a href="#4-2-6-使用-MethodNameBasedMBeanInfoAssembler" class="headerlink" title="4.2.6. 使用 MethodNameBasedMBeanInfoAssembler"></a>4.2.6. 使用 MethodNameBasedMBeanInfoAssembler</h4><p><code>MethodNameBasedMBeanInfoAssembler</code>允许您指定作为属性和操作向 JMX 公开的方法名称列表。以下 code 显示 sample configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean5&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;assembler&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;managedMethods&quot;&gt;</span><br><span class="line">                &lt;value&gt;add,myOperation,getName,setName,getAge&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，您可以看到<code>add</code>和<code>myOperation</code>方法作为 JMX 操作公开，而<code>getName()</code>，<code>setName(String)</code>和<code>getAge()</code>公开为 JMX 属性的适当一半。在前面的 code 中，方法映射适用于暴露给 JMX 的 beans。要在 bean-by-bean 的基础上控制方法曝光，可以使用</p>
<h3 id="4-3-控制-Beans-的-ObjectName-实例"><a href="#4-3-控制-Beans-的-ObjectName-实例" class="headerlink" title="4.3. 控制 Beans 的 ObjectName 实例"></a>4.3. 控制 Beans 的 ObjectName 实例</h3><p>在幕后，<code>MBeanExporter</code>委托<code>ObjectNamingStrategy</code>的_i实现为它注册的每个 beans 获取一个<code>ObjectName</code>实例。默认情况下，默认 implementation，<code>KeyNamingStrategy</code>使用<code>beans</code> <code>Map</code>的 key 作为<code>ObjectName</code>。此外，<code>KeyNamingStrategy</code>可以将<code>beans</code> <code>Map</code>的 key 映射到<code>Properties</code>文件(或 files)中的条目以解析<code>ObjectName</code>。除了<code>KeyNamingStrategy</code>之外，Spring 还提供了两个额外的<code>ObjectNamingStrategy</code> __mplement：<code>IdentityNamingStrategy</code>(基于 bean 的 JVM 标识构建<code>ObjectName</code>)和<code>MetadataNamingStrategy</code>(使用 source-level 元数据来获取<code>ObjectName</code>)。</p>
<h4 id="4-3-1-从-Properties-读取-ObjectName-实例"><a href="#4-3-1-从-Properties-读取-ObjectName-实例" class="headerlink" title="4.3.1. 从 Properties 读取 ObjectName 实例"></a>4.3.1. 从 Properties 读取 ObjectName 实例</h4><p>您可以配置自己的<code>KeyNamingStrategy</code>实例并将其配置为从<code>Properties</code>实例读取<code>ObjectName</code>实例，而不是使用 bean key。 <code>KeyNamingStrategy</code>尝试使用与 bean key 对应的 key 在<code>Properties</code>中找到一个条目。如果未找到任何条目或<code>Properties</code>实例为<code>null</code>，则使用 bean key 本身。</p>
<p>以下 code 显示<code>KeyNamingStrategy</code>的 sample configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testBean&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;namingStrategy&quot; ref&#x3D;&quot;namingStrategy&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;namingStrategy&quot; class&#x3D;&quot;org.springframework.jmx.export.naming.KeyNamingStrategy&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mappings&quot;&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key&#x3D;&quot;testBean&quot;&gt;bean:name&#x3D;testBean1&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;&#x2F;props&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mappingLocations&quot;&gt;</span><br><span class="line">            &lt;value&gt;names1.properties,names2.properties&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 配置<code>KeyNamingStrategy</code>的实例，其中<code>Properties</code>实例与映射 property 定义的<code>Properties</code>实例和位于映射 property 定义的_path 中的 properties files 合并。在此 configuration 中，<code>testBean</code> bean 被赋予<code>ObjectName</code> <code>bean:name=testBean1</code>，因为这是<code>Properties</code>实例中具有与 bean key 对应的 key 的条目。</p>
<p>如果找不到<code>Properties</code>实例中的条目，则 bean key name 用作<code>ObjectName</code>。</p>
<h4 id="4-3-2-使用-MetadataNamingStrategy"><a href="#4-3-2-使用-MetadataNamingStrategy" class="headerlink" title="4.3.2. 使用 MetadataNamingStrategy"></a>4.3.2. 使用 MetadataNamingStrategy</h4><p><code>MetadataNamingStrategy</code>在每个 bean 上使用<code>ManagedResource</code>属性的<code>objectName</code> property 来创建<code>ObjectName</code>。以下 code 显示了<code>MetadataNamingStrategy</code>的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testBean&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;namingStrategy&quot; ref&#x3D;&quot;namingStrategy&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;namingStrategy&quot; class&#x3D;&quot;org.springframework.jmx.export.naming.MetadataNamingStrategy&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;attributeSource&quot; ref&#x3D;&quot;attributeSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;attributeSource&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有为<code>ManagedResource</code>属性提供<code>objectName</code>，则使用以下格式创建<code>ObjectName</code>：[1274] :type = [1275]， name = [1276]。对于 example，以下 bean 生成的<code>ObjectName</code>将为<code>com.example:type=MyClass,name=myBean</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;myBean&quot; class&#x3D;&quot;com.example.MyClass&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-配置-Annotation-based-MBean-Export"><a href="#4-3-3-配置-Annotation-based-MBean-Export" class="headerlink" title="4.3.3. 配置 Annotation-based MBean Export"></a>4.3.3. 配置 Annotation-based MBean Export</h4><p>如果您更喜欢使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-interface-metadata">annotation-based 方法</a>来定义 management 接口，则可以使用<code>MBeanExporter</code>的便捷子类：<code>AnnotationMBeanExporter</code>。定义此子类的实例时，不再需要<code>namingStrategy</code>，<code>assembler</code>和<code>attributeSource</code> configuration，因为它始终使用标准 Java annotation-based 元数据(自动检测也始终启用)。实际上，<code>@EnableMBeanExport</code> 注释支持更简单的语法，而不是定义<code>MBeanExporter</code> bean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableMBeanExport</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您更喜欢 XML-based configuration，则<code>&lt;context:mbean-export/&gt;</code>元素具有相同的用途，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:mbean-export&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>如有必要，您可以为特定 MBean <code>server</code>提供 reference，<code>defaultDomain</code>属性(<code>AnnotationMBeanExporter</code>的 property)接受生成的 MBean <code>ObjectName</code>域的备用 value。这用于代替<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-naming-metadata">类 MetadataNamingStrategy</a>上一节中描述的完全限定的包 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@EnableMBeanExport(server&#x3D;&quot;myMBeanServer&quot;, defaultDomain&#x3D;&quot;myDomain&quot;)</span><br><span class="line">@Configuration</span><br><span class="line">ContextConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 annotation-based example 的 XML 等价物：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:mbean-export server&#x3D;&quot;myMBeanServer&quot; default-domain&#x3D;&quot;myDomain&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不要将 interface-based AOP 代理与 bean classes 中的 JMX annotations 自动检测结合使用。 Interface-based proxies“隐藏”目标 class，它也隐藏了 JMX-managed 资源注释。因此，在这种情况下你应该使用 target-class 代理(通过在<code>&lt;aop:config/&gt;</code>，<code>&lt;tx:annotation-driven/&gt;</code>等上设置’proxy-target-class’flag)。否则，您的 JMX beans 可能会在启动时被忽略。</p>
</blockquote>
<h3 id="4-4-使用-JSR-160-连接器"><a href="#4-4-使用-JSR-160-连接器" class="headerlink" title="4.4. 使用 JSR-160 连接器"></a>4.4. 使用 JSR-160 连接器</h3><p>对于 remote 访问，Spring JMX 模块在<code>org.springframework.jmx.support</code>包中提供两个<code>FactoryBean</code> implementations，用于创建 server-和 client-side 连接器。</p>
<h4 id="4-4-1-Server-side-连接器"><a href="#4-4-1-Server-side-连接器" class="headerlink" title="4.4.1. Server-side 连接器"></a>4.4.1. Server-side 连接器</h4><p>要让 Spring JMX 创建，启动和公开 JSR-160 <code>JMXConnectorServer</code>，您可以使用以下 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;serverConnector&quot; class&#x3D;&quot;org.springframework.jmx.support.ConnectorServerFactoryBean&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>ConnectorServerFactoryBean</code>创建<code>JMXConnectorServer</code>绑定到<code>service:jmx:jmxmp://localhost:9875</code>。 <code>serverConnector</code> bean 因此通过 localhost，port 9875 上的 JMXMP 协议公开本地<code>MBeanServer</code>到 clients。请注意，JSR 160 规范将 JMXMP 协议标记为可选。目前，主要的 open-source JMX implementation，MX4J 和 JDK 提供的那个不支持 JMXMP。</p>
<p>要指定另一个 URL 并使用<code>MBeanServer</code>注册<code>JMXConnectorServer</code>本身，可以分别使用<code>serviceUrl</code>和<code>ObjectName</code> properties，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;serverConnector&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jmx.support.ConnectorServerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;objectName&quot; value&#x3D;&quot;connector:name&#x3D;rmi&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot;</span><br><span class="line">            value&#x3D;&quot;service:jmx:rmi:&#x2F;&#x2F;localhost&#x2F;jndi&#x2F;rmi:&#x2F;&#x2F;localhost:1099&#x2F;myconnector&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>如果设置了<code>ObjectName</code> property，Spring 会自动将连接器注册到<code>ObjectName</code>下的<code>MBeanServer</code>。以下 example 显示了_创建<code>JMXConnector</code>时可以传递给<code>ConnectorServerFactoryBean</code>的完整参数集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;serverConnector&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jmx.support.ConnectorServerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;objectName&quot; value&#x3D;&quot;connector:name&#x3D;iiop&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot;</span><br><span class="line">        value&#x3D;&quot;service:jmx:iiop:&#x2F;&#x2F;localhost&#x2F;jndi&#x2F;iiop:&#x2F;&#x2F;localhost:900&#x2F;myconnector&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;threaded&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;daemon&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;environment&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;someKey&quot; value&#x3D;&quot;someValue&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，当您使用 RMI-based 连接器时，需要在 order 中启动查找服务(<code>tnameserv</code>或<code>rmiregistry</code>)才能完成 name 注册。如果您通过 RMI 使用 Spring 来 export remote 服务，Spring 已经构建了一个 RMI 注册表。如果没有，您可以使用以下 configuration 片段轻松启动注册表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;registry&quot; class&#x3D;&quot;org.springframework.remoting.rmi.RmiRegistryFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;1099&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-Client-side-连接器"><a href="#4-4-2-Client-side-连接器" class="headerlink" title="4.4.2. Client-side 连接器"></a>4.4.2. Client-side 连接器</h4><p>要创建<code>MBeanServerConnection</code>到 remote JSR-160-enabled <code>MBeanServer</code>，可以使用<code>MBeanServerConnectionFactoryBean</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;clientConnector&quot; class&#x3D;&quot;org.springframework.jmx.support.MBeanServerConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot; value&#x3D;&quot;service:jmx:rmi:&#x2F;&#x2F;localhost&#x2F;jndi&#x2F;rmi:&#x2F;&#x2F;localhost:1099&#x2F;jmxrmi&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-3-JMX-over-Hessian-或-SOAP"><a href="#4-4-3-JMX-over-Hessian-或-SOAP" class="headerlink" title="4.4.3. JMX over Hessian 或 SOAP"></a>4.4.3. JMX over Hessian 或 SOAP</h4><p>JSR-160 允许 extensions 到 client 和服务器之间进行通信的方式。前面部分中显示的示例使用 JSR-160 规范(IIOP 和 JRMP)和(可选)JMXMP 所需的强制 RMI-based implementation。通过使用其他提供程序或 JMX implementations(例如<a target="_blank" rel="noopener" href="http://mx4j.sourceforge.net/">MX4J</a>)，您可以利用 SOAP 或 Hessian 等协议而不是简单的 HTTP 或 SSL 等，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;serverConnector&quot; class&#x3D;&quot;org.springframework.jmx.support.ConnectorServerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;objectName&quot; value&#x3D;&quot;connector:name&#x3D;burlap&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot; value&#x3D;&quot;service:jmx:burlap:&#x2F;&#x2F;localhost:9874&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，我们使用了 MX4J 3.0.0. 有关更多信息，请参阅官方 MX4J 文档。</p>
<h3 id="4-5-通过代理访问-MBean"><a href="#4-5-通过代理访问-MBean" class="headerlink" title="4.5. 通过代理访问 MBean"></a>4.5. 通过代理访问 MBean</h3><p>Spring JMX 允许您创建 re-route calls 到在本地或 remote <code>MBeanServer</code>中注册的 MBean 的代理。这些代理为您提供了标准的 Java 接口，您可以通过它与 MBean 进行交互。以下 code 显示如何在本地<code>MBeanServer</code>中为 MBean running 配置代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;proxy&quot; class&#x3D;&quot;org.springframework.jmx.access.MBeanProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;objectName&quot; value&#x3D;&quot;bean:name&#x3D;testBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;proxyInterface&quot; value&#x3D;&quot;org.springframework.jmx.IJmxTestBean&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，您可以看到为在<code>bean:name=testBean</code> <code>ObjectName</code>下注册的 MBean 创建了代理。代理实现的接口集由<code>proxyInterfaces</code> property 控制，并且将这些接口上的方法和 properties 映射到 MBean 上的操作和属性的规则与<code>InterfaceBasedMBeanInfoAssembler</code>使用的规则相同。</p>
<p><code>MBeanProxyFactoryBean</code>可以为任何可通过<code>MBeanServerConnection</code>访问的 MBean 创建代理。默认情况下，找到并使用本地<code>MBeanServer</code>，但您可以覆盖它并提供<code>MBeanServerConnection</code>指向 remote <code>MBeanServer</code>以满足指向 remote MBeans 的代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;clientConnector&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jmx.support.MBeanServerConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serviceUrl&quot; value&#x3D;&quot;service:jmx:rmi:&#x2F;&#x2F;remotehost:9875&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;proxy&quot; class&#x3D;&quot;org.springframework.jmx.access.MBeanProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;objectName&quot; value&#x3D;&quot;bean:name&#x3D;testBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;proxyInterface&quot; value&#x3D;&quot;org.springframework.jmx.IJmxTestBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;server&quot; ref&#x3D;&quot;clientConnector&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，我们创建一个<code>MBeanServerConnection</code>，指向使用<code>MBeanServerConnectionFactoryBean</code>的 remote 机器。然后将<code>MBeanServerConnection</code>通过<code>server</code> property 传递给<code>MBeanProxyFactoryBean</code>。创建的代理通过此<code>MBeanServerConnection</code>将所有调用转发给<code>MBeanServer</code>。</p>
<h3 id="4-6-通知"><a href="#4-6-通知" class="headerlink" title="4.6. 通知"></a>4.6. 通知</h3><p>Spring 的 JMX 产品包括对 JMX 通知的全面支持。</p>
<h4 id="4-6-1-为通知注册-Listeners"><a href="#4-6-1-为通知注册-Listeners" class="headerlink" title="4.6.1. 为通知注册 Listeners"></a>4.6.1. 为通知注册 Listeners</h4><p>Spring 的 JMX 支持可以轻松地向任意数量的 MBean 注册任意数量的<code>NotificationListeners</code>(这包括 Spring 的<code>MBeanExporter</code>导出的 MBean 和通过其他机制注册的 MBean)。例如，考虑一个场景，其中一个人希望(通过<code>Notification</code>)每个 time 一个目标 MBean 的属性发生变化。以下 example 将通知写入 console：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"></span><br><span class="line">import javax.management.AttributeChangeNotification;</span><br><span class="line">import javax.management.Notification;</span><br><span class="line">import javax.management.NotificationFilter;</span><br><span class="line">import javax.management.NotificationListener;</span><br><span class="line"></span><br><span class="line">public class ConsoleLoggingNotificationListener</span><br><span class="line">        implements NotificationListener, NotificationFilter &#123;</span><br><span class="line"></span><br><span class="line">    public void handleNotification(Notification notification, Object handback) &#123;</span><br><span class="line">        System.out.println(notification);</span><br><span class="line">        System.out.println(handback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isNotificationEnabled(Notification notification) &#123;</span><br><span class="line">        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 将<code>ConsoleLoggingNotificationListener</code>(在前面的 example 中定义)添加到<code>notificationListenerMappings</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;notificationListenerMappings&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot;&gt;</span><br><span class="line">                    &lt;bean class&#x3D;&quot;com.example.ConsoleLoggingNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>使用前面的 configuration，每隔 time JMX <code>Notification</code>从目标 MBean(<code>bean:name=testBean1</code>)broadcast，通过<code>notificationListenerMappings</code> property 注册为 listener 的<code>ConsoleLoggingNotificationListener</code> bean 被通知。然后<code>ConsoleLoggingNotificationListener</code> bean 可以采取它认为适当的任何行动来响应<code>Notification</code>。</p>
<p>您还可以使用直 bean 名称作为导出的 beans 和 listeners 之间的链接，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;notificationListenerMappings&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;testBean&quot;&gt;</span><br><span class="line">                    &lt;bean class&#x3D;&quot;com.example.ConsoleLoggingNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;entry&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>如果要为封闭<code>MBeanExporter</code>导出的所有 beans 注册单个<code>NotificationListener</code>实例，则可以使用特殊通配符(<code>*</code>)作为<code>notificationListenerMappings</code> property map 中条目的 key，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name&#x3D;&quot;notificationListenerMappings&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key&#x3D;&quot;*&quot;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;com.example.ConsoleLoggingNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;entry&gt;</span><br><span class="line">    &lt;&#x2F;map&gt;</span><br><span class="line">&lt;&#x2F;property&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要执行逆操作(即，针对 MBean 注册多个不同的 listeners)，则必须使用<code>notificationListeners</code> list property(优先于<code>notificationListenerMappings</code> property)。这个 time，而不是为单个 MBean 配置<code>NotificationListener</code>，我们配置<code>NotificationListenerBean</code>实例。 封装了一个<code>NotificationListener</code>和<code>ObjectName</code>(或<code>ObjectNames</code>)，它将在<code>MBeanServer</code>中注册。 <code>NotificationListenerBean</code>还封装了许多其他 properties，例如<code>NotificationFilter</code>和可在高级 JMX 通知方案中使用的任意 handback object。</p>
<p>使用<code>NotificationListenerBean</code>实例时的 configuration 与之前提供的内容没有太大的不同，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;notificationListeners&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.springframework.jmx.export.NotificationListenerBean&quot;&gt;</span><br><span class="line">                    &lt;constructor-arg&gt;</span><br><span class="line">                        &lt;bean class&#x3D;&quot;com.example.ConsoleLoggingNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;constructor-arg&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;mappedObjectNames&quot;&gt;</span><br><span class="line">                        &lt;list&gt;</span><br><span class="line">                            &lt;value&gt;bean:name&#x3D;testBean1&lt;&#x2F;value&gt;</span><br><span class="line">                        &lt;&#x2F;list&gt;</span><br><span class="line">                    &lt;&#x2F;property&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 等同于第一个通知 example。那么假设我们希望每_一次被提出一个回传 object，并且我们也希望通过提供<code>NotificationFilter</code>来过滤掉无关的<code>Notifications</code>。以下 example 实现了以下目标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;exporter&quot; class&#x3D;&quot;org.springframework.jmx.export.MBeanExporter&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;beans&quot;&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean1&quot; value-ref&#x3D;&quot;testBean1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;entry key&#x3D;&quot;bean:name&#x3D;testBean2&quot; value-ref&#x3D;&quot;testBean2&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;map&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;notificationListeners&quot;&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.springframework.jmx.export.NotificationListenerBean&quot;&gt;</span><br><span class="line">                    &lt;constructor-arg ref&#x3D;&quot;customerNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;mappedObjectNames&quot;&gt;</span><br><span class="line">                        &lt;list&gt;</span><br><span class="line">                            &lt;!-- handles notifications from two distinct MBeans --&gt;</span><br><span class="line">                            &lt;value&gt;bean:name&#x3D;testBean1&lt;&#x2F;value&gt;</span><br><span class="line">                            &lt;value&gt;bean:name&#x3D;testBean2&lt;&#x2F;value&gt;</span><br><span class="line">                        &lt;&#x2F;list&gt;</span><br><span class="line">                    &lt;&#x2F;property&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;handback&quot;&gt;</span><br><span class="line">                        &lt;bean class&#x3D;&quot;java.lang.String&quot;&gt;</span><br><span class="line">                            &lt;constructor-arg value&#x3D;&quot;This could be anything...&quot;&#x2F;&gt;</span><br><span class="line">                        &lt;&#x2F;bean&gt;</span><br><span class="line">                    &lt;&#x2F;property&gt;</span><br><span class="line">                    &lt;property name&#x3D;&quot;notificationFilter&quot; ref&#x3D;&quot;customerNotificationListener&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;bean&gt;</span><br><span class="line">            &lt;&#x2F;list&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- implements both the NotificationListener and NotificationFilter interfaces --&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;customerNotificationListener&quot; class&#x3D;&quot;com.example.ConsoleLoggingNotificationListener&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean1&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;testBean2&quot; class&#x3D;&quot;org.springframework.jmx.JmxTestBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ANOTHER TEST&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;200&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>(有关 handback object 是什么以及<code>NotificationFilter</code>是什么的完整讨论，请参阅标题为’JMX Notification Model’的 JMX 规范(1.2)部分.)</p>
<h4 id="4-6-2-发布通知"><a href="#4-6-2-发布通知" class="headerlink" title="4.6.2. 发布通知"></a>4.6.2. 发布通知</h4><p>Spring 不仅支持注册接收<code>Notifications</code>，还支持发布<code>Notifications</code>。</p>
<blockquote>
<p>此部分实际上仅与通过<code>MBeanExporter</code>公开为 MBean 的 Spring-managed beans 相关。任何现有的 user-defined MBean 都应使用标准 JMX API 进行通知发布。</p>
</blockquote>
<p>Spring 的 JMX 通知发布支持中的 key 接口是<code>NotificationPublisher</code>接口(在<code>org.springframework.jmx.export.notification</code>包中定义)。任何将通过<code>MBeanExporter</code>实例导出为 MBean 的 bean 都可以实现相关的<code>NotificationPublisherAware</code>接口以获取对<code>NotificationPublisher</code>实例的访问权限。 <code>NotificationPublisherAware</code>接口通过一个简单的 setter 方法向实现 bean 提供<code>NotificationPublisher</code>的实例，然后 bean 可以用来发布<code>Notifications</code>。</p>
<p>正如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jmx/export/notification/NotificationPublisher.html">NotificationPublisher</a>接口的 javadoc 中所述，通过<code>NotificationPublisher</code>机制发布 events 的托管 beans 不负责通知 listeners 的 state management。 Spring 的 JMX 支持负责处理所有 JMX 基础架构问题。作为 application 开发人员，您需要做的就是实现<code>NotificationPublisherAware</code>接口并使用提供的<code>NotificationPublisher</code>实例开始发布 events。请注意，是在使用<code>MBeanServer</code>注册托管 bean 之后设置的。</p>
<p>使用<code>NotificationPublisher</code>实例非常简单。您创建一个 JMX <code>Notification</code>实例(或适当的<code>Notification</code>子类的实例)，使用与要发布的 event 相关的数据填充通知，并在<code>NotificationPublisher</code>实例上调用<code>sendNotification(Notification)</code>，传入<code>Notification</code>。</p>
<p>在下面的示例中，<code>JmxTestBean</code>的导出实例每 time发布一次<code>NotificationEvent</code>，<code>add(int, int)</code>操作被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.jmx;</span><br><span class="line"></span><br><span class="line">import org.springframework.jmx.export.notification.NotificationPublisherAware;</span><br><span class="line">import org.springframework.jmx.export.notification.NotificationPublisher;</span><br><span class="line">import javax.management.Notification;</span><br><span class="line"></span><br><span class="line">public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private boolean isSuperman;</span><br><span class="line">    private NotificationPublisher publisher;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; other getters and setters omitted for clarity</span><br><span class="line"></span><br><span class="line">    public int add(int x, int y) &#123;</span><br><span class="line">        int answer &#x3D; x + y;</span><br><span class="line">        this.publisher.sendNotification(new Notification(&quot;add&quot;, this, 0));</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void dontExposeMe() &#123;</span><br><span class="line">        throw new RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNotificationPublisher(NotificationPublisher notificationPublisher) &#123;</span><br><span class="line">        this.publisher &#x3D; notificationPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NotificationPublisher</code>接口和使其全部工作的机制是 Spring 的 JMX 支持的更好的 features 之一。但是，它确实带有将 classes 与 Spring 和 JMX 耦合的价格标签。一如既往，这里的建议是务实。如果您需要<code>NotificationPublisher</code>提供的功能，并且您可以接受与 Spring 和 JMX 的耦合，那么请执行此操作。</p>
<h3 id="4-7-更多资源"><a href="#4-7-更多资源" class="headerlink" title="4.7. 更多资源"></a>4.7. 更多资源</h3><p>本节包含有关 JMX 的更多资源的链接：</p>
<ul>
<li>Oracle 的<a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javase/tech/javamanagement-140525.html">JMX 主页</a>。</li>
<li><a target="_blank" rel="noopener" href="https://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JMX 规范</a>(JSR-000003)。</li>
<li><a target="_blank" rel="noopener" href="https://jcp.org/aboutJava/communityprocess/final/jsr160/index.html">JMX Remote API 规范</a>(JSR-000160)。</li>
<li><a target="_blank" rel="noopener" href="http://mx4j.sourceforge.net/">MX4J 主页</a>。 (MX4J 是各种 JMX 的 open-source 实现 specs.)</li>
</ul>
<h2 id="5-JCA-CCI"><a href="#5-JCA-CCI" class="headerlink" title="5. JCA CCI"></a>5. JCA CCI</h2><p>Java EE 提供了一个规范来标准化对企业信息系统(EIS)的访问：JCA(Java EE Connector Architecture)。该规范分为两个不同的部分：</p>
<ul>
<li>连接器提供程序必须实现的 SPI(服务提供程序接口)。这些接口构成可以部署在 Java EE application 服务器上的资源适配器。在这种情况下，服务器管理连接池，transactions 和安全性(托管模式)。 application 服务器还负责管理 configuration，它位于 client application 之外。也可以在没有 application 服务器的情况下使用连接器。在这种情况下，application 必须直接配置它(non-managed 模式)。</li>
<li>CCI(Common Client Interface)， application 可用于与连接器交互，从而与 EIS 通信。还提供了用于本地 transaction 划分的 API。</li>
</ul>
<p>Spring CCI 支持的目的是使用 Spring Framework 的一般资源和 transaction management 工具提供 classes 以典型的 Spring 样式访问 CCI 连接器。</p>
<blockquote>
<p>连接器的 client 端并不总是使用 CCI。某些连接器公开自己的 API，提供 JCA 资源适配器以使用 Java EE 容器的系统 contracts(连接池，global transactions 和安全性)。 Spring 不为此类 connector-specific API 提供特殊支持。</p>
</blockquote>
<h3 id="5-1-配置-CCI"><a href="#5-1-配置-CCI" class="headerlink" title="5.1. 配置 CCI"></a>5.1. 配置 CCI</h3><p>本节介绍如何配置 Common Client 接口(CCI)。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-config-connector">连接器 Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-config-connectionfactory">Spring 中的 ConnectionFactory Configuration</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-config-cci-connections">配置 CCI 连接</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-config-single-connection">使用单个 CCI 连接</a></li>
</ul>
<h4 id="5-1-1-连接器-Configuration"><a href="#5-1-1-连接器-Configuration" class="headerlink" title="5.1.1. 连接器 Configuration"></a>5.1.1. 连接器 Configuration</h4><p>使用 JCA CCI 的基本资源是<code>ConnectionFactory</code>接口。您使用的连接器必须提供此接口的 implementation。</p>
<p>要使用连接器，可以将其部署在 application 服务器上，并从服务器的 JNDI 环境(托管模式)获取<code>ConnectionFactory</code>。必须将连接器打包为 RAR 文件(资源适配器归档文件)，并包含<code>ra.xml</code>文件以描述其部署特征。部署资源时指定资源的实际 name。要在 Spring 中访问它，可以使用 Spring 的<code>JndiObjectFactoryBean</code>或<code>&lt;jee:jndi-lookup&gt;</code>通过其 JNDI name 获取工厂。</p>
<p>使用连接器的另一种方法是将其嵌入到 application(non-managed 模式)中，而不是使用 application 服务器来部署和配置它。 Spring 提供了通过<code>FactoryBean</code> implementation 调用(<code>LocalConnectionFactoryBean</code>)将连接器配置为 bean 的可能性。通过这种方式，您只需要 classpath 中的连接器 library(不需要 RAR 文件，也不需要<code>ra.xml</code>描述符)。如有必要，必须从连接器的 RAR 文件中提取 library。</p>
<p>一旦有权访问<code>ConnectionFactory</code>实例，就可以将其注入组件中。这些组件可以针对普通 CCI API 进行编码，也可以使用 Spring 的支持 classes 进行 CCI 访问(e.g. <code>CciTemplate</code>)。</p>
<blockquote>
<p>在 non-managed 模式下使用连接器时，不能使用 global transactions，因为资源在当前线程的当前 global transaction 中从未登记或退市。资源不知道可能正在运行的任何 global Java EE transactions。</p>
</blockquote>
<h4 id="5-1-2-Spring-中的-ConnectionFactory-Configuration"><a href="#5-1-2-Spring-中的-ConnectionFactory-Configuration" class="headerlink" title="5.1.2. Spring 中的 ConnectionFactory Configuration"></a>5.1.2. Spring 中的 ConnectionFactory Configuration</h4><p>要建立与 EIS 的连接，您需要从 application 服务器获取<code>ConnectionFactory</code>(如果您处于托管模式)或直接从 Spring 获取(如果您处于 non-managed 模式)。</p>
<p>在托管模式下，您可以从 JNDI 访问<code>ConnectionFactory</code>。它的 properties 在 application 服务器中配置。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;eciConnectionFactory&quot; jndi-name&#x3D;&quot;eis&#x2F;cicseci&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在 non-managed 模式下，必须将要在 Spring 的 configuration 中使用的<code>ConnectionFactory</code>配置为 JavaBean。 <code>LocalConnectionFactoryBean</code> class 提供此设置样式，传递连接器的<code>ManagedConnectionFactory</code> implementation，显示 application-level CCI <code>ConnectionFactory</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;eciManagedConnectionFactory&quot; class&#x3D;&quot;com.ibm.connector2.cics.ECIManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serverName&quot; value&#x3D;&quot;TXSERIES&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;tcp:&#x2F;&#x2F;localhost&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;portNumber&quot; value&#x3D;&quot;2006&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;eciConnectionFactory&quot; class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;eciManagedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您不能直接实例化特定的<code>ConnectionFactory</code>。您需要为连接器完成<code>ManagedConnectionFactory</code>接口的相应 implementation。该接口是 JCA SPI 规范的一部分。</p>
</blockquote>
<h4 id="5-1-3-配置-CCI-连接"><a href="#5-1-3-配置-CCI-连接" class="headerlink" title="5.1.3. 配置 CCI 连接"></a>5.1.3. 配置 CCI 连接</h4><p>JCA CCI 允许您使用连接器的<code>ConnectionSpec</code> implementation 配置与 EIS 的连接。要配置其 properties，需要使用专用适配器<code>ConnectionSpecConnectionFactoryAdapter</code>包装目标连接工厂。您可以使用<code>connectionSpec</code> property(作为内部 bean)配置专用<code>ConnectionSpec</code>。</p>
<p>此 property 不是必需的，因为 CCI <code>ConnectionFactory</code>接口定义了两种不同的方法来获取 CCI 连接。您通常可以在 application 服务器(在托管模式下)或相应的本地<code>ManagedConnectionFactory</code> implementation 中配置一些<code>ConnectionSpec</code> properties。以下清单显示了<code>ConnectionFactory</code>接口定义的相关部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ConnectionFactory implements Serializable, Referenceable &#123;</span><br><span class="line">    ...</span><br><span class="line">    Connection getConnection() throws ResourceException;</span><br><span class="line">    Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 提供<code>ConnectionSpecConnectionFactoryAdapter</code>，允许您指定<code>ConnectionSpec</code>实例以用于给定工厂上的所有操作。如果指定了适配器的<code>connectionSpec</code> property，则适配器将<code>getConnection</code>变量与<code>ConnectionSpec</code>参数一起使用。否则，适配器使用不带该参数的变量。以下 example 显示了如何配置<code>ConnectionSpecConnectionFactoryAdapter</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;managedConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:9001&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverName&quot; value&#x3D;&quot;org.hsqldb.jdbcDriver&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;targetConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;managedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;connectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetConnectionFactory&quot; ref&#x3D;&quot;targetConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionSpec&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;com.sun.connector.cciblackbox.CciConnectionSpec&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;sa&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-4-使用单个-CCI-连接"><a href="#5-1-4-使用单个-CCI-连接" class="headerlink" title="5.1.4. 使用单个 CCI 连接"></a>5.1.4. 使用单个 CCI 连接</h4><p>如果要使用单个 CCI 连接，Spring 会提供另一个<code>ConnectionFactory</code>适配器来管理它。 <code>SingleConnectionFactory</code> adapter class 延迟打开一个连接，并在 application shutdown 时销毁 bean 时关闭它。此 class 公开了相应行为的特殊<code>Connection</code>代理，它们共享相同的底层物理连接。以下 example 显示了如何使用<code>SingleConnectionFactory</code> adapter class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;eciManagedConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;com.ibm.connector2.cics.ECIManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serverName&quot; value&#x3D;&quot;TEST&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;tcp:&#x2F;&#x2F;localhost&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;portNumber&quot; value&#x3D;&quot;2006&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;targetEciConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;eciManagedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;eciConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.cci.connection.SingleConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetConnectionFactory&quot; ref&#x3D;&quot;targetEciConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此<code>ConnectionFactory</code>适配器无法直接配置<code>ConnectionSpec</code>。如果您需要针对特定<code>ConnectionSpec</code>的单个连接，则可以使用<code>SingleConnectionFactory</code>与之通信的中介<code>ConnectionSpecConnectionFactoryAdapter</code>。</p>
</blockquote>
<h3 id="5-2-使用-Spring-的-CCI-访问支持"><a href="#5-2-使用-Spring-的-CCI-访问支持" class="headerlink" title="5.2. 使用 Spring 的 CCI 访问支持"></a>5.2. 使用 Spring 的 CCI 访问支持</h3><p>本节介绍如何使用 Spring 对 CCI 的支持来实现各种目的。它包括以下主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-record-creator">Record 转换</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-using-template">使用 CciTemplate</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-using-dao">使用 DAO 支持</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#automatic-output-generation">自动输出记录生成</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#template-summary">CciTemplate 交互摘要</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-straight">直接使用 CCI 连接和交互</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-template-example">_CciTemplate 用法示例</a></li>
</ul>
<h4 id="5-2-1-Record-转换"><a href="#5-2-1-Record-转换" class="headerlink" title="5.2.1. Record 转换"></a>5.2.1. Record 转换</h4><p>Spring 的 JCA CCI 支持的目的之一是为操作 CCI 记录提供便利的设施。您可以指定策略来创建记录并从记录中提取数据，以便与 Spring 的<code>CciTemplate</code>一起使用。如果您不想直接在 application 中使用记录，则本节中描述的接口将策略配置为使用输入和输出记录。</p>
<p>要创建输入<code>Record</code>，您可以使用<code>RecordCreator</code>接口的专用 implementation。以下清单显示了<code>RecordCreator</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RecordCreator &#123;</span><br><span class="line"></span><br><span class="line">    Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>createRecord(..)</code>方法接收<code>RecordFactory</code>实例作为参数，该参数对应于<code>ConnectionFactory</code>的<code>RecordFactory</code>。您可以使用此 reference 创建<code>IndexedRecord</code>或<code>MappedRecord</code>实例。以下 sample 显示了如何使用<code>RecordCreator</code>接口以及索引或映射记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecordCreator implements RecordCreator &#123;</span><br><span class="line"></span><br><span class="line">    public Record createRecord(RecordFactory recordFactory) throws ResourceException &#123;</span><br><span class="line">        IndexedRecord input &#x3D; recordFactory.createIndexedRecord(&quot;input&quot;);</span><br><span class="line">        input.add(new Integer(id));</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用输出<code>Record</code>从 EIS 接收数据。因此，您可以将<code>RecordExtractor</code>接口的特定 implementation 传递给 Spring 的<code>CciTemplate</code>以从输出<code>Record</code>中提取数据。以下清单显示了<code>RecordExtractor</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RecordExtractor &#123;</span><br><span class="line"></span><br><span class="line">    Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用<code>RecordExtractor</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class MyRecordExtractor implements RecordExtractor &#123;</span><br><span class="line"></span><br><span class="line">    public Object extractData(Record record) throws ResourceException &#123;</span><br><span class="line">        CommAreaRecord commAreaRecord &#x3D; (CommAreaRecord) record;</span><br><span class="line">        String str &#x3D; new String(commAreaRecord.toByteArray());</span><br><span class="line">        String field1 &#x3D; string.substring(0,6);</span><br><span class="line">        String field2 &#x3D; string.substring(6,1);</span><br><span class="line">        return new OutputObject(Long.parseLong(field1), field2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-使用-CciTemplate"><a href="#5-2-2-使用-CciTemplate" class="headerlink" title="5.2.2. 使用 CciTemplate"></a>5.2.2. 使用 CciTemplate</h4><p><code>CciTemplate</code>是核心 CCI 支持包(<code>org.springframework.jca.cci.core</code>)的核心 class。它简化了 CCI 的使用，因为它处理资源的创建和发布。这有助于避免 common 错误，例如忘记始终关闭连接。它关注连接和交互 objects 的生命周期，让 application code 专注于从 application 数据生成输入记录并从输出记录中提取 application 数据。</p>
<p>JCA CCI 规范定义了两种不同的方法来调用 EIS 上的操作。 CCI <code>Interaction</code>接口提供两个执行方法签名，如下面的清单所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface javax.resource.cci.Interaction &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;</span><br><span class="line"></span><br><span class="line">    Record execute(InteractionSpec spec, Record input) throws ResourceException;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据调用的模板方法，<code>CciTemplate</code>知道要在交互上调用哪个<code>execute</code>方法。无论如何，正确初始化的<code>InteractionSpec</code>实例是必需的。</p>
<p>您可以通过两种方式使用<code>CciTemplate.execute(..)</code>：</p>
<ul>
<li>直接使用<code>Record</code> arguments。在这种情况下，您需要传入 CCI 输入 record，返回的 object 是相应的 CCI 输出 record。</li>
<li>使用 application objects，使用 record 映射。在这种情况下，您需要提供相应的<code>RecordCreator</code>和<code>RecordExtractor</code>实例。</li>
</ul>
<p>使用第一种方法，使用以下方法(直接对应于<code>Interaction</code>接口上的方法)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class CciTemplate implements CciOperations &#123;</span><br><span class="line"></span><br><span class="line">    public Record execute(InteractionSpec spec, Record inputRecord)</span><br><span class="line">            throws DataAccessException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)</span><br><span class="line">            throws DataAccessException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用第二种方法，我们需要将 record 创建和 record 提取策略指定为 arguments。使用的接口是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-record-creator">上一节关于 record 转换</a>中描述的接口。以下清单显示了相应的<code>CciTemplate</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CciTemplate implements CciOperations &#123;</span><br><span class="line"></span><br><span class="line">    public Record execute(InteractionSpec spec,</span><br><span class="line">            RecordCreator inputCreator) throws DataAccessException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object execute(InteractionSpec spec, Record inputRecord,</span><br><span class="line">            RecordExtractor outputExtractor) throws DataAccessException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object execute(InteractionSpec spec, RecordCreator creator,</span><br><span class="line">            RecordExtractor extractor) throws DataAccessException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除非在模板上设置了<code>outputRecordCreator</code> property(参见下一节)，否则每个方法都会使用两个参数调用 CCI <code>Interaction</code>的相应<code>execute</code>方法：<code>InteractionSpec</code>和输入<code>Record</code>。它接收输出<code>Record</code>作为其 return value。</p>
<p><code>CciTemplate</code>还提供了通过<code>createIndexRecord(..)</code>和<code>createMappedRecord(..)</code>方法在<code>RecordCreator</code> implementation 之外创建<code>IndexRecord</code>和<code>MappedRecord</code>的方法。您可以在 DAO implementations 中使用它来创建<code>Record</code>实例以传递到相应的<code>CciTemplate.execute(..)</code>方法。以下清单显示了<code>CciTemplate</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class CciTemplate implements CciOperations &#123;</span><br><span class="line"></span><br><span class="line">    public IndexedRecord createIndexedRecord(String name) throws DataAccessException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    public MappedRecord createMappedRecord(String name) throws DataAccessException &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-使用-DAO-支持"><a href="#5-2-3-使用-DAO-支持" class="headerlink" title="5.2.3. 使用 DAO 支持"></a>5.2.3. 使用 DAO 支持</h4><p>Spring 的 CCI 支持为 DAO 提供了一个抽象 class，支持注入<code>ConnectionFactory</code>或<code>CciTemplate</code>实例。 class 的 name 是<code>CciDaoSupport</code>。它提供简单的<code>setConnectionFactory</code>和<code>setCciTemplate</code>方法。在内部，此 class 为 passed-in <code>ConnectionFactory</code>创建<code>CciTemplate</code>实例，将其公开给子类中的具体数据访问 implementations。以下 example 显示了如何使用<code>CciDaoSupport</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CciDaoSupport &#123;</span><br><span class="line"></span><br><span class="line">    public void setConnectionFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ConnectionFactory getConnectionFactory() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCciTemplate(CciTemplate cciTemplate) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CciTemplate getCciTemplate() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-4-自动输出记录生成"><a href="#5-2-4-自动输出记录生成" class="headerlink" title="5.2.4. 自动输出记录生成"></a>5.2.4. 自动输出记录生成</h4><p>如果您使用的连接器仅支持带有输入和输出记录作为参数的<code>Interaction.execute(..)</code>方法(也就是说，它需要传入所需的输出 record 而不是返回适当的输出 record)，则可以将<code>CciTemplate</code>的<code>outputRecordCreator</code> property 设置为收到响应时，自动生成一个由 JCA 连接器填充的输出 record。然后将此 record 返回给模板的调用者。</p>
<p>此 property 包含<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cci-record-creator">RecordCreator 界面</a>的 implementation，用于此目的。您必须直接在<code>CciTemplate</code>上指定<code>outputRecordCreator</code> property。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());</span><br></pre></td></tr></table></figure>
<p>或者(我们建议使用此方法)，在 Spring configuration 中，如果将<code>CciTemplate</code>配置为专用的 bean 实例，则可以按以下方式定义 beans：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;eciOutputRecordCreator&quot; class&#x3D;&quot;eci.EciOutputRecordCreator&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;cciTemplate&quot; class&#x3D;&quot;org.springframework.jca.cci.core.CciTemplate&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;eciConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;outputRecordCreator&quot; ref&#x3D;&quot;eciOutputRecordCreator&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于<code>CciTemplate</code> class 是 thread-safe，因此通常将其配置为共享实例。</p>
</blockquote>
<h4 id="5-2-5-CciTemplate-交互摘要"><a href="#5-2-5-CciTemplate-交互摘要" class="headerlink" title="5.2.5. CciTemplate 交互摘要"></a>5.2.5. CciTemplate 交互摘要</h4><p>以下 table 总结了<code>CciTemplate</code> class 的机制以及在 CCI <code>Interaction</code>接口上调用的相应方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>CciTemplate</code>方法签名</th>
<th><code>CciTemplate</code> <code>outputRecordCreator</code> property</th>
<th>在 CCI Interaction 上调用<code>execute</code>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Record execute(InteractionSpec, Record)</code></td>
<td>没有设置</td>
<td><code>Record execute(InteractionSpec, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, Record)</code></td>
<td>组</td>
<td><code>boolean execute(InteractionSpec, Record, Record)</code></td>
</tr>
<tr>
<td>void execute(InteractionSpec，Record，Record)</td>
<td>没有设置</td>
<td>void execute(InteractionSpec，Record，Record)</td>
</tr>
<tr>
<td><code>void execute(InteractionSpec, Record, Record)</code></td>
<td>组</td>
<td><code>void execute(InteractionSpec, Record, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, RecordCreator)</code></td>
<td>没有设置</td>
<td><code>Record execute(InteractionSpec, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, RecordCreator)</code></td>
<td>组</td>
<td><code>void execute(InteractionSpec, Record, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, Record, RecordExtractor)</code></td>
<td>没有设置</td>
<td><code>Record execute(InteractionSpec, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, Record, RecordExtractor)</code></td>
<td>组</td>
<td><code>void execute(InteractionSpec, Record, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, RecordCreator, RecordExtractor)</code></td>
<td>没有设置</td>
<td><code>Record execute(InteractionSpec, Record)</code></td>
</tr>
<tr>
<td><code>Record execute(InteractionSpec, RecordCreator, RecordExtractor)</code></td>
<td>组</td>
<td><code>void execute(InteractionSpec, Record, Record)</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-2-6-直接使用-CCI-连接和交互"><a href="#5-2-6-直接使用-CCI-连接和交互" class="headerlink" title="5.2.6. 直接使用 CCI 连接和交互"></a>5.2.6. 直接使用 CCI 连接和交互</h4><p><code>CciTemplate</code>还允许您直接使用 CCI 连接和交互，方式与<code>JdbcTemplate</code>和<code>JmsTemplate</code>相同。如果要对 CCI 连接或交互执行多个操作，这对于 example 非常有用。</p>
<p><code>ConnectionCallback</code>接口提供 CCI <code>Connection</code>作为参数(对其执行自定义操作)以及创建<code>Connection</code>的 CCI <code>ConnectionFactory</code>。后者可能很有用(例如，获取关联的<code>RecordFactory</code>实例并创建 indexed/mapped 记录)。以下清单显示了<code>ConnectionCallback</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ConnectionCallback &#123;</span><br><span class="line"></span><br><span class="line">    Object doInConnection(Connection connection, ConnectionFactory connectionFactory)</span><br><span class="line">            throws ResourceException, SQLException, DataAccessException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InteractionCallback</code>接口提供 CCI <code>Interaction</code>(对其执行自定义操作)以及相应的 CCI <code>ConnectionFactory</code>。以下清单显示了<code>InteractionCallback</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface InteractionCallback &#123;</span><br><span class="line"></span><br><span class="line">    Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)</span><br><span class="line">        throws ResourceException, SQLException, DataAccessException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>InteractionSpec</code> objects 可以在多个模板 calls 之间共享，也可以在每个回调方法中新创建。这完全取决于 DAO implementation。</p>
</blockquote>
<h4 id="5-2-7-CciTemplate-用法示例"><a href="#5-2-7-CciTemplate-用法示例" class="headerlink" title="5.2.7. _CciTemplate 用法示例"></a>5.2.7. _CciTemplate 用法示例</h4><p>在本节中，我们将使用 IBM CICS ECI 连接器显示<code>CciTemplate</code>用于使用 ECI 模式访问 CICS 的用法。</p>
<p>首先，我们必须对 CCI <code>InteractionSpec</code>进行一些初始化，以指定要访问的 CICS 程序以及如何与其进行交互，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECIInteractionSpec interactionSpec &#x3D; new ECIInteractionSpec();</span><br><span class="line">interactionSpec.setFunctionName(&quot;MYPROG&quot;);</span><br><span class="line">interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</span><br></pre></td></tr></table></figure>
<p>然后程序可以通过 Spring 的模板使用 CCI 并指定 custom objects 和 CCI <code>Records</code>之间的映射，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyDaoImpl extends CciDaoSupport implements MyDao &#123;</span><br><span class="line"></span><br><span class="line">    public OutputObject getData(InputObject input) &#123;</span><br><span class="line">        ECIInteractionSpec interactionSpec &#x3D; ...;</span><br><span class="line"></span><br><span class="line">    OutputObject output &#x3D; (ObjectOutput) getCciTemplate().execute(interactionSpec,</span><br><span class="line">        new RecordCreator() &#123;</span><br><span class="line">            public Record createRecord(RecordFactory recordFactory) throws ResourceException &#123;</span><br><span class="line">                return new CommAreaRecord(input.toString().getBytes());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        new RecordExtractor() &#123;</span><br><span class="line">            public Object extractData(Record record) throws ResourceException &#123;</span><br><span class="line">                CommAreaRecord commAreaRecord &#x3D; (CommAreaRecord)record;</span><br><span class="line">                String str &#x3D; new String(commAreaRecord.toByteArray());</span><br><span class="line">                String field1 &#x3D; string.substring(0,6);</span><br><span class="line">                String field2 &#x3D; string.substring(6,1);</span><br><span class="line">                return new OutputObject(Long.parseLong(field1), field2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如前所述，您可以使用回调直接处理 CCI 连接或交互。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyDaoImpl extends CciDaoSupport implements MyDao &#123;</span><br><span class="line"></span><br><span class="line">    public OutputObject getData(InputObject input) &#123;</span><br><span class="line">        ObjectOutput output &#x3D; (ObjectOutput) getCciTemplate().execute(</span><br><span class="line">            new ConnectionCallback() &#123;</span><br><span class="line">                public Object doInConnection(Connection connection,</span><br><span class="line">                        ConnectionFactory factory) throws ResourceException &#123;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; do something...</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>ConnectionCallback</code>时，使用的<code>Connection</code>由<code>CciTemplate</code>管理和关闭，但回调 implementation 必须管理在连接上创建的任何交互。</p>
</blockquote>
<p>对于更具体的回调，您可以实现<code>InteractionCallback</code>。如果这样做，passed-in <code>Interaction</code>将由<code>CciTemplate</code>管理和关闭。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyDaoImpl extends CciDaoSupport implements MyDao &#123;</span><br><span class="line"></span><br><span class="line">    public String getData(String input) &#123;</span><br><span class="line">        ECIInteractionSpec interactionSpec &#x3D; ...;</span><br><span class="line">        String output &#x3D; (String) getCciTemplate().execute(interactionSpec,</span><br><span class="line">            new InteractionCallback() &#123;</span><br><span class="line">                public Object doInInteraction(Interaction interaction,</span><br><span class="line">                        ConnectionFactory factory) throws ResourceException &#123;</span><br><span class="line">                    Record input &#x3D; new CommAreaRecord(inputString.getBytes());</span><br><span class="line">                    Record output &#x3D; new CommAreaRecord();</span><br><span class="line">                    interaction.execute(holder.getInteractionSpec(), input, output);</span><br><span class="line">                    return new String(output.toByteArray());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        return output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前面的示例，所涉及的 Spring beans 的相应 configuration 可能类似于 non-managed 模式中的以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;managedConnectionFactory&quot; class&#x3D;&quot;com.ibm.connector2.cics.ECIManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serverName&quot; value&#x3D;&quot;TXSERIES&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;local:&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userName&quot; value&#x3D;&quot;CICSUSER&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;CICS&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;connectionFactory&quot; class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;managedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;mypackage.MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在托管模式下(即在 Java EE 环境中)，configuration 可能类似于以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;connectionFactory&quot; jndi-name&#x3D;&quot;eis&#x2F;cicseci&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-3-将-CCI-访问建模为操作-Objects"><a href="#5-3-将-CCI-访问建模为操作-Objects" class="headerlink" title="5.3. 将 CCI 访问建模为操作 Objects"></a>5.3. 将 CCI 访问建模为操作 Objects</h3><p><code>org.springframework.jca.cci.object</code>包包含支持 classes，允许您以不同的方式访问 EIS：通过可重用的操作 objects，类似于 Spring 的 JDBC 操作 objects(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#jdbc">数据访问章节的 JDBC 部分</a>)。这通常封装了 CCI API。 application-level 输入 object 被传递给操作 object，因此它可以构造输入 record，然后将接收到的 record 数据转换为 application-level 输出 object 并 return 它。</p>
<blockquote>
<p>这种方法在内部基于<code>CciTemplate</code> class 和<code>RecordCreator</code>或<code>RecordExtractor</code>接口，重用了 Spring 核心 CCI 支持的机制。</p>
</blockquote>
<h4 id="5-3-1-使用-MappingRecordOperation"><a href="#5-3-1-使用-MappingRecordOperation" class="headerlink" title="5.3.1. 使用 MappingRecordOperation"></a>5.3.1. 使用 MappingRecordOperation</h4><p><code>MappingRecordOperation</code>本质上执行与<code>CciTemplate</code>相同的工作，但将 pre-configured 操作表示为 object。它提供了两个模板方法来指定如何将输入 object 转换为输入 record 以及如何将输出 record 转换为输出 object(record mapping)：</p>
<ul>
<li><code>createInputRecord(..)</code>：指定如何将输入 object 转换为输入<code>Record</code></li>
<li><code>extractOutputData(..)</code>：指定如何从输出中提取输出 object <code>Record</code></li>
</ul>
<p>以下清单显示了这些方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MappingRecordOperation extends EisOperation &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    protected abstract Record createInputRecord(RecordFactory recordFactory,</span><br><span class="line">            Object inputObject) throws ResourceException, DataAccessException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract Object extractOutputData(Record outputRecord)</span><br><span class="line">            throws ResourceException, SQLException, DataAccessException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后，执行 EIS 操作，您需要使用单个<code>execute</code>方法，传入 application-level 输入 object 并接收 application-level 输出 object 作为结果。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MappingRecordOperation extends EisOperation &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public Object execute(Object inputObject) throws DataAccessException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>CciTemplate</code> class 相反，此<code>execute(..)</code>方法没有<code>InteractionSpec</code>作为参数。相反，<code>InteractionSpec</code>是 global 操作。必须使用以下构造函数来实例化具有特定<code>InteractionSpec</code>的操作 object。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InteractionSpec spec &#x3D; ...;</span><br><span class="line">MyMappingRecordOperation eisOperation &#x3D; new MyMappingRecordOperation(getConnectionFactory(), spec);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-使用-MappingCommAreaOperation"><a href="#5-3-2-使用-MappingCommAreaOperation" class="headerlink" title="5.3.2. 使用 MappingCommAreaOperation"></a>5.3.2. 使用 MappingCommAreaOperation</h4><p>某些连接器使用基于 COMMAREA 的记录，该记录表示包含要发送到 EIS 的参数及其返回的数据的 array 字节。 Spring 提供了一个特殊的操作 class，用于直接在 COMMAREA 而不是记录上工作。 <code>MappingCommAreaOperation</code> class 扩展了<code>MappingRecordOperation</code> class 以提供这种特殊的 COMMAREA 支持。它隐式使用<code>CommAreaRecord</code> class 作为输入和输出 record 类型，并提供两种新方法将输入 object 转换为输入 COMMAREA，并将输出 COMMAREA 转换为输出 object。以下清单显示了相关的方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class MappingCommAreaOperation extends MappingRecordOperation &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    protected abstract byte[] objectToBytes(Object inObject)</span><br><span class="line">            throws IOException, DataAccessException;</span><br><span class="line"></span><br><span class="line">    protected abstract Object bytesToObject(byte[] bytes)</span><br><span class="line">        throws IOException, DataAccessException;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-3-自动输出记录生成"><a href="#5-3-3-自动输出记录生成" class="headerlink" title="5.3.3. 自动输出记录生成"></a>5.3.3. 自动输出记录生成</h4><p>由于每个<code>MappingRecordOperation</code>子类都在内部基于 CciTemplate，因此可以使用与<code>CciTemplate</code>一样自动生成输出记录的相同方法。每个操作 object 都提供相应的<code>setOutputRecordCreator(..)</code>方法。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#automatic-output-generation">自动输出记录生成</a>。</p>
<h4 id="5-3-4-摘要"><a href="#5-3-4-摘要" class="headerlink" title="5.3.4. 摘要"></a>5.3.4. 摘要</h4><p>操作 object 方法以与<code>CciTemplate</code> class 相同的方式使用记录。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>MappingRecordOperation</code>方法签名</th>
<th><code>MappingRecordOperation</code> <code>outputRecordCreator</code> property</th>
<th>在 CCI Interaction 上调用<code>execute</code>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Object execute(Object)</code></td>
<td>没有设置</td>
<td><code>Record execute(InteractionSpec, Record)</code></td>
</tr>
<tr>
<td><code>Object execute(Object)</code></td>
<td>组</td>
<td><code>boolean execute(InteractionSpec, Record, Record)</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="5-3-5-MappingRecordOperation-用法示例"><a href="#5-3-5-MappingRecordOperation-用法示例" class="headerlink" title="5.3.5. MappingRecordOperation 用法示例"></a>5.3.5. MappingRecordOperation 用法示例</h4><p>在本节中，我们将展示如何使用<code>MappingRecordOperation</code>访问具有 Blackbox CCI 连接器的数据库。</p>
<blockquote>
<p>此连接器的原始 version 由 Java EE SDK(version 1.3)提供，可从 Oracle 获得。</p>
</blockquote>
<p>首先，必须对 CCI <code>InteractionSpec</code>进行一些初始化，以指定要执行的 SQL 请求。在下面的示例中，我们直接定义将请求的参数转换为 CCI record 的方式以及将 CCI 结果 record 转换为<code>Person</code> class 的实例的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class PersonMappingOperation extends MappingRecordOperation &#123;</span><br><span class="line"></span><br><span class="line">    public PersonMappingOperation(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        setConnectionFactory(connectionFactory);</span><br><span class="line">        CciInteractionSpec interactionSpec &#x3D; new CciConnectionSpec();</span><br><span class="line">        interactionSpec.setSql(&quot;select * from person where person_id&#x3D;?&quot;);</span><br><span class="line">        setInteractionSpec(interactionSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Record createInputRecord(RecordFactory recordFactory,</span><br><span class="line">            Object inputObject) throws ResourceException &#123;</span><br><span class="line">        Integer id &#x3D; (Integer) inputObject;</span><br><span class="line">        IndexedRecord input &#x3D; recordFactory.createIndexedRecord(&quot;input&quot;);</span><br><span class="line">        input.add(new Integer(id));</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected Object extractOutputData(Record outputRecord)</span><br><span class="line">            throws ResourceException, SQLException &#123;</span><br><span class="line">        ResultSet rs &#x3D; (ResultSet) outputRecord;</span><br><span class="line">        Person person &#x3D; null;</span><br><span class="line">        if (rs.next()) &#123;</span><br><span class="line">            Person person &#x3D; new Person();</span><br><span class="line">            person.setId(rs.getInt(&quot;person_id&quot;));</span><br><span class="line">            person.setLastName(rs.getString(&quot;person_last_name&quot;));</span><br><span class="line">            person.setFirstName(rs.getString(&quot;person_first_name&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后 application 可以执行操作 object，并将 person 标识符作为参数。请注意，您可以将操作 object 设置为共享实例，因为它是 thread-safe。以下以 person 标识符作为参数执行操作 object：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class MyDaoImpl extends CciDaoSupport implements MyDao &#123;</span><br><span class="line"></span><br><span class="line">    public Person getPerson(int id) &#123;</span><br><span class="line">        PersonMappingOperation query &#x3D; new PersonMappingOperation(getConnectionFactory());</span><br><span class="line">        Person person &#x3D; (Person) query.execute(new Integer(id));</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 non-managed 模式下 Spring beans 的相应 configuration 可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;managedConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:9001&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverName&quot; value&#x3D;&quot;org.hsqldb.jdbcDriver&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;targetConnectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;managedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;connectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetConnectionFactory&quot; ref&#x3D;&quot;targetConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionSpec&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;com.sun.connector.cciblackbox.CciConnectionSpec&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;sa&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在托管模式下(即在 Java EE 环境中)，configuration 可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;targetConnectionFactory&quot; jndi-name&#x3D;&quot;eis&#x2F;blackbox&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;connectionFactory&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetConnectionFactory&quot; ref&#x3D;&quot;targetConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionSpec&quot;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;com.sun.connector.cciblackbox.CciConnectionSpec&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;user&quot; value&#x3D;&quot;sa&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-6-MappingCommAreaOperation-用法示例"><a href="#5-3-6-MappingCommAreaOperation-用法示例" class="headerlink" title="5.3.6. MappingCommAreaOperation 用法示例"></a>5.3.6. MappingCommAreaOperation 用法示例</h4><p>在本节中，我们将展示如何使用<code>MappingCommAreaOperation</code>来使用 IBM CICS ECI 连接器访问带有 ECI 模式的 CICS。</p>
<p>首先，我们需要初始化 CCI <code>InteractionSpec</code>以指定要访问的 CICS 程序以及如何与之交互，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class EciMappingOperation extends MappingCommAreaOperation &#123;</span><br><span class="line"></span><br><span class="line">    public EciMappingOperation(ConnectionFactory connectionFactory, String programName) &#123;</span><br><span class="line">        setConnectionFactory(connectionFactory);</span><br><span class="line">        ECIInteractionSpec interactionSpec &#x3D; new ECIInteractionSpec(),</span><br><span class="line">        interactionSpec.setFunctionName(programName);</span><br><span class="line">        interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</span><br><span class="line">        interactionSpec.setCommareaLength(30);</span><br><span class="line">        setInteractionSpec(interactionSpec);</span><br><span class="line">        setOutputRecordCreator(new EciOutputRecordCreator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class EciOutputRecordCreator implements RecordCreator &#123;</span><br><span class="line">        public Record createRecord(RecordFactory recordFactory) throws ResourceException &#123;</span><br><span class="line">            return new CommAreaRecord();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以将 abstract <code>EciMappingOperation</code> class 子类化为指定 custom objects 和<code>Records</code>之间的映射，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class MyDaoImpl extends CciDaoSupport implements MyDao &#123;</span><br><span class="line"></span><br><span class="line">    public OutputObject getData(Integer id) &#123;</span><br><span class="line">        EciMappingOperation query &#x3D; new EciMappingOperation(getConnectionFactory(), &quot;MYPROG&quot;) &#123;</span><br><span class="line"></span><br><span class="line">            protected abstract byte[] objectToBytes(Object inObject) throws IOException &#123;</span><br><span class="line">                Integer id &#x3D; (Integer) inObject;</span><br><span class="line">                return String.valueOf(id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            protected abstract Object bytesToObject(byte[] bytes) throws IOException;</span><br><span class="line">                String str &#x3D; new String(bytes);</span><br><span class="line">                String field1 &#x3D; str.substring(0,6);</span><br><span class="line">                String field2 &#x3D; str.substring(6,1);</span><br><span class="line">                String field3 &#x3D; str.substring(7,1);</span><br><span class="line">                return new OutputObject(field1, field2, field3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return (OutputObject) query.execute(new Integer(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 non-managed 模式下 Spring beans 的相应 configuration 可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;managedConnectionFactory&quot; class&#x3D;&quot;com.ibm.connector2.cics.ECIManagedConnectionFactory&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;serverName&quot; value&#x3D;&quot;TXSERIES&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionURL&quot; value&#x3D;&quot;local:&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;userName&quot; value&#x3D;&quot;CICSUSER&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;CICS&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;connectionFactory&quot; class&#x3D;&quot;org.springframework.jca.support.LocalConnectionFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;managedConnectionFactory&quot; ref&#x3D;&quot;managedConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>在托管模式下(即在 Java EE 环境中)，configuration 可能如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;connectionFactory&quot; jndi-name&#x3D;&quot;eis&#x2F;cicseci&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;component&quot; class&#x3D;&quot;MyDaoImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;connectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-Transactions"><a href="#5-4-Transactions" class="headerlink" title="5.4. Transactions"></a>5.4. Transactions</h3><p>JCA 为资源适配器指定了几个 transaction 支持级别。资源适配器支持的 transactions 类型在其<code>ra.xml</code>文件中指定。基本上有三个选项：none(对于 example，使用 CICS EPI 连接器)，local transactions(对于 example，使用 CICS ECI 连接器)和 global transactions(对于 example，使用 IMS 连接器)。以下 example 配置 global 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;connector&gt;</span><br><span class="line">    &lt;resourceadapter&gt;</span><br><span class="line">        &lt;!-- &lt;transaction-support&gt;NoTransaction&lt;&#x2F;transaction-support&gt; --&gt;</span><br><span class="line">        &lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;&#x2F;transaction-support&gt; --&gt;</span><br><span class="line">        &lt;transaction-support&gt;XATransaction&lt;&#x2F;transaction-support&gt;</span><br><span class="line">    &lt;resourceadapter&gt;</span><br><span class="line">&lt;connector&gt;</span><br></pre></td></tr></table></figure>
<p>对于 global transactions，您可以使用 Spring 的通用 transaction 基础结构来划分 transactions，将<code>JtaTransactionManager</code>作为后端(委托给下面的 Java EE 服务器的分布式 transaction 协调器)。</p>
<p>对于单个 CCI <code>ConnectionFactory</code>上的本地 transactions，Spring 为 CCI 提供了特定的 transaction-management 策略，类似于 JDBC 的<code>DataSourceTransactionManager</code>。 CCI API 定义了本地 transaction object 和相应的本地 transaction 分界方法。 Spring 的<code>CciLocalTransactionManager</code>以完全符合 Spring 的通用<code>PlatformTransactionManager</code>抽象的方式执行这样的本地 CCI transactions。以下 example 配置<code>CciLocalTransactionManager</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;eciConnectionFactory&quot; jndi-name&#x3D;&quot;eis&#x2F;cicseci&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;eciTransactionManager&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.jca.cci.connection.CciLocalTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;connectionFactory&quot; ref&#x3D;&quot;eciConnectionFactory&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>您可以将 transaction 策略与 Spring 的 transaction 分界设施中的任何一个一起使用，无论是声明性的还是编程式的。这是 Spring 的通用<code>PlatformTransactionManager</code>抽象的结果，它将 transaction 分界与实际执行策略分离。您可以根据需要在<code>JtaTransactionManager</code>和<code>CciLocalTransactionManager</code>之间切换，保持 transaction 分界 as-is。</p>
<p>有关 Spring 的 transaction 工具的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction">Transaction Management</a>。</p>
<h2 id="6-电子邮件"><a href="#6-电子邮件" class="headerlink" title="6.电子邮件"></a>6.电子邮件</h2><p>本节介绍如何使用 Spring Framework 发送电子邮件。</p>
<p>Library 依赖</p>
<p>以下 JAR 需要在 order 中的 application 的 classpath 上使用 Spring Framework 的电子邮件 library：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javaee.github.io/javamail/">JavaMail</a> library</li>
</ul>
<p>这个 library 可以在 web 上免费获取 - 对于 example，在 Maven Central 中可以作为<code>com.sun.mail:javax.mail</code>。</p>
<p>Spring Framework 提供了一个有用的实用程序 library，用于发送电子邮件，使您免受底层邮件系统的细节影响，并负责代表 client 进行 low-level 资源处理。</p>
<p><code>org.springframework.mail</code>包是 Spring Framework 电子邮件支持的 root level 包。发送电子邮件的中央界面是<code>MailSender</code>界面。一个简单的 value object 封装了一个简单邮件的 properties，例如<code>from</code>和<code>to</code>(加上许多其他邮件)是<code>SimpleMailMessage</code> class。此包还包含已检查的 exceptions 层次结构，这些层次结构在较低的 level 邮件系统 exceptions 上提供更高级别的抽象，其中根 exception 为<code>MailException</code>。有关富邮件 exception 层次结构的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/mail/MailException.html">javadoc</a>。</p>
<p><code>org.springframework.mail.javamail.JavaMailSender</code>接口向<code>MailSender</code>接口(从中继承)添加了专门的 JavaMail features，例如 MIME 消息支持。 <code>JavaMailSender</code>还提供了一个名为<code>org.springframework.mail.javamail.MimeMessagePreparator</code>的回调接口，用于准备<code>MimeMessage</code>。</p>
<h3 id="6-1-用法"><a href="#6-1-用法" class="headerlink" title="6.1. 用法"></a>6.1. 用法</h3><p>假设我们有一个名为<code>OrderManager</code>的业务接口，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface OrderManager &#123;</span><br><span class="line"></span><br><span class="line">    void placeOrder(Order order);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步假设我们有一个要求，即需要生成带有 order 编号的电子邮件消息并将其发送给放置相关 order 的客户。</p>
<h4 id="6-1-1-基本-MailSender-和-SimpleMailMessage-用法"><a href="#6-1-1-基本-MailSender-和-SimpleMailMessage-用法" class="headerlink" title="6.1.1. 基本 MailSender 和 SimpleMailMessage 用法"></a>6.1.1. 基本 MailSender 和 SimpleMailMessage 用法</h4><p>以下 example 显示了当有人放置 order 时如何使用<code>MailSender</code>和<code>SimpleMailMessage</code>发送电子邮件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.mail.MailException;</span><br><span class="line">import org.springframework.mail.MailSender;</span><br><span class="line">import org.springframework.mail.SimpleMailMessage;</span><br><span class="line"></span><br><span class="line">public class SimpleOrderManager implements OrderManager &#123;</span><br><span class="line"></span><br><span class="line">    private MailSender mailSender;</span><br><span class="line">    private SimpleMailMessage templateMessage;</span><br><span class="line"></span><br><span class="line">    public void setMailSender(MailSender mailSender) &#123;</span><br><span class="line">        this.mailSender &#x3D; mailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTemplateMessage(SimpleMailMessage templateMessage) &#123;</span><br><span class="line">        this.templateMessage &#x3D; templateMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void placeOrder(Order order) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Do the business calculations...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Call the collaborators to persist the order...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create a thread safe &quot;copy&quot; of the template message and customize it</span><br><span class="line">        SimpleMailMessage msg &#x3D; new SimpleMailMessage(this.templateMessage);</span><br><span class="line">        msg.setTo(order.getCustomer().getEmailAddress());</span><br><span class="line">        msg.setText(</span><br><span class="line">            &quot;Dear &quot; + order.getCustomer().getFirstName()</span><br><span class="line">                + order.getCustomer().getLastName()</span><br><span class="line">                + &quot;, thank you for placing order. Your order number is &quot;</span><br><span class="line">                + order.getOrderNumber());</span><br><span class="line">        try&#123;</span><br><span class="line">            this.mailSender.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (MailException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; simply log it and go on...</span><br><span class="line">            System.err.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 code 的 bean 定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;mailSender&quot; class&#x3D;&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;mail.mycompany.com&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- this is a template message that we can pre-load with default state --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;templateMessage&quot; class&#x3D;&quot;org.springframework.mail.SimpleMailMessage&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;from&quot; value&#x3D;&quot;[emailprotected]&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;subject&quot; value&#x3D;&quot;Your order&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;orderManager&quot; class&#x3D;&quot;com.mycompany.businessapp.support.SimpleOrderManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mailSender&quot; ref&#x3D;&quot;mailSender&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;templateMessage&quot; ref&#x3D;&quot;templateMessage&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-使用-JavaMailSender-和-MimeMessagePreparator"><a href="#6-1-2-使用-JavaMailSender-和-MimeMessagePreparator" class="headerlink" title="6.1.2. 使用 JavaMailSender 和 MimeMessagePreparator"></a>6.1.2. 使用 JavaMailSender 和 MimeMessagePreparator</h4><p>本节介绍使用<code>MimeMessagePreparator</code>回调接口的<code>OrderManager</code>的另一个_implement。在下面的示例中，<code>mailSender</code> property 的类型为<code>JavaMailSender</code>，因此我们可以使用 JavaMail <code>MimeMessage</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import javax.mail.Message;</span><br><span class="line">import javax.mail.MessagingException;</span><br><span class="line">import javax.mail.internet.InternetAddress;</span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line"></span><br><span class="line">import javax.mail.internet.MimeMessage;</span><br><span class="line">import org.springframework.mail.MailException;</span><br><span class="line">import org.springframework.mail.javamail.JavaMailSender;</span><br><span class="line">import org.springframework.mail.javamail.MimeMessagePreparator;</span><br><span class="line"></span><br><span class="line">public class SimpleOrderManager implements OrderManager &#123;</span><br><span class="line"></span><br><span class="line">    private JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    public void setMailSender(JavaMailSender mailSender) &#123;</span><br><span class="line">        this.mailSender &#x3D; mailSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void placeOrder(final Order order) &#123;</span><br><span class="line">        &#x2F;&#x2F; Do the business calculations...</span><br><span class="line">        &#x2F;&#x2F; Call the collaborators to persist the order...</span><br><span class="line"></span><br><span class="line">        MimeMessagePreparator preparator &#x3D; new MimeMessagePreparator() &#123;</span><br><span class="line">            public void prepare(MimeMessage mimeMessage) throws Exception &#123;</span><br><span class="line">                mimeMessage.setRecipient(Message.RecipientType.TO,</span><br><span class="line">                        new InternetAddress(order.getCustomer().getEmailAddress()));</span><br><span class="line">                mimeMessage.setFrom(new InternetAddress(&quot;[emailprotected]&quot;));</span><br><span class="line">                mimeMessage.setText(&quot;Dear &quot; + order.getCustomer().getFirstName() + &quot; &quot; +</span><br><span class="line">                        order.getCustomer().getLastName() + &quot;, thanks for your order. &quot; +</span><br><span class="line">                        &quot;Your order number is &quot; + order.getOrderNumber() + &quot;.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            this.mailSender.send(preparator);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (MailException ex) &#123;</span><br><span class="line">            &#x2F;&#x2F; simply log it and go on...</span><br><span class="line">            System.err.println(ex.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mail code 是一个横切关注的问题，很可能是重构为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">自定义 Spring AOP aspect</a>的候选者，然后可以在<code>OrderManager</code>目标上的适当连接点执行。</p>
</blockquote>
<p>Spring Framework 的邮件支持附带标准的 JavaMail implementation。有关更多信息，请参阅相关的 javadoc。</p>
<h3 id="6-2-使用-JavaMail-MimeMessageHelper"><a href="#6-2-使用-JavaMail-MimeMessageHelper" class="headerlink" title="6.2. 使用 JavaMail MimeMessageHelper"></a>6.2. 使用 JavaMail MimeMessageHelper</h3><p>处理 JavaMail 消息时非常方便的 class 是<code>org.springframework.mail.javamail.MimeMessageHelper</code>，它使您不必使用详细的 JavaMail API。使用<code>MimeMessageHelper</code>，创建<code>MimeMessage</code>非常容易，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; of course you would use DI in any real-world cases</span><br><span class="line">JavaMailSenderImpl sender &#x3D; new JavaMailSenderImpl();</span><br><span class="line">sender.setHost(&quot;mail.host.com&quot;);</span><br><span class="line"></span><br><span class="line">MimeMessage message &#x3D; sender.createMimeMessage();</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(message);</span><br><span class="line">helper.setTo(&quot;[emailprotected]&quot;);</span><br><span class="line">helper.setText(&quot;Thank you for ordering!&quot;);</span><br><span class="line"></span><br><span class="line">sender.send(message);</span><br></pre></td></tr></table></figure>
<h4 id="6-2-1-发送附件和内联资源"><a href="#6-2-1-发送附件和内联资源" class="headerlink" title="6.2.1. 发送附件和内联资源"></a>6.2.1. 发送附件和内联资源</h4><p>Multipart 电子邮件允许附件和内联资源。内联资源的示例包括您要在邮件中使用但不希望显示为附件的图像或样式表。</p>
<h5 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h5><p>以下 example 显示如何使用<code>MimeMessageHelper</code>发送包含单个 JPEG 图像附件的电子邮件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">JavaMailSenderImpl sender &#x3D; new JavaMailSenderImpl();</span><br><span class="line">sender.setHost(&quot;mail.host.com&quot;);</span><br><span class="line"></span><br><span class="line">MimeMessage message &#x3D; sender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use the true flag to indicate you need a multipart message</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(message, true);</span><br><span class="line">helper.setTo(&quot;[emailprotected]&quot;);</span><br><span class="line"></span><br><span class="line">helper.setText(&quot;Check out this image!&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; let&#39;s attach the infamous windows Sample file (this time copied to c:&#x2F;)</span><br><span class="line">FileSystemResource file &#x3D; new FileSystemResource(new File(&quot;c:&#x2F;Sample.jpg&quot;));</span><br><span class="line">helper.addAttachment(&quot;CoolImage.jpg&quot;, file);</span><br><span class="line"></span><br><span class="line">sender.send(message);</span><br></pre></td></tr></table></figure>
<h5 id="内联资源"><a href="#内联资源" class="headerlink" title="内联资源"></a>内联资源</h5><p>以下 example 显示如何使用<code>MimeMessageHelper</code>发送带有内嵌图像的电子邮件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">JavaMailSenderImpl sender &#x3D; new JavaMailSenderImpl();</span><br><span class="line">sender.setHost(&quot;mail.host.com&quot;);</span><br><span class="line"></span><br><span class="line">MimeMessage message &#x3D; sender.createMimeMessage();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use the true flag to indicate you need a multipart message</span><br><span class="line">MimeMessageHelper helper &#x3D; new MimeMessageHelper(message, true);</span><br><span class="line">helper.setTo(&quot;[emailprotected]&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; use the true flag to indicate the text included is HTML</span><br><span class="line">helper.setText(&quot;&lt;html&gt;&lt;body&gt;&lt;img src&#x3D;&#39;cid:identifier1234&#39;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; let&#39;s include the infamous windows Sample file (this time copied to c:&#x2F;)</span><br><span class="line">FileSystemResource res &#x3D; new FileSystemResource(new File(&quot;c:&#x2F;Sample.jpg&quot;));</span><br><span class="line">helper.addInline(&quot;identifier1234&quot;, res);</span><br><span class="line"></span><br><span class="line">sender.send(message);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过使用指定的<code>Content-ID</code>(上面的 example 中的<code>identifier1234</code>)将内联资源添加到<code>MimeMessage</code>。添加文本和资源的 order 非常重要。请务必先添加文本，然后再添加资源。如果你反过来这样做，它就行不通。</p>
</blockquote>
<h4 id="6-2-2-使用模板-Library-创建电子邮件内容"><a href="#6-2-2-使用模板-Library-创建电子邮件内容" class="headerlink" title="6.2.2. 使用模板 Library 创建电子邮件内容"></a>6.2.2. 使用模板 Library 创建电子邮件内容</h4><p>前面部分中显示的示例中的 code 通过使用方法 calls(例如<code>message.setText(..)</code>)显式创建了电子邮件消息的内容。这对于简单的情况很好，并且在上述示例的 context 中是可以的，其目的是向您展示 API 的基础知识。</p>
<p>但是，在典型的企业应用程序中，开发人员通常不会使用之前显示的方法创建电子邮件内容，原因如下：</p>
<ul>
<li>在 Java code 中创建 HTML-based 电子邮件内容是单调乏味且容易出错的。</li>
<li>显示逻辑和业务逻辑之间没有明确的区别。</li>
<li>更改电子邮件内容的显示结构需要编写 Java code，重新编译，重新部署等。</li>
</ul>
<p>通常，解决这些问题的方法是使用模板 library(例如 FreeMarker)来定义电子邮件内容的显示结构。这使得 code 的任务只是创建要在电子邮件模板中呈现的数据并发送电子邮件。当您的电子邮件内容变得相当复杂时，这绝对是一种最佳实践，并且，对于 FreeMarker，使用 Spring Framework 支持 classes，它变得非常容易。</p>
<h2 id="7-任务执行和调度"><a href="#7-任务执行和调度" class="headerlink" title="7.任务执行和调度"></a>7.任务执行和调度</h2><p>Spring Framework 分别为<code>TaskExecutor</code>和<code>TaskScheduler</code>接口提供异步执行和任务调度的抽象。 Spring 还 features implementations 那些支持线程池或在 application 服务器环境中委托给 CommonJ 的接口。最终，在 common 接口后面使用这些_implement 将抽象出 Java SE 5，Java SE 6 和 Java EE 环境之间的差异。</p>
<p>Spring 还 features integration classes 以支持使用<code>Timer</code>(自 1.3 以来的 JDK 的一部分)和 Quartz Scheduler(<a target="_blank" rel="noopener" href="http://quartz-scheduler.org/">http://quartz-scheduler.org</a>)进行调度。您可以分别使用带有可选 references 的<code>FactoryBean</code>和<code>Timer</code>或<code>Trigger</code>实例的<code>FactoryBean</code>来设置这两个调度程序。此外，Quartz Scheduler 和<code>Timer</code>的便捷 class 可用于调用现有目标 object 的方法(类似于普通的<code>MethodInvokingFactoryBean</code>操作)。</p>
<h3 id="7-1-Spring-TaskExecutor-抽象"><a href="#7-1-Spring-TaskExecutor-抽象" class="headerlink" title="7.1. Spring TaskExecutor 抽象"></a>7.1. Spring TaskExecutor 抽象</h3><p>执行程序是线程池概念的 JDK name。 “执行程序”命名是由于无法保证底层 implementation 实际上是一个池。执行程序可能是 single-threaded 甚至是同步的。 Spring 的抽象隐藏了 Java SE 和 Java EE 环境之间的 implementation 细节。</p>
<p>Spring 的<code>TaskExecutor</code>接口与<code>java.util.concurrent.Executor</code>接口相同。实际上，最初，它存在的主要原因是在使用线程池时抽象出对 Java 5 的需求。该接口具有单个方法(<code>execute(Runnable task)</code>)，该方法基于线程池的语义和 configuration 接受要执行的任务。</p>
<p>最初创建<code>TaskExecutor</code>是为了给其他 Spring 组件提供所需的线程池抽象。诸如<code>ApplicationEventMulticaster</code>，JMS 的<code>AbstractMessageListenerContainer</code>和 Quartz integration 之类的组件都使用<code>TaskExecutor</code>抽象来池化线程。但是，如果您的 beans 需要线程池行为，您也可以根据自己的需要使用此抽象。</p>
<h4 id="7-1-1-TaskExecutor-类型"><a href="#7-1-1-TaskExecutor-类型" class="headerlink" title="7.1.1. TaskExecutor 类型"></a>7.1.1. TaskExecutor 类型</h4><p>Spring 包含许多 pre-built __mplempleations of <code>TaskExecutor</code>。很可能，你永远不需要实现自己的。 Spring 提供的变体如下：</p>
<ul>
<li><code>SyncTaskExecutor</code>：此 implementation 不会异步执行调用。相反，每次调用都发生在调用线程中。它主要用于不需要 multi-threading 的情况，例如在简单的测试用例中。</li>
<li><code>SimpleAsyncTaskExecutor</code>：此 implementation 不会重用任何线程。相反，它为每次调用启动一个新线程。但是，它确实支持并发限制，该限制会阻止任何超出限制的调用，直到释放一个插槽。如果您正在寻找 true 池，请参阅此列表中的<code>ThreadPoolTaskExecutor</code>。</li>
<li><code>ConcurrentTaskExecutor</code>：此 implementation 是<code>java.util.concurrent.Executor</code>实例的适配器。有一个替代(<code>ThreadPoolTaskExecutor</code>)将<code>Executor</code> configuration 参数公开为 bean properties。很少需要直接使用<code>ConcurrentTaskExecutor</code>。但是，如果<code>ThreadPoolTaskExecutor</code>不够灵活以满足您的需求，<code>ConcurrentTaskExecutor</code>是另一种选择。</li>
<li><code>ThreadPoolTaskExecutor</code>：此 implementation 最常用。它公开 bean properties 以配置<code>java.util.concurrent.ThreadPoolExecutor</code>并将其包装在<code>TaskExecutor</code>中。如果您需要适应不同类型的<code>java.util.concurrent.Executor</code>，我们建议您改用<code>ConcurrentTaskExecutor</code>。</li>
<li><code>WorkManagerTaskExecutor</code>：此 implementation 使用 CommonJ <code>WorkManager</code>作为其后备服务提供程序，并且是在 Spring application context 中在 WebLogic 或 WebSphere 上设置 CommonJ-based 线程池 integration 的中心便捷 class。</li>
<li><code>DefaultManagedTaskExecutor</code>：此 implementation 在 JSR-236 兼容的运行时环境(例如 Java EE 7 application 服务器)中使用 JNDI-obtained <code>ManagedExecutorService</code>，为此目的替换 CommonJ WorkManager。</li>
</ul>
<h4 id="7-1-2-使用-TaskExecutor"><a href="#7-1-2-使用-TaskExecutor" class="headerlink" title="7.1.2. 使用 TaskExecutor"></a>7.1.2. 使用 TaskExecutor</h4><p>Spring 的<code>TaskExecutor</code> implementations 用作简单的 JavaBeans。在下面的示例中，我们定义一个 bean，它使用<code>ThreadPoolTaskExecutor</code>异步打印出一组消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.core.task.TaskExecutor;</span><br><span class="line"></span><br><span class="line">public class TaskExecutorExample &#123;</span><br><span class="line"></span><br><span class="line">    private class MessagePrinterTask implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">        private String message;</span><br><span class="line"></span><br><span class="line">        public MessagePrinterTask(String message) &#123;</span><br><span class="line">            this.message &#x3D; message;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private TaskExecutor taskExecutor;</span><br><span class="line"></span><br><span class="line">    public TaskExecutorExample(TaskExecutor taskExecutor) &#123;</span><br><span class="line">        this.taskExecutor &#x3D; taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printMessages() &#123;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; 25; i++) &#123;</span><br><span class="line">            taskExecutor.execute(new MessagePrinterTask(&quot;Message&quot; + i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如您所见，您不是从池中检索线程并自行执行，而是将<code>Runnable</code>添加到队列中。然后<code>TaskExecutor</code>使用其内部规则来决定何时执行任务。</p>
<p>要配置<code>TaskExecutor</code>使用的规则，我们公开简单的 bean properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;taskExecutor&quot; class&#x3D;&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;corePoolSize&quot; value&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;maxPoolSize&quot; value&#x3D;&quot;10&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;queueCapacity&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;taskExecutorExample&quot; class&#x3D;&quot;TaskExecutorExample&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref&#x3D;&quot;taskExecutor&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-2-Spring-TaskScheduler-抽象"><a href="#7-2-Spring-TaskScheduler-抽象" class="headerlink" title="7.2. Spring TaskScheduler 抽象"></a>7.2. Spring TaskScheduler 抽象</h3><p>除了<code>TaskExecutor</code>抽象之外，Spring 3.0 引入了一个<code>TaskScheduler</code>，其中包含各种方法，可以在将来的某个时刻调度任务。以下清单显示了<code>TaskScheduler</code>接口定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public interface TaskScheduler &#123;</span><br><span class="line"></span><br><span class="line">    ScheduledFuture schedule(Runnable task, Trigger trigger);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture schedule(Runnable task, Instant startTime);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture schedule(Runnable task, Date startTime);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleAtFixedRate(Runnable task, Date startTime, long period);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleAtFixedRate(Runnable task, long period);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleWithFixedDelay(Runnable task, Date startTime, long delay);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay);</span><br><span class="line"></span><br><span class="line">    ScheduledFuture scheduleWithFixedDelay(Runnable task, long delay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的方法是名为<code>schedule</code>的方法，只占用<code>Runnable</code>和<code>Date</code>。这导致任务在指定的 time 之后运行一次。所有其他方法都能够重复调度任务。 fixed-rate 和 fixed-delay 方法用于简单的定期执行，但接受<code>Trigger</code>的方法更灵活。</p>
<h4 id="7-2-1-触发接口"><a href="#7-2-1-触发接口" class="headerlink" title="7.2.1. 触发接口"></a>7.2.1. 触发接口</h4><p><code>Trigger</code>界面基本上受 JSR-236 的启发，从 Spring 3.0 开始，尚未正式实施。 <code>Trigger</code>的基本 idea 是执行时间可以根据过去的执行结果甚至任意条件来确定。如果这些确定确实考虑了前面执行的结果，则该信息在<code>TriggerContext</code>内可用。 <code>Trigger</code>界面本身非常简单，如下面的清单所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Trigger &#123;</span><br><span class="line"></span><br><span class="line">    Date nextExecutionTime(TriggerContext triggerContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TriggerContext</code>是最重要的部分。它封装了所有相关数据，如有必要，将来可以进行扩展。 <code>TriggerContext</code>是一个接口(默认使用<code>SimpleTriggerContext</code> implementation)。以下清单显示了<code>Trigger</code> implementations 的可用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface TriggerContext &#123;</span><br><span class="line"></span><br><span class="line">    Date lastScheduledExecutionTime();</span><br><span class="line"></span><br><span class="line">    Date lastActualExecutionTime();</span><br><span class="line"></span><br><span class="line">    Date lastCompletionTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-2-触发-Implementations"><a href="#7-2-2-触发-Implementations" class="headerlink" title="7.2.2. 触发 Implementations"></a>7.2.2. 触发 Implementations</h4><p>Spring 提供了<code>Trigger</code>接口的两个 implementations。最有趣的是<code>CronTrigger</code>。它支持基于 cron 表达式调度任务。例如，以下任务计划在每小时后运行 15 分钟，但仅限于工作日的 9-to-5“营业时间”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheduler.schedule(task, new CronTrigger(&quot;0 15 9-17 * * MON-FRI&quot;));</span><br></pre></td></tr></table></figure>
<p>另一个 implementation 是<code>PeriodicTrigger</code>，它接受一个固定的句点，一个可选的初始延迟 value 和一个 boolean 来指示该句点是应该被解释为 fixed-rate 还是 fixed-delay。由于<code>TaskScheduler</code>接口已经定义了以固定速率或固定延迟调度任务的方法，因此应尽可能直接使用这些方法。 <code>PeriodicTrigger</code> implementation 的 value 是你可以在依赖<code>Trigger</code>抽象的组件中使用它。例如，允许定期触发，cron-based 触发器甚至自定义触发器 implementations 可以互换使用可能很方便。这样的 component 可以利用依赖注入，这样你就可以在外部配置这样的<code>Triggers</code>，因此可以很容易地修改或扩展它们。</p>
<h4 id="7-2-3-TaskScheduler-implementations"><a href="#7-2-3-TaskScheduler-implementations" class="headerlink" title="7.2.3. TaskScheduler implementations"></a>7.2.3. TaskScheduler implementations</h4><p>与 Spring 的<code>TaskExecutor</code>抽象一样，<code>TaskScheduler</code>安排的主要好处是 application 的调度需求与部署环境分离。在部署到 application 服务器环境时，此抽象 level 特别相关，其中不应由 application 本身直接创建线程。对于这样的场景，Spring 提供了一个<code>TimerManagerTaskScheduler</code>，它委托给 WebLogic 或 WebSphere 上的 CommonJ <code>TimerManager</code>以及一个委托给 Java EE 7 环境中的 JSR-236 <code>ManagedScheduledExecutorService</code>的更新<code>DefaultManagedTaskScheduler</code>。两者通常都配置有 JNDI 查找。</p>
<p>每当外部线程 management 不是必需的时候，更简单的替代方案是 application 中的本地<code>ScheduledExecutorService</code>设置，可以通过 Spring 的<code>ConcurrentTaskScheduler</code>进行调整。为方便起见，Spring 还提供了一个<code>ThreadPoolTaskScheduler</code>，它在内部委托<code>ScheduledExecutorService</code>沿的行提供 common bean-style configuration。这些变体适用于宽松的 application 服务器环境中的本地嵌入式线程池设置，特别是在 Tomcat 和 Jetty 上。</p>
<h3 id="7-3-Annotation-支持调度和异步执行"><a href="#7-3-Annotation-支持调度和异步执行" class="headerlink" title="7.3. Annotation 支持调度和异步执行"></a>7.3. Annotation 支持调度和异步执行</h3><p>Spring 为任务调度和异步方法执行提供 annotation 支持。</p>
<h4 id="7-3-1-启用计划注释"><a href="#7-3-1-启用计划注释" class="headerlink" title="7.3.1. 启用计划注释"></a>7.3.1. 启用计划注释</h4><p>要启用对<code>@Scheduled</code>和<code>@Async</code> 注释的支持，可以将<code>@EnableScheduling</code>和<code>@EnableAsync</code>添加到其中一个<code>@Configuration</code> classes 中，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableAsync</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以为 application 选择相关的注释。例如，如果您只需要支持<code>@Scheduled</code>，则可以省略<code>@EnableAsync</code>。对于更多 fine-grained 控件，您还可以实现<code>SchedulingConfigurer</code>接口，<code>AsyncConfigurer</code>接口或两者。有关完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/annotation/SchedulingConfigurer.html">SchedulingConfigurer</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/annotation/AsyncConfigurer.html">AsyncConfigurer</a> javadoc。</p>
<p>如果您更喜欢 XML configuration，则可以使用<code>&lt;task:annotation-driven&gt;</code>元素，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven executor&#x3D;&quot;myExecutor&quot; scheduler&#x3D;&quot;myScheduler&quot;&#x2F;&gt;</span><br><span class="line">&lt;task:executor id&#x3D;&quot;myExecutor&quot; pool-size&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">&lt;task:scheduler id&#x3D;&quot;myScheduler&quot; pool-size&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，使用前面的 XML，提供了 executor reference 用于处理与具有<code>@Async</code> annotation 的方法对应的那些任务，并且提供了 scheduler reference 用于管理用<code>@Scheduled</code>注释的那些方法。</p>
<blockquote>
<p>处理<code>@Async</code> annotations 的默认建议模式是<code>proxy</code>，它允许仅通过代理拦截 calls。同一 class 中的本地 calls 不能以这种方式截获。对于更高级的拦截模式，请考虑结合 compile-time 或 load-time 编织切换到<code>aspectj</code>模式。</p>
</blockquote>
<h4 id="7-3-2-Scheduled-annotation"><a href="#7-3-2-Scheduled-annotation" class="headerlink" title="7.3.2. @Scheduled annotation"></a>7.3.2. @Scheduled annotation</h4><p>您可以将<code>@Scheduled</code> annotation 与触发器元数据一起添加到方法中。对于 example，以固定延迟每五秒调用以下方法，这意味着该周期是从每个前一次调用的完成 time 开始测量的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(fixedDelay&#x3D;5000)</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    &#x2F;&#x2F; something that should execute periodically</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要执行 fixed-rate，则可以更改 annotation 中指定的 property name。每五秒调用以下方法(在每次调用的连续开始时间之间测量)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(fixedRate&#x3D;5000)</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    &#x2F;&#x2F; something that should execute periodically</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 fixed-delay 和 fixed-rate 任务，您可以通过指示在第一次执行方法之前等待的毫秒数来指定初始延迟，如下面的<code>fixedRate</code> example 显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(initialDelay&#x3D;1000, fixedRate&#x3D;5000)</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    &#x2F;&#x2F; something that should execute periodically</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果简单的定期调度表达不够，则可以提供 cron 表达式。对于 example，以下仅在工作日执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Scheduled(cron&#x3D;&quot;*&#x2F;5 * * * * MON-FRI&quot;)</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">    &#x2F;&#x2F; something that should execute on weekdays only</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您还可以使用<code>zone</code>属性指定解析 cron 表达式的 time zone。</p>
</blockquote>
<p>请注意，要调度的方法必须具有 void 返回，并且不得指望任何 arguments。如果该方法需要与 application context 中的其他 object 交互，那么这些通常是通过依赖注入提供的。</p>
<blockquote>
<p>从 Spring Framework 4.3 开始，任何范围的 beans 都支持<code>@Scheduled</code>方法。</p>
</blockquote>
<p>确保您没有在运行时初始化同一<code>@Scheduled</code> annotation class 的多个实例，除非您确实要为每个此类实例安排回调。与此相关，请确保不要在使用<code>@Scheduled</code>注释的 bean classes 上使用<code>@Configurable</code>，并将其作为常规 Spring beans 注册到容器中。否则，您将获得 double 初始化(一次通过容器，一次通过<code>@Configurable</code> aspect)，每次<code>@Scheduled</code>方法的结果被调用两次。</p>
<h4 id="Async注解"><a href="#Async注解" class="headerlink" title="Async注解"></a>Async注解</h4><p>您可以在方法上提供<code>@Async</code> annotation，以便异步调用该方法。换句话说，调用者在调用时立即返回，而方法的实际执行发生在已提交给 Spring <code>TaskExecutor</code>的任务中。在最简单的情况下，您可以将 annotation 应用于返回<code>void</code>的方法，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// this will be executed asynchronously</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与使用<code>@Scheduled</code> annotation 注释的方法不同，这些方法可以期望 arguments，因为它们在运行时由调用者以“正常”方式调用，而不是由容器管理的调度任务调用。对于 example，以下 code 是<code>@Async</code> annotation 的合法 application：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">void doSomething(String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; this will be executed asynchronously</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>甚至可以异步调用 return value 的方法。但是，这些方法需要具有<code>Future</code> -typed return value。这仍然提供异步执行的好处，以便调用者可以在<code>Future</code>上调用<code>get()</code>之前执行其他任务。以下 example 显示如何在返回 value 的方法上使用<code>@Async</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line">Future&lt;String&gt; returnSomething(int i) &#123;</span><br><span class="line">    &#x2F;&#x2F; this will be executed asynchronously</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@Async</code>方法不仅可以声明常规<code>java.util.concurrent.Future</code> return 类型，还可以声明 Spring 的<code>org.springframework.util.concurrent.ListenableFuture</code>，或者 Spring 4.2，JDK 8 的<code>java.util.concurrent.CompletableFuture</code>，以便与异步任务进行更丰富的交互，并通过进一步的处理步骤立即合成。</p>
</blockquote>
<p>您不能将<code>@Async</code>与生命周期回调(如<code>@PostConstruct</code>)结合使用。要异步初始化 Spring beans，您当前必须使用单独的初始化 Spring bean，然后在目标上调用<code>@Async</code>带注释的方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SampleBeanImpl implements SampleBean &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    void doSomething() &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SampleBeanInitializer &#123;</span><br><span class="line"></span><br><span class="line">    private final SampleBean bean;</span><br><span class="line"></span><br><span class="line">    public SampleBeanInitializer(SampleBean bean) &#123;</span><br><span class="line">        this.bean &#x3D; bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void initialize() &#123;</span><br><span class="line">        bean.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@Async</code>没有直接的 XML 等价物，因为这些方法应该首先设计用于异步执行，而不是外部 re-declared 是异步的。但是，您可以使用 Spring AOP 手动设置 Spring 的<code>AsyncExecutionInterceptor</code>，并结合自定义切入点。</p>
</blockquote>
<h4 id="7-3-4-执行者资格与-Async"><a href="#7-3-4-执行者资格与-Async" class="headerlink" title="7.3.4. 执行者资格与 @Async"></a>7.3.4. 执行者资格与 @Async</h4><p>默认情况下，在方法上指定<code>@Async</code>时，使用的执行程序是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#scheduling-enable-annotation-support">在启用异步支持时配置</a>，i.e。如果使用 XML 或<code>AsyncConfigurer</code> implementation(如果有)，则为“annotation-driven”元素。但是，当您需要指示在执行给定方法时应使用非默认执行程序时，可以使用<code>@Async</code> annotation 的<code>value</code>属性。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Async(&quot;otherExecutor&quot;)</span><br><span class="line">void doSomething(String s) &#123;</span><br><span class="line">    &#x2F;&#x2F; this will be executed asynchronously by &quot;otherExecutor&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，<code>&quot;otherExecutor&quot;</code>可以是 Spring 容器中任何<code>Executor</code> bean 的 name，也可以是与任何<code>Executor</code>关联的限定符的 name(对于 example，与<code>&lt;qualifier&gt;</code>元素或 Spring 的<code>@Qualifier</code> annotation 一起指定)。</p>
<h4 id="7-3-5-Exception-Management-with-Async"><a href="#7-3-5-Exception-Management-with-Async" class="headerlink" title="7.3.5. Exception Management with @Async"></a>7.3.5. Exception Management with @Async</h4><p>当<code>@Async</code>方法具有<code>Future</code> -typed return value 时，很容易管理在方法执行期间抛出的 exception，因为在<code>Future</code>结果上调用<code>get</code>时会抛出此 exception。但是，使用<code>void</code> return 类型时，exception 未被捕获且无法传输。您可以提供<code>AsyncUncaughtExceptionHandler</code>来处理此类 exceptions。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123;</span><br><span class="line">        &#x2F;&#x2F; handle exception</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，仅记录 exception。您可以使用<code>AsyncConfigurer</code>或<code>&lt;task:annotation-driven/&gt;</code> XML 元素定义自定义<code>AsyncUncaughtExceptionHandler</code>。</p>
<h3 id="7-4-任务命名空间"><a href="#7-4-任务命名空间" class="headerlink" title="7.4. 任务命名空间"></a>7.4. 任务命名空间</h3><p>从 version 3.0 开始，Spring 包含一个用于配置<code>TaskExecutor</code>和<code>TaskScheduler</code>实例的 XML 命名空间。它还提供了一种方便的方法来配置要使用触发器安排的任务。</p>
<h4 id="‘调度程序’元素"><a href="#‘调度程序’元素" class="headerlink" title="‘调度程序’元素"></a>‘调度程序’元素</h4><p>以下元素使用指定的线程池大小创建<code>ThreadPoolTaskScheduler</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:scheduler id&#x3D;&quot;scheduler&quot; pool-size&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>为<code>id</code>属性提供的 value 用作池中线程名称的前缀。 <code>scheduler</code>元素相对简单。如果未提供<code>pool-size</code>属性，则默认线程池只有一个线程。调度程序没有其他 configuration 选项。</p>
<h4 id="执行元素"><a href="#执行元素" class="headerlink" title="执行元素"></a>执行元素</h4><p>以下创建<code>ThreadPoolTaskExecutor</code>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:executor id&#x3D;&quot;executor&quot; pool-size&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#scheduling-task-namespace-scheduler">上一节</a>中显示的调度程序一样，为<code>id</code>属性提供的 value 用作池中线程名称的前缀。就池大小而言，<code>executor</code>元素支持比<code>scheduler</code>元素更多的 configuration 选项。首先，<code>ThreadPoolTaskExecutor</code>的线程池本身更易于配置。执行程序的线程池可以具有不同的核心值和最大大小，而不仅仅是单个大小。如果提供单个 value，则执行程序具有 fixed-size 线程池(核心和最大大小相同)。但是，<code>executor</code>元素的<code>pool-size</code>属性也接受<code>min-max</code>形式的范围。以下 example _set 设置<code>5</code>的最小值和<code>25</code>的最大值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:executor</span><br><span class="line">        id&#x3D;&quot;executorWithPoolSizeRange&quot;</span><br><span class="line">        pool-size&#x3D;&quot;5-25&quot;</span><br><span class="line">        queue-capacity&#x3D;&quot;100&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 configuration 中，还提供了<code>queue-capacity</code> value。还应根据执行程序的队列容量来考虑线程池的配置。有关池大小和队列容量之间关系的完整说明，请参阅<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>的文档。主要的是，当提交任务时，如果 active 线程的数量当前小于核心大小，则执行程序首先尝试使用空闲线程。如果已达到核心大小，则任务将添加到队列中，因为尚未达到其容量 long。只有这样，如果已达到队列的容量，执行程序是否会创建超出核心大小的新线程。如果还达到了最大大小，则执行程序拒绝该任务。</p>
<p>默认情况下，队列是无限制的，但这很少是所需的 configuration，因为如果在所有池线程都忙的情况下将足够的任务添加到该队列，它可能会导致<code>OutOfMemoryErrors</code>。此外，如果队列是无界的，则最大大小根本没有影响。由于执行程序总是在创建超出核心大小的新线程之前尝试队列，因此队列必须具有有限的容量，以使线程池增长超出核心大小(这就是为什么 fixed-size 池是使用无界时唯一合理的情况队列)。</p>
<p>如上所述，在任务被拒绝时考虑这种情况。默认情况下，当任务被拒绝时，线程池执行程序会抛出<code>TaskRejectedException</code>。但是，拒绝 policy 实际上是可配置的。使用默认拒绝 policy 时会抛出 exception，这是<code>AbortPolicy</code> implementation。对于可以在高负载下跳过某些任务的 applications，您可以改为配置<code>DiscardPolicy</code>或<code>DiscardOldestPolicy</code>。另一个适用于需要在重负载下限制提交的任务的应用程序的选项是<code>CallerRunsPolicy</code>。 policy 不会抛出 exception 或丢弃任务，而是强制调用 submit 方法的线程 run 任务本身。 idea 是这样一个调用者在忙于运行该任务而不能立即提交其他任务时。因此，它提供了一种简单的方法来限制传入的负载，同时保持线程池和队列的限制。通常，这允许执行程序“赶上”它正在处理的任务，从而释放队列，池中或两者中的一些容量。您可以从<code>executor</code>元素的<code>rejection-policy</code>属性的可用值枚举中选择任何这些选项。</p>
<p>以下 example 显示了一个<code>executor</code>元素，其中包含许多属性以指定各种行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:executor</span><br><span class="line">        id&#x3D;&quot;executorWithCallerRunsPolicy&quot;</span><br><span class="line">        pool-size&#x3D;&quot;5-25&quot;</span><br><span class="line">        queue-capacity&#x3D;&quot;100&quot;</span><br><span class="line">        rejection-policy&#x3D;&quot;CALLER_RUNS&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>最后，<code>keep-alive</code>设置确定线程在终止之前可以保持 idle 的 time 限制(以秒为单位)。如果池中当前有多个线程核心数，则在等待此数量的 time 而不处理任务后，多余的线程将被终止。 time value 为零会导致多余线程在执行任务后立即终止，而不会在任务队列中保留 follow-up 工作。以下 example _set <code>keep-alive</code> value 为两分钟：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:executor</span><br><span class="line">        id&#x3D;&quot;executorWithKeepAlive&quot;</span><br><span class="line">        pool-size&#x3D;&quot;5-25&quot;</span><br><span class="line">        keep-alive&#x3D;&quot;120&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="‘scheduled-tasks’元素"><a href="#‘scheduled-tasks’元素" class="headerlink" title="‘scheduled-tasks’元素"></a>‘scheduled-tasks’元素</h4><p>Spring 任务命名空间最强大的 feature 是支持在 Spring Application Context 中配置要安排的任务。这遵循类似于 Spring 中的其他“method-invokers”的方法，例如由 JMS 名称空间提供的用于配置 message-driven POJO 的方法。基本上，<code>ref</code>属性可以指向任何 Spring-managed object，<code>method</code>属性提供要在该对象上调用的方法的 name。以下清单显示了一个简单的 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:scheduled-tasks scheduler&#x3D;&quot;myScheduler&quot;&gt;</span><br><span class="line">    &lt;task:scheduled ref&#x3D;&quot;beanA&quot; method&#x3D;&quot;methodA&quot; fixed-delay&#x3D;&quot;5000&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;task:scheduled-tasks&gt;</span><br><span class="line"></span><br><span class="line">&lt;task:scheduler id&#x3D;&quot;myScheduler&quot; pool-size&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>调度程序由外部元素引用，每个单独的任务包括其触发器元数据的 configuration。在前面的示例中，该元数据定义了具有固定延迟的周期性触发，该延迟指示在每个任务执行完成之后等待的毫秒数。另一个选项是<code>fixed-rate</code>，表示该方法应该执行的频率，无论先前执行的时间长度是多长。此外，对于<code>fixed-delay</code>和<code>fixed-rate</code>任务，您可以指定’initial-delay’参数，指示在第一次执行该方法之前等待的毫秒数。要获得更多控制，您可以改为提供<code>cron</code>属性。以下 example 显示了以下其他选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:scheduled-tasks scheduler&#x3D;&quot;myScheduler&quot;&gt;</span><br><span class="line">    &lt;task:scheduled ref&#x3D;&quot;beanA&quot; method&#x3D;&quot;methodA&quot; fixed-delay&#x3D;&quot;5000&quot; initial-delay&#x3D;&quot;1000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;task:scheduled ref&#x3D;&quot;beanB&quot; method&#x3D;&quot;methodB&quot; fixed-rate&#x3D;&quot;5000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;task:scheduled ref&#x3D;&quot;beanC&quot; method&#x3D;&quot;methodC&quot; cron&#x3D;&quot;*&#x2F;5 * * * * MON-FRI&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;task:scheduled-tasks&gt;</span><br><span class="line"></span><br><span class="line">&lt;task:scheduler id&#x3D;&quot;myScheduler&quot; pool-size&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用Quartz调度程序"><a href="#使用Quartz调度程序" class="headerlink" title="使用Quartz调度程序"></a>使用Quartz调度程序</h3><p>Quartz 使用<code>Trigger</code>，<code>Job</code>和<code>JobDetail</code> objects 来实现各种作业的调度。有关 Quartz 背后的基本概念，请参阅<a target="_blank" rel="noopener" href="http://quartz-scheduler.org/">http://quartz-scheduler.org</a>。为方便起见，Spring 提供了几个 classes，简化了在 Spring-based applications 中使用 Quartz 的过程。</p>
<h4 id="使用JobDetailFactoryBean"><a href="#使用JobDetailFactoryBean" class="headerlink" title="使用JobDetailFactoryBean"></a>使用JobDetailFactoryBean</h4><p>Quartz <code>JobDetail</code> objects 包含_jun job 所需的所有信息。 Spring 提供<code>JobDetailFactoryBean</code>，它提供 bean-style properties 用于 XML 配置目的。考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean name&#x3D;&quot;exampleJob&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jobClass&quot; value&#x3D;&quot;example.ExampleJob&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jobDataAsMap&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;timeout&quot; value&#x3D;&quot;5&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>job detail configuration 具有_jun job(<code>ExampleJob</code>)所需的所有信息。超时在 job data map 中指定。 job 数据 map 可通过<code>JobExecutionContext</code>(在执行 time 时传递给您)获得，但<code>JobDetail</code>也从 job 数据中获取 properties 映射到 job 实例的 properties。因此，在下面的示例中，<code>ExampleJob</code>包含一个名为<code>timeout</code>的 bean property，<code>JobDetail</code>会自动应用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package example;</span><br><span class="line"></span><br><span class="line">public class ExampleJob extends QuartzJobBean &#123;</span><br><span class="line"></span><br><span class="line">    private int timeout;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Setter called after the ExampleJob is instantiated</span><br><span class="line">     * with the value from the JobDetailFactoryBean (5)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public void setTimeout(int timeout) &#123;</span><br><span class="line">        this.timeout &#x3D; timeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException &#123;</span><br><span class="line">        &#x2F;&#x2F; do the actual work</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您也可以使用 job data map 中的所有其他 properties。</p>
<blockquote>
<p>通过使用<code>name</code>和<code>group</code> properties，您可以分别修改 job 的 name 和 group。默认情况下，job 的 name 与<code>JobDetailFactoryBean</code>的 bean name 匹配(上面的 example 中的<code>exampleJob</code>)。</p>
</blockquote>
<h4 id="7-5-2-使用-MethodInvokingJobDetailFactoryBean"><a href="#7-5-2-使用-MethodInvokingJobDetailFactoryBean" class="headerlink" title="7.5.2. 使用 MethodInvokingJobDetailFactoryBean"></a>7.5.2. 使用 MethodInvokingJobDetailFactoryBean</h4><p>通常，您只需要在特定的 object 上调用方法。通过使用<code>MethodInvokingJobDetailFactoryBean</code>，您可以完成此操作，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetObject&quot; ref&#x3D;&quot;exampleBusinessObject&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetMethod&quot; value&#x3D;&quot;doIt&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 导致在<code>exampleBusinessObject</code>方法上调用<code>doIt</code>方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ExampleBusinessObject &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; properties and collaborators</span><br><span class="line"></span><br><span class="line">    public void doIt() &#123;</span><br><span class="line">        &#x2F;&#x2F; do the actual work</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;exampleBusinessObject&quot; class&#x3D;&quot;examples.ExampleBusinessObject&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>通过使用<code>MethodInvokingJobDetailFactoryBean</code>，您无需创建仅调用方法的 one-line 作业。您只需要创建实际业务 object 并连接详细信息 object。</p>
<p>默认情况下，Quartz Jobs 是 stateless，导致作业可能互相干扰。如果为同一个<code>JobDetail</code>指定了两个触发器，则可能在第一个 job 完成之前，第二个触发器启动。如果<code>JobDetail</code> classes 实现<code>Stateful</code>接口，则不会发生这种情况。第二个 job 在第一个 job 完成之前没有启动。要使<code>MethodInvokingJobDetailFactoryBean</code>得到的作业为 non-concurrent，请将<code>concurrent</code> flag 设置为<code>false</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jobDetail&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetObject&quot; ref&#x3D;&quot;exampleBusinessObject&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;targetMethod&quot; value&#x3D;&quot;doIt&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;concurrent&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，作业将以并发方式运行。</p>
</blockquote>
<h4 id="7-5-3-使用触发器和-SchedulerFactoryBean-连接作业"><a href="#7-5-3-使用触发器和-SchedulerFactoryBean-连接作业" class="headerlink" title="7.5.3. 使用触发器和 SchedulerFactoryBean 连接作业"></a>7.5.3. 使用触发器和 SchedulerFactoryBean 连接作业</h4><p>我们创建了 job 细节和工作。我们还回顾了 easy bean，它允许您在特定的 object 上调用方法。当然，我们仍然需要自己安排工作。这是通过使用触发器和<code>SchedulerFactoryBean</code>来完成的。 Quartz 中有几个触发器，Spring 提供两个 Quartz <code>FactoryBean</code> implementations，默认方便：<code>CronTriggerFactoryBean</code>和<code>SimpleTriggerFactoryBean</code>。</p>
<p>需要安排触发器。 Spring 提供<code>SchedulerFactoryBean</code>，公开要设置为 properties 的触发器。 <code>SchedulerFactoryBean</code>使用这些触发器安排实际作业。</p>
<p>以下列表同时使用<code>SimpleTriggerFactoryBean</code>和<code>CronTriggerFactoryBean</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simpleTrigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;!-- see the example of method invoking job above --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;jobDetail&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- 10 seconds --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;startDelay&quot; value&#x3D;&quot;10000&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- repeat every 50 seconds --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;repeatInterval&quot; value&#x3D;&quot;50000&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;cronTrigger&quot; class&#x3D;&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jobDetail&quot; ref&#x3D;&quot;exampleJob&quot;&#x2F;&gt;</span><br><span class="line">    &lt;!-- run every morning at 6 AM --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cronExpression&quot; value&#x3D;&quot;0 0 6 * * ?&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 设置了两个触发器，一个是每 50 秒运行一次，启动延迟为 10 秒，每天早上 6 点运行一次。要完成所有操作，我们需要设置<code>SchedulerFactoryBean</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;triggers&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;cronTrigger&quot;&#x2F;&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;simpleTrigger&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p><code>SchedulerFactoryBean</code>可以使用更多 properties，例如 job 详细信息使用的日历，properties 自定义 Quartz 等等。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html">SchedulerFactoryBean 负责</a> javadoc。</p>
<h2 id="8-缓存抽象"><a href="#8-缓存抽象" class="headerlink" title="8.缓存抽象"></a>8.缓存抽象</h2><p>从 version 3.1 开始，Spring Framework 支持透明地向现有的 Spring application 添加缓存。与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction">交易</a>支持类似，缓存抽象允许一致使用各种缓存解决方案，而对 code 的影响最小。</p>
<p>从 Spring 4.1 开始，在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-jsr-107">JSR-107 注释</a>和更多自定义选项的支持下，缓存抽象得到了显着改进。</p>
<h3 id="8-1-了解缓存抽象"><a href="#8-1-了解缓存抽象" class="headerlink" title="8.1. 了解缓存抽象"></a>8.1. 了解缓存抽象</h3><p>缓存与缓冲区</p>
<p>术语“缓冲区”和“缓存”倾向于可互换使用。但请注意，它们代表不同的东西。传统上，缓冲区用作快速和慢速实体之间数据的中间临时 store。由于一方必须等待另一方(这会影响 performance)，缓冲区通过允许整个数据块一次移动而不是小块来缓解这种情况。数据仅从缓冲区写入和读取一次。此外，缓冲区对于至少知道它的一方是可见的。</p>
<p>另一方面，高速缓存根据定义是隐藏的，并且任何一方都不知道发生了高速缓存。它还改善了 performance，但是通过快速方式多次读取相同的数据来实现这一点。</p>
<p>您可以找到缓冲区和缓存<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cache_(computing">这里</a>#The_difference_between_buffer_and_cache)之间差异的进一步说明。</p>
<p>缓存抽象的核心是将缓存应用于 Java 方法，从而根据缓存中可用的信息减少执行次数。也就是说，每个 time 调用一个目标方法，抽象应用一个缓存行为，检查该方法是否已经为给定的 arguments 执行。如果已执行，则返回缓存的结果，而不必执行实际方法。如果该方法尚未执行，则执行该方法，并将结果缓存并返回给用户，以便在调用该方法的下一个 time 时，返回缓存的结果。这样，对于给定的一组参数，昂贵的方法(无论是 CPU-或 IO-bound)只能执行一次，并且重用结果而不必再次实际执行该方法。缓存逻辑是透明应用的，不会对调用者造成任何干扰。</p>
<blockquote>
<p>此方法仅适用于保证为给定输入(或 arguments)返回相同输出(结果)的方法，无论它执行多少次。</p>
</blockquote>
<p>缓存抽象提供其他 cache-related 操作，例如更新缓存内容或删除一个或所有条目的能力。如果缓存处理在 application 过程中可能发生变化的数据，这些非常有用。</p>
<p>与 Spring Framework 中的其他服务一样，缓存服务是抽象(不是缓存实现)，并且需要使用实际存储来存储缓存数据 - 也就是说，抽象使您无需编写缓存逻辑，但是不提供实际数据 store。这种抽象由<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现。</p>
<p>Spring 提供了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-store-configuration">一些实现</a>的抽象：基于 JDK <code>java.util.concurrent.ConcurrentMap</code>的缓存，<a target="_blank" rel="noopener" href="http://ehcache.org/">Ehcache 2.x</a>，Gemfire 缓存，<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki">咖啡因</a>和 JSR-107 兼容缓存(例如 Ehcache 3.x)。有关插入其他缓存存储和提供程序的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-plug">Plugging-in 不同的 Back-end 缓存</a>。</p>
<blockquote>
<p>缓存抽象对 multi-threaded 和 multi-process 环境没有特殊处理，因为 features 由 cache implementation 处理。 。</p>
</blockquote>
<p>如果您有 multi-process 环境(即，在多个节点上部署了一个 application)，则需要相应地配置缓存提供程序。根据您的使用情况，几个节点上的相同数据的副本就足够了。但是，如果在 application 过程中更改数据，则可能需要启用其他传播机制。</p>
<p>缓存特定 item 直接等效于程序化缓存交互中发现的典型 get-if-not-found-then - proceed-and-put-eventually code 块。没有应用锁，并且多个线程可能会尝试同时加载相同的 item。驱逐也是如此。如果多个线程试图同时更新或逐出数据，则可以使用陈旧数据。某些缓存提供程序在该区域中提供高级 features。有关更多详细信息，请参阅缓存提供程序的文档。</p>
<p>要使用缓存抽象，您需要注意两个方面：</p>
<ul>
<li>缓存声明：确定需要缓存的方法及其 policy。</li>
<li>高速缓存 configuration：存储数据并从中读取数据的后备高速缓存。</li>
</ul>
<h3 id="8-2-声明式-Annotation-based-缓存"><a href="#8-2-声明式-Annotation-based-缓存" class="headerlink" title="8.2. 声明式 Annotation-based 缓存"></a>8.2. 声明式 Annotation-based 缓存</h3><p>对于缓存声明，Spring 的缓存抽象提供了一组 Java annotations：</p>
<ul>
<li><code>@Cacheable</code>：触发缓存填充。</li>
<li><code>@CacheEvict</code>：触发缓存逐出。</li>
<li><code>@CachePut</code>：更新缓存而不会干扰方法执行。</li>
<li><code>@Caching</code>：重新组合要在方法上应用的多个缓存操作。</li>
<li><code>@CacheConfig</code>：在 class-level 分享一些 common cache-related 设置。</li>
</ul>
<h4 id="8-2-1-Cacheable-Annotation"><a href="#8-2-1-Cacheable-Annotation" class="headerlink" title="8.2.1. @Cacheable Annotation"></a>8.2.1. @Cacheable Annotation</h4><p>正如 name 所暗示的那样，您可以使用<code>@Cacheable</code>来划分可缓存的方法 - 即，将结果存储在缓存中的方法，以便在后续调用(具有相同的 arguments)时，返回缓存中的 value 而不必须实际执行该方法。在最简单的形式中，annotation 声明需要与带注释的方法关联的缓存的 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(&quot;books&quot;)</span><br><span class="line">public Book findBook(ISBN isbn) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的代码段中，<code>findBook</code>方法与名为<code>books</code>的缓存关联。调用该方法的每个 time 时，都会检查缓存以查看调用是否已经执行且不必重复。虽然在大多数情况下，只声明了一个缓存，但 annotation 允许指定多个名称，以便使用多个缓存。在这种情况下，在执行方法之前检查每个缓存 - 如果至少有一个缓存被命中，则返回关联的 value。</p>
<blockquote>
<p>所有其他不包含 value 的高速缓存也会更新，即使实际上没有执行高速缓存的方法。</p>
</blockquote>
<p>以下 example 在<code>findBook</code>方法上使用<code>@Cacheable</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(&#123;&quot;books&quot;, &quot;isbns&quot;&#125;)</span><br><span class="line">public Book findBook(ISBN isbn) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h5 id="默认-Key-Generation"><a href="#默认-Key-Generation" class="headerlink" title="默认 Key Generation"></a>默认 Key Generation</h5><p>由于高速缓存本质上是 key-value stores，因此需要将每个高速缓存方法的调用转换为适合高速缓存访问的 key。缓存抽象使用基于以下算法的简单<code>KeyGenerator</code>：</p>
<ul>
<li>如果没有给出参数，return <code>SimpleKey.EMPTY</code>。</li>
<li>如果只给出一个参数，则 return 该实例。</li>
<li>如果给出了更多的参数，则 return <code>SimpleKey</code>包含所有参数。</li>
</ul>
<p>这种方法适用于大多数 use-cases，因为 long 因为参数具有自然键并实现有效的<code>hashCode()</code>和<code>equals()</code>方法。如果不是这种情况，则需要更改策略。</p>
<p>要提供不同的默认 key generator，需要实现<code>org.springframework.cache.interceptor.KeyGenerator</code>接口。</p>
<blockquote>
<p>随着 Spring 4.0 的发布，默认的 key 生成策略发生了变化。早期版本的 Spring 使用了 key 生成策略，对于多个 key 参数，只考虑<code>hashCode()</code>参数而不是<code>equals()</code>。这可能会导致意外的 key 碰撞(请参阅背景的<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR-10237">SPR-10237</a>)。新的<code>SimpleKeyGenerator</code>使用复合 key 来表示这种情况。</p>
</blockquote>
<p>如果要继续使用以前的 key 策略，可以配置已弃用的<code>org.springframework.cache.interceptor.DefaultKeyGenerator</code> class 或创建自定义 hash-based <code>KeyGenerator</code> implementation。</p>
<h5 id="自定义-Key-Generation-声明"><a href="#自定义-Key-Generation-声明" class="headerlink" title="自定义 Key Generation 声明"></a>自定义 Key Generation 声明</h5><p>由于缓存是通用的，因此目标方法很可能具有各种签名，这些签名无法轻松映射到缓存结构之上。当目标方法具有多个 arguments 时，这往往变得明显，其中只有一些适合于缓存(而 rest 仅由方法逻辑使用)。考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(&quot;books&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<p>乍一看，虽然两个<code>boolean</code> arguments 影响了书的发现方式，但它们对缓存没有用处。如果两个中只有一个重要而另一个不重要怎么办？</p>
<p>对于这种情况，<code>@Cacheable</code> annotation 允许您指定 key 如何通过其<code>key</code>属性生成。您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions">规划环境地政司</a>来选择感兴趣的 arguments(或它们的嵌套 properties)，执行操作，甚至调用任意方法，而无需编写任何 code 或实现任何接口。这是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-annotations-cacheable-default-key">默认 generator</a>的推荐方法，因为随着 code 基数的增长，签名在签名方面往往会有很大不同。虽然默认策略可能适用于某些方法，但它很少适用于所有方法。</p>
<p>以下示例是各种 SpEL 声明(如果您不熟悉 SpEL，请自己帮忙并阅读<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions">Spring 表达语言</a>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;#isbn&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br><span class="line"></span><br><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;#isbn.rawNumber&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br><span class="line"></span><br><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;T(someType).hash(#isbn)&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<p>前面的片段显示了选择某个参数，其中一个 properties，甚至是一个任意(静态)方法是多么容易。</p>
<p>如果负责生成 key 的算法太具体或者需要共享，则可以在操作上定义自定义<code>keyGenerator</code>。为此，请指定要使用的<code>KeyGenerator</code> bean implementation 的 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, keyGenerator&#x3D;&quot;myKeyGenerator&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>key</code>和<code>keyGenerator</code>参数是互斥的，并且指定两者的操作都会导致 exception。</p>
</blockquote>
<h5 id="默认缓存分辨率"><a href="#默认缓存分辨率" class="headerlink" title="默认缓存分辨率"></a>默认缓存分辨率</h5><p>缓存抽象使用一个简单的<code>CacheResolver</code>，它使用配置的<code>CacheManager</code>检索操作 level 中定义的缓存。</p>
<p>要提供不同的默认缓存解析程序，需要实现<code>org.springframework.cache.interceptor.CacheResolver</code>接口。</p>
<h5 id="自定义缓存分辨率"><a href="#自定义缓存分辨率" class="headerlink" title="自定义缓存分辨率"></a>自定义缓存分辨率</h5><p>默认缓存分辨率非常适合使用单个<code>CacheManager</code>且没有复杂缓存分辨率要求的 applications。</p>
<p>对于适用于多个缓存 managers 的 applications，您可以设置<code>cacheManager</code>用于每个操作，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, cacheManager&#x3D;&quot;anotherCacheManager&quot;) (1)</span><br><span class="line">public Book findBook(ISBN isbn) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定<code>anotherCacheManager</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>您也可以以类似于替换<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-annotations-cacheable-key">key 代</a>的方式完全替换<code>CacheResolver</code>。为每个缓存操作请求解析，让 implementation 实际上解析基于 runtime arguments 使用的缓存。以下 example 显示了如何指定<code>CacheResolver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheResolver&#x3D;&quot;runtimeCacheResolver&quot;) (1)</span><br><span class="line">public Book findBook(ISBN isbn) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定<code>CacheResolver</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>从 Spring 4.1 开始，cache annotations 的<code>value</code>属性不再是必需的，因为无论 annotation 的内容如何，<code>CacheResolver</code>都可以提供此特定信息。</p>
</blockquote>
<p>与<code>key</code>和<code>keyGenerator</code>类似，<code>cacheManager</code>和<code>cacheResolver</code>参数是互斥的，指定两者的操作都会导致 exception。作为自定义<code>CacheManager</code>被<code>CacheResolver</code> implementation 忽略。这可能不是你所期望的。</p>
<h5 id="同步缓存"><a href="#同步缓存" class="headerlink" title="同步缓存"></a>同步缓存</h5><p>在 multi-threaded 环境中，可能会为同一参数同时调用某些操作(通常在启动时)。默认情况下，缓存抽象不会锁定任何内容，并且可能会多次计算相同的 value，从而无法实现缓存。</p>
<p>对于这些特定情况，您可以使用<code>sync</code>属性来指示底层缓存提供程序在计算 value 时锁定缓存条目。因此，只有一个线程忙于计算 value，而其他线程则被阻塞，直到缓存中的条目更新为止。以下 example 显示了如何使用<code>sync</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;foos&quot;, sync&#x3D;true) (1)</span><br><span class="line">public Foo executeExpensiveOperation(String id) &#123;...&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>sync</code>属性。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>这是一个可选的 feature，您最喜欢的缓存 library 可能不支持它。核心 framework 提供的所有<code>CacheManager</code> _implement 都支持它。有关更多详细信息，请参阅缓存提供程序的文档。</p>
</blockquote>
<h5 id="条件缓存"><a href="#条件缓存" class="headerlink" title="条件缓存"></a>条件缓存</h5><p>有时，方法可能不适合缓存所有 time(对于 example，它可能取决于给定的 arguments)。 cache annotations 通过<code>condition</code>参数支持此类功能，该参数采用<code>SpEL</code>表达式，该表达式被评估为<code>true</code>或<code>false</code>。如果<code>true</code>，则缓存该方法。如果不是，则其行为就好像该方法未被缓存(即，无论缓存中的值是什么，或者使用了哪些 arguments，该方法每 time 执行一次)。对于 example，仅当参数<code>name</code>的长度小于 32 时，才会缓存以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;book&quot;, condition&#x3D;&quot;#name.length() &lt; 32&quot;) (1)</span><br><span class="line">public Book findBook(String name)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在<code>@Cacheable</code>上设置条件。</td>
</tr>
</tbody>
</table>
</div>
<p>除了<code>condition</code>参数之外，您还可以使用<code>unless</code>参数来否决向缓存添加 value。与<code>condition</code>不同，<code>unless</code>表达式在调用方法后进行计算。要扩展上一个 example，也许我们只想缓存平装书，如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;book&quot;, condition&#x3D;&quot;#name.length() &lt; 32&quot;, unless&#x3D;&quot;#result.hardback&quot;) (1)</span><br><span class="line">public Book findBook(String name)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>unless</code>属性来阻止精装本。</td>
</tr>
</tbody>
</table>
</div>
<p>高速缓存抽象支持<code>java.util.Optional</code>，仅当它存在时才使用其内容作为高速缓存的 value。 <code>#result</code>始终引用业务实体，从不支持 wrapper，因此可以按如下方式重写上一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;book&quot;, condition&#x3D;&quot;#name.length() &lt; 32&quot;, unless&#x3D;&quot;#result?.hardback&quot;)</span><br><span class="line">public Optional&lt;Book&gt; findBook(String name)</span><br></pre></td></tr></table></figure>
<p>请注意，<code>result</code>仍然是指<code>Book</code>而不是<code>Optional</code>。因为它可能是<code>null</code>，我们应该使用安全导航 operator。</p>
<h5 id="可用缓存-SpEL-Evaluation-Context"><a href="#可用缓存-SpEL-Evaluation-Context" class="headerlink" title="可用缓存 SpEL Evaluation Context"></a>可用缓存 SpEL Evaluation Context</h5><p>每个<code>SpEL</code>表达式都针对专用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-language-ref">context</a>进行求值。除 built-in 参数外，framework 还提供专用的 caching-related 元数据，例如参数名称。以下 table 描述了 context 可用的项目，以便您可以将它们用于 key 和条件计算：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>地点</th>
<th>描述</th>
<th>例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>methodName</code></td>
<td>Root object</td>
<td>要调用的方法的 name</td>
<td><code>#root.methodName</code></td>
</tr>
<tr>
<td><code>method</code></td>
<td>Root object</td>
<td>正在调用的方法</td>
<td><code>#root.method.name</code></td>
</tr>
<tr>
<td><code>target</code></td>
<td>Root object</td>
<td>正在调用目标 object</td>
<td><code>#root.target</code></td>
</tr>
<tr>
<td><code>targetClass</code></td>
<td>Root object</td>
<td>正在调用的目标的 class</td>
<td><code>#root.targetClass</code></td>
</tr>
<tr>
<td><code>args</code></td>
<td>Root object</td>
<td>arguments(as array)用于调用目标</td>
<td><code>#root.args[0]</code></td>
</tr>
<tr>
<td><code>caches</code></td>
<td>Root object</td>
<td>执行当前方法的高速缓存的集合</td>
<td><code>#root.caches[0].name</code></td>
</tr>
<tr>
<td>参数 name</td>
<td>Evaluation context</td>
<td>任何方法 arguments 的 Name。如果名称不可用(可能由于没有调试信息)，参数名称也可以在<code>#a&lt;#arg&gt;</code>下获得，其中<code>#arg</code>代表参数索引(从<code>0</code>开始)。</td>
<td><code>#iban</code>或<code>#a0</code>(您也可以使用<code>#p0</code>或<code>#p&lt;#arg&gt;</code>表示法作为别名)。</td>
</tr>
<tr>
<td><code>result</code></td>
<td>Evaluation context</td>
<td>方法调用的结果(要缓存的 value)。仅在<code>unless</code>表达式，<code>cache put</code>表达式(用于计算<code>key</code>)或<code>cache evict</code>表达式(当<code>beforeInvocation</code>为<code>false</code>时)中可用。对于受支持的包装器(例如<code>Optional</code>)，<code>#result</code>指的是实际的 object，而不是 wrapper。</td>
<td><code>#result</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="8-2-2-CachePut-Annotation"><a href="#8-2-2-CachePut-Annotation" class="headerlink" title="8.2.2. @CachePut Annotation"></a>8.2.2. @CachePut Annotation</h4><p>当需要更新缓存而不干扰方法执行时，可以使用<code>@CachePut</code> annotation。也就是说，始终执行该方法，并将其结果放入缓存中(根据<code>@CachePut</code>选项)。它支持与<code>@Cacheable</code>相同的选项，应该用于缓存填充而不是方法流优化。以下 example 使用<code>@CachePut</code> annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CachePut(cacheNames&#x3D;&quot;book&quot;, key&#x3D;&quot;#isbn&quot;)</span><br><span class="line">public Book updateBook(ISBN isbn, BookDescriptor descriptor)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通常强烈建议不要在同一方法上使用<code>@CachePut</code>和<code>@Cacheable</code> 注释，因为它们具有不同的行为。虽然后者导致通过使用缓存跳过方法执行，但前者强制执行 order 以执行缓存更新。这会导致意外行为，并且由于特定 corner-cases 的 exception(例如 annotations 具有将它们彼此排除的条件)，应该避免这样的声明。另请注意，此类条件不应依赖于结果 object(即<code>#result</code>变量)，因为这些条件已经过验证 up-front 以确认排除。</p>
</blockquote>
<h4 id="8-2-3-CacheEvict-annotation"><a href="#8-2-3-CacheEvict-annotation" class="headerlink" title="8.2.3. @CacheEvict annotation"></a>8.2.3. @CacheEvict annotation</h4><p>缓存抽象不仅允许缓存 store 的填充，还允许驱逐。此 process 对于从缓存中删除过时或未使用的数据非常有用。与<code>@Cacheable</code>相反，<code>@CacheEvict</code>划分执行缓存逐出的方法(即，用作从缓存中删除数据的触发器的方法)。与其兄弟类似，<code>@CacheEvict</code>需要指定受操作影响的一个或多个缓存，允许自定义缓存和 key 解析或指定条件，并 features 一个额外参数(<code>allEntries</code>)，指示 cache-wide 驱逐是否需要执行而不仅仅是一个条目驱逐(基于 key)。以下 example 清除<code>books</code>缓存中的所有条目：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CacheEvict(cacheNames&#x3D;&quot;books&quot;, allEntries&#x3D;true) (1)</span><br><span class="line">public void loadBooks(InputStream batch)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>allEntries</code>属性驱逐缓存中的所有条目。</td>
</tr>
</tbody>
</table>
</div>
<p>当需要清除整个缓存区域时，此选项会派上用场。而不是驱逐每个条目(这将花费 long time，因为它效率低)，所有条目在一个操作中被移除，如前面的 example 所示。请注意，framework 忽略了此方案中指定的任何 key，因为它不适用(整个缓存被驱逐，而不仅仅是一个条目)。</p>
<p>您还可以通过使用<code>beforeInvocation</code>属性指示在(默认)之后或方法执行之前是否应该进行逐出。前者提供与 annotations 的 rest 相同的语义：一旦方法成功完成，就会执行缓存上的操作(在本例中为驱逐)。如果方法未执行(因为它可能被缓存)或抛出 exception，则不会发生逐出。后者(<code>beforeInvocation=true</code>)导致驱逐始终在调用方法之前发生。这在驱逐不需要与方法结果相关联的情况下非常有用。</p>
<p>请注意<code>void</code>方法可以与<code>@CacheEvict</code>一起使用 - 因为方法充当触发器，return 值被忽略(因为它们不与缓存交互)。 <code>@Cacheable</code>不是这种情况，它将数据添加或更新到缓存中，因此需要一个结果。</p>
<h4 id="8-2-4-Caching-Annotation"><a href="#8-2-4-Caching-Annotation" class="headerlink" title="8.2.4. @Caching Annotation"></a>8.2.4. @Caching Annotation</h4><p>有时，需要指定多个相同类型的注释(例如<code>@CacheEvict</code>或<code>@CachePut</code>) - 例如，因为条件或 key 表达式在不同的缓存之间是不同的。 <code>@Caching</code>允许在同一方法上使用多个嵌套的<code>@Cacheable</code>，<code>@CachePut</code>和<code>@CacheEvict</code> 注释。以下 example 使用两个<code>@CacheEvict</code> 注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Caching(evict &#x3D; &#123; @CacheEvict(&quot;primary&quot;), @CacheEvict(cacheNames&#x3D;&quot;secondary&quot;, key&#x3D;&quot;#p0&quot;) &#125;)</span><br><span class="line">public Book importBooks(String deposit, Date date)</span><br></pre></td></tr></table></figure>
<h4 id="8-2-5-CacheConfig-annotation"><a href="#8-2-5-CacheConfig-annotation" class="headerlink" title="8.2.5. @CacheConfig annotation"></a>8.2.5. @CacheConfig annotation</h4><p>到目前为止，我们已经看到缓存操作提供了许多自定义选项，您可以为每个操作设置这些选项。但是，如果某些自定义选项适用于 class 的所有操作，则可能需要配置一些自定义选项。例如，指定用于 class 的每个高速缓存操作的高速缓存的 name 可以由单个 class-level 定义替换。这是<code>@CacheConfig</code>发挥作用的地方。以下示例使用<code>@CacheConfig</code>来设置缓存的 name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@CacheConfig(&quot;books&quot;) (1)</span><br><span class="line">public class BookRepositoryImpl implements BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Cacheable</span><br><span class="line">    public Book findBook(ISBN isbn) &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@CacheConfig</code>设置缓存的 name。</td>
</tr>
</tbody>
</table>
</div>
<p><code>@CacheConfig</code>是注释，允许共享缓存名称，自定义<code>KeyGenerator</code>，自定义<code>CacheManager</code>和自定义<code>CacheResolver</code>。将此 annotation 放在 class 上不会打开任何缓存操作。</p>
<p>operation-level 自定义始终会覆盖<code>@CacheConfig</code>上的自定义集。因此，这为每个缓存操作提供了三个级别的自定义：</p>
<ul>
<li>全局配置，可用于<code>CacheManager</code>，<code>KeyGenerator</code>。</li>
<li>在 class level 中，使用<code>@CacheConfig</code>。</li>
<li>在 level 操作。</li>
</ul>
<h4 id="8-2-6-启用缓存注释"><a href="#8-2-6-启用缓存注释" class="headerlink" title="8.2.6. 启用缓存注释"></a>8.2.6. 启用缓存注释</h4><p>重要的是要注意，尽管声明缓存注释不会自动触发它们的操作 - 就像 Spring 中的许多内容一样，feature 必须以声明方式启用(这意味着如果您怀疑缓存是责任，您可以通过删除来禁用它只有一个 configuration line 而不是 code 中的所有 annotations。</p>
<p>要启用缓存注释，请将注释<code>@EnableCaching</code>添加到<code>@Configuration</code> classes 中的一个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableCaching</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，对于 XML configuration，您可以使用<code>cache:annotation-driven</code>元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:cache&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;cache&#x2F;spring-cache.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;cache:annotation-driven&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><code>cache:annotation-driven</code>元素和<code>@EnableCaching</code> annotation 都允许您指定影响缓存行为通过 AOP 添加到 application 的方式的各种选项。 configuration 有意与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#tx-annotation-driven-settings">@Transactional</a>类似。</p>
<blockquote>
<p>处理缓存注释的默认建议模式是<code>proxy</code>，它允许仅通过代理拦截 calls。同一 class 中的本地 calls 不能以这种方式截获。对于更高级的拦截模式，请考虑结合 compile-time 或 load-time 编织切换到<code>aspectj</code>模式。</p>
<p>有关实现<code>CachingConfigurer</code>所需的高级自定义(使用 Java configuration)的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">javadoc</a>。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>XML 属性</th>
<th>Annotation 属性</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cache-manager</code></td>
<td>N/A(参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">CachingConfigurer</a> javadoc)</td>
<td><code>cacheManager</code></td>
<td>要使用的缓存 manager 的 name。使用此缓存 manager 在后台初始化默认<code>CacheResolver</code>(如果未设置，则为<code>cacheManager</code>)。有关缓存分辨率的更多 fine-grained 管理，请考虑设置“cache-resolver”属性。</td>
</tr>
<tr>
<td><code>cache-resolver</code></td>
<td>N/A(参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">CachingConfigurer</a> javadoc)</td>
<td>A <code>SimpleCacheResolver</code>使用配置的<code>cacheManager</code>。</td>
<td>要用于解析后备高速缓存的 CacheResolver 的 bean name。此属性不是必需的，只需要指定为’cache-manager’属性的替代。</td>
</tr>
<tr>
<td><code>key-generator</code></td>
<td>N/A(参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">CachingConfigurer</a> javadoc)</td>
<td><code>SimpleKeyGenerator</code></td>
<td>要使用的自定义 key generator 的名称。</td>
</tr>
<tr>
<td><code>error-handler</code></td>
<td>N/A(参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">CachingConfigurer</a> javadoc)</td>
<td><code>SimpleCacheErrorHandler</code></td>
<td>要使用的自定义缓存错误处理程序的 name。默认情况下，在缓存相关操作期间抛出的任何 exception 都会返回到 client。</td>
</tr>
<tr>
<td><code>mode</code></td>
<td><code>mode</code></td>
<td><code>proxy</code></td>
<td>默认模式(<code>proxy</code>)通过使用 Spring 的 AOP framework 处理带注释的 beans 代理(遵循代理语义，如前所述，仅适用于通过代理进入的方法 calls)。替代模式(<code>aspectj</code>)使用 Spring 的 AspectJ 缓存 aspect 编译受影响的 classes，修改目标 class byte code 以应用于任何类型的方法调用。 AspectJ 编织需要在 classpath 中启用<code>spring-aspects.jar</code>以及启用 load-time 编织(或 compile-time 编织)。 (有关如何设置 load-time weaving.)的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw-spring">Spring configuration</a></td>
</tr>
<tr>
<td><code>proxy-target-class</code></td>
<td><code>proxyTargetClass</code></td>
<td><code>false</code></td>
<td>仅适用于代理模式。控制为使用<code>@Cacheable</code>或<code>@CacheEvict</code> 注释注释的 class 创建的缓存代理类型。如果<code>proxy-target-class</code>属性设置为<code>true</code>，则会创建 class-based 个代理。如果<code>proxy-target-class</code>是<code>false</code>或者省略了该属性，则会创建标准 JDK interface-based 代理。 (有关不同代理人的详细检查，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-proxying">代理机制</a> types.)</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>order</code></td>
<td>Ordered.LOWEST_PRECEDENCE</td>
<td>定义应用于使用<code>@Cacheable</code>或<code>@CacheEvict</code>注释的 beans 的缓存建议的 order。 (有关与排序 AOP 建议相关的规则的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-ataspectj-advice-ordering">建议订购</a> .)未指定 ordering 意味着 AOP 子系统确定建议的 order。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>&lt;cache:annotation-driven/&gt;</code>仅在定义它的同一 application context 中的 beans 上查找<code>@Cacheable/@CachePut/@CacheEvict/@Caching</code>。这意味着，如果您将<code>&lt;cache:annotation-driven/&gt;</code>放在<code>WebApplicationContext</code>中<code>DispatcherServlet</code>，它只会在您的控制器中检查 beans，而不是您的服务。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet">MVC 部分</a>。</p>
</blockquote>
<p>方法可见性和缓存注释</p>
<p>使用代理时，应将 cache annotations 仅应用于具有公共可见性的方法。如果使用这些注释注释 protected，private 或 package-visible 方法，则不会引发错误，但带注释的方法不会显示已配置的缓存设置。如果需要注释 non-public 方法，请考虑使用 AspectJ(参见本节的 rest)，因为它会更改字节码本身。</p>
<blockquote>
<p>Spring 建议您只使用<code>@Cache*</code> annotation 注释具体的 classes(以及具体 classes 的方法)，而不是注释接口。您当然可以将<code>@Cache*</code> annotation 放在接口(或接口方法)上，但这只能在您使用 interface-based 代理时按预期工作。 Java annotations 不是从接口继承的事实意味着，如果使用 class-based 代理(<code>proxy-target-class=&quot;true&quot;</code>)或 weaving-based aspect(<code>mode=&quot;aspectj&quot;</code>)，代理和编织基础结构无法识别缓存设置，并且 object 不包含在缓存代理，这将是非常糟糕的。</p>
<p>在代理模式(默认)下，只拦截通过代理进入的外部方法 calls。这意味着 self-invocation(实际上，目标 object 中的一个方法 calls 目标 object 的另一个方法)在运行时不会导致实际的缓存，即使被调用的方法用<code>@Cacheable</code>标记。在这种情况下，请考虑使用<code>aspectj</code>模式。此外，必须完全初始化代理以提供预期的行为，因此您不应该在初始化 code(即<code>@PostConstruct</code>)中依赖此 feature。</p>
</blockquote>
<h4 id="8-2-7-使用自定义注释"><a href="#8-2-7-使用自定义注释" class="headerlink" title="8.2.7. 使用自定义注释"></a>8.2.7. 使用自定义注释</h4><p>自定义 annotation 和 AspectJ</p>
<p>此 feature 仅适用于 proxy-based 方法，但可以通过使用 AspectJ 进行一些额外的工作。</p>
<p><code>spring-aspects</code>模块仅为标准 annotations 定义 aspect。如果您已经定义了自己的注释，则还需要为这些注释定义 aspect。检查<code>AnnotationCacheAspect</code>是否为 example。</p>
<p>缓存抽象允许您使用自己的注释来标识触发缓存填充或驱逐的方法。这作为模板机制非常方便，因为它消除了复制缓存注释声明的需要，如果指定了 key 或条件或者 code 基础中不允许外部导入(<code>org.springframework</code>)，这尤其有用。与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-stereotype-annotations">铅板</a> annotations 的 rest 类似，您可以使用<code>@Cacheable</code>，<code>@CachePut</code>，<code>@CacheEvict</code>和<code>@CacheConfig</code>作为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-meta-annotations">meta-annotations</a>(即可以注释其他注释的注释)。在下面的示例中，我们用自己的自定义 annotation 替换 common <code>@Cacheable</code>声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;#isbn&quot;)</span><br><span class="line">public @interface SlowService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，我们定义了自己的<code>SlowService</code> annotation，它本身用<code>@Cacheable</code>注释。现在我们可以替换以下 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;#isbn&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了 custom annotation，我们可以使用它来替换前面的 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@SlowService</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<p>即使<code>@SlowService</code>不是 Spring annotation，容器也会在运行时自动获取其声明并理解其含义。请注意，如上所述<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-annotation-enable">前</a>，需要启用 annotation-driven 行为。</p>
<h3 id="8-3-JCache-JSR-107-Annotations"><a href="#8-3-JCache-JSR-107-Annotations" class="headerlink" title="8.3. JCache(JSR-107)Annotations"></a>8.3. JCache(JSR-107)Annotations</h3><p>从 version 4.1 开始，缓存抽象完全支持 JCache 标准 annotations：<code>@CacheResult</code>，<code>@CachePut</code>，<code>@CacheRemove</code>和<code>@CacheRemoveAll</code>以及<code>@CacheDefaults</code>，<code>@CacheKey</code>和<code>@CacheValue</code>伴随。您可以使用这些注释而无需将缓存 store 迁移到 JSR-107。内部 implementation 使用 Spring 的缓存抽象，并提供符合规范的默认<code>CacheResolver</code>和<code>KeyGenerator</code> implementations。换句话说，如果您已经在使用 Spring 的缓存抽象，则可以切换到这些标准注释而无需更改缓存存储(或 configuration)。</p>
<h4 id="8-3-1-Feature-摘要"><a href="#8-3-1-Feature-摘要" class="headerlink" title="8.3.1. Feature 摘要"></a>8.3.1. Feature 摘要</h4><p>对于那些熟悉 Spring 的缓存注释的人，下面的 table 描述了 Spring annotations 和 JSR-107 对应物之间的主要区别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>弹簧</th>
<th>JSR-107</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Cacheable</code></td>
<td><code>@CacheResult</code></td>
<td>非常相似。 <code>@CacheResult</code>可以缓存特定的 exceptions 并强制执行该方法，而不管缓存的内容如何。</td>
</tr>
<tr>
<td><code>@CachePut</code></td>
<td><code>@CachePut</code></td>
<td>当 Spring 使用方法调用的结果更新缓存时，JCache 要求将其作为使用<code>@CacheValue</code>注释的参数传递。由于这种差异，JCache 允许在实际方法调用之前或之后更新缓存。</td>
</tr>
<tr>
<td><code>@CacheEvict</code></td>
<td><code>@CacheRemove</code></td>
<td>非常相似。当方法调用导致 exception 时，<code>@CacheRemove</code>支持条件驱逐。</td>
</tr>
<tr>
<td><code>@CacheEvict(allEntries=true)</code></td>
<td><code>@CacheRemoveAll</code></td>
<td>见<code>@CacheRemove</code>。</td>
</tr>
<tr>
<td><code>@CacheConfig</code></td>
<td><code>@CacheDefaults</code></td>
<td>允许您以类似的方式配置相同的概念。</td>
</tr>
</tbody>
</table>
</div>
<p>JCache 有<code>javax.cache.annotation.CacheResolver</code>的概念，它与 Spring 的<code>CacheResolver</code>接口相同，只是 JCache 只支持单个缓存。默认情况下，一个简单的 implementation 根据 annotation 上声明的 name 检索要使用的缓存。应该注意的是，如果在 annotation 上没有指定 cache name，则会自动生成默认值。有关更多信息，请参见<code>@CacheResult#cacheName()</code>的 javadoc。</p>
<p><code>CacheResolverFactory</code>实例由<code>CacheResolverFactory</code>检索。可以为每个缓存操作自定义工厂，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult(cacheNames&#x3D;&quot;books&quot;, cacheResolverFactory&#x3D;MyCacheResolverFactory.class) (1)</span><br><span class="line">public Book findBook(ISBN isbn)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>为此操作自定义工厂。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>对于所有引用的 classes，Spring 尝试找到具有给定类型的 bean。如果存在多个 match，则会创建一个新实例，并且可以使用常规 bean 生命周期回调，例如依赖项注入。</p>
</blockquote>
<p>密钥由<code>javax.cache.annotation.CacheKeyGenerator</code>生成，其作用与 Spring 的<code>KeyGenerator</code>相同。默认情况下，除非至少有一个参数使用<code>@CacheKey</code>注释，否则将考虑所有方法 arguments。这类似于 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-annotations-cacheable-key">自定义 key 生成声明</a>。例如，以下是相同的操作，一个使用 Spring 的抽象，另一个使用 JCache：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(cacheNames&#x3D;&quot;books&quot;, key&#x3D;&quot;#isbn&quot;)</span><br><span class="line">public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br><span class="line"></span><br><span class="line">@CacheResult(cacheName&#x3D;&quot;books&quot;)</span><br><span class="line">public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed)</span><br></pre></td></tr></table></figure>
<p>您还可以在操作上指定<code>CacheKeyResolver</code>，类似于指定<code>CacheResolverFactory</code>的方式。</p>
<p>JCache 可以管理带注释方法抛出的 exceptions。这可以防止更新缓存，但它也可以将 exception 缓存为失败的指示器，而不是再次调用该方法。假设如果 ISBN 的结构无效，则抛出<code>InvalidIsbnNotFoundException</code>。这是一个永久性的失败(没有用这样的参数检索书籍)。下面缓存 exception，以便进一步 calls 具有相同的无效 ISBN 直接抛出缓存的 exception 而不是再次调用该方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@CacheResult(cacheName&#x3D;&quot;books&quot;, exceptionCacheName&#x3D;&quot;failures&quot;</span><br><span class="line">            cachedExceptions &#x3D; InvalidIsbnNotFoundException.class)</span><br><span class="line">public Book findBook(ISBN isbn)</span><br></pre></td></tr></table></figure>
<h4 id="8-3-2-启用-JSR-107-支持"><a href="#8-3-2-启用-JSR-107-支持" class="headerlink" title="8.3.2. 启用 JSR-107 支持"></a>8.3.2. 启用 JSR-107 支持</h4><p>除了 Spring 的声明性 annotation 支持之外，您无需执行任何特定的操作来启用 JSR-107 支持。如果 class 路径中存在 JSR-107 API 和<code>spring-context-support</code>模块，则<code>@EnableCaching</code>和<code>cache:annotation-driven</code>元素都会自动启用 JCache 支持。</p>
<blockquote>
<p>根据您的使用情况，选择基本上是您的。您甚至可以在某些服务上使用 JSR-107 API 并在其他服务器上使用 Spring 自己的注释来混合和 match 服务。但是，如果这些服务影响相同的缓存，则应使用一致且相同的 key generation implementation。</p>
</blockquote>
<h3 id="8-4-声明式-XML-based-缓存"><a href="#8-4-声明式-XML-based-缓存" class="headerlink" title="8.4. 声明式 XML-based 缓存"></a>8.4. 声明式 XML-based 缓存</h3><p>如果 annotations 不是一个选项(可能是由于无法访问源或没有外部 code)，您可以使用 XML 进行声明性缓存。因此，您可以在外部指定目标方法和缓存指令，而不是注释缓存方法(类似于声明式 transaction management <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-first-example">忠告</a>)。上一节中的 example 可以转换为以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the service we want to make cacheable --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;bookService&quot; class&#x3D;&quot;x.y.service.DefaultBookService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- cache definitions --&gt;</span><br><span class="line">&lt;cache:advice id&#x3D;&quot;cacheAdvice&quot; cache-manager&#x3D;&quot;cacheManager&quot;&gt;</span><br><span class="line">    &lt;cache:caching cache&#x3D;&quot;books&quot;&gt;</span><br><span class="line">        &lt;cache:cacheable method&#x3D;&quot;findBook&quot; key&#x3D;&quot;#isbn&quot;&#x2F;&gt;</span><br><span class="line">        &lt;cache:cache-evict method&#x3D;&quot;loadBooks&quot; all-entries&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;cache:caching&gt;</span><br><span class="line">&lt;&#x2F;cache:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- apply the cacheable behavior to all BookService interfaces --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref&#x3D;&quot;cacheAdvice&quot; pointcut&#x3D;&quot;execution(* x.y.BookService.*(..))&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- cache manager definition omitted --&gt;</span><br></pre></td></tr></table></figure>
<p>在前面的 configuration 中，<code>bookService</code>可以缓存。要应用的缓存语义封装在<code>cache:advice</code>定义中，这会导致<code>findBooks</code>方法用于将数据放入缓存，而<code>loadBooks</code>方法用于驱逐数据。这两个定义都适用于<code>books</code>缓存。</p>
<p><code>aop:config</code>定义通过使用 AspectJ 切入点表达式将缓存建议应用于程序中的适当点(更多信息在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop">使用 Spring 进行面向对象编程</a>中可用)。在前面的 example 中，将考虑<code>BookService</code>中的所有方法，并将缓存建议应用于它们。</p>
<p>声明性 XML 缓存支持所有 annotation-based model，因此在两者之间移动应该相当容易。此外，两者都可以在同一个 application 中使用。 XML-based 方法不会触及目标 code。然而，它本质上更加冗长。当处理具有重载方法的 classes 时，识别正确的方法确实需要额外的努力，因为<code>method</code>参数不是一个好的鉴别器。在这些情况下，您可以使用 AspectJ 切入点来挑选目标方法并应用适当的缓存功能。但是，通过 XML，更容易应用包或 group 或 interface-wide 缓存(同样，由于 AspectJ 切入点)并创建 template-like 定义(正如我们在前面的 example 中通过<code>cache:definitions</code> <code>cache</code>属性定义目标缓存所做的那样)。</p>
<h3 id="8-5-配置缓存存储"><a href="#8-5-配置缓存存储" class="headerlink" title="8.5. 配置缓存存储"></a>8.5. 配置缓存存储</h3><p>缓存抽象提供了几个存储 integration 选项。要使用它们，您需要声明一个适当的<code>CacheManager</code>(一个控制和管理<code>Cache</code>实例的实体，可用于检索这些实例以进行存储)。</p>
<h4 id="8-5-1-JDK-ConcurrentMap-based-缓存"><a href="#8-5-1-JDK-ConcurrentMap-based-缓存" class="headerlink" title="8.5.1. JDK ConcurrentMap-based 缓存"></a>8.5.1. JDK ConcurrentMap-based 缓存</h4><p>JDK-based <code>Cache</code> implementation 位于<code>org.springframework.cache.concurrent</code>包下。它允许您使用<code>ConcurrentHashMap</code>作为后台<code>Cache</code> store。以下 example 显示了如何配置两个缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- simple cache manager --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.support.SimpleCacheManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;caches&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot; p:name&#x3D;&quot;default&quot;&#x2F;&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&quot; p:name&#x3D;&quot;books&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的代码片段使用<code>SimpleCacheManager</code>为名为<code>default</code>和<code>books</code>的两个嵌套<code>ConcurrentMapCache</code>实例创建<code>CacheManager</code>。请注意，名称是直接为每个缓存配置的。</p>
<p>由于缓存是由 application 创建的，因此它被绑定到其生命周期，使其适用于基本用例，测试或简单的应用程序。缓存可以很好地扩展并且非常快，但它不提供任何管理，持久性功能或逐出 contracts。</p>
<h4 id="8-5-2-Ehcache-based-缓存"><a href="#8-5-2-Ehcache-based-缓存" class="headerlink" title="8.5.2. Ehcache-based 缓存"></a>8.5.2. Ehcache-based 缓存</h4><blockquote>
<p>Ehcache 3.x 完全符合 JSR-107 标准，不需要专门的支持。</p>
</blockquote>
<p>Ehcache 2.x implementation 位于<code>org.springframework.cache.ehcache</code>包中。同样，要使用它，您需要声明适当的<code>CacheManager</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheCacheManager&quot; p:cache-manager-ref&#x3D;&quot;ehcache&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- EhCache library setup --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;ehcache&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot; p:config-location&#x3D;&quot;ehcache.xml&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>此设置引导 Spring IoC 内的 ehcache library(通过<code>ehcache</code> bean)，然后将其连接到专用的<code>CacheManager</code> implementation。请注意，从<code>ehcache.xml</code>读取整个 ehcache-specific configuration。</p>
<h4 id="8-5-3-Caffeine-Cache"><a href="#8-5-3-Caffeine-Cache" class="headerlink" title="8.5.3. Caffeine Cache"></a>8.5.3. Caffeine Cache</h4><p>Caffeine 是 Guava 缓存的 Java 8 rewrite，它的 implementation 位于<code>org.springframework.cache.caffeine</code>包中，可以访问 Caffeine 的几个 feature。</p>
<p>以下 example 配置<code>CacheManager</code>，根据需要创建缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>您还可以提供明确使用的缓存。在这种情况下，只有那些由 manager 提供。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.caffeine.CaffeineCacheManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;caches&quot;&gt;</span><br><span class="line">        &lt;set&gt;</span><br><span class="line">            &lt;value&gt;default&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;books&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>Caffeine <code>CacheManager</code>还支持自定义<code>Caffeine</code>和<code>CacheLoader</code>。有关这些内容的详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine/wiki">Caffeine 文档</a>。</p>
<h4 id="8-5-4-GemFire-based-缓存"><a href="#8-5-4-GemFire-based-缓存" class="headerlink" title="8.5.4. GemFire-based 缓存"></a>8.5.4. GemFire-based 缓存</h4><p>GemFire 是一个 memory-oriented，disk-backed，可弹性扩展，持续可用，active(具有 built-in pattern-based 订阅通知)，全局复制数据库并提供 fully-featured 边缘缓存。有关如何将 GemFire 用作<code>CacheManager</code>(及更多)的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-gemfire/docs/current/reference/html/">Spring Data GemFire reference 文档</a>。</p>
<h4 id="8-5-5-JSR-107-缓存"><a href="#8-5-5-JSR-107-缓存" class="headerlink" title="8.5.5. JSR-107 缓存"></a>8.5.5. JSR-107 缓存</h4><p>Spring 的缓存抽象也可以使用 JSR-107-compliant 缓存。 JCache implementation 位于<code>org.springframework.cache.jcache</code>包中。</p>
<p>同样，要使用它，您需要声明适当的<code>CacheManager</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.cache.jcache.JCacheCacheManager&quot;</span><br><span class="line">        p:cache-manager-ref&#x3D;&quot;jCacheManager&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- JSR-107 cache manager setup  --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;jCacheManager&quot; ...&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-6-在没有支持-Store-的情况下处理缓存"><a href="#8-5-6-在没有支持-Store-的情况下处理缓存" class="headerlink" title="8.5.6. 在没有支持 Store 的情况下处理缓存"></a>8.5.6. 在没有支持 Store 的情况下处理缓存</h4><p>有时，在切换环境或进行测试时，您可能会在没有配置实际的后备缓存的情况下进行缓存声明。由于这是一个无效的 configuration，因此在运行时抛出了 exception，因为缓存基础结构无法找到合适的 store。在这种情况下，而不是删除缓存声明(这可能证明是乏味的)，您可以连接一个不执行缓存的简单虚拟缓存 - 也就是说，它强制每隔 time 执行缓存的方法。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;cacheManager&quot; class&#x3D;&quot;org.springframework.cache.support.CompositeCacheManager&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cacheManagers&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;jdkCache&quot;&#x2F;&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;gemfireCache&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;fallbackToNoOpCache&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的<code>CompositeCacheManager</code>连接多个<code>CacheManager</code>实例，并通过<code>fallbackToNoOpCache</code> flag 为所有未由配置的缓存 managers 处理的定义添加 no-op 缓存。也就是说，<code>jdkCache</code>或<code>gemfireCache</code>(在 example 中先前配置)中找不到的每个缓存定义都由 no-op 缓存处理，该缓存不存储任何信息，导致每隔 time 执行一次目标方法。</p>
<h3 id="8-6-Plugging-in-不同的-Back-end-缓存"><a href="#8-6-Plugging-in-不同的-Back-end-缓存" class="headerlink" title="8.6. Plugging-in 不同的 Back-end 缓存"></a>8.6. Plugging-in 不同的 Back-end 缓存</h3><p>显然，有很多缓存产品可以用作支持 store。要插入它们，您需要提供<code>CacheManager</code>和<code>Cache</code> implementation，因为遗憾的是，我们无法使用可用的标准。这可能听起来比实际上更难，因为在实践中，class 往往是简单的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Adapter_pattern">适配器</a>，它将缓存抽象 framework 映射到存储 API 之上，就像<code>ehcache</code> classes 那样。大多数<code>CacheManager</code> classes 可以使用<code>org.springframework.cache.support</code>包中的 classes(例如<code>AbstractCacheManager</code>，它负责 boiler-plate code，只留下实际的映射完成)。我们希望，在 time 中，提供与 Spring 的整合的 libraries 可以填补这个小的 configuration 差距。</p>
<h3 id="8-7-如何设置-TTL-TTI-Eviction-policy-XXX-feature？"><a href="#8-7-如何设置-TTL-TTI-Eviction-policy-XXX-feature？" class="headerlink" title="8.7. 如何设置 TTL/TTI/Eviction policy/XXX feature？"></a>8.7. 如何设置 TTL/TTI/Eviction policy/XXX feature？</h3><p>直接通过缓存提供程序。缓存抽象是抽象，而不是缓存实现。您使用的解决方案可能支持各种数据 policies 和其他解决方案不支持的不同拓扑(例如，JDK <code>ConcurrentHashMap</code> - 暴露在缓存抽象中将是无用的，因为没有后备支持)。应该通过后备缓存(配置时)或通过其本机 API 直接控制此类功能。</p>
<h2 id="9-附录"><a href="#9-附录" class="headerlink" title="9.附录"></a>9.附录</h2><h3 id="9-1-XML-模式"><a href="#9-1-XML-模式" class="headerlink" title="9.1. XML 模式"></a>9.1. XML 模式</h3><p>附录的这一部分列出了与 integration 技术相关的 XML 模式。</p>
<h4 id="9-1-1-jee-Schema"><a href="#9-1-1-jee-Schema" class="headerlink" title="9.1.1. jee Schema"></a>9.1.1. jee Schema</h4><p><code>jee</code>元素处理与 Java EE(Java Enterprise Edition)configuration 相关的问题，例如查找 JNDI object 和定义 EJB references。</p>
<p>要使用<code>jee</code> schema 中的元素，您需要在 Spring XML configuration 文件的顶部添加以下前导码。以下代码段中的文本引用了正确的 schema，以便<code>jee</code>命名空间中的元素可供您使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jee&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&quot; xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jee&#x2F;spring-jee.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2494-3-gt-简单"><a href="#lt-hh-2494-3-gt-简单" class="headerlink" title="&lt; hh:// +2494+ 3 &gt;(简单)"></a>&lt; hh:// +2494+ <em>3</em> &gt;(简单)</h5><p>以下 example 显示了如何使用 JNDI 在没有<code>jee</code> schema 的情况下查找数据源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.foo.JdbcUserDao&quot;&gt;</span><br><span class="line">    &lt;!-- Spring will do the cast automatically (as usual) --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用 JNDI 使用<code>jee</code> schema 查找数据源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;dataSource&quot; jndi-name&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;com.foo.JdbcUserDao&quot;&gt;</span><br><span class="line">    &lt;!-- Spring will do the cast automatically (as usual) --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2501-3-gt-使用单-JNDI-环境设置"><a href="#lt-hh-2501-3-gt-使用单-JNDI-环境设置" class="headerlink" title="&lt; hh:// +2501+ 3 &gt;(使用单 JNDI 环境设置)"></a>&lt; hh:// +2501+ <em>3</em> &gt;(使用单 JNDI 环境设置)</h5><p>以下 example 显示了如何使用 JNDI 在没有<code>jee</code>的情况下查找环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simple&quot; class&#x3D;&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiEnvironment&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;ping&quot;&gt;pong&lt;&#x2F;prop&gt;</span><br><span class="line">        &lt;&#x2F;props&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用 JNDI 查找带有<code>jee</code>的环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;simple&quot; jndi-name&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&gt;</span><br><span class="line">    &lt;jee:environment&gt;ping&#x3D;pong&lt;&#x2F;jee:environment&gt;</span><br><span class="line">&lt;&#x2F;jee:jndi-lookup&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2508-3-gt-具有多个-JNDI-环境设置"><a href="#lt-hh-2508-3-gt-具有多个-JNDI-环境设置" class="headerlink" title="&lt; hh:// +2508+ 3 &gt;(具有多个 JNDI 环境设置)"></a>&lt; hh:// +2508+ <em>3</em> &gt;(具有多个 JNDI 环境设置)</h5><p>以下 example 显示了如何使用 JNDI 在没有<code>jee</code>的情况下查找多个环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simple&quot; class&#x3D;&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiEnvironment&quot;&gt;</span><br><span class="line">        &lt;props&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;sing&quot;&gt;song&lt;&#x2F;prop&gt;</span><br><span class="line">            &lt;prop key&#x3D;&quot;ping&quot;&gt;pong&lt;&#x2F;prop&gt;</span><br><span class="line">        &lt;&#x2F;props&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用 JNDI 使用<code>jee</code>查找多个环境变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;simple&quot; jndi-name&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&gt;</span><br><span class="line">    &lt;!-- newline-separated, key-value pairs for the environment (standard Properties format) --&gt;</span><br><span class="line">    &lt;jee:environment&gt;</span><br><span class="line">        sing&#x3D;song</span><br><span class="line">        ping&#x3D;pong</span><br><span class="line">    &lt;&#x2F;jee:environment&gt;</span><br><span class="line">&lt;&#x2F;jee:jndi-lookup&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2515-3-gt-复杂"><a href="#lt-hh-2515-3-gt-复杂" class="headerlink" title="&lt; hh:// +2515+ 3 &gt;(复杂)"></a>&lt; hh:// +2515+ <em>3</em> &gt;(复杂)</h5><p>以下 example 显示了如何在没有<code>jee</code>的情况下使用 JNDI 查找数据源和许多不同的 properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simple&quot; class&#x3D;&quot;org.springframework.jndi.JndiObjectFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cache&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceRef&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;lookupOnStartup&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;expectedType&quot; value&#x3D;&quot;com.myapp.DefaultThing&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;proxyInterface&quot; value&#x3D;&quot;com.myapp.Thing&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用 JNDI 通过<code>jee</code>查找数据源和许多不同的 properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:jndi-lookup id&#x3D;&quot;simple&quot;</span><br><span class="line">        jndi-name&#x3D;&quot;jdbc&#x2F;MyDataSource&quot;</span><br><span class="line">        cache&#x3D;&quot;true&quot;</span><br><span class="line">        resource-ref&#x3D;&quot;true&quot;</span><br><span class="line">        lookup-on-startup&#x3D;&quot;false&quot;</span><br><span class="line">        expected-type&#x3D;&quot;com.myapp.DefaultThing&quot;</span><br><span class="line">        proxy-interface&#x3D;&quot;com.myapp.Thing&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2522-3-gt-简单"><a href="#lt-hh-2522-3-gt-简单" class="headerlink" title="&lt; hh:// +2522+ 3 &gt;(简单)"></a>&lt; hh:// +2522+ <em>3</em> &gt;(简单)</h5><p><code>&lt;jee:local-slsb/&gt;</code>元素配置对本地 EJB Stateless SessionBean 的 reference。</p>
<p>以下 example 显示了如何在没有<code>jee</code>的情况下将 reference 配置到本地 EJB Stateless SessionBean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simple&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;ejb&#x2F;RentalServiceBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;businessInterface&quot; value&#x3D;&quot;com.foo.service.RentalService&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用<code>jee</code>配置 reference 到本地 EJB Stateless SessionBean：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:local-slsb id&#x3D;&quot;simpleSlsb&quot; jndi-name&#x3D;&quot;ejb&#x2F;RentalServiceBean&quot;</span><br><span class="line">        business-interface&#x3D;&quot;com.foo.service.RentalService&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2530-3-gt-复杂"><a href="#lt-hh-2530-3-gt-复杂" class="headerlink" title="&lt; hh:// +2530+ 3 &gt;(复杂)"></a>&lt; hh:// +2530+ <em>3</em> &gt;(复杂)</h5><p><code>&lt;jee:local-slsb/&gt;</code>元素配置对本地 EJB Stateless SessionBean 的 reference。</p>
<p>以下 example 显示了如何配置 reference 到本地 EJB Stateless SessionBean 和许多没有<code>jee</code>的 properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;complexLocalEjb&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;ejb&#x2F;RentalServiceBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;businessInterface&quot; value&#x3D;&quot;com.example.service.RentalService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cacheHome&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;lookupHomeOnStartup&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceRef&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用<code>jee</code>配置 reference 到本地 EJB Stateless SessionBean 和多个 properties：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:local-slsb id&#x3D;&quot;complexLocalEjb&quot;</span><br><span class="line">        jndi-name&#x3D;&quot;ejb&#x2F;RentalServiceBean&quot;</span><br><span class="line">        business-interface&#x3D;&quot;com.foo.service.RentalService&quot;</span><br><span class="line">        cache-home&#x3D;&quot;true&quot;</span><br><span class="line">        lookup-home-on-startup&#x3D;&quot;true&quot;</span><br><span class="line">        resource-ref&#x3D;&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="lt-hh-2538-3-gt"><a href="#lt-hh-2538-3-gt" class="headerlink" title="&lt; hh:// +2538+ 3 &gt;"></a>&lt; hh:// +2538+ <em>3</em> &gt;</h5><p><code>&lt;jee:remote-slsb/&gt;</code>元素配置__ EJB Stateless SessionBean 的 reference。</p>
<p>以下 example 显示了如何在没有<code>jee</code>的情况下配置 remote EJB Stateless SessionBean 的 reference：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;complexRemoteEjb&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;jndiName&quot; value&#x3D;&quot;ejb&#x2F;MyRemoteBean&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;businessInterface&quot; value&#x3D;&quot;com.foo.service.RentalService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;cacheHome&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;lookupHomeOnStartup&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;resourceRef&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;homeInterface&quot; value&#x3D;&quot;com.foo.service.RentalService&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;refreshHomeOnConnectFailure&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何使用<code>jee</code>配置 remote EJB Stateless SessionBean 的 reference：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;jee:remote-slsb id&#x3D;&quot;complexRemoteEjb&quot;</span><br><span class="line">        jndi-name&#x3D;&quot;ejb&#x2F;MyRemoteBean&quot;</span><br><span class="line">        business-interface&#x3D;&quot;com.foo.service.RentalService&quot;</span><br><span class="line">        cache-home&#x3D;&quot;true&quot;</span><br><span class="line">        lookup-home-on-startup&#x3D;&quot;true&quot;</span><br><span class="line">        resource-ref&#x3D;&quot;true&quot;</span><br><span class="line">        home-interface&#x3D;&quot;com.foo.service.RentalService&quot;</span><br><span class="line">        refresh-home-on-connect-failure&#x3D;&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-2-jms-Schema"><a href="#9-1-2-jms-Schema" class="headerlink" title="9.1.2. jms Schema"></a>9.1.2. jms Schema</h4><p><code>jms</code>元素处理配置 JMS-related beans，例如 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-mdp">消息 Listener 容器</a>。这些元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms">JMS 章节</a>标题为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jms-namespace">JMS 命名空间支持</a>的部分详细说明。有关此支持和<code>jms</code>元素本身的完整详细信息，请参阅该章。</p>
<p>为了完整性，要使用<code>jms</code> schema 中的元素，您需要在 Spring XML configuration 文件的顶部包含以下前导码。以下代码段中的文本引用了正确的 schema，以便<code>jms</code>命名空间中的元素可供您使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:jms&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms&quot; xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;jms&#x2F;spring-jms.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- bean definitions here --&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="9-1-3-使用-lt-hh-2559-h-gt"><a href="#9-1-3-使用-lt-hh-2559-h-gt" class="headerlink" title="9.1.3. 使用&lt; hh:// +2559+ .h &gt;"></a>9.1.3. 使用&lt; hh:// +2559+ .h &gt;</h4><p>这个元素在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-context-mbeanexport">配置 Annotation-based MBean Export</a>中有详细说明。</p>
<h4 id="9-1-4-缓存-Schema"><a href="#9-1-4-缓存-Schema" class="headerlink" title="9.1.4. 缓存 Schema"></a>9.1.4. 缓存 Schema</h4><p>您可以使用<code>cache</code>元素启用对 Spring 的<code>@CacheEvict</code>，<code>@CachePut</code>和<code>@Caching</code> 注释的支持。它还支持声明性 XML-based 缓存。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-annotation-enable">启用缓存注释</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#cache-declarative-xml">声明式 XML-based 缓存</a>。</p>
<p>要使用<code>cache</code> schema 中的元素，您需要在 Spring XML configuration 文件的顶部添加以下前导码。以下代码段中的文本引用了正确的 schema，以便<code>cache</code>命名空间中的元素可供您使用：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:cache</span>=<span class="string">&quot;http://www.springframework.org/schema/cache&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- bean definitions here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/" rel="prev" title="SpringFramework官方文档翻译-Web on Reactive Stack">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-Web on Reactive Stack
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81/" rel="next" title="SpringFramework官方文档翻译-语言支持">
      SpringFramework官方文档翻译-语言支持 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%9B%86%E6%88%90"><span class="nav-number">1.</span> <span class="nav-text">集成</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Remoting-%E5%92%8C-Web-Services-with-Spring"><span class="nav-number">1.1.</span> <span class="nav-text">Remoting 和 Web Services with Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-RMI-%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.1.</span> <span class="nav-text">使用 RMI 公开服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8RmiServiceExporter%E5%AF%BC%E5%87%BA%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">使用RmiServiceExporter导出服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-Client-%E4%B8%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">在 Client 中链接服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Hessian%E9%80%9A%E8%BF%87HTTP%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.2.</span> <span class="nav-text">使用Hessian通过HTTP远程调用服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BAHessian%E8%BF%9E%E6%8E%A5DispatcherServlet"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">为Hessian连接DispatcherServlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HessianServiceExporter%E5%85%AC%E5%BC%80%E4%BD%A0%E7%9A%84Beans"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">使用HessianServiceExporter公开你的Beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Client%E4%B8%8A%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">在Client上链接服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86HTTP%E5%9F%BA%E6%9C%AC%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%BA%94%E7%94%A8%E4%BA%8E%E9%80%9A%E8%BF%87Hessian%E5%85%AC%E5%BC%80%E7%9A%84%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">将HTTP基本身份验证应用于通过Hessian公开的服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HTTPInvokers%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.3.</span> <span class="nav-text">使用HTTPInvokers公开服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1Object"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">公开服务Object</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8Client%E4%B8%AD%E9%93%BE%E6%8E%A5%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">在Client中链接服务</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.4.</span> <span class="nav-text">网页服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JAX-WS%E5%85%AC%E5%BC%80%E5%9F%BA%E4%BA%8EServlet%E7%9A%84WebServices"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">使用JAX-WS公开基于Servlet的WebServices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JAX-WS%E5%AF%BC%E5%87%BA%E7%8B%AC%E7%AB%8B%E7%9A%84WebServices"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">使用JAX-WS导出独立的WebServices</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-3-%E4%BD%BF%E7%94%A8-JAX-WS-RI-%E7%9A%84-Spring-%E6%94%AF%E6%8C%81%E5%AF%BC%E5%87%BA-Web-Services"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">1.4.3. 使用 JAX-WS RI 的 Spring 支持导出 Web Services</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-4-%E4%BD%BF%E7%94%A8-JAX-WS-%E8%AE%BF%E9%97%AE-Web-Services"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">1.4.4. 使用 JAX-WS 访问 Web Services</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E9%80%9A%E8%BF%87-JMS-%E5%85%AC%E5%BC%80%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5. 通过 JMS 公开服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-Server-side-Configuration"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">1.5.1. Server-side Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-2-Client-side-Configuration"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">1.5.2. Client-side Configuration</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-AMQP"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6. AMQP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E9%80%89%E6%8B%A9%E6%8A%80%E6%9C%AF%E6%97%B6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.7. 选择技术时的注意事项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-REST-Endpoints"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.8. REST Endpoints</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-1-%E4%BD%BF%E7%94%A8-RestTemplate"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">1.8.1. 使用 RestTemplate</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.1.8.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#URIs"><span class="nav-number">1.1.8.1.2.</span> <span class="nav-text">URIs</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Headers"><span class="nav-number">1.1.8.1.3.</span> <span class="nav-text">Headers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BA%AB%E4%BD%93"><span class="nav-number">1.1.8.1.4.</span> <span class="nav-text">身体</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.8.1.5.</span> <span class="nav-text">消息转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Jackson-JSON-%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.8.1.6.</span> <span class="nav-text">Jackson JSON 视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipart"><span class="nav-number">1.1.8.1.7.</span> <span class="nav-text">Multipart</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-2-%E4%BD%BF%E7%94%A8-AsyncRestTemplate-%E5%B7%B2%E5%BC%83%E7%94%A8"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">1.8.2. 使用 AsyncRestTemplate(已弃用)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Enterprise-JavaBeans-EJB-Integration"><span class="nav-number">1.2.</span> <span class="nav-text">2. Enterprise JavaBeans(EJB)Integration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AE%BF%E9%97%AE-EJB"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1. 访问 EJB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">2.1.1. 概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-%E8%AE%BF%E9%97%AE%E6%9C%AC%E5%9C%B0-SLSB"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2.1.2. 访问本地 SLSB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-%E8%AE%BF%E9%97%AE-Remote-SLSB"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">2.1.3. 访问 Remote SLSB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4-%E8%AE%BF%E9%97%AE-EJB-2-x-SLSB-%E4%B8%8E-EJB-3-SLSB"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">2.1.4. 访问 EJB 2.x SLSB 与 EJB 3 SLSB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JMS-Java-%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1"><span class="nav-number">1.3.</span> <span class="nav-text">3. JMS(Java 消息服务)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%BD%BF%E7%94%A8-Spring-JMS"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1. 使用 Spring JMS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E4%BD%BF%E7%94%A8-JmsTemplate"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1. 使用 JmsTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2. 连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E8%B5%84%E6%BA%90"><span class="nav-number">1.3.1.2.1.</span> <span class="nav-text">缓存消息传递资源</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SingleConnectionFactory"><span class="nav-number">1.3.1.2.2.</span> <span class="nav-text">使用 SingleConnectionFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-CachingConnectionFactory"><span class="nav-number">1.3.1.2.3.</span> <span class="nav-text">使用 CachingConnectionFactory</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E7%9B%AE%E7%9A%84%E5%9C%B0%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.1.3. 目的地管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E6%B6%88%E6%81%AF-Listener-%E5%AE%B9%E5%99%A8"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3.1.4. 消息 Listener 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-SimpleMessageListenerContainer"><span class="nav-number">1.3.1.4.1.</span> <span class="nav-text">使用 SimpleMessageListenerContainer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-DefaultMessageListenerContainer"><span class="nav-number">1.3.1.4.2.</span> <span class="nav-text">使用 DefaultMessageListenerContainer</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5-Transaction-Management"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">3.1.5. Transaction Management</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2. 发送消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1. 使用消息转换器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-%E4%BD%BF%E7%94%A8-SessionCallback-%E5%92%8C-ProducerCallback"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2. 使用 SessionCallback 和 ProducerCallback</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E6%94%B6%E5%88%B0%E6%B6%88%E6%81%AF"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3. 收到消息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-%E5%90%8C%E6%AD%A5%E6%8E%A5%E6%94%B6"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1. 同步接收</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E5%BC%82%E6%AD%A5%E6%8E%A5%E6%94%B6%EF%BC%9AMessage-Driven-POJO"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2. 异步接收：Message-Driven POJO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-%E4%BD%BF%E7%94%A8-SessionAwareMessageListener-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3. 使用 SessionAwareMessageListener 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-%E4%BD%BF%E7%94%A8-MessageListenerAdapter"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">3.3.4. 使用 MessageListenerAdapter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5-%E5%9C%A8-Transactions-%E4%B8%AD%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">3.3.5. 在 Transactions 中处理消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E6%94%AF%E6%8C%81-JCA-%E6%B6%88%E6%81%AF-Endpoints"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4. 支持 JCA 消息 Endpoints</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Annotation-driven-Listener-Endpoints"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5. Annotation-driven Listener Endpoints</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1-%E5%90%AF%E7%94%A8-Listener-Endpoint-Annotations"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1. 启用 Listener Endpoint Annotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2-%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%AB%AF%E7%82%B9%E6%B3%A8%E5%86%8C"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2. 程序化端点注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3-%E5%B8%A6%E6%B3%A8%E9%87%8A%E7%9A%84%E7%AB%AF%E7%82%B9%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">3.5.3. 带注释的端点方法签名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-4-%E5%9B%9E%E5%BA%94%E7%AE%A1%E7%90%86"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">3.5.4. 回应管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-JMS-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%94%AF%E6%8C%81"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6. JMS 命名空间支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-JMX"><span class="nav-number">1.4.</span> <span class="nav-text">4. JMX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E5%B0%86-Beans-%E5%AF%BC%E5%87%BA%E5%88%B0-JMX"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1. 将 Beans 导出到 JMX</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1-Creating-MBeanServer"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1. Creating MBeanServer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2-%E9%87%8D%E7%94%A8%E7%8E%B0%E6%9C%89%E7%9A%84-MBeanServer"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2. 重用现有的 MBeanServer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3-Lazily-%E5%88%9D%E5%A7%8B%E5%8C%96-MBean"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">4.1.3. Lazily 初始化 MBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4-MBean-%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.1.4. MBean 的自动注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E6%8E%A7%E5%88%B6%E6%B3%A8%E5%86%8C%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">4.1.5. 控制注册行为</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%8E%A7%E5%88%B6-Beans-%E7%9A%84-Management-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2. 控制 Beans 的 Management 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-%E4%BD%BF%E7%94%A8-MBeanInfoAssembler-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1. 使用 MBeanInfoAssembler 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-%E4%BD%BF%E7%94%A8-Source-level-%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%9AJava-Annotations"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2. 使用 Source-level 元数据：Java Annotations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-Source-level-%E5%85%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">4.2.3. Source-level 元数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E4%BD%BF%E7%94%A8-AutodetectCapableMBeanInfoAssembler-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.2.4. 使用 AutodetectCapableMBeanInfoAssembler 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5-%E4%BD%BF%E7%94%A8-Java-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89-Management-%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">4.2.5. 使用 Java 接口定义 Management 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-6-%E4%BD%BF%E7%94%A8-MethodNameBasedMBeanInfoAssembler"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">4.2.6. 使用 MethodNameBasedMBeanInfoAssembler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%8E%A7%E5%88%B6-Beans-%E7%9A%84-ObjectName-%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3. 控制 Beans 的 ObjectName 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-%E4%BB%8E-Properties-%E8%AF%BB%E5%8F%96-ObjectName-%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1. 从 Properties 读取 ObjectName 实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2-%E4%BD%BF%E7%94%A8-MetadataNamingStrategy"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2. 使用 MetadataNamingStrategy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3-%E9%85%8D%E7%BD%AE-Annotation-based-MBean-Export"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">4.3.3. 配置 Annotation-based MBean Export</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E4%BD%BF%E7%94%A8-JSR-160-%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4. 使用 JSR-160 连接器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-Server-side-%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1. Server-side 连接器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2-Client-side-%E8%BF%9E%E6%8E%A5%E5%99%A8"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2. Client-side 连接器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-JMX-over-Hessian-%E6%88%96-SOAP"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3. JMX over Hessian 或 SOAP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE-MBean"><span class="nav-number">1.4.5.</span> <span class="nav-text">4.5. 通过代理访问 MBean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E9%80%9A%E7%9F%A5"><span class="nav-number">1.4.6.</span> <span class="nav-text">4.6. 通知</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-%E4%B8%BA%E9%80%9A%E7%9F%A5%E6%B3%A8%E5%86%8C-Listeners"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">4.6.1. 为通知注册 Listeners</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-%E5%8F%91%E5%B8%83%E9%80%9A%E7%9F%A5"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">4.6.2. 发布通知</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-number">1.4.7.</span> <span class="nav-text">4.7. 更多资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JCA-CCI"><span class="nav-number">1.5.</span> <span class="nav-text">5. JCA CCI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E9%85%8D%E7%BD%AE-CCI"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1. 配置 CCI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-%E8%BF%9E%E6%8E%A5%E5%99%A8-Configuration"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">5.1.1. 连接器 Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-Spring-%E4%B8%AD%E7%9A%84-ConnectionFactory-Configuration"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">5.1.2. Spring 中的 ConnectionFactory Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3-%E9%85%8D%E7%BD%AE-CCI-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">5.1.3. 配置 CCI 连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-%E4%BD%BF%E7%94%A8%E5%8D%95%E4%B8%AA-CCI-%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">5.1.4. 使用单个 CCI 连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E4%BD%BF%E7%94%A8-Spring-%E7%9A%84-CCI-%E8%AE%BF%E9%97%AE%E6%94%AF%E6%8C%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2. 使用 Spring 的 CCI 访问支持</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-Record-%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">5.2.1. Record 转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-%E4%BD%BF%E7%94%A8-CciTemplate"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">5.2.2. 使用 CciTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-%E4%BD%BF%E7%94%A8-DAO-%E6%94%AF%E6%8C%81"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">5.2.3. 使用 DAO 支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4-%E8%87%AA%E5%8A%A8%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95%E7%94%9F%E6%88%90"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">5.2.4. 自动输出记录生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5-CciTemplate-%E4%BA%A4%E4%BA%92%E6%91%98%E8%A6%81"><span class="nav-number">1.5.2.5.</span> <span class="nav-text">5.2.5. CciTemplate 交互摘要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-6-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-CCI-%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%BA%A4%E4%BA%92"><span class="nav-number">1.5.2.6.</span> <span class="nav-text">5.2.6. 直接使用 CCI 连接和交互</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-7-CciTemplate-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.5.2.7.</span> <span class="nav-text">5.2.7. _CciTemplate 用法示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E5%B0%86-CCI-%E8%AE%BF%E9%97%AE%E5%BB%BA%E6%A8%A1%E4%B8%BA%E6%93%8D%E4%BD%9C-Objects"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3. 将 CCI 访问建模为操作 Objects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E4%BD%BF%E7%94%A8-MappingRecordOperation"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">5.3.1. 使用 MappingRecordOperation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E4%BD%BF%E7%94%A8-MappingCommAreaOperation"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">5.3.2. 使用 MappingCommAreaOperation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-%E8%87%AA%E5%8A%A8%E8%BE%93%E5%87%BA%E8%AE%B0%E5%BD%95%E7%94%9F%E6%88%90"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">5.3.3. 自动输出记录生成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-%E6%91%98%E8%A6%81"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">5.3.4. 摘要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-MappingRecordOperation-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">5.3.5. MappingRecordOperation 用法示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-6-MappingCommAreaOperation-%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">5.3.6. MappingCommAreaOperation 用法示例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-Transactions"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4. Transactions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">1.6.</span> <span class="nav-text">6.电子邮件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E7%94%A8%E6%B3%95"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1. 用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E5%9F%BA%E6%9C%AC-MailSender-%E5%92%8C-SimpleMailMessage-%E7%94%A8%E6%B3%95"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">6.1.1. 基本 MailSender 和 SimpleMailMessage 用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E4%BD%BF%E7%94%A8-JavaMailSender-%E5%92%8C-MimeMessagePreparator"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">6.1.2. 使用 JavaMailSender 和 MimeMessagePreparator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E4%BD%BF%E7%94%A8-JavaMail-MimeMessageHelper"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2. 使用 JavaMail MimeMessageHelper</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E5%8F%91%E9%80%81%E9%99%84%E4%BB%B6%E5%92%8C%E5%86%85%E8%81%94%E8%B5%84%E6%BA%90"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">6.2.1. 发送附件和内联资源</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%99%84%E4%BB%B6"><span class="nav-number">1.6.2.1.1.</span> <span class="nav-text">附件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E8%81%94%E8%B5%84%E6%BA%90"><span class="nav-number">1.6.2.1.2.</span> <span class="nav-text">内联资源</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF-Library-%E5%88%9B%E5%BB%BA%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">6.2.2. 使用模板 Library 创建电子邮件内容</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B0%83%E5%BA%A6"><span class="nav-number">1.7.</span> <span class="nav-text">7.任务执行和调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-Spring-TaskExecutor-%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1. Spring TaskExecutor 抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-1-TaskExecutor-%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">7.1.1. TaskExecutor 类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-2-%E4%BD%BF%E7%94%A8-TaskExecutor"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">7.1.2. 使用 TaskExecutor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-Spring-TaskScheduler-%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2. Spring TaskScheduler 抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1-%E8%A7%A6%E5%8F%91%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">7.2.1. 触发接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2-%E8%A7%A6%E5%8F%91-Implementations"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">7.2.2. 触发 Implementations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3-TaskScheduler-implementations"><span class="nav-number">1.7.2.3.</span> <span class="nav-text">7.2.3. TaskScheduler implementations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-Annotation-%E6%94%AF%E6%8C%81%E8%B0%83%E5%BA%A6%E5%92%8C%E5%BC%82%E6%AD%A5%E6%89%A7%E8%A1%8C"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3. Annotation 支持调度和异步执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-1-%E5%90%AF%E7%94%A8%E8%AE%A1%E5%88%92%E6%B3%A8%E9%87%8A"><span class="nav-number">1.7.3.1.</span> <span class="nav-text">7.3.1. 启用计划注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-2-Scheduled-annotation"><span class="nav-number">1.7.3.2.</span> <span class="nav-text">7.3.2. @Scheduled annotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Async%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.7.3.3.</span> <span class="nav-text">Async注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-4-%E6%89%A7%E8%A1%8C%E8%80%85%E8%B5%84%E6%A0%BC%E4%B8%8E-Async"><span class="nav-number">1.7.3.4.</span> <span class="nav-text">7.3.4. 执行者资格与 @Async</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-5-Exception-Management-with-Async"><span class="nav-number">1.7.3.5.</span> <span class="nav-text">7.3.5. Exception Management with @Async</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E4%BB%BB%E5%8A%A1%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.4.</span> <span class="nav-text">7.4. 任务命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%98%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F%E2%80%99%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">‘调度程序’元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">执行元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%80%98scheduled-tasks%E2%80%99%E5%85%83%E7%B4%A0"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">‘scheduled-tasks’元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Quartz%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.7.5.</span> <span class="nav-text">使用Quartz调度程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JobDetailFactoryBean"><span class="nav-number">1.7.5.1.</span> <span class="nav-text">使用JobDetailFactoryBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-2-%E4%BD%BF%E7%94%A8-MethodInvokingJobDetailFactoryBean"><span class="nav-number">1.7.5.2.</span> <span class="nav-text">7.5.2. 使用 MethodInvokingJobDetailFactoryBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-5-3-%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8%E5%92%8C-SchedulerFactoryBean-%E8%BF%9E%E6%8E%A5%E4%BD%9C%E4%B8%9A"><span class="nav-number">1.7.5.3.</span> <span class="nav-text">7.5.3. 使用触发器和 SchedulerFactoryBean 连接作业</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.8.</span> <span class="nav-text">8.缓存抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E4%BA%86%E8%A7%A3%E7%BC%93%E5%AD%98%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1. 了解缓存抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E5%A3%B0%E6%98%8E%E5%BC%8F-Annotation-based-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2. 声明式 Annotation-based 缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-Cacheable-Annotation"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">8.2.1. @Cacheable Annotation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4-Key-Generation"><span class="nav-number">1.8.2.1.1.</span> <span class="nav-text">默认 Key Generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-Key-Generation-%E5%A3%B0%E6%98%8E"><span class="nav-number">1.8.2.1.2.</span> <span class="nav-text">自定义 Key Generation 声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%BC%93%E5%AD%98%E5%88%86%E8%BE%A8%E7%8E%87"><span class="nav-number">1.8.2.1.3.</span> <span class="nav-text">默认缓存分辨率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E5%88%86%E8%BE%A8%E7%8E%87"><span class="nav-number">1.8.2.1.4.</span> <span class="nav-text">自定义缓存分辨率</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.2.1.5.</span> <span class="nav-text">同步缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.2.1.6.</span> <span class="nav-text">条件缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E7%94%A8%E7%BC%93%E5%AD%98-SpEL-Evaluation-Context"><span class="nav-number">1.8.2.1.7.</span> <span class="nav-text">可用缓存 SpEL Evaluation Context</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-CachePut-Annotation"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">8.2.2. @CachePut Annotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-CacheEvict-annotation"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">8.2.3. @CacheEvict annotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-4-Caching-Annotation"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">8.2.4. @Caching Annotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-5-CacheConfig-annotation"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">8.2.5. @CacheConfig annotation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-6-%E5%90%AF%E7%94%A8%E7%BC%93%E5%AD%98%E6%B3%A8%E9%87%8A"><span class="nav-number">1.8.2.6.</span> <span class="nav-text">8.2.6. 启用缓存注释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-7-%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A"><span class="nav-number">1.8.2.7.</span> <span class="nav-text">8.2.7. 使用自定义注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-JCache-JSR-107-Annotations"><span class="nav-number">1.8.3.</span> <span class="nav-text">8.3. JCache(JSR-107)Annotations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1-Feature-%E6%91%98%E8%A6%81"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">8.3.1. Feature 摘要</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2-%E5%90%AF%E7%94%A8-JSR-107-%E6%94%AF%E6%8C%81"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">8.3.2. 启用 JSR-107 支持</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E5%A3%B0%E6%98%8E%E5%BC%8F-XML-based-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.4.</span> <span class="nav-text">8.4. 声明式 XML-based 缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-5-%E9%85%8D%E7%BD%AE%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8"><span class="nav-number">1.8.5.</span> <span class="nav-text">8.5. 配置缓存存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-1-JDK-ConcurrentMap-based-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">8.5.1. JDK ConcurrentMap-based 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-2-Ehcache-based-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">8.5.2. Ehcache-based 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-3-Caffeine-Cache"><span class="nav-number">1.8.5.3.</span> <span class="nav-text">8.5.3. Caffeine Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-4-GemFire-based-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.5.4.</span> <span class="nav-text">8.5.4. GemFire-based 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-5-JSR-107-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.5.5.</span> <span class="nav-text">8.5.5. JSR-107 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-6-%E5%9C%A8%E6%B2%A1%E6%9C%89%E6%94%AF%E6%8C%81-Store-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A4%84%E7%90%86%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.5.6.</span> <span class="nav-text">8.5.6. 在没有支持 Store 的情况下处理缓存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-6-Plugging-in-%E4%B8%8D%E5%90%8C%E7%9A%84-Back-end-%E7%BC%93%E5%AD%98"><span class="nav-number">1.8.6.</span> <span class="nav-text">8.6. Plugging-in 不同的 Back-end 缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-7-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE-TTL-TTI-Eviction-policy-XXX-feature%EF%BC%9F"><span class="nav-number">1.8.7.</span> <span class="nav-text">8.7. 如何设置 TTL&#x2F;TTI&#x2F;Eviction policy&#x2F;XXX feature？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E9%99%84%E5%BD%95"><span class="nav-number">1.9.</span> <span class="nav-text">9.附录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1-XML-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.9.1.</span> <span class="nav-text">9.1. XML 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-1-jee-Schema"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">9.1.1. jee Schema</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2494-3-gt-%E7%AE%80%E5%8D%95"><span class="nav-number">1.9.1.1.1.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2494+ 3 &gt;(简单)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2501-3-gt-%E4%BD%BF%E7%94%A8%E5%8D%95-JNDI-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.9.1.1.2.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2501+ 3 &gt;(使用单 JNDI 环境设置)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2508-3-gt-%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA-JNDI-%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.9.1.1.3.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2508+ 3 &gt;(具有多个 JNDI 环境设置)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2515-3-gt-%E5%A4%8D%E6%9D%82"><span class="nav-number">1.9.1.1.4.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2515+ 3 &gt;(复杂)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2522-3-gt-%E7%AE%80%E5%8D%95"><span class="nav-number">1.9.1.1.5.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2522+ 3 &gt;(简单)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2530-3-gt-%E5%A4%8D%E6%9D%82"><span class="nav-number">1.9.1.1.6.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2530+ 3 &gt;(复杂)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-hh-2538-3-gt"><span class="nav-number">1.9.1.1.7.</span> <span class="nav-text">&lt; hh:&#x2F;&#x2F; +2538+ 3 &gt;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-2-jms-Schema"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">9.1.2. jms Schema</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-3-%E4%BD%BF%E7%94%A8-lt-hh-2559-h-gt"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">9.1.3. 使用&lt; hh:&#x2F;&#x2F; +2559+ .h &gt;</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-1-4-%E7%BC%93%E5%AD%98-Schema"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">9.1.4. 缓存 Schema</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%9B%86%E6%88%90/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-集成/";
    this.page.title = "SpringFramework官方文档翻译-集成";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
