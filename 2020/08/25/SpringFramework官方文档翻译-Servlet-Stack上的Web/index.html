<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Servlet Stack 上的 WebSpring Web MVCSpring Web MVC 是在 Servlet API 上构建的原始 web framework，并且从一开始就包含在 Spring Framework 中。形式 name，“ Spring Web MVC”来自其源模块(spring-webmvc)的 name，但它通常被称为“Spring MVC”。 Parallel 到">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-Servlet Stack上的Web">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Servlet Stack 上的 WebSpring Web MVCSpring Web MVC 是在 Servlet API 上构建的原始 web framework，并且从一开始就包含在 Spring Framework 中。形式 name，“ Spring Web MVC”来自其源模块(spring-webmvc)的 name，但它通常被称为“Spring MVC”。 Parallel 到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/mvc-context-hierarchy.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/message-flow-simple-broker.jpg">
<meta property="og:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/message-flow-broker-relay.jpg">
<meta property="article:published_time" content="2020-08-25T00:33:56.000Z">
<meta property="article:modified_time" content="2020-09-10T07:38:33.830Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/mvc-context-hierarchy.jpg">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-Servlet Stack上的Web | Hexo</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-Servlet Stack上的Web
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 08:33:56" itemprop="dateCreated datePublished" datetime="2020-08-25T08:33:56+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-10 15:38:33" itemprop="dateModified" datetime="2020-09-10T15:38:33+08:00">2020-09-10</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Servlet-Stack-上的-Web"><a href="#Servlet-Stack-上的-Web" class="headerlink" title="Servlet Stack 上的 Web"></a>Servlet Stack 上的 Web</h1><h2 id="Spring-Web-MVC"><a href="#Spring-Web-MVC" class="headerlink" title="Spring Web MVC"></a>Spring Web MVC</h2><p>Spring Web MVC 是在 Servlet API 上构建的原始 web framework，并且从一开始就包含在 Spring Framework 中。形式 name，“ Spring Web MVC”来自其源模块(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc">spring-webmvc</a>)的 name，但它通常被称为“Spring MVC”。</p>
<p>Parallel 到 Spring Web MVC，Spring Framework 5.0 引入了一个 reactive-stack web framework，其 name，“ Spring WebFlux”也是基于它的源模块(<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webflux">spring-webflux</a>)。本节介绍 Spring Web MVC。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#spring-web-reactive">下一节</a>涵盖 Spring WebFlux。</p>
<p>有关基线信息以及与 Servlet 容器和 Java EE version 范围的兼容性，请参阅 Spring Framework <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions">维基</a>。</p>
<a id="more"></a>
<h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-dispatcher-handler">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 和许多其他 web 框架一样，是围绕前端控制器 pattern 设计的，其中中心<code>Servlet</code>，<code>DispatcherServlet</code>为请求处理提供了共享算法，而实际工作则由可配置的委托组件执行。这个 model 非常灵活，支持各种工作流程。</p>
<p><code>DispatcherServlet</code>，与任何<code>Servlet</code>一样，需要使用 Java configuration 或<code>web.xml</code>根据 Servlet 规范进行声明和映射。反过来，<code>DispatcherServlet</code>使用 Spring configuration 来发现请求映射，视图解析，exception 处理，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet-special-bean-types">和更多</a>所需的委托组件。</p>
<p>下面的 Java configuration 示例注册并初始化<code>DispatcherServlet</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletCxt) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Load Spring web application configuration</span><br><span class="line">        AnnotationConfigWebApplicationContext ac &#x3D; new AnnotationConfigWebApplicationContext();</span><br><span class="line">        ac.register(AppConfig.class);</span><br><span class="line">        ac.refresh();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Create and register the DispatcherServlet</span><br><span class="line">        DispatcherServlet servlet &#x3D; new DispatcherServlet(ac);</span><br><span class="line">        ServletRegistration.Dynamic registration &#x3D; servletCxt.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;&#x2F;app&#x2F;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>除了直接使用 ServletContext API 之外，您还可以扩展<code>AbstractAnnotationConfigDispatcherServletInitializer</code>并覆盖特定方法(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-container-config">Context 层次结构</a>下的 example)。</p>
</blockquote>
<p>以下<code>web.xml</code> configuration 的 example 注册并初始化<code>DispatcherServlet</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">    &lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;&#x2F;WEB-INF&#x2F;app-context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;app&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;app&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Spring Boot 遵循不同的初始化顺序。 Spring Boot 使用 Spring configuration 来引导自身和嵌入的 Servlet 容器，而不是挂钩 Servlet 容器的生命周期。在 Spring configuration 中检测到<code>Filter</code>和<code>Servlet</code>声明，并在 Servlet 容器中注册。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#mvc-servlet-context-hierarchy">Spring Boot 文档</a>。</p>
</blockquote>
<h4 id="Context-层次结构"><a href="#Context-层次结构" class="headerlink" title="Context 层次结构"></a>Context 层次结构</h4><p><code>DispatcherServlet</code>期望<code>WebApplicationContext</code>(普通<code>ApplicationContext</code>的扩展名)用于自己的 configuration。 <code>WebApplicationContext</code>有一个指向<code>ServletContext</code>和<code>Servlet</code>的链接。它也绑定到<code>ServletContext</code>，这样 applications 可以使用<code>RequestContextUtils</code>上的静态方法查找<code>WebApplicationContext</code>，如果它们需要访问它。</p>
<p>对于许多 applications 来说，拥有一个<code>WebApplicationContext</code>很简单而且足够了。也可以有一个 context 层次结构，其中一个根<code>WebApplicationContext</code>在多个<code>DispatcherServlet</code>(或其他<code>Servlet</code>)实例之间共享，每个实例都有自己的 child <code>WebApplicationContext</code> configuration。有关 context 层次结构 feature 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#boot-features-embedded-container">ApplicationContext 的附加功能</a>。</p>
<p>根<code>WebApplicationContext</code>通常包含基础结构 beans，例如需要跨多个<code>Servlet</code>实例共享的数据存储库和业务服务。那些 beans 是有效继承的，可以在 Servlet-specific child <code>WebApplicationContext</code>中覆盖(即 re-declared)，它通常包含给定<code>Servlet</code>本地的 beans。下图显示了这种关系：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/mvc-context-hierarchy.jpg" alt="mvc context 层次结构"></p>
<p>以下 example 配置<code>WebApplicationContext</code>层次结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return new Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[] &#123; &quot;&#x2F;app1&#x2F;*&quot; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不需要 application context 层次结构，applications 可以</p>
</blockquote>
<p>以下 example 显示<code>web.xml</code>等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line"></span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">    &lt;&#x2F;listener&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">        &lt;param-value&gt;&#x2F;WEB-INF&#x2F;root-context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">    &lt;&#x2F;context-param&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;app1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">            &lt;param-value&gt;&#x2F;WEB-INF&#x2F;app1-context.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">        &lt;&#x2F;init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span><br><span class="line">    &lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;app1&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;app1&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不需要 application context 层次结构，则 applications 可以仅配置“root”context 并将<code>contextConfigLocation</code> Servlet 参数保留为空。</p>
</blockquote>
<h4 id="特殊的Bean类型"><a href="#特殊的Bean类型" class="headerlink" title="特殊的Bean类型"></a>特殊的Bean类型</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#context-introduction">与 Spring WebFlux 相同</a></p>
<p><code>DispatcherServlet</code>委托特殊的 beans 来处理请求并呈现适当的响应。 “special beans”是指实现 WebFlux framework contracts 的 Spring-managed <code>Object</code>实例。那些通常带有 built-in contracts，但您可以自定义它们的 properties 并扩展或替换它们。</p>
<p>以下 table lists 列出<code>DispatcherHandler</code>检测到的特殊 beans：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Bean 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>HandlerMapping</code></td>
<td>将一个请求映射到一个处理程序以及一个<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-special-bean-types">拦截器</a>列表，用于 pre-和 post-processing。映射基于某些标准，其详细信息因<code>HandlerMapping</code> implementation 而异。 两个主要的<code>HandlerMapping</code> implementations 是<code>RequestMappingHandlerMapping</code>(它支持<code>@RequestMapping</code>带注释的方法)和<code>SimpleUrlHandlerMapping</code>(它维护 URI 路径模式到处理程序的显式注册)。</td>
</tr>
<tr>
<td><code>HandlerAdapter</code></td>
<td>无论实际调用处理程序如何，都帮助<code>DispatcherServlet</code>调用映射到请求的处理程序。例如，调用带注释的控制器需要解析 annotations。 <code>HandlerAdapter</code>的主要目的是保护<code>DispatcherServlet</code>免受这些细节的影响。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-handlermapping-interceptor">HandlerExceptionResolver</a></td>
<td>解决 exceptions 的策略，可能将它们映射到处理程序，HTML 错误视图或其他目标。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-exceptionhandlers">Exceptions</a>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-exceptionhandlers">视图解析器</a></td>
<td>将从处理程序返回的逻辑<code>String</code> -based 视图名称解析为实际<code>View</code>，以便将其呈现给响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-viewresolver">查看分辨率</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-viewresolver">查看技术</a>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view">LocaleResolver</a>, <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver">LocaleContextResolver</a></td>
<td>在 order 中解析<code>Locale</code> a client 正在使用并且可能是 time zone，以便能够提供国际化视图。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-timezone">locale</a>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver">ThemeResolver</a></td>
<td>解析 web application 可以使用的主题 - 例如，提供个性化布局。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-themeresolver">主题</a>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-themeresolver">MultipartResolver</a></td>
<td>在一些 multipart 解析 library 的帮助下，解析 multi-part 请求(用于 example，浏览器表单文件上传)的抽象。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart">Multipart Resolver</a>。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart">FlashMapManager</a></td>
<td>Store 并检索“输入”和“输出”<code>FlashMap</code>，它们可用于将属性从一个请求传递到另一个请求，通常是通过重定向。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-flash-attributes">Flash 属性</a>。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="WebMVC配置"><a href="#WebMVC配置" class="headerlink" title="WebMVC配置"></a>WebMVC配置</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#WebFlux配置">与 Spring WebFlux 相同</a></p>
<p>Applications 可以声明<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-framework-config">特殊的 Bean 类型</a>中列出的 process_abans 是 process 请求所需的。 <code>DispatcherServlet</code>检查每个特殊 bean 的<code>WebApplicationContext</code>。如果没有匹配的 bean 类型，则它会回退到<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties">DispatcherServlet.properties</a>中列出的默认类型。</p>
<p>在大多数情况下，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet-special-bean-types">MVC 配置</a>是最好的起点。它在 Java 或 XML 中声明了所需的 beans，并提供了 higher-level configuration 回调 API 来自定义它。</p>
<blockquote>
<p>Spring Boot 依赖于 MVC Java configuration 来配置 Spring MVC 并提供许多额外的方便选项。</p>
</blockquote>
<h4 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h4><p>在 Servlet 3.0 环境中，您可以选择以编程方式配置 Servlet 容器作为替代方法或与<code>web.xml</code>文件组合使用。以下 example 注册<code>DispatcherServlet</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext container) &#123;</span><br><span class="line">        XmlWebApplicationContext appContext &#x3D; new XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(&quot;&#x2F;WEB-INF&#x2F;spring&#x2F;dispatcher-config.xml&quot;);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic registration &#x3D; container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;&#x2F;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WebApplicationInitializer</code>是 Spring MVC 提供的接口，可确保检测到 implementation 并自动用于初始化任何 Servlet 3 容器。名为<code>AbstractDispatcherServletInitializer</code>的<code>WebApplicationInitializer</code>的抽象 base class implementation 使得通过重写方法注册<code>DispatcherServlet</code>更容易，以指定 servlet 映射和<code>DispatcherServlet</code> configuration 的位置。</p>
<p>对于使用 Java-based Spring configuration 的 applications，建议使用此方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return new Class&lt;?&gt;[] &#123; MyWebConfig.class &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[] &#123; &quot;&#x2F;&quot; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 XML-based Spring configuration，则应直接从<code>AbstractDispatcherServletInitializer</code>扩展，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected WebApplicationContext createRootApplicationContext() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected WebApplicationContext createServletApplicationContext() &#123;</span><br><span class="line">        XmlWebApplicationContext cxt &#x3D; new XmlWebApplicationContext();</span><br><span class="line">        cxt.setConfigLocation(&quot;&#x2F;WEB-INF&#x2F;spring&#x2F;dispatcher-config.xml&quot;);</span><br><span class="line">        return cxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return new String[] &#123; &quot;&#x2F;&quot; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractDispatcherServletInitializer</code>还提供了添加<code>Filter</code>实例的便捷方式，并将它们自动映射到<code>DispatcherServlet</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyWebAppInitializer extends AbstractDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Filter[] getServletFilters() &#123;</span><br><span class="line">        return new Filter[] &#123;</span><br><span class="line">            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个过滤器根据其具体类型添加默认 name 并自动映射到<code>DispatcherServlet</code>。</p>
<p><code>AbstractDispatcherServletInitializer</code>的<code>isAsyncSupported</code> protected 方法提供了一个单独的位置来启用<code>DispatcherServlet</code>上的异步支持以及映射到它的所有过滤器。默认情况下，此 flag 设置为<code>true</code>。</p>
<p>最后，如果您需要进一步自定义<code>DispatcherServlet</code>本身，则可以覆盖<code>createDispatcherServlet</code>方法。</p>
<h4 id="Processing"><a href="#Processing" class="headerlink" title="Processing"></a>Processing</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#Processing">与 Spring WebFlux 相同</a></p>
<p><code>DispatcherServlet</code>处理请求如下：</p>
<ul>
<li>在请求中搜索并绑定<code>WebApplicationContext</code>作为控制器和 process 中的其他元素可以使用的属性。它默认绑定在<code>DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key 下。</li>
<li>locale 解析器绑定到请求，以便让 process 中的元素解析处理请求时使用的 locale(呈现视图，准备数据等)。如果您不需要 locale 解析，则不需要 locale 解析器。</li>
<li>主题解析器绑定到请求，以允许视图等元素确定要使用的主题。如果您不使用主题，则可以忽略它。</li>
<li>如果指定 multipart 文件解析程序，则会检查请求的多部分。如果找到多部分，请求将包装在<code>MultipartHttpServletRequest</code>中，以供 process 中的其他元素进一步处理。有关 multipart 处理的更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-dispatcher-handler-sequence">Multipart Resolver</a>。</li>
<li>搜索适当的处理程序。如果找到了处理程序，则在 order 中执行与处理程序关联的执行链(预处理程序，后处理程序和控制器)以准备 model 或呈现。或者，对于带注释的控制器，可以呈现响应(在<code>HandlerAdapter</code>内)而不是返回视图。</li>
<li>如果返回 model，则呈现视图。如果没有返回 model(可能是由于预处理器或后处理器拦截请求，可能是出于安全原因)，则不会呈现任何视图，因为该请求可能已经完成。</li>
</ul>
<p>在<code>WebApplicationContext</code>中声明的<code>HandlerExceptionResolver</code> beans 用于解决在请求处理期间抛出的 exceptions。那些 exception 解析器允许自定义逻辑来解决 exceptions。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart">Exceptions</a>。</p>
<p>Spring <code>DispatcherServlet</code>还支持<code>last-modification-date</code>的 return，由 Servlet API 指定。确定特定请求的最后修改 date 的 process 很简单：<code>DispatcherServlet</code>查找适当的处理程序映射并测试找到的处理程序是否实现了<code>LastModified</code>接口。如果是这样，<code>LastModified</code>接口的<code>long getLastModified(request)</code>方法的 value 将返回到 client。</p>
<p>您可以通过将 Servlet 初始化参数(<code>init-param</code>元素)添加到<code>web.xml</code>文件中的 Servlet 声明来自定义单个<code>DispatcherServlet</code>实例。以下 table lists 支持的参数：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>contextClass</code></td>
<td>实现<code>ConfigurableWebApplicationContext</code>的 Class，由此 Servlet 实例化并本地配置。默认情况下，使用<code>XmlWebApplicationContext</code>。</td>
</tr>
<tr>
<td><code>contextConfigLocation</code></td>
<td>String 传递给 context 实例(由<code>contextClass</code>指定)以指示可以找到上下文的位置。 string 可能包含多个 strings(使用逗号作为分隔符)以支持多个上下文。如果多个 context 位置的 beans 定义了两次，则最新位置优先。</td>
</tr>
<tr>
<td><code>namespace</code></td>
<td><code>WebApplicationContext</code>的命名空间。默认为<code>[servlet-name]-servlet</code>。</td>
</tr>
<tr>
<td><code>throwExceptionIfNoHandlerFound</code></td>
<td>当没有找到请求的处理程序时是否抛出<code>NoHandlerFoundException</code>。然后可以使用<code>HandlerExceptionResolver</code>(对于 example，使用<code>@ExceptionHandler</code>控制器方法)捕获 exception，并像处理其他任何方法一样处理。 默认情况下，它设置为<code>false</code>，在这种情况下<code>DispatcherServlet</code> 将响应状态设置为 404(NOT_FOUND)而不引发 exception。 请注意，如果还配置了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-exceptionhandlers">默认 servlet 处理</a>，则始终将未解析的请求转发到默认的 servlet，并且永远不会引发 404。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="截击"><a href="#截击" class="headerlink" title="截击"></a>截击</h4><p>所有<code>HandlerMapping</code> implementations 都支持处理程序拦截器，当您想要将特定功能应用于某些请求时，这些拦截器非常有用 - 例如，检查主体。拦截器必须使用三种方法从<code>org.springframework.web.servlet</code>包中实现<code>HandlerInterceptor</code>，这些方法应该提供足够的灵活性来执行各种 pre-processing 和 post-processing：</p>
<ul>
<li><code>preHandle(..)</code>：在执行实际处理程序之前</li>
<li><code>postHandle(..)</code>：处理程序执行后</li>
<li><code>afterCompletion(..)</code>：完成请求完成后</li>
</ul>
<p><code>preHandle(..)</code>方法返回 boolean value。您可以使用此方法 break 或继续处理执行链。当此方法返回<code>true</code>时，处理程序执行链继续。当它返回 false 时，<code>DispatcherServlet</code>假定拦截器本身已处理请求(并且，对于 example，呈现了适当的视图)并且不继续执行其他拦截器和执行链中的实际处理程序。</p>
<p>有关如何配置拦截器的示例，请参阅 MVC configuration 一节中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-default-servlet-handler">拦截器</a>。您也可以使用单个<code>HandlerMapping</code> implementations 上的 setter 直接注册它们。</p>
<p>请注意，对于<code>@ResponseBody</code>和<code>ResponseEntity</code>方法，<code>postHandle</code>不太有用，在<code>HandlerAdapter</code>和<code>postHandle</code>之前写入并提交响应。这意味着对响应进行任何更改都为时已晚，例如添加额外的标头。对于这种情况，您可以实现<code>ResponseBodyAdvice</code>并将其声明为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-interceptors">控制器建议</a> bean 或直接在<code>RequestMappingHandlerAdapter</code>上进行配置。</p>
<h4 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-controller-advice">与 Spring WebFlux 相同</a></p>
<p>如果在请求映射期间发生 exception 或从请求处理程序(例如<code>@Controller</code>)抛出，则<code>DispatcherServlet</code>委托给<code>HandlerExceptionResolver</code> beans 链来解析 exception 并提供替代处理，这通常是错误响应。</p>
<p>以下 table lists 可用<code>HandlerExceptionResolver</code> implementations：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>HandlerExceptionResolver</code></th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SimpleMappingExceptionResolver</code></td>
<td>exception class 名称和错误视图名称之间的映射。用于在浏览器 application 中呈现错误页面。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html">DefaultHandlerExceptionResolver</a></td>
<td>解析 Spring MVC 引发的 exceptions，并将它们 maps 转换为 HTTP 状态代码。另请参阅替代<code>ResponseEntityExceptionHandler</code>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-dispatcher-exceptions">REST API exceptions</a>。</td>
</tr>
<tr>
<td><code>ResponseStatusExceptionResolver</code></td>
<td>使用<code>@ResponseStatus</code> annotation 解析 exceptions，并根据 annotation 中的 value 将它们 maps 到 HTTP 状态代码。</td>
</tr>
<tr>
<td><code>ExceptionHandlerExceptionResolver</code></td>
<td>通过在<code>@Controller</code>或<code>@ControllerAdvice</code> class 中调用<code>@ExceptionHandler</code>方法来解析 exceptions。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-rest-exceptions">@ExceptionHandler 方法</a>。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="左轮手枪链"><a href="#左轮手枪链" class="headerlink" title="左轮手枪链"></a>左轮手枪链</h5><p>您可以通过在 Spring configuration 中声明多个<code>HandlerExceptionResolver</code> beans 并根据需要设置其<code>order</code> properties 来形成 exception 解析程序链。 order property 越高，exception 解析器的位置越晚。</p>
<p>的 contract 指定它可以 return：</p>
<ul>
<li>a <code>ModelAndView</code>指向错误视图。</li>
<li>如果在解析器中处理了 exception，则返回空<code>ModelAndView</code>。</li>
<li><code>null</code>如果 exception 仍未解析，则后续解析器尝试，如果 exception 仍然在结尾，则允许冒泡到 Servlet 容器。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-exceptionhandler">MVC 配置</a>自动声明 built-in 解析器用于默认的 Spring MVC exceptions，用于<code>@ResponseStatus</code> annotated exceptions，以及支持<code>@ExceptionHandler</code>方法。您可以自定义该列表或替换它。</p>
<h5 id="容器错误页面"><a href="#容器错误页面" class="headerlink" title="容器错误页面"></a>容器错误页面</h5><p>如果任何<code>HandlerExceptionResolver</code>仍然无法解析 exception，并且因此将其传播或者如果响应状态设置为错误状态(即 4xx，5xx)，则 Servlet 容器可以呈现 HTML 中的默认错误页面。要自定义容器的默认错误页面，可以在<code>web.xml</code>中声明错误页面映射。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;error-page&gt;</span><br><span class="line">    &lt;location&gt;&#x2F;error&lt;&#x2F;location&gt;</span><br><span class="line">&lt;&#x2F;error-page&gt;</span><br></pre></td></tr></table></figure>
<p>给定前面的 example，当 exception 冒泡或响应具有错误状态时，Servlet 容器会在容器内对配置的 URL 进行 ERROR 调度(对于 example，<code>/error</code>)。然后由<code>DispatcherServlet</code>处理，可能将其映射到<code>@Controller</code>，可以使用 model 实现 return 错误视图 name 或呈现 JSON 响应，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class ErrorController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(path &#x3D; &quot;&#x2F;error&quot;)</span><br><span class="line">    public Map&lt;String, Object&gt; handle(HttpServletRequest request) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;status&quot;, request.getAttribute(&quot;javax.servlet.error.status_code&quot;));</span><br><span class="line">        map.put(&quot;reason&quot;, request.getAttribute(&quot;javax.servlet.error.message&quot;));</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Servlet API 不提供在 Java 中创建错误页面映射的方法。但是，您可以使用<code>WebApplicationInitializer</code>和最小<code>web.xml</code>。</p>
</blockquote>
<h4 id="View解析器"><a href="#View解析器" class="headerlink" title="View解析器"></a>View解析器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 定义了<code>ViewResolver</code>和<code>View</code>接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。 <code>ViewResolver</code>提供视图名称和实际视图之间的映射。 <code>View</code>解决了在移交给特定视图技术之前的数据准备工作。</p>
<p>以下 table 提供了有关<code>ViewResolver</code>层次结构的更多详细信息：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>视图解析器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AbstractCachingViewResolver</code></td>
<td>他们解析的<code>AbstractCachingViewResolver</code>个<code>AbstractCachingViewResolver</code>缓存视图实例。缓存提高了某些视图技术的性能。您可以通过将<code>cache</code> property 设置为<code>false</code>来关闭缓存。此外，如果必须在运行时刷新某个视图(对于 example，当修改 FreeMarker 模板时)，可以使用<code>removeFromCache(String viewName, Locale loc)</code>方法。</td>
</tr>
<tr>
<td><code>XmlViewResolver</code></td>
<td>实现<code>ViewResolver</code>接受用 XML 编写的 configuration 文件，其中包含与 Spring 的 XML bean 工厂相同的 DTD。默认的 configuration 文件是<code>/WEB-INF/views.xml</code>。</td>
</tr>
<tr>
<td><code>ResourceBundleViewResolver</code></td>
<td>的实现，在<code>ResourceBundle</code>中使用 bean 定义，由 bundle base name 指定。对于它应该解析的每个视图，它使用 property <code>[viewname].(class)</code>的 value 作为 view class，使用 property <code>[viewname].url</code>的 value 作为视图 URL。您可以在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-viewresolution">查看技术</a>章节中找到示例。</td>
</tr>
<tr>
<td><code>UrlBasedViewResolver</code></td>
<td><code>ViewResolver</code>接口的简单 implementation，它影响逻辑视图名称直接解析为没有显式映射定义的 URL。如果您的逻辑名称以直接的方式匹配视图资源的名称，而不需要任意映射，这是合适的。</td>
</tr>
<tr>
<td><code>InternalResourceViewResolver</code></td>
<td>方便的<code>UrlBasedViewResolver</code>子类，支持<code>InternalResourceView</code>(实际上是 Servlets 和 JSP)和子类，如<code>JstlView</code>和<code>TilesView</code>。您可以使用<code>setViewClass(..)</code>为此解析程序生成的所有视图指定视图 class。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/reactive/result/view/UrlBasedViewResolver.html">作为 UrlBasedViewResolver</a> javadoc。</td>
</tr>
<tr>
<td><code>FreeMarkerViewResolver</code></td>
<td>方便的<code>UrlBasedViewResolver</code>子类，支持<code>FreeMarkerView</code>及其自定义子类。</td>
</tr>
<tr>
<td><code>ContentNegotiatingViewResolver</code></td>
<td>根据请求文件 name 或<code>Accept</code>标头解析视图的<code>ViewResolver</code>接口的实现。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-view">内容谈判</a>。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Handling"><a href="#Handling" class="headerlink" title="Handling"></a>Handling</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-multiple-representations">与 Spring WebFlux 相同</a></p>
<p>您可以通过声明多个解析程序 bean 来链接视图解析器，并在必要时通过设置<code>order</code> property 来指定 ordering。请记住，order property 越高，视图解析器在链中的位置越晚。</p>
<p>的 contract 指定它可以 return null 以指示无法找到该视图。但是，对于 JSP 和<code>InternalResourceViewResolver</code>，确定 JSP 是否存在的唯一方法是通过<code>RequestDispatcher</code>执行调度。因此，您必须始终将<code>InternalResourceViewResolver</code>配置为视图解析器的整个 order 中的最后一个。</p>
<p>配置视图分辨率就像在 Spring configuration 中添加<code>ViewResolver</code> beans 一样简单。 <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-viewresolution-handling">MVC 配置</a>为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config">查看解析器</a>提供专用的 configuration API，并添加 logic-less <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-view-resolvers">查看控制器</a>，这对于没有控制器逻辑的 HTML 模板渲染非常有用。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-view-controller">与 Spring WebFlux 相同</a></p>
<p>视图 name 中的特殊<code>redirect:</code>前缀允许您执行重定向。 <code>UrlBasedViewResolver</code>(及其子类)将此识别为需要重定向的指令。视图 name 的 rest 是重定向 URL。</p>
<p>净效果与控制器返回<code>RedirectView</code>的效果相同，但现在控制器本身可以根据逻辑视图名称进行操作。逻辑视图 name(例如<code>redirect:/myapp/some/resource</code>)相对于当前 Servlet context 重定向，而 name 等 name 重定向到绝对 URL。</p>
<p>请注意，如果使用<code>@ResponseStatus</code>注释控制器方法，则 annotation value 优先于<code>RedirectView</code>设置的响应状态。</p>
<h5 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h5><p>您还可以为最终由<code>UrlBasedViewResolver</code>和子类解析的视图名称使用特殊的<code>forward:</code>前缀。这会创建一个<code>InternalResourceView</code>，它会执行<code>RequestDispatcher.forward()</code>。因此，此前缀对于<code>InternalResourceViewResolver</code>和<code>InternalResourceView</code>(对于 JSP)没有用，但如果您使用其他视图技术但仍希望强制由 Servlet/JSP 引擎处理资源的转发，则它可能会有所帮助。请注意，您也可以链接多个视图解析器。</p>
<h5 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#内容协商">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/ContentNegotiatingViewResolver.html">ContentNegotiatingViewResolver</a>不解析视图本身，而是委托给其他视图解析器，并选择类似于 client 请求的表示的视图。可以从<code>Accept</code>标头或查询参数(对于 example，<code>&quot;/path?format=pdf&quot;</code>)确定表示。</p>
<p><code>ContentNegotiatingViewResolver</code>通过将请求媒体类型与所支持的媒体类型(也称为<code>Content-Type</code>)进行比较来选择适当的<code>View</code>来处理请求。列表中具有兼容<code>Content-Type</code>的第一个<code>View</code>将表示返回给 client。如果<code>ViewResolver</code>链不能提供兼容的视图，则会查阅通过<code>DefaultViews</code> property 指定的视图列表。后一个选项适用于 singleton <code>Views</code>，它可以呈现当前资源的适当表示，而不管逻辑视图 name。 <code>Accept</code>标头可以包含通配符(对于 example <code>text/*</code>)，在这种情况下，<code>View</code> <code>Accept</code>是<code>text/xml</code>是兼容的 match。</p>
<p>有关 configuration 详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-multiple-representations">MVC 配置</a>下的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-view-resolvers">查看解析器</a>。</p>
<h4 id="locale"><a href="#locale" class="headerlink" title="locale"></a>locale</h4><p>Spring 的 architecture 的大多数部分都支持国际化，就像 Spring web MVC framework 那样。 <code>DispatcherServlet</code>允许您使用 client 的 locale 自动解析消息。这是通过<code>LocaleResolver</code> objects 完成的。</p>
<p>当一个请求进来时，<code>DispatcherServlet</code>会查找一个 locale 解析器，如果找到一个，它会尝试使用它来设置 locale。通过使用<code>RequestContext.getLocale()</code>方法，您始终可以检索 locale 解析程序解析的 locale。</p>
<p>除了自动 locale 解析之外，您还可以将拦截器附加到处理程序映射(有关处理程序映射拦截器的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config">截击</a>)以在特定情况下更改 locale(对于 example，基于请求中的参数)。</p>
<p>Locale 解析器和拦截器在<code>org.springframework.web.servlet.i18n</code>包中定义，并以正常方式在 application context 中配置。 _Spoc 包含以下选择的 locale 解析器。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-handlermapping-interceptor">时区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-timezone">标题解析器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver-acceptheader">Cookie Resolver</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver-cookie">Session Resolver</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver-session">Locale 拦截器</a></li>
</ul>
<h5 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h5><p>除了获取 client 的 locale 之外，知道它的 time zone 通常很有用。 <code>LocaleContextResolver</code>接口提供了<code>LocaleResolver</code>的扩展，允许解析器提供更丰富的<code>LocaleContext</code>，其中可能包含 time zone 信息。</p>
<p>可用时，可以使用<code>RequestContext.getTimeZone()</code>方法获取用户的<code>TimeZone</code>。 Time zone 信息由 Spring 的<code>ConversionService</code>注册的任何 Date/Time <code>Converter</code>和<code>Formatter</code> objects 自动使用。</p>
<h5 id="标题解析器"><a href="#标题解析器" class="headerlink" title="标题解析器"></a>标题解析器</h5><p>这个 locale 解析器检查 client 发送的请求中的<code>accept-language</code>标头(对于 example，一个 web 浏览器)。通常，此头字段包含 client 操作系统的 locale。请注意，此解析程序不支持 time zone 信息。</p>
<h5 id="Cookie解析器"><a href="#Cookie解析器" class="headerlink" title="Cookie解析器"></a>Cookie解析器</h5><p>此 locale 解析程序检查 client 上可能存在的<code>Cookie</code>，以查看是否指定了<code>Locale</code>或<code>TimeZone</code>。如果是，则使用指定的详细信息。通过使用此 locale 解析程序的 properties，您可以指定 cookie 的 name 以及最大年龄。以下 example 定义<code>CookieLocaleResolver</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cookieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;clientlanguage&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cookieMaxAge&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100000&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下 table 描述 properties <code>CookieLocaleResolver</code>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cookieName</code></td>
<td>classname LOCALE</td>
<td>cookie 的 name</td>
</tr>
<tr>
<td><code>cookieMaxAge</code></td>
<td>Servlet 容器默认</td>
<td>client 上_chokie 持续的最大 time 时间。如果指定了<code>-1</code>，则不会保留 cookie。它仅在 client 关闭浏览器之前可用。</td>
</tr>
<tr>
<td><code>cookiePath</code></td>
<td>/</td>
<td>限制 cookie 对您网站某个部分的可见性。指定<code>cookiePath</code>时，cookie 仅对该路径及其下方的_path 可见。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Session解析器"><a href="#Session解析器" class="headerlink" title="Session解析器"></a>Session解析器</h5><p><code>SessionLocaleResolver</code>允许您从 session 中检索可能与用户请求相关联的<code>Locale</code>和<code>TimeZone</code>。与<code>CookieLocaleResolver</code>相反，此策略存储 Servlet 容器的<code>HttpSession</code>中本地选择的 locale 设置。因此，这些设置对于每个 session 都是临时的，因此在每个 session 终止时都会丢失。</p>
<p>请注意，与外部 session management 机制没有直接关系，例如 Spring Session 项目。此<code>SessionLocaleResolver</code>针对当前<code>HttpServletRequest</code>评估和修改相应的<code>HttpSession</code>属性。</p>
<h5 id="Locale拦截器"><a href="#Locale拦截器" class="headerlink" title="Locale拦截器"></a>Locale拦截器</h5><p>您可以通过将<code>LocaleChangeInterceptor</code>添加到<code>HandlerMapping</code>定义之一来启用区域设置的更改。它检测请求中的参数并相应地更改 locale，在调度程序的 application context 中调用<code>LocaleResolver</code>上的<code>setLocale</code>方法。下一个 example 显示 calls 到包含名为<code>siteLanguage</code>的参数的所有<code>*.view</code>资源现在更改 locale。因此，对于 example，对 URL 的请求<code>http://www.sf.net/home.view?siteLanguage=nl</code>会将网站语言更改为荷兰语。以下 example 显示了如何拦截 locale：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;localeChangeInterceptor&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;paramName&quot; value&#x3D;&quot;siteLanguage&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;localeResolver&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;urlMapping&quot;</span><br><span class="line">        class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;interceptors&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;ref bean&#x3D;&quot;localeChangeInterceptor&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mappings&quot;&gt;</span><br><span class="line">        &lt;value&gt;&#x2F;**&#x2F;*.view&#x3D;someController&lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>您可以应用 Spring Web MVC framework 主题来设置 application 的整体 look-and-feel，从而增强用户体验。主题是静态资源的集合，通常是样式表和图像，它们会影响 application 的视觉样式。</p>
<h5 id="定义主题"><a href="#定义主题" class="headerlink" title="定义主题"></a>定义主题</h5><p>要在 web application 中使用主题，必须设置<code>org.springframework.ui.context.ThemeSource</code>接口的 implementation。 <code>WebApplicationContext</code>接口扩展<code>ThemeSource</code>但将其职责委托给专用的 implementation。默认情况下，委托是一个<code>org.springframework.ui.context.support.ResourceBundleThemeSource</code> implementation，它从 classpath 的根目录加载 properties files。要使用自定义<code>ThemeSource</code> implementation 或配置<code>ResourceBundleThemeSource</code>的基本 name 前缀，可以在 application context 中使用 reserved name，<code>themeSource</code>注册 bean。 web application context 会自动检测具有该 name 的 bean 并使用它。</p>
<p>使用<code>ResourceBundleThemeSource</code>时，主题在简单的 properties 文件中定义。 properties 文件列出构成主题的资源，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">styleSheet&#x3D;&#x2F;themes&#x2F;cool&#x2F;style.css</span><br><span class="line">background&#x3D;&#x2F;themes&#x2F;cool&#x2F;img&#x2F;coolBg.jpg</span><br></pre></td></tr></table></figure>
<p>properties 的键是引用 view code 中的主题元素的名称。对于 JSP，通常使用<code>spring:theme</code>自定义标记执行此操作，该标记与<code>spring:message</code>标记非常相似。以下 JSP 片段使用前一个 example 中定义的主题来自定义外观：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;spring&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&quot;%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&lt;spring:theme code&#x3D;&#39;styleSheet&#39;&#x2F;&gt;&quot; type&#x3D;&quot;text&#x2F;css&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body style&#x3D;&quot;background&#x3D;&lt;spring:theme code&#x3D;&#39;background&#39;&#x2F;&gt;&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>ResourceBundleThemeSource</code>使用空基 name 前缀。因此，properties files 从 classpath 的根加载。因此，您可以将<code>cool.properties</code>主题定义放在 classpath 根目录的目录中(对于 example，在<code>/WEB-INF/classes</code>中)。 <code>ResourceBundleThemeSource</code>使用标准的 Java 资源包 loading 机制，允许主题的完全国际化。对于 example，我们可以使用引用带有荷兰文本的特殊背景图像。</p>
<h5 id="解决主题"><a href="#解决主题" class="headerlink" title="解决主题"></a>解决主题</h5><p>定义主题后，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-localeresolver-interceptor">前一节</a>中所述，您可以决定使用哪个主题。 <code>DispatcherServlet</code>查找名为<code>themeResolver</code>的 bean，以找出要使用的<code>ThemeResolver</code> implementation。主题解析器的工作方式与<code>LocaleResolver</code>非常相似。它检测用于特定请求的主题，还可以更改请求的主题。以下 table 描述了 Spring 提供的主题解析器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FixedThemeResolver</code></td>
<td>选择使用<code>defaultThemeName</code> property 设置的固定主题。</td>
</tr>
<tr>
<td><code>SessionThemeResolver</code></td>
<td>主题在用户的 HTTP session 中维护。它只需要为每个 session 设置一次，但不会在会话之间保留。</td>
</tr>
<tr>
<td><code>CookieThemeResolver</code></td>
<td>所选主题存储在 client 上的 cookie 中。</td>
</tr>
</tbody>
</table>
</div>
<p>Spring 还提供了一个<code>ThemeChangeInterceptor</code>，它允许使用简单的请求参数对每个请求进行主题更改。</p>
<h4 id="Multipart解析器"><a href="#Multipart解析器" class="headerlink" title="Multipart解析器"></a>Multipart解析器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-themeresolver-defining">与 Spring WebFlux 相同</a></p>
<p>来自<code>org.springframework.web.multipart</code>包的<code>MultipartResolver</code>是一种解析 multipart 请求(包括文件上载)的策略。有一个基于<a target="_blank" rel="noopener" href="https://jakarta.apache.org/commons/fileupload">Commons _FileUpload</a>的 implementation 和另一个基于 Servlet 3.0 multipart 请求解析的实现。</p>
<p>要启用 multipart 处理，您需要在<code>DispatcherServlet</code> Spring configuration 中使用 name <code>multipartResolver</code>声明<code>MultipartResolver</code> bean。 <code>DispatcherServlet</code>检测到它并将其应用于传入请求。当收到 content-type 为<code>multipart/form-data</code>的 POST 时，解析器会解析内容并将当前<code>HttpServletRequest</code>包装为<code>MultipartHttpServletRequest</code>，以提供对已解析部分的访问，并将其作为请求参数公开。</p>
<h5 id="Apache常规FileUpload"><a href="#Apache常规FileUpload" class="headerlink" title="Apache常规FileUpload"></a>Apache常规FileUpload</h5><p>要使用 Apache Commons <code>FileUpload</code>，您可以使用 name <code>multipartResolver</code>配置类型的 bean。您还需要将<code>commons-fileupload</code>作为 classpath 的依赖项。</p>
<h5 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h5><p>需要通过 Servlet 容器 configuration 启用 Servlet 3.0 multipart 解析。为此：</p>
<ul>
<li>在 Java 中，在 Servlet 注册上设置<code>MultipartConfigElement</code>。</li>
<li>在<code>web.xml</code>中，将<code>&quot;&lt;multipart-config&gt;&quot;</code>部分添加到 servlet 声明中。</li>
</ul>
<p>以下 example 显示了如何在 Servlet 注册上设置<code>MultipartConfigElement</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void customizeRegistration(ServletRegistration.Dynamic registration) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold</span><br><span class="line">        registration.setMultipartConfig(new MultipartConfigElement(&quot;&#x2F;tmp&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦 Servlet 3.0 configuration 到位，就可以添加一个<code>StandardServletMultipartResolver</code>类型的 bean，其 name 为<code>multipartResolver</code>。</p>
<h4 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-multipart">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 中的 DEBUG-level logging 设计为紧凑，最小和 human-friendly。它侧重于反复使用的 high-value 位信息，而只有在调试特定问题时才有用。</p>
<p>TRACE-level logging 通常遵循与 DEBUG 相同的原则(并且，例如，也不应该是消防水管)，但可以用于调试任何问题。此外，一些 log 消息可能在 TRACE 与 DEBUG 中显示不同的级细节。</p>
<p>好 logging 来自使用日志的经验。如果您发现任何不符合既定目标的事件，请告诉我们。</p>
<h5 id="敏感数据"><a href="#敏感数据" class="headerlink" title="敏感数据"></a>敏感数据</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-logging">与 Spring WebFlux 相同</a></p>
<p>DEBUG 和 TRACE logging 可以 log 敏感信息。这就是默认情况下屏蔽请求参数和 headers 的原因，并且必须通过<code>DispatcherServlet</code>上的<code>enableLoggingRequestDetails</code> property 显式启用它们的 logging。</p>
<p>以下 example 显示了如何使用 Java configuration 执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class MyInitializer</span><br><span class="line">        extends AbstractAnnotationConfigDispatcherServletInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        return ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        return ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected String[] getServletMappings() &#123;</span><br><span class="line">        return ... ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void customizeRegistration(Dynamic registration) &#123;</span><br><span class="line">        registration.setInitParameter(&quot;enableLoggingRequestDetails&quot;, &quot;true&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-logging-sensitive-data">与 Spring WebFlux 相同</a></p>
<p><code>spring-web</code>模块提供了一些有用的过滤器：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-filters">表格数据</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-http-put">转发 Headers</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-forwarded-headers">浅 ETag</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-shallow-etag">CORS</a></li>
</ul>
<h4 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h4><p>浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据，但 non-browser clients 也可以使用 HTTP PUT，PATCH 和 DELETE。 Servlet API 需要<code>ServletRequest.getParameter*()</code>方法才支持仅对 HTTP POST 进行表单字段访问。</p>
<p><code>spring-web</code>模块提供<code>FormContentFilter</code>来拦截带有 content type <code>application/x-www-form-urlencoded</code>的 HTTP PUT，PATCH 和 DELETE 请求，从请求正文中读取表单数据，并包装<code>ServletRequest</code>以通过<code>ServletRequest.getParameter*()</code>方法系列提供表单数据。</p>
<h4 id="转发Headers"><a href="#转发Headers" class="headerlink" title="转发Headers"></a>转发Headers</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#filters-cors">与 Spring WebFlux 相同</a></p>
<p>当请求通过代理(例如负载平衡器)时，host， port 和 scheme 可能会发生变化，这使得从 client 透视图创建指向正确的 host，port 和 scheme 的链接成为一项挑战。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7239">RFC 7239</a>定义了代理可用于提供有关原始请求的信息的<code>Forwarded</code> HTTP 标头。还有其他 non-standard headers，包括<code>X-Forwarded-Host</code>，<code>X-Forwarded-Port</code>，<code>X-Forwarded-Proto</code>，<code>X-Forwarded-Ssl</code>和<code>X-Forwarded-Prefix</code>。</p>
<p><code>ForwardedHeaderFilter</code>是一个 Servlet 过滤器，它根据<code>Forwarded</code> headers 修改请求的 host，port 和 scheme，然后删除那些 headers。</p>
<p>转发 headers 有安全注意事项，因为 application 无法知道代理是否按预期添加了 headers，还是恶意 client。这就是为什么应该配置信任边界的代理来删除来自外部的不受信任的<code>Forwarded</code> _header。您还可以使用<code>removeOnly=true</code>配置<code>ForwardedHeaderFilter</code>，在这种情况下，它会删除但不使用 headers。</p>
<h4 id="浅ETag"><a href="#浅ETag" class="headerlink" title="浅ETag"></a>浅ETag</h4><p><code>ShallowEtagHeaderFilter</code>过滤器通过缓存写入响应的内容并从中计算 MD5 哈希来创建“浅”ETag。 _ 客户端发送的下一个 time，它也会相同，但它也会将计算出的 value 与<code>If-None-Match</code>请求标头进行比较，如果两者相等，则返回 304(NOT_MODIFIED)。</p>
<p>此策略可节省网络带宽，但不能节省 CPU，因为必须为每个请求计算完整响应。前面描述的控制器 level 的其他策略可以避免计算。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-forwarded-headers">HTTP 缓存</a>。</p>
<p>此过滤器具有<code>writeWeakETag</code>参数，该参数将过滤器配置为写入弱 ETag，类似于以下内容：<code>W/&quot;02a2d595e6ed9a0b24f027f2b63b134d6&quot;</code>(在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7232#mvc-caching">RFC 7232 第 2.3 节</a>中定义)。</p>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#section-2.3">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 通过控制器上的 annotations 为 CORS configuration 提供 fine-grained 支持。但是，当与 Spring Security 一起使用时，我们建议依赖于必须在 Spring Security 的过滤器链之前排序的 built-in <code>CorsFilter</code>。</p>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-filters-cors">CORS</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-cors">CORS 过滤器</a>部分。</p>
<h3 id="带注解的控制器"><a href="#带注解的控制器" class="headerlink" title="带注解的控制器"></a>带注解的控制器</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-cors-filter">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 提供 annotation-based 编程 model，其中<code>@Controller</code>和<code>@RestController</code>组件使用 annotations 来表达请求映射，请求输入，exception 处理等。带注释的控制器具有灵活的方法签名，不必扩展 base classes，也不必实现特定的接口。以下 example 显示了 annotations 定义的控制器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;hello&quot;)</span><br><span class="line">    public String handle(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;message&quot;, &quot;Hello World!&quot;);</span><br><span class="line">        return &quot;index&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，该方法接受<code>Model</code>并将 view name 作为<code>String</code>返回，但是存在许多其他选项，本章稍后将对此进行说明。</p>
<blockquote>
<p>上的指南和教程使用本节中描述的 annotation-based 编程模型。</p>
</blockquote>
<h4 id="宣言"><a href="#宣言" class="headerlink" title="宣言"></a>宣言</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-controller">与 Spring WebFlux 相同</a></p>
<p>您可以使用 Servlet 的<code>WebApplicationContext</code>中的标准 Spring bean 定义来定义 controller beans。 <code>@Controller</code>构造型允许 auto-detection，与 Spring 一致支持，用于检测 classpath 中的<code>@Component</code> classes 和 auto-registering bean 定义。它还充当带注释的 class 的构造型，表明它作为 web component 的角色。</p>
<p>要启用 auto-detection 这样的<code>@Controller</code> beans，可以将 component 扫描添加到 Java configuration 中，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(&quot;org.example.web&quot;)</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;</span><br><span class="line">    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;org.example.web&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- ... --&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p><code>@RestController</code>是一个<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-ann-controller">撰写 annotation</a>本身 meta-annotated，<code>@Controller</code>和<code>@ResponseBody</code>表示一个控制器，其每个方法都继承 type-level <code>@ResponseBody</code> 注释，因此，直接写入响应主体与视图分辨率和使用 HTML 模板呈现。</p>
<h5 id="AOPProxies"><a href="#AOPProxies" class="headerlink" title="AOPProxies"></a>AOPProxies</h5><p>在某些情况下，您需要在运行时使用 AOP 代理装饰控制器。一个示例是您选择直接在控制器上使用<code>@Transactional</code> annotations。在这种情况下，对于控制器，我们建议使用 class-based 代理。这通常是控制器的默认选择。但是，如果控制器必须实现不是 Spring Context 回调的接口(例如<code>InitializingBean</code>，<code>*Aware</code>和其他)，则可能需要显式配置 class-based 代理。对于 example，使用<code>&lt;tx:annotation-driven/&gt;</code>，您可以更改为<code>&lt;tx:annotation-driven proxy-target-class=&quot;true&quot;/&gt;</code>。</p>
<h4 id="请求映射"><a href="#请求映射" class="headerlink" title="请求映射"></a>请求映射</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#beans-meta-annotations">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@RequestMapping</code> annotation 来向控制器方法发送 map 请求。它具有 match 的各种属性，包括 URL，HTTP 方法，请求参数，headers 和媒体类型。您可以在 class level 中使用它来表示共享映射，或者在方法 level 中使用它来缩小到特定的端点映射。</p>
<p>还有<code>@RequestMapping</code>的 HTTP 方法特定快捷方式变体：</p>
<ul>
<li><code>@GetMapping</code></li>
<li><code>@PostMapping</code></li>
<li><code>@PutMapping</code></li>
<li><code>@DeleteMapping</code></li>
<li><code>@PatchMapping</code></li>
</ul>
<p>提供的快捷方式是<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestmapping">自定义注释</a>，因为可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。同时，class level 仍然需要<code>@RequestMapping</code>来表示共享映射。</p>
<p>以下 example 具有类型和方法 level 映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;persons&quot;)</span><br><span class="line">class PersonController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Person getPerson(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping</span><br><span class="line">    @ResponseStatus(HttpStatus.CREATED)</span><br><span class="line">    public void add(@RequestBody Person person) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="URI模式"><a href="#URI模式" class="headerlink" title="URI模式"></a>URI模式</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestmapping-composed">与 Spring WebFlux 相同</a></p>
<p>您可以使用以下 glob 模式和通配符 map 请求：</p>
<ul>
<li><code>?</code>匹配一个字符</li>
<li><code>*</code>匹配路径段中的零个或多个字符</li>
<li><code>**</code> 匹配零个或多个路径段</li>
</ul>
<p>您还可以声明 URI 变量并使用<code>@PathVariable</code>访问它们的值，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在 class 和方法级别声明 URI 变量，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;)</span><br><span class="line">public class OwnerController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URI 变量会自动转换为适当的类型，或者引发<code>TypeMismatchException</code>。默认情况下支持简单类型(<code>int</code>，<code>long</code>，<code>Date</code>等)，您可以注册对任何其他数据类型的支持。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestmapping-uri-templates">类型转换</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-typeconversion">DataBinder</a>。</p>
<p>您可以显式 name URI 变量(对于 example，<code>@PathVariable(&quot;customId&quot;)</code>)，但如果名称相同并且您的 code 是使用调试信息编译的，或者使用 Java 8 上的<code>-parameters</code>编译器 flag 编译，则可以保留该详细信息。</p>
<p>语法<code>&#123;varName:regex&#125;</code>声明一个 URI 变量，其正则表达式的语法为<code>&#123;varName:regex&#125;</code>。对于 example，给定 URL <code>&quot;/spring-web-3.0.5 .jar&quot;</code>，以下方法提取 name，version 和文件扩展名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&#123;name:[a-z-]+&#125;-&#123;version:\\d\\.\\d\\.\\d&#125;&#123;ext:\\.[a-z]+&#125;&quot;)</span><br><span class="line">public void handle(@PathVariable String version, @PathVariable String ext) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>URI 路径模式还可以嵌入<code>$&#123;…&#125;</code>占位符，这些占位符在启动时通过对本地，系统，环境和其他 property 源使用<code>PropertyPlaceHolderConfigurer</code>来解析。例如，您可以使用此参数来基于某些外部配置参数化基本 URL。</p>
<blockquote>
<p>Spring MVC 使用<code>PathMatcher</code> contract 和<code>spring-core</code> implementation 来实现 URI 路径匹配。</p>
</blockquote>
<h5 id="Pattern比较"><a href="#Pattern比较" class="headerlink" title="Pattern比较"></a>Pattern比较</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#Pattern比较">与 Spring WebFlux 相同</a></p>
<p>当多个模式匹配 URL 时，必须对它们进行比较以找到最佳的 match。这是通过使用<code>AntPathMatcher.getPatternComparator(String path)</code>来完成的，它会查找更具体的模式。</p>
<p>如果 pattern 的 URI 变量数量较少而单个通配符计为 1 且 double 通配符计为 2，则 pattern 的特定性较低。给定相等的分数，选择较长的 pattern。给定相同的分数和长度，选择具有比通配符更多的 URI 变量的 pattern。</p>
<p>默认映射 pattern(<code>/**</code>)从评分中排除，并始终排序到最后。此外，前缀模式(例如<code>/public/**</code>)被认为不如没有 double 通配符的其他 pattern 特定。</p>
<p>有关完整的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.html">AntPathMatcher</a>中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/AntPathMatcher.AntPatternComparator.html">AntPatternComparator</a>，并记住您可以自定义<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/util/PathMatcher.html">和 PathMatcher</a> implementation。请参阅 configuration 部分中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestmapping-pattern-comparison">路径匹配</a>。</p>
<h5 id="后缀-Match"><a href="#后缀-Match" class="headerlink" title="后缀 Match"></a>后缀 Match</h5><p>默认情况下，Spring MVC 执行<code>.*</code>后缀 pattern 匹配，以便映射到<code>/person</code>的控制器也隐式映射到<code>/person.*</code>。然后，文件扩展名用于解释请求的 content type 以用于响应(即，而不是<code>Accept</code>标头) - 用于 example，<code>/person.pdf</code>，<code>/person.xml</code>等。</p>
<p>当浏览器用于发送难以一致解释的<code>Accept</code> headers 时，以这种方式使用文件 extensions 是必要的。目前，这不再是必需品，使用<code>Accept</code>标头应该是首选。</p>
<p>在 time 期间，文件 name extensions 的使用已经证明在各种方面存在问题。当使用 URI 变量，路径参数和 URI 编码进行覆盖时，它可能会导致歧义。关于 URL-based 授权和安全性的推理(更多细节见下一节)也变得更加困难。</p>
<p>要完全禁用文件 extensions，必须同时设置以下两项：</p>
<ul>
<li><code>useSuffixPatternMatching(false)</code>，见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-path-matching">PathMatchConfigurer</a></li>
<li><code>favorPathExtension(false)</code>，见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-path-matching">ContentNegotiationConfigurer</a></li>
</ul>
<p>URL-based content negotiation 仍然有用(例如，在浏览器中 typing 一个 URL 时)。为了实现这一点，我们建议使用查询 parameter-based 策略来避免文件 extensions 带来的大多数问题。或者，如果必须使用文件 extensions，请考虑通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-content-negotiation">ContentNegotiationConfigurer</a>的<code>mediaTypes</code> property 将它们限制为显式注册的 extensions 列表。</p>
<h5 id="后缀匹配和-RFD"><a href="#后缀匹配和-RFD" class="headerlink" title="后缀匹配和 RFD"></a>后缀匹配和 RFD</h5><p>反射文件下载(RFD)攻击类似于 XSS，因为它依赖于响应中反映的请求输入(对于 example，查询参数和 URI 变量)。但是，RFD 攻击不依赖于将 JavaScript 插入 HTML，而是依赖浏览器切换来执行下载，并在 double-clicked 之后将响应视为可执行脚本。</p>
<p>在 Spring MVC 中，<code>@ResponseBody</code>和<code>ResponseEntity</code>方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过 URL 路径 extensions 请求这些内容类型。禁用后缀 pattern 匹配并使用路径 extensions 进行内容协商可降低风险，但不足以防止 RFD 攻击。</p>
<p>为了防止 RFD 攻击，在呈现响应主体之前，Spring MVC 添加<code>Content-Disposition:inline;filename=f.txt</code>标头以建议固定且安全的下载文件。仅当 URL 路径包含既未列入白名单也未明确注册内容 negotiation 的文件扩展名时，才会执行此操作。但是，当直接在浏览器中输入 URL 时，它可能会产生副作用。</p>
<p>默认情况下，许多 common path extensions 都列入白名单。具有自定义<code>HttpMessageConverter</code> __mplementations 的应用程序可以显式注册文件 extensions 以进行内容 negotiation，以避免为这些 extensions 添加<code>Content-Disposition</code>标头。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-content-negotiation">内容类型</a>。</p>
<p>有关 RFD 的其他建议，请参阅<a target="_blank" rel="noopener" href="https://pivotal.io/security/cve-2015-5211">CVE-2015-5211</a>。</p>
<h5 id="可消费的媒体类型"><a href="#可消费的媒体类型" class="headerlink" title="可消费的媒体类型"></a>可消费的媒体类型</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-content-negotiation">与 Spring WebFlux 相同</a></p>
<p>您可以根据请求的<code>Content-Type</code>缩小请求映射，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(path &#x3D; &quot;&#x2F;pets&quot;, consumes &#x3D; &quot;application&#x2F;json&quot;) (1)</span><br><span class="line">public void addPet(@RequestBody Pet pet) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>consumes</code>属性通过 content type 缩小映射范围。</td>
</tr>
</tbody>
</table>
</div>
<p><code>consumes</code>属性还支持否定表达式 - 对于 example，<code>!text/plain</code>表示除<code>text/plain</code>之外的任何 content type。</p>
<p>您可以在 class level 声明共享的<code>consumes</code>属性。但是，与大多数其他 request-mapping 属性不同，当在 class level 中使用时，method-level <code>consumes</code>属性会覆盖而不是扩展 class-level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量，例如<code>APPLICATION_JSON_VALUE</code>和<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h5 id="可生产的媒体类型"><a href="#可生产的媒体类型" class="headerlink" title="可生产的媒体类型"></a>可生产的媒体类型</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#可生产的媒体类型">与 Spring WebFlux 相同</a></p>
<p>您可以根据<code>Accept</code>请求标头和控制器方法生成的内容类型列表缩小请求映射，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(path = &quot;/pets/&#123;petId&#125;&quot;, produces = &quot;application/json;charset=UTF-8&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Pet <span class="title">getPet</span><span class="params">(<span class="meta">@PathVariable</span> String petId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>produces</code>属性通过 content type 缩小映射范围。</td>
</tr>
</tbody>
</table>
</div>
<p>媒体类型可以指定字符集。支持否定表达式 - 例如，<code>!text/plain</code>表示除“text/plain”之外的任何 content type。</p>
<blockquote>
<p>对于 JSON content type，即使<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7159#webflux-ann-requestmapping-produces">RFC7159</a>明确指出“没有为此注册定义 charset 参数”，也应指定 UTF-8 charset，因为某些浏览器要求它正确解释 UTF-8 特殊字符。</p>
</blockquote>
<p>您可以在 class level 声明共享的<code>produces</code>属性。但是，与大多数其他 request-mapping 属性不同，当在 class level 中使用时，method-level <code>produces</code>属性会覆盖而不是扩展 class-level 声明。</p>
<blockquote>
<p><code>MediaType</code>提供常用媒体类型的常量，例如<code>APPLICATION_JSON_UTF8_VALUE</code>和<code>APPLICATION_XML_VALUE</code>。</p>
</blockquote>
<h5 id="参数和Headers"><a href="#参数和Headers" class="headerlink" title="参数和Headers"></a>参数和Headers</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#参数和Headers">与 Spring WebFlux 相同</a></p>
<p>您可以根据请求参数条件缩小请求映射。您可以测试是否存在请求参数(<code>myParam</code>)，缺少一个(<code>!myParam</code>)或特定 value(<code>myParam=myValue</code>)。以下 example 显示了如何测试特定的 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path &#x3D; &quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;, params &#x3D; &quot;myParam&#x3D;myValue&quot;) (1)</span><br><span class="line">public void findPet(@PathVariable String petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>测试<code>myParam</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>您还可以将其与请求标头条件一起使用，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path &#x3D; &quot;&#x2F;pets&quot;, headers &#x3D; &quot;myHeader&#x3D;myValue&quot;) (1)</span><br><span class="line">public void findPet(@PathVariable String petId) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>测试<code>myHeader</code>是否等于<code>myValue</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>您可以使用 headers 条件 match <code>Content-Type</code>和<code>Accept</code>，但最好使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestmapping-params-and-headers">消耗</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-consumes">产生</a>。</p>
</blockquote>
<h5 id="HTTP头-OPTIONS"><a href="#HTTP头-OPTIONS" class="headerlink" title="HTTP头,OPTIONS"></a>HTTP头,OPTIONS</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#HTTP头,OPTIONS">与 Spring WebFlux 相同</a></p>
<p><code>@GetMapping</code>(和<code>@RequestMapping(method=HttpMethod.GET)</code>)透明地支持 HTTP HEAD 以进行请求映射。控制器方法无需更改。在<code>javax.servlet.http.HttpServlet</code>中应用的响应 wrapper 确保将<code>Content-Length</code>标头设置为写入的字节数(不实际写入响应)。</p>
<p><code>@GetMapping</code>(和<code>@RequestMapping(method=HttpMethod.GET)</code>)隐式映射到并支持 HTTP HEAD。处理 HTTP HEAD 请求就像它是 HTTP GET 一样，除了写入字体而不是写入主体，计算字节数并设置<code>Content-Length</code>标头。</p>
<p>默认情况下，通过将<code>Allow</code>响应标头设置为具有匹配的 URL 模式的所有<code>@RequestMapping</code>方法中列出的 HTTP 方法列表来处理 HTTP OPTIONS。</p>
<p>对于没有 HTTP 方法声明的<code>@RequestMapping</code>，<code>Allow</code>标头设置为<code>GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS</code>。控制器方法应始终声明支持的 HTTP 方法(对于 example，使用 HTTP 方法特定的变体：<code>@GetMapping</code>，<code>@PostMapping</code>和其他)。</p>
<p>您可以将<code>@RequestMapping</code>方法显式 map 映射到 HTTP HEAD 和 HTTP OPTIONS，但在 common 情况下这不是必需的。</p>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#自定义注解">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 支持使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-requestmapping-head-options">撰写注释</a>进行请求映射。这些是注释本身 meta-annotated 与<code>@RequestMapping</code>并且用于重新声明<code>@RequestMapping</code>属性的子集(或全部)以及更窄，更具体的目的。</p>
<p><code>@GetMapping</code>，<code>@PostMapping</code>，<code>@PutMapping</code>，<code>@DeleteMapping</code>和<code>@PatchMapping</code>是组合注释的示例。提供它们是因为，可以说，大多数控制器方法应该映射到特定的 HTTP 方法而不是使用<code>@RequestMapping</code>，默认情况下，它与所有 HTTP 方法匹配。如果您需要_notample of annotations，请查看如何声明它们。</p>
<p>Spring MVC 还支持使用自定义 request-matching 逻辑的自定义 request-mapping 属性。这是一个更高级的选项，需要子类化<code>RequestMappingHandlerMapping</code>并覆盖<code>getCustomMethodCondition</code>方法，您可以在其中检查自定义属性并 return 您自己的<code>RequestCondition</code>。</p>
<h5 id="显式注册"><a href="#显式注册" class="headerlink" title="显式注册"></a>显式注册</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#显式注册">与 Spring WebFlux 相同</a></p>
<p>您可以以编程方式注册处理程序方法，可以将其用于动态注册或高级情况，例如不同 URL 下的同一处理程序的不同实例。以下 example 注册了一个处理程序方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) (1)</span><br><span class="line">            throws NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        RequestMappingInfo info &#x3D; RequestMappingInfo</span><br><span class="line">                .paths(&quot;&#x2F;user&#x2F;&#123;id&#125;&quot;).methods(RequestMethod.GET).build(); (2)</span><br><span class="line"></span><br><span class="line">        Method method &#x3D; UserHandler.class.getMethod(&quot;getUser&quot;, Long.class); (3)</span><br><span class="line"></span><br><span class="line">        mapping.registerMapping(info, handler, method); (4)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Inject 目标处理程序和控制器的处理程序映射。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>准备映射元数据的请求。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>获取处理程序方法。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>添加注册。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="处理程序方法"><a href="#处理程序方法" class="headerlink" title="处理程序方法"></a>处理程序方法</h4><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#处理程序方法">与 Spring WebFlux 相同</a></p>
<p><code>@RequestMapping</code>处理程序方法具有灵活的签名，可以从一系列受支持的控制器方法 arguments 和 return 值中进行选择。</p>
<h5 id="方法Arguments"><a href="#方法Arguments" class="headerlink" title="方法Arguments"></a>方法Arguments</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#方法Arguments">与 Spring WebFlux 相同</a></p>
<p>下一个 table 描述了支持的控制器方法 arguments。 _ararments 不支持 Reactive 类型。</p>
<p>支持 JDK 8 的<code>java.util.Optional</code>作为方法参数与具有<code>required</code>属性(对于 example，<code>@RequestParam</code>，<code>@RequestHeader</code>和其他)的 annotations 结合使用，并且等同于<code>required=false</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制器方法参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WebRequest</code> , <code>NativeWebRequest</code></td>
<td>无需直接使用 Servlet API 即可访问请求参数以及 request 和 session 属性。</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code> , <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定请求或响应类型 - 对于 example，<code>ServletRequest</code>，<code>HttpServletRequest</code>或 Spring 的<code>MultipartRequest</code>，<code>MultipartHttpServletRequest</code>。</td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制存在 session。因此，这样的论证永远不会<code>null</code>。请注意，session 访问不是 thread-safe。如果允许多个请求同时访问 session，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code> flag 设置为<code>true</code>。</td>
</tr>
<tr>
<td><code>javax.servlet.http.PushBuilder</code></td>
<td>Servlet 4.0 push builder API 用于程序化 HTTP/2 资源推送。请注意，根据 Servlet 规范，如果 client 不支持 HTTP/2 feature，则注入的<code>PushBuilder</code>实例可以为 null。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>目前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code> implementation class。</td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的 HTTP 方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求 locale，由最具体的<code>LocaleResolver</code>可用(实际上是已配置的<code>LocaleResolver</code>或<code>LocaleContextResolver</code>)确定。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td>
<td>与当前请求关联的 time zone，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>java.io.InputStream</code> , <code>java.io.Reader</code></td>
<td>用于访问 Servlet API 公开的原始请求主体。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code> , <code>java.io.Writer</code></td>
<td>用于访问 Servlet API 公开的原始响应主体。</td>
</tr>
<tr>
<td><code>@PathVariable</code></td>
<td>用于访问 URI 模板变量。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-arguments">URI 模式</a>。</td>
</tr>
<tr>
<td><code>@MatrixVariable</code></td>
<td>用于访问 URI 路径段中的 name-value 对。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-uri-templates">矩阵变量</a>。</td>
</tr>
<tr>
<td><code>@RequestParam</code></td>
<td>用于访问 Servlet 请求参数，包括 multipart files。参数值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-matrix-variables">@RequestParam</a>以及<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestparam">Multipart</a>。 注意，对于简单的参数值，使用<code>@RequestParam</code>是可选的。请参阅本 table 末尾的“任何其他参数”。</td>
</tr>
<tr>
<td><code>@RequestHeader</code></td>
<td>用于访问请求 headers。标头值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart-forms">@RequestHeader</a>。</td>
</tr>
<tr>
<td><code>@CookieValue</code></td>
<td>访问 cookies。 Cookies 值将转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestheader">@CookieValue</a>。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>用于访问 HTTP 请求正文。使用<code>HttpMessageConverter</code> implementations 将正文内容转换为声明的方法参数类型。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-cookievalue">@RequestBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code></td>
<td>用于访问请求 headers 和 body。身体用<code>HttpMessageConverter</code>转换。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestbody">HttpEntity</a>。</td>
</tr>
<tr>
<td><code>@RequestPart</code></td>
<td>要访问<code>multipart/form-data</code>请求中的零件，请使用<code>HttpMessageConverter</code>转换零件的主体。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-httpentity">Multipart</a>。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code> , <code>org.springframework.ui.ModelMap</code></td>
<td>用于访问 HTML 控制器中使用的 model，并作为视图呈现的一部分向模板公开。</td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td>指定在重定向(即，要附加到查询 string)的情况下使用的属性，以及临时存储的 flash 属性，直到重定向后的请求为止。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart-forms">重定向属性</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-redirecting-passing-data">Flash 属性</a>。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>用于访问 model 中的现有属性(如果不存在则实例化)，并应用数据 binding 和验证。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-flash-attributes">@ModelAttribute</a>以及<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-modelattrib-method-args">模型</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-modelattrib-methods">DataBinder</a>。 请注意，使用<code>@ModelAttribute</code>是可选的(对于 example，设置其属性)。请参阅本 table 末尾的“任何其他参数”。</td>
</tr>
<tr>
<td><code>Errors</code> , <code>BindingResult</code></td>
<td>用于访问命令 object(即<code>@ModelAttribute</code>参数)的验证和数据 binding 的错误，或者验证<code>@RequestBody</code>或<code>@RequestPart</code> arguments 的错误。您必须在经过验证的方法参数后立即声明<code>Errors</code>或<code>BindingResult</code>参数。</td>
</tr>
<tr>
<td><code>SessionStatus</code> class-level <code>@SessionAttributes</code></td>
<td>用于标记表单处理完成，它触发通过 class-level <code>@SessionAttributes</code> 注释声明的 session 属性的清除。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-initbinder">@SessionAttributes</a>。</td>
</tr>
<tr>
<td><code>UriComponentsBuilder</code></td>
<td>用于准备相对于当前请求的 host， port，scheme，context 路径和 servlet 映射的文字部分的 URL。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattributes">URI 链接</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何 session 属性，与 session 属性存储在 session 中的 model 属性相反。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-uri-building">@SessionAttribute</a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattribute">@RequestAttribute</a>。</td>
</tr>
<tr>
<td>任何其他论点</td>
<td>如果方法参数与此 table 中的任何早期值不匹配，并且它是一个简单类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-ann-requestattrib">BeanUtils 的#isSimpleProperty</a>确定，则将其解析为<code>@RequestParam</code>。否则，它将被解析为<code>@ModelAttribute</code>。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Return值"><a href="#Return值" class="headerlink" title="Return值"></a>Return值</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#Return值">与 Spring WebFlux 相同</a></p>
<p>下一个 table 描述了支持的控制器方法 return 值。所有 return 值都支持 Reactive 类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>控制器方法 return value</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ResponseBody</code></td>
<td>return value 通过<code>HttpMessageConverter</code> implementations 转换并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-return-types">@ResponseBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code> , <code>ResponseEntity&lt;B&gt;</code></td>
<td>指定完整响应(包括 HTTP headers 和 body)的 return value 将通过<code>HttpMessageConverter</code> implementations 转换并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responsebody">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>HttpHeaders</code></td>
<td>用 headers 返回响应，没有正文。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code> implementations 解析并与隐式 model 一起使用的视图 name - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responseentity">明确的注册</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>一个<code>View</code>实例，用于与隐式 model 一起呈现 - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-registration">明确的注册</a>)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式 model 的属性，其中 view name 通过<code>RequestToViewNameTranslator</code>隐式确定。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到 model 的属性，其中 view name 通过<code>RequestToViewNameTranslator</code>隐式确定。 注意<code>@ModelAttribute</code>是可选的。请参阅本 table 末尾的“任何其他 return value”。</td>
</tr>
<tr>
<td><code>ModelAndView</code> object</td>
<td>要使用的视图和 model 属性，以及可选的响应状态。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>具有<code>void</code> return 类型(或<code>null</code> return value)的方法如果还具有<code>ServletResponse</code>，<code>OutputStream</code>参数或<code>@ResponseStatus</code> 注释，则认为已完全处理了响应。如果控制器进行了正<code>ETag</code>或<code>lastModified</code>时间戳检查，那么同样也是 true(详见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestmapping-registration">控制器</a>)。 如果上面的 none 是 true，则<code>void</code> return 类型也可以为 REST 控制器指示“无响应主体”或为 HTML 控制器指示默认视图 name 选择。</td>
</tr>
<tr>
<td><code>DeferredResult&lt;V&gt;</code></td>
<td>从任何线程异步生成任何前面的 return 值 - 对于 example，作为某些 event 或回调的结果。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-caching-etag-lastmodified">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">DeferredResult</a>。</td>
</tr>
<tr>
<td><code>Callable&lt;V&gt;</code></td>
<td>在 Spring MVC-managed 线程中异步生成上述任何 return 值。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-deferredresult">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">可赎回</a>。</td>
</tr>
<tr>
<td><code>ListenableFuture&lt;V&gt;</code> , <code>java.util.concurrent.CompletionStage&lt;V&gt;</code> , <code>java.util.concurrent.CompletableFuture&lt;V&gt;</code></td>
<td>作为方便的替代<code>DeferredResult</code>(例如，当底层服务返回其中一个时)。</td>
</tr>
<tr>
<td><code>ResponseBodyEmitter</code> , <code>SseEmitter</code></td>
<td>异步发送 objects 流以使用<code>HttpMessageConverter</code> implementations 写入响应。也支持<code>ResponseEntity</code>的主体。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-callable">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">HTTP 流媒体</a>。</td>
</tr>
<tr>
<td><code>StreamingResponseBody</code></td>
<td>异步写入响应<code>OutputStream</code>。也支持<code>ResponseEntity</code>的主体。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-http-streaming">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">HTTP 流媒体</a>。</td>
</tr>
<tr>
<td>Reactive 类型 - Reactor，RxJava 或其他通过<code>ReactiveAdapterRegistry</code></td>
<td><code>DeferredResult</code>替代 multi-value 流(对于 example，<code>Flux</code>，<code>Observable</code>)收集到<code>List</code>。 对于流方案(对于 example，<code>text/event-stream</code>，<code>application/json+stream</code>)，使用<code>SseEmitter</code>和<code>ResponseBodyEmitter</code>，其中<code>ServletOutputStream</code>阻塞 I/O 在 Spring MVC-managed 线程上执行，并且对每次写入完成施加背压。 见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-http-streaming">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">Reactive 类型</a>。</td>
</tr>
<tr>
<td>任何其他 return value</td>
<td>任何 return value 不_匹配此 table 中的任何早期值，并且或<code>void</code>被视为视图 name(默认视图 name 选择通过<code>RequestToViewNameTranslator</code>适用)，前提是它不是一个简单类型，由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-ann-async-reactive-types">BeanUtils 的#isSimpleProperty</a>确定。简单类型的值仍未解决。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#类型转换">与 Spring WebFlux 相同</a></p>
<p>如果参数声明为<code>String</code>以外的其他内容，则表示<code>String</code> -based 请求输入的某些带注释的控制器方法 arguments(例如<code>@RequestParam</code>，<code>@RequestHeader</code>，<code>@PathVariable</code>，<code>@MatrixVariable</code>和<code>@CookieValue</code>)可能需要进行类型转换。</p>
<p>对于此类情况，将根据配置的转换器自动应用类型转换。默认情况下，支持简单类型(<code>int</code>，<code>long</code>，<code>Date</code>和其他)。您可以通过<code>WebDataBinder</code>(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-typeconversion">DataBinder</a>)或使用<code>FormattingConversionService</code>注册<code>Formatters</code>来自定义类型转换。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-initbinder">Spring 字段格式</a>。</p>
<h5 id="矩阵变量"><a href="#矩阵变量" class="headerlink" title="矩阵变量"></a>矩阵变量</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#矩阵变量">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3986#webflux-ann-matrix-variables">RFC 3986</a>讨论路径段中的 name-value 对。在 Spring MVC 中，我们将它们称为基于 Tim Berners-Lee 的<a target="_blank" rel="noopener" href="https://www.w3.org/DesignIssues/MatrixURIs.html">“老帖子”</a>的“矩阵变量”，但它们也可以称为 URI 路径参数。</p>
<p>矩阵变量可以出现在任何路径段中，每个变量用分号分隔，多个值用逗号分隔(对于 example，<code>/cars;color=red,green;year=2012</code>)。也可以通过重复的变量名称指定多个值(对于 example，<code>color=red;color=green;color=blue</code>)。</p>
<p>如果 URL 预计包含矩阵变量，则控制器方法的请求映射必须使用 URI 变量来屏蔽该变量内容，并确保请求可以成功匹配，而与矩阵变量 order 和 presence 无关。以下 example 使用矩阵变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; petId &#x3D;&#x3D; 42</span><br><span class="line">    &#x2F;&#x2F; q &#x3D;&#x3D; 11</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鉴于所有路径段都可能包含矩阵变量，您有时可能需要消除矩阵变量预期所在的路径变量的歧义。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;owners&#x2F;42;q&#x3D;11&#x2F;pets&#x2F;21;q&#x3D;22</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(</span><br><span class="line">        @MatrixVariable(name&#x3D;&quot;q&quot;, pathVar&#x3D;&quot;ownerId&quot;) int q1,</span><br><span class="line">        @MatrixVariable(name&#x3D;&quot;q&quot;, pathVar&#x3D;&quot;petId&quot;) int q2) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; q1 &#x3D;&#x3D; 11</span><br><span class="line">    &#x2F;&#x2F; q2 &#x3D;&#x3D; 22</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵变量可以定义为可选，并指定默认 value，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(@MatrixVariable(required&#x3D;false, defaultValue&#x3D;&quot;1&quot;) int q) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; q &#x3D;&#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取所有矩阵变量，可以使用<code>MultiValueMap</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; GET &#x2F;owners&#x2F;42;q&#x3D;11;r&#x3D;12&#x2F;pets&#x2F;21;q&#x3D;22;s&#x3D;23</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)</span><br><span class="line">public void findPet(</span><br><span class="line">        @MatrixVariable MultiValueMap&lt;String, String&gt; matrixVars,</span><br><span class="line">        @MatrixVariable(pathVar&#x3D;&quot;petId&quot;) MultiValueMap&lt;String, String&gt; petMatrixVars) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; matrixVars: [&quot;q&quot; : [11,22], &quot;r&quot; : 12, &quot;s&quot; : 23]</span><br><span class="line">    &#x2F;&#x2F; petMatrixVars: [&quot;q&quot; : 22, &quot;s&quot; : 23]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，您需要启用矩阵变量的使用。在 MVC Java configuration 中，您需要使用<code>removeSemicolonContent=false</code>到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#section-3.3">路径匹配</a>设置<code>UrlPathHelper</code>。在 MVC XML 命名空间中，您可以设置<code>&lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;/&gt;</code>。</p>
<h5 id="RequestParam注解"><a href="#RequestParam注解" class="headerlink" title="RequestParam注解"></a>RequestParam注解</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#RequestParam注解">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@RequestParam</code> annotation 将 Servlet 请求参数(即查询参数或表单数据)绑定到控制器中的方法参数。</p>
<p>以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;pets&quot;)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @GetMapping</span><br><span class="line">    public String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123; (1)</span><br><span class="line">        Pet pet &#x3D; this.clinic.loadPet(petId);</span><br><span class="line">        model.addAttribute(&quot;pet&quot;, pet);</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestParam</code>绑定<code>petId</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>默认情况下，需要使用此 annotation 的方法参数，但您可以通过将<code>@RequestParam</code> annotation 的<code>required</code> flag 设置为<code>false</code>或通过使用<code>java.util.Optional</code> wrapper 声明参数来指定方法参数是可选的。</p>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestparam">类型转换</a>。</p>
<p>将参数类型声明为 array 或 list 允许为同一参数 name 解析多个参数值。</p>
<p>当<code>@RequestParam</code> annotation 声明为<code>Map&lt;String, String&gt;</code>或<code>MultiValueMap&lt;String, String&gt;</code>时，如果没有在 annotation 中指定参数 name，则使用每个给定参数 name 的请求参数值填充 map。</p>
<p>请注意，使用<code>@RequestParam</code>是可选的(对于 example，设置其属性)。默认情况下，任何作为简单 value 类型的参数(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-ann-typeconversion">BeanUtils 的#isSimpleProperty</a>确定)并且不由任何其他参数解析器解析，将被视为使用<code>@RequestParam</code>进行注释。</p>
<h5 id="RequestHeader注解"><a href="#RequestHeader注解" class="headerlink" title="RequestHeader注解"></a>RequestHeader注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#isSimpleProperty-java.lang.Class-">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@RequestHeader</code> annotation 将请求标头绑定到控制器中的方法参数。</p>
<p>使用 headers 考虑以下请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host                    localhost:8080</span><br><span class="line">Accept                  text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9</span><br><span class="line">Accept-Language         fr,en-gb;q&#x3D;0.7,en;q&#x3D;0.3</span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-8859-1,utf-8;q&#x3D;0.7,*;q&#x3D;0.7</span><br><span class="line">Keep-Alive              300</span><br></pre></td></tr></table></figure>
<p>以下 example 获取<code>Accept-Encoding</code>和<code>Keep-Alive</code> headers 的 value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;demo&quot;)</span><br><span class="line">public void handle(</span><br><span class="line">        @RequestHeader(&quot;Accept-Encoding&quot;) String encoding, (1)</span><br><span class="line">        @RequestHeader(&quot;Keep-Alive&quot;) long keepAlive) &#123; (2)</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>获取<code>Accept-Encoding</code>标头的 value。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>获取<code>Keep-Alive</code>标头的 value。</td>
</tr>
</tbody>
</table>
</div>
<p>如果目标方法参数类型不是<code>String</code>，则会自动应用类型转换。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestheader">类型转换</a>。</p>
<p>在<code>Map&lt;String, String&gt;</code>，<code>MultiValueMap&lt;String, String&gt;</code>或<code>HttpHeaders</code>参数上使用<code>@RequestHeader</code> annotation 时，map 将填充所有标头值。</p>
<blockquote>
<p>Built-in 支持可用于将 comma-separated string 转换为 array 或 strings 集合或类型转换系统已知的其他类型。对于 example，使用<code>@RequestHeader(&quot;Accept&quot;)</code>注释的方法参数可以是<code>String</code>类型，但也可以是<code>String[]</code>或<code>List&lt;String&gt;</code>。</p>
</blockquote>
<h5 id="CookieValue注解"><a href="#CookieValue注解" class="headerlink" title="CookieValue注解"></a>CookieValue注解</h5><p><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#CookieValue注解">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@CookieValue</code> annotation 将 HTTP cookie 的 value 绑定到控制器中的方法参数。</p>
<p>考虑使用以下 cookie 的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSESSIONID&#x3D;415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何获取 cookie value：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;demo&quot;)</span><br><span class="line">public void handle(@CookieValue(&quot;JSESSIONID&quot;) String cookie) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>获取<code>JSESSIONID</code> cookie 的 value。</td>
</tr>
</tbody>
</table>
</div>
<p>如果目标方法参数类型不是<code>String</code>，则自动应用类型转换。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-cookievalue">类型转换</a>。</p>
<h5 id="ModelAttribute注解"><a href="#ModelAttribute注解" class="headerlink" title="ModelAttribute注解"></a>ModelAttribute注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-typeconversion">与 Spring WebFlux 相同</a></p>
<p>您可以在方法参数上使用<code>@ModelAttribute</code> annotation 来从 model 访问属性，或者如果不存在则将其实例化。 model 属性还覆盖了 HTTP Servlet 请求参数的值，这些参数的名称为 match 到字段名称。这称为数据 binding，它使您不必处理解析和转换单个查询参数和表单字段。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@ModelAttribute Pet pet) &#123; &#125; (1)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>绑定<code>Pet</code>的实例。</td>
</tr>
</tbody>
</table>
</div>
<p>上面的<code>Pet</code>实例解析如下：</p>
<ul>
<li>从 model 开始，如果已经使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-modelattrib-method-args">模型</a>添加了。</li>
<li>通过使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-modelattrib-methods">@SessionAttributes</a>从 HTTP session。</li>
<li>从通过<code>Converter</code>的 URI 路径变量(参见下一个 example)。</li>
<li>从默认构造函数的调用。</li>
<li>从“主构造函数”调用 arguments match 到 Servlet 请求参数。参数名称通过字节码中的 JavaBeans <code>@ConstructorProperties</code>或 runtime-retained 参数名称确定。</li>
</ul>
<p>虽然使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattributes">模型</a>来使用属性填充_mode 是常见的，但另一种替代方法是依赖于<code>Converter&lt;String, T&gt;</code>与 URI 路径变量约定的组合。在下面的示例中，model 属性 name，<code>account</code>与 URI 路径变量<code>account</code>匹配，并通过将<code>String</code>帐号传递给已注册的<code>Converter&lt;String, Account&gt;</code>来加载<code>Account</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(&quot;&#x2F;accounts&#x2F;&#123;account&#125;&quot;)</span><br><span class="line">public String save(@ModelAttribute(&quot;account&quot;) Account account) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 model 属性实例后，将应用数据 binding。 <code>WebDataBinder</code> class 将 Servlet 请求参数名称(查询参数和表单字段)与目标<code>Object</code>上的字段名称相匹配。在必要时，在应用类型转换后填充匹配字段。有关数据 binding(和验证)的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-modelattrib-methods">验证</a>。有关自定义数据 binding 的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#validation">DataBinder</a>。</p>
<p>数据绑定可能导致错误。默认情况下，会引发<code>BindException</code>。但是，要在控制器方法中检查此类错误，可以在<code>@ModelAttribute</code>旁边添加<code>BindingResult</code>参数，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123; (1)</span><br><span class="line">    if (result.hasErrors()) &#123;</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在<code>@ModelAttribute</code>旁边添加<code>BindingResult</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>在某些情况下，您可能希望在没有数据 binding 的情况下访问 model 属性。对于这种情况，您可以_将<code>Model</code>注入控制器并直接访问它，或者设置<code>@ModelAttribute(binding=false)</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public AccountForm setUpForm() &#123;</span><br><span class="line">    return new AccountForm();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@ModelAttribute</span><br><span class="line">public Account findAccount(@PathVariable String accountId) &#123;</span><br><span class="line">    return accountRepository.findOne(accountId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@PostMapping(&quot;update&quot;)</span><br><span class="line">public String update(@Valid AccountUpdateForm form, BindingResult result,</span><br><span class="line">        @ModelAttribute(binding&#x3D;false) Account account) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>设置<code>@ModelAttribute(binding=false)</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>通过添加<code>javax.validation.Valid</code> annotation 或 Spring 的<code>@Validated</code> annotation(ee <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#mvc-ann-initbinder">Bean 验证</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#validation-beanvalidation">Spring 验证</a>)，您可以在数据 binding 后自动应用验证。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&#x2F;edit&quot;)</span><br><span class="line">public String processSubmit(@Valid @ModelAttribute(&quot;pet&quot;) Pet pet, BindingResult result) &#123; (1)</span><br><span class="line">    if (result.hasErrors()) &#123;</span><br><span class="line">        return &quot;petForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>验证<code>Pet</code>实例。</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，使用<code>@ModelAttribute</code>是可选的(对于 example，设置其属性)。默认情况下，任何不是简单 value 类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#validation">BeanUtils 的#isSimpleProperty</a>确定)并且未被任何其他参数解析器解析的参数都被视为使用<code>@ModelAttribute</code>进行注释。</p>
<h5 id="SessionAttributes注解"><a href="#SessionAttributes注解" class="headerlink" title="SessionAttributes注解"></a>SessionAttributes注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#isSimpleProperty-java.lang.Class-">与 Spring WebFlux 相同</a></p>
<p><code>@SessionAttributes</code>用于在请求之间的 HTTP Servlet session 中存储 model 属性。它是 type-level annotation，声明特定控制器使用的 session 属性。这通常列出 model 属性的名称或 model 属性的类型，这些属性应该透明地存储在 session 中以供后续访问请求使用。</p>
<p>以下 example 使用<code>@SessionAttributes</code> annotation：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@SessionAttributes(&quot;pet&quot;) (1)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttributes</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<p>在第一个请求中，当 model 的 model 属性被添加到 model 时，它会自动提升并保存在 HTTP Servlet session 中。它保持不变，直到另一个控制器方法使用<code>SessionStatus</code>方法参数来清除存储，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@SessionAttributes(&quot;pet&quot;) (1)</span><br><span class="line">public class EditPetForm &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;pets&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public String handle(Pet pet, BindingResult errors, SessionStatus status) &#123;</span><br><span class="line">        if (errors.hasErrors) &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">            status.setComplete(); (2)</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将<code>Pet</code> value 存储在 Servlet session 中。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>清除 Servlet session 中的<code>Pet</code> value。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="SessionAttribute注解"><a href="#SessionAttribute注解" class="headerlink" title="SessionAttribute注解"></a>SessionAttribute注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-sessionattributes">与 Spring WebFlux 相同</a></p>
<p>如果需要访问全局管理的 pre-existing session 属性(即，在控制器外部 - 对于 example，通过过滤器)并且可能存在或不存在，则可以在方法参数上使用<code>@SessionAttribute</code> annotation，如下所示 example 说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@SessionAttribute User user) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@SessionAttribute</code> 注释。</td>
</tr>
</tbody>
</table>
</div>
<p>对于需要添加或删除 session 属性的用例，请考虑将<code>org.springframework.web.context.request.WebRequest</code>或<code>javax.servlet.http.HttpSession</code>注入控制器方法。</p>
<p>要在 session 中临时存储 model 属性作为控制器工作流的一部分，请考虑使用<code>@SessionAttributes</code>，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-sessionattribute">@SessionAttributes</a>中所述。</p>
<h5 id="RequestAttribute注解"><a href="#RequestAttribute注解" class="headerlink" title="RequestAttribute注解"></a>RequestAttribute注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-sessionattributes">与 Spring WebFlux 相同</a></p>
<p>与<code>@SessionAttribute</code>类似，您可以使用<code>@RequestAttribute</code> annotations 访问之前创建的 pre-existing 请求属性(对于 example，Servlet <code>Filter</code>或<code>HandlerInterceptor</code>)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestAttribute Client client) &#123; (1)</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用<code>@RequestAttribute</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="重定向属性"><a href="#重定向属性" class="headerlink" title="重定向属性"></a>重定向属性</h5><p>默认情况下，所有 model 属性都被视为在重定向 URL 中公开为 URI 模板变量。在其余属性中，原始类型或集合或基本类型数组的属性会自动附加为查询参数。</p>
<p>如果专门为重定向准备了 model 实例，则将原始类型属性作为查询参数附加可以是期望的结果。但是，在带注释的控制器中，model 可以包含为渲染目的而添加的其他属性(对于 example，drop-down 字段值)。为了避免在 URL 中出现此类属性的可能性，<code>@RequestMapping</code>方法可以声明类型为<code>RedirectAttributes</code>的参数，并使用它来指定可供<code>RedirectView</code>使用的确切属性。如果方法重定向，则使用<code>RedirectAttributes</code>的内容。否则，使用 model 的内容。</p>
<p><code>RequestMappingHandlerAdapter</code>提供了一个名为<code>ignoreDefaultModelOnRedirect</code>的 flag，您可以使用它来指示如果控制器方法重定向，则永远不应使用默认<code>Model</code>的内容。相反，控制器方法应声明类型为<code>RedirectAttributes</code>的属性，如果不这样做，则不应将任何属性传递给<code>RedirectView</code>。 MVC 命名空间和 MVC Java configuration 都将此 flag 设置为<code>false</code>，以保持向后兼容性。但是，对于新的 applications，我们建议将其设置为<code>true</code>。</p>
<p>请注意，在展开重定向 URL 时，当前请求中的 URI 模板变量会自动变为可用，您需要通过<code>Model</code>或<code>RedirectAttributes</code>显式添加它们。以下 example 显示了如何定义重定向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;files&#x2F;&#123;path&#125;&quot;)</span><br><span class="line">public String upload(...) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    return &quot;redirect:files&#x2F;&#123;path&#125;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将数据传递到重定向目标的另一种方法是使用 flash 属性。与其他重定向属性不同，Flash 属性保存在 HTTP session 中(因此，不会出现在 URL 中)。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-requestattrib">Flash 属性</a>。</p>
<h5 id="Flash-属性"><a href="#Flash-属性" class="headerlink" title="Flash 属性"></a>Flash 属性</h5><p>Flash 属性为一个请求提供了一种方法来存储打算在另一个请求中使用的属性。这在重定向时最常见 - 例如，Post-Redirect-Get pattern。 Flash 属性在重定向之前临时保存(通常在 session 中)，以便在重定向后对请求可用并立即删除。</p>
<p>Spring MVC 有两个主要的抽象支持 flash 属性。 <code>FlashMap</code>用于保存 flash 属性，而<code>FlashMapManager</code>用于 store，检索和管理<code>FlashMap</code>实例。</p>
<p>Flash 属性支持始终处于“打开”状态，无需显式启用。但是，如果不使用，它永远不会导致 HTTP session 创建。在每个请求中，都有一个“输入”<code>FlashMap</code>，其中包含从先前请求(如果有)传递的属性，以及“输出”<code>FlashMap</code>，其中包含要为后续请求保存的属性。 <code>FlashMap</code>实例都可以通过<code>RequestContextUtils</code>中的静态方法从 Spring MVC 中的任何位置访问。</p>
<p>带注释的控制器通常不需要直接使用<code>FlashMap</code>。相反，<code>@RequestMapping</code>方法可以接受<code>RedirectAttributes</code>类型的参数，并使用它为重定向方案添加 flash 属性。通过<code>RedirectAttributes</code>添加的 Flash 属性会自动传播到“输出”FlashMap。同样，在重定向之后，“input”<code>FlashMap</code>中的属性会自动添加到为目标 URL 提供服务的控制器的<code>Model</code>中。</p>
<p>匹配闪存属性的请求</p>
<p>flash 属性的概念存在于许多其他 web 框架中，并且已证明有时会暴露于并发问题。这是因为，根据定义，闪存属性将被存储直到下一个请求。但是，非常“下一个”请求可能不是预期的接收者而是另一个异步请求(对于 example，轮询或资源请求)，在这种情况下，过早地删除 flash 属性。</p>
<p>为了减少此类问题的可能性，<code>RedirectView</code>使用目标重定向 URL 的路径和查询参数自动“标记”<code>FlashMap</code>实例。反过来，默认<code>FlashMapManager</code>在查找“输入”<code>FlashMap</code>时将该信息与传入请求进行匹配。</p>
<p>这并不能完全消除并发问题的可能性，但会使用重定向 URL 中已有的信息大大减少并发问题。因此，我们建议您主要使用 Flash 属性进行重定向方案。</p>
<h5 id="Multipart"><a href="#Multipart" class="headerlink" title="Multipart"></a>Multipart</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-flash-attributes">与 Spring WebFlux 相同</a></p>
<p>在<code>MultipartResolver</code>已经<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-multipart-forms">启用</a>之后，具有<code>multipart/form-data</code>的 POST 请求的内容被解析并可作为常规请求参数访问。以下 example 访问一个常规表单字段和一个上载文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;form&quot;)</span><br><span class="line">    public String handleFormUpload(@RequestParam(&quot;name&quot;) String name,</span><br><span class="line">            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line"></span><br><span class="line">        if (!file.isEmpty()) &#123;</span><br><span class="line">            byte[] bytes &#x3D; file.getBytes();</span><br><span class="line">            &#x2F;&#x2F; store the bytes somewhere</span><br><span class="line">            return &quot;redirect:uploadSuccess&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;redirect:uploadFailure&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将参数类型声明为<code>List&lt;MultipartFile&gt;</code>允许为同一参数 name 解析多个 files。</p>
<p>当<code>@RequestParam</code> annotation 声明为<code>Map&lt;String, MultipartFile&gt;</code>或<code>MultiValueMap&lt;String, MultipartFile&gt;</code>时，如果没有在 annotation 中指定参数 name，则 map 将使用 multipart files 为每个给定参数 name 填充。</p>
<blockquote>
<p>使用 Servlet 3.0 multipart 解析，您还可以声明<code>javax.servlet.http.Part</code>而不是 Spring 的<code>MultipartFile</code>，作为方法参数或集合 value 类型。</p>
</blockquote>
<p>您还可以将 multipart 内容用作数据 binding 到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-multipart">命令 object</a>的一部分。对于 example，前面 example 中的表单字段和文件可以是表单 object 上的字段，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MyForm &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private MultipartFile file;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;form&quot;)</span><br><span class="line">    public String handleFormUpload(MyForm form, BindingResult errors) &#123;</span><br><span class="line">        if (!form.getFile().isEmpty()) &#123;</span><br><span class="line">            byte[] bytes &#x3D; form.getFile().getBytes();</span><br><span class="line">            &#x2F;&#x2F; store the bytes somewhere</span><br><span class="line">            return &quot;redirect:uploadSuccess&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;redirect:uploadFailure&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Multipart 请求也可以在 RESTful 服务方案中从 non-browser clients 提交。以下 example 显示了一个带有 JSON 的文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;someUrl</span><br><span class="line">Content-Type: multipart&#x2F;mixed</span><br><span class="line"></span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;meta-data&quot;</span><br><span class="line">Content-Type: application&#x2F;json; charset&#x3D;UTF-8</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;value&quot;</span><br><span class="line">&#125;</span><br><span class="line">--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;file-data&quot;; filename&#x3D;&quot;file.properties&quot;</span><br><span class="line">Content-Type: text&#x2F;xml</span><br><span class="line">Content-Transfer-Encoding: 8bit</span><br><span class="line">... File Data ...</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>@RequestParam</code>作为<code>String</code>访问“meta-data”部分，但您可能希望它从 JSON 反序列化(类似于<code>@RequestBody</code>)。在使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#mvc-ann-modelattrib-method-args">HttpMessageConverter</a>转换后，使用<code>@RequestPart</code> annotation 访问 multipart：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@RequestPart(&quot;meta-data&quot;) MetaData metadata,</span><br><span class="line">        @RequestPart(&quot;file-data&quot;) MultipartFile file) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将<code>@RequestPart</code>与<code>javax.validation.Valid</code>结合使用或使用 Spring 的<code>@Validated</code> annotation，这两种方法都会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>，这会转换为 400(BAD_REQUEST)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">public String handle(@Valid @RequestPart(&quot;meta-data&quot;) MetaData metadata,</span><br><span class="line">        BindingResult result) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RequestBody注解"><a href="#RequestBody注解" class="headerlink" title="RequestBody注解"></a>RequestBody注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#rest-message-conversion">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@RequestBody</code> annotation 将请求主体读取并反序列化为<code>Object</code>到<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-ann-requestbody">HttpMessageConverter</a>。以下 example 使用<code>@RequestBody</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(@RequestBody Account account) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#rest-message-conversion">MVC 配置</a>的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-message-converters">消息转换器</a>选项来配置或自定义邮件转换。</p>
<p>您可以将<code>@RequestBody</code>与<code>javax.validation.Valid</code>或 Spring 的<code>@Validated</code> annotation 结合使用，这两种方法都会导致应用标准 Bean 验证。默认情况下，验证错误会导致<code>MethodArgumentNotValidException</code>，这会转换为 400(BAD_REQUEST)响应。或者，您可以通过<code>Errors</code>或<code>BindingResult</code>参数在控制器内本地处理验证错误，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(@Valid @RequestBody Account account, BindingResult result) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="HttpEntity"><a href="#HttpEntity" class="headerlink" title="HttpEntity"></a>HttpEntity</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config">与 Spring WebFlux 相同</a></p>
<p><code>HttpEntity</code>与使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-httpentity">@RequestBody</a>或多或少相同，但是基于暴露请求 headers 和 body 的容器 object。以下清单显示了一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping(&quot;&#x2F;accounts&quot;)</span><br><span class="line">public void handle(HttpEntity&lt;Account&gt; entity) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ResponseBody注解"><a href="#ResponseBody注解" class="headerlink" title="ResponseBody注解"></a>ResponseBody注解</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestbody">与 Spring WebFlux 相同</a></p>
<p>您可以在方法上使用<code>@ResponseBody</code> annotation 通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-ann-responsebody">HttpMessageConverter</a>将 return 序列化到响应正文。以下清单显示了一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Account handle() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class level 也支持<code>@ResponseBody</code>，在这种情况下，它由所有控制器方法继承。这是<code>@RestController</code>的效果，它只不过标有<code>@Controller</code>和<code>@ResponseBody</code>。</p>
<p>您可以将<code>@ResponseBody</code>与 reactive 类型一起使用。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#rest-message-conversion">异步请求</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async">Reactive 类型</a>。</p>
<p>您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-reactive-types">MVC 配置</a>的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-message-converters">消息转换器</a>选项来配置或自定义邮件转换。</p>
<p>您可以将<code>@ResponseBody</code>方法与 JSON 序列化视图结合使用。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config">Jackson JSON</a>。</p>
<h5 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-jackson">与 Spring WebFlux 相同</a></p>
<p><code>ResponseEntity</code>就像<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-responseentity">@ResponseBody</a>但有状态和 headers。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;something&quot;)</span><br><span class="line">public ResponseEntity&lt;String&gt; handle() &#123;</span><br><span class="line">    String body &#x3D; ... ;</span><br><span class="line">    String etag &#x3D; ... ;</span><br><span class="line">    return ResponseEntity.ok().eTag(etag).build(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC 支持使用单个 value <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responsebody">reactive 类型</a>为主体生成<code>ResponseEntity</code>异步，and/or 单和 multi-valuereactive 类型。</p>
<h5 id="JacksonJSON"><a href="#JacksonJSON" class="headerlink" title="JacksonJSON"></a>JacksonJSON</h5><p>Spring 支持 Jackson JSON library。</p>
<h6 id="Jackson序列化视图"><a href="#Jackson序列化视图" class="headerlink" title="Jackson序列化视图"></a>Jackson序列化视图</h6><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-async-reactive-types">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 为<a target="_blank" rel="noopener" href="http://wiki.fasterxml.com/JacksonJsonViews">Jackson 的序列化视图</a>提供了 built-in 支持，它允许只渲染<code>Object</code>中所有字段的子集。要将其与<code>@ResponseBody</code>或<code>ResponseEntity</code>控制器方法一起使用，可以使用 Jackson 的<code>@JsonView</code> annotation 来激活序列化视图 class，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    @JsonView(User.WithoutPasswordView.class)</span><br><span class="line">    public User getUser() &#123;</span><br><span class="line">        return new User(&quot;eric&quot;, &quot;7!jd#h23&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    public interface WithoutPasswordView &#123;&#125;;</span><br><span class="line">    public interface WithPasswordView extends WithoutPasswordView &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    private String username;</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    public User() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User(String username, String password) &#123;</span><br><span class="line">        this.username &#x3D; username;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @JsonView(WithoutPasswordView.class)</span><br><span class="line">    public String getUsername() &#123;</span><br><span class="line">        return this.username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @JsonView(WithPasswordView.class)</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@JsonView</code>允许 array 视图 classes，但是每个控制器方法只能指定一个。如果需要激活多个视图，可以使用复合接口。</p>
</blockquote>
<p>对于依赖于视图分辨率的控制器，可以将序列化视图 class 添加到 model，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class UserController extends AbstractController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">    public String getUser(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;user&quot;, new User(&quot;eric&quot;, &quot;7!jd#h23&quot;));</span><br><span class="line">        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);</span><br><span class="line">        return &quot;userView&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-jsonview">与 Spring WebFlux 相同</a></p>
<p>您可以使用<code>@ModelAttribute</code> annotation：</p>
<ul>
<li>在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-modelattrib-methods">方法论证</a> in <code>@RequestMapping</code>方法中，从 model 创建或访问<code>Object</code>并通过<code>WebDataBinder</code>将其绑定到请求。</li>
<li>作为<code>@Controller</code>或<code>@ControllerAdvice</code> classes 中的 method-level annotation，有助于在任何<code>@RequestMapping</code>方法调用之前初始化 model。</li>
<li>在方法上标记其 return value 是 model 属性。</li>
</ul>
<p>本节讨论<code>@ModelAttribute</code>方法 - 前面列表中的第二个 item。控制器可以有任意数量的<code>@ModelAttribute</code>方法。所有这些方法都在同一控制器中的<code>@RequestMapping</code>方法之前调用。也可以通过<code>@ControllerAdvice</code>在控制器之间共享<code>@ModelAttribute</code>方法。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-modelattrib-method-args">控制器建议</a>部分。</p>
<p><code>@ModelAttribute</code>方法具有灵活的方法签名。它们支持许多与<code>@RequestMapping</code>方法相同的 arguments，除了<code>@ModelAttribute</code>本身或与请求体相关的任何东西。</p>
<p>以下 example 显示了<code>@ModelAttribute</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public void populateModel(@RequestParam String number, Model model) &#123;</span><br><span class="line">    model.addAttribute(accountRepository.findAccount(number));</span><br><span class="line">    &#x2F;&#x2F; add more ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 仅添加一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ModelAttribute</span><br><span class="line">public Account addAccount(@RequestParam String number) &#123;</span><br><span class="line">    return accountRepository.findAccount(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果未明确指定 name，则会根据<code>Object</code>类型选择默认 name，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Conventions.html">约定</a>的 javadoc 中所述。您始终可以使用重载的<code>addAttribute</code>方法或<code>@ModelAttribute</code>上的<code>name</code>属性(对于 return value)分配显式 name。</p>
</blockquote>
<p>您还可以在<code>@RequestMapping</code>方法上使用<code>@ModelAttribute</code>作为 method-level annotation，在这种情况下，<code>@RequestMapping</code>方法的 return value 将被解释为 model 属性。这通常不是必需的，因为它是 HTML 控制器中的默认行为，除非 return value 是<code>String</code>否则将被解释为 view name。 <code>@ModelAttribute</code>还可以自定义 model 属性 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">@ModelAttribute(&quot;myAccount&quot;)</span><br><span class="line">public Account handle() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    return account;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DataBinder"><a href="#DataBinder" class="headerlink" title="DataBinder"></a>DataBinder</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-controller-advice">与 Spring WebFlux 相同</a></p>
<p><code>@Controller</code>或<code>@ControllerAdvice</code> classes 可以有<code>@InitBinder</code>方法来初始化<code>WebDataBinder</code>的实例，而这些方法又可以：</p>
<ul>
<li>将请求参数(即表单或查询数据)绑定到 model object。</li>
<li>将 String-based 请求值(例如请求参数，路径变量，headers，cookies 等)转换为控制器方法 arguments 的目标类型。</li>
<li>在呈现 HTML 表单时将 model object 值格式化为<code>String</code>值。</li>
</ul>
<p><code>@InitBinder</code>方法可以注册 controller-specific <code>java.bean.PropertyEditor</code>或 Spring <code>Converter</code>和<code>Formatter</code>组件。此外，您可以使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-initbinder">MVC 配置</a>在全局共享的<code>FormattingConversionService</code>中注册<code>Converter</code>和<code>Formatter</code>类型。</p>
<p><code>@InitBinder</code>方法支持许多与<code>@RequestMapping</code>方法相同的 arguments，但<code>@ModelAttribute</code>(命令 object)arguments 除外。通常，它们使用<code>WebDataBinder</code>参数(用于注册)和<code>void</code> return value 声明。以下清单显示了一个 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FormController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder (1)</span><br><span class="line">    public void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">        dateFormat.setLenient(false);</span><br><span class="line">        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>定义<code>@InitBinder</code>方法。</td>
</tr>
</tbody>
</table>
</div>
<p>或者，当您通过共享<code>FormattingConversionService</code>使用<code>Formatter</code> -based 设置时，您可以 re-use 采用相同的方法并注册 controller-specific <code>Formatter</code> __mplement，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class FormController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder (1)</span><br><span class="line">    protected void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        binder.addCustomFormatter(new DateFormatter(&quot;yyyy-MM-dd&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在自定义格式化程序上定义<code>@InitBinder</code>方法。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="Exceptions-1"><a href="#Exceptions-1" class="headerlink" title="Exceptions"></a>Exceptions</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-conversion">与 Spring WebFlux 相同</a></p>
<p><code>@Controller</code>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-ann-controller-exceptions">@ControllerAdvice</a> classes 可以有<code>@ExceptionHandler</code>方法来处理来自控制器方法的 exceptions，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SimpleController &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler</span><br><span class="line">    public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exception 可以_对正在传播的 top-level exception(即，直接<code>IOException</code>被抛出)或wrapper exception 中的直接原因匹配(对于 example，包裹在<code>IllegalStateException</code>内)。</p>
<p>对于匹配 exception 类型，最好将目标 exception 声明为方法参数，如前面的 example 所示。当多个 exception 方法 match 时，root exception match 通常优先于 cause exception match。更具体地说，<code>ExceptionDepthComparator</code>用于根据抛出的 exception 类型的深度对 exceptions 进行排序。</p>
<p>或者，annotation 声明可以将 exception 类型缩小为 match，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span><br><span class="line">public ResponseEntity&lt;String&gt; handle(IOException ex) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您甚至可以使用具有非常通用参数签名的特定 exception 类型列表，如以下 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler(&#123;FileSystemException.class, RemoteException.class&#125;)</span><br><span class="line">public ResponseEntity&lt;String&gt; handle(Exception ex) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>root 和 cause exception 匹配之间的区别可能是令人惊讶的。</p>
</blockquote>
<p>在前面显示的<code>IOException</code>变体中，通常使用实际的<code>FileSystemException</code>或<code>RemoteException</code>实例作为参数调用该方法，因为它们都从<code>IOException</code>延伸。但是，如果在 wrapper exception 中传播任何这样的匹配 exception，它本身就是<code>IOException</code>，那么 passed-in exception 实例就是 wrapper exception。</p>
<p>在<code>handle(Exception)</code>变体中，行为更简单。这总是在包装场景中使用 wrapper exception 调用，在这种情况下通过<code>ex.getCause()</code>找到实际匹配的 exception。 passed-in exception 只有当它们被抛出为 top-level exceptions 时才是实际的<code>FileSystemException</code>或<code>RemoteException</code>实例。</p>
<p>我们通常建议您在参数签名中尽可能具体，减少 root 和 cause exception 类型之间不匹配的可能性。考虑将 multi-matching 方法分解为单独的<code>@ExceptionHandler</code>方法，每个方法通过其签名匹配单个特定的 exception 类型。</p>
<p>在多<code>@ControllerAdvice</code>排列中，我们建议在<code>@ControllerAdvice</code>上使用相应的 order 优先声明主根 exception 映射。虽然根 exception match 优先于某个原因，但这是在给定控制器或<code>@ControllerAdvice</code> class 的方法中定义的。这意味着 higher-priority <code>@ControllerAdvice</code> bean 上的原因 match 优先于 lower-priority <code>@ControllerAdvice</code> bean 上的任何 match(对于 example，root)。</p>
<p>最后但并非最不重要的是，<code>@ExceptionHandler</code>方法 implementation 可以选择通过以原始形式重新抛出它来退出处理给定的 exception 实例。这在您仅对 root-level 匹配或在无法静态确定的特定 context 中的匹配中感兴趣的情况下非常有用。重新生成的 exception 通过剩余的解析链传播，就好像给定的<code>@ExceptionHandler</code>方法首先不匹配一样。</p>
<p>Spring MVC 中对<code>@ExceptionHandler</code>方法的支持建立在<code>DispatcherServlet</code> level，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-controller-advice">HandlerExceptionResolver</a>机制之上。</p>
<h5 id="方法-Arguments"><a href="#方法-Arguments" class="headerlink" title="方法 Arguments"></a>方法 Arguments</h5><p><code>@ExceptionHandler</code>方法支持以下 arguments：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法论证</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Exception 类型</td>
<td>用于访问引发的 exception。</td>
</tr>
<tr>
<td><code>HandlerMethod</code></td>
<td>用于访问引发 exception 的控制器方法。</td>
</tr>
<tr>
<td><code>WebRequest</code> , <code>NativeWebRequest</code></td>
<td>无需直接使用 Servlet API 即可访问请求参数和 request 和 session 属性。</td>
</tr>
<tr>
<td><code>javax.servlet.ServletRequest</code> , <code>javax.servlet.ServletResponse</code></td>
<td>选择任何特定请求或响应类型(对于 example，<code>ServletRequest</code>或<code>HttpServletRequest</code>或 Spring 的<code>MultipartRequest</code>或<code>MultipartHttpServletRequest</code>)。</td>
</tr>
<tr>
<td><code>javax.servlet.http.HttpSession</code></td>
<td>强制存在 session。因此，这样的论证永远不会<code>null</code>。 注意 session 访问不是 thread-safe。如果允许多个请求同时访问 session，请考虑将<code>RequestMappingHandlerAdapter</code>实例的<code>synchronizeOnSession</code> flag 设置为<code>true</code>。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>目前经过身份验证的用户 - 如果已知，可能是特定的<code>Principal</code> implementation class。</td>
</tr>
<tr>
<td><code>HttpMethod</code></td>
<td>请求的 HTTP 方法。</td>
</tr>
<tr>
<td><code>java.util.Locale</code></td>
<td>当前请求 locale，由最具体的<code>LocaleResolver</code>可用 - 确定 - 生效，配置为<code>LocaleResolver</code>或<code>LocaleContextResolver</code>。</td>
</tr>
<tr>
<td><code>java.util.TimeZone</code> , <code>java.time.ZoneId</code></td>
<td>与当前请求关联的 time zone，由<code>LocaleContextResolver</code>确定。</td>
</tr>
<tr>
<td><code>java.io.OutputStream</code> , <code>java.io.Writer</code></td>
<td>用于访问原始响应主体，由 Servlet API 公开。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code> , <code>org.springframework.ui.ModelMap</code></td>
<td>用于访问 model 以获取错误响应。永远是空的。</td>
</tr>
<tr>
<td><code>RedirectAttributes</code></td>
<td>指定在重定向的情况下使用的属性 - (将附加到查询 string)和临时存储的 flash 属性，直到重定向后的请求为止。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-exceptionhandlers">重定向属性</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-redirecting-passing-data">Flash 属性</a>。</td>
</tr>
<tr>
<td><code>@SessionAttribute</code></td>
<td>用于访问任何 session 属性，与 session 属性存储在 session 中的 model 属性相反。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-flash-attributes">@SessionAttribute</a>。</td>
</tr>
<tr>
<td><code>@RequestAttribute</code></td>
<td>用于访问请求属性。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-sessionattribute">@RequestAttribute</a>。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Return-值"><a href="#Return-值" class="headerlink" title="Return 值"></a>Return 值</h5><p><code>@ExceptionHandler</code>方法支持以下 return 值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Return value</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@ResponseBody</code></td>
<td>return value 通过<code>HttpMessageConverter</code>实例转换并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-requestattrib">@ResponseBody</a>。</td>
</tr>
<tr>
<td><code>HttpEntity&lt;B&gt;</code> , <code>ResponseEntity&lt;B&gt;</code></td>
<td>return value 指定完整响应(包括 HTTP headers 和正文)通过<code>HttpMessageConverter</code>实例转换并写入响应。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responsebody">ResponseEntity</a>。</td>
</tr>
<tr>
<td><code>String</code></td>
<td>要使用<code>ViewResolver</code> implementations 解析并与隐式 model 一起使用的视图 name - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(如前所述)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>View</code></td>
<td>一个<code>View</code>实例，用于与隐式 model 一起呈现 - 通过命令 objects 和<code>@ModelAttribute</code>方法确定。处理程序方法还可以通过声明<code>Model</code>参数(先前描述)以编程方式丰富 model。</td>
</tr>
<tr>
<td><code>java.util.Map</code> , <code>org.springframework.ui.Model</code></td>
<td>要添加到隐式 model 的属性，其中 view name 通过<code>RequestToViewNameTranslator</code>隐式确定。</td>
</tr>
<tr>
<td><code>@ModelAttribute</code></td>
<td>要添加到 model 的属性，其中 view name 通过<code>RequestToViewNameTranslator</code>隐式确定。 注意<code>@ModelAttribute</code>是可选的。请参阅本 table 末尾的“任何其他 return value”。</td>
</tr>
<tr>
<td><code>ModelAndView</code> object</td>
<td>要使用的视图和 model 属性，以及可选的响应状态。</td>
</tr>
<tr>
<td><code>void</code></td>
<td>具有<code>void</code> return 类型(或<code>null</code> return value)的方法被认为已完全处理了响应，如果它还具有<code>ServletResponse</code> <code>OutputStream</code>参数或<code>@ResponseStatus</code> annotation。如果控制器进行了正<code>ETag</code>或<code>lastModified</code>时间戳检查，那么同样也是 true(详见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-responseentity">控制器</a>)。 如果上面的 none 是 true，则<code>void</code> return 类型也可以为 REST 控制器指示“无响应主体”或为 HTML 控制器指定默认视图 name。</td>
</tr>
<tr>
<td>任何其他 return value</td>
<td>如果 return value 与上述任何一个都不匹配且不是简单类型(由<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#mvc-caching-etag-lastmodified">BeanUtils 的#isSimpleProperty</a>确定)，则默认情况下，它被视为要添加到 model 的 model 属性。如果它是一个简单的类型，它仍然没有得到解决。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="REST-API异常"><a href="#REST-API异常" class="headerlink" title="REST-API异常"></a>REST-API异常</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#isSimpleProperty-java.lang.Class-">与 Spring WebFlux 相同</a></p>
<p>REST 服务的 common 要求是在响应正文中包含错误详细信息。 Spring Framework 不会自动执行此操作，因为响应正文中的错误详细信息的表示形式为 application-specific。但是，<code>@RestController</code>可以使用<code>@ExceptionHandler</code>方法和<code>ResponseEntity</code> return value 来设置响应的状态和正文。此类方法也可以在<code>@ControllerAdvice</code> classes 中声明，以便全局应用它们。</p>
<p>在响应主体中实现带有错误详细信息的 global exception 处理的应用程序应考虑扩展<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html">ResponseEntityExceptionHandler</a>，它提供 Spring MVC 引发的 exceptions 的处理，并提供钩子来自定义响应主体。要使用它，创建<code>ResponseEntityExceptionHandler</code>的子类，用<code>@ControllerAdvice</code>注释它，覆盖必要的方法，并将其声明为 Spring bean。</p>
<h4 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="ControllerAdvice"></a>ControllerAdvice</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-ann-rest-exceptions">与 Spring WebFlux 相同</a></p>
<p>通常，<code>@ExceptionHandler</code>，<code>@InitBinder</code>和<code>@ModelAttribute</code>方法适用于声明它们的<code>@Controller</code> class(或 class 层次结构)。如果您希望此类方法更全局地应用(跨控制器)，则可以在标有<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>的 class 中声明它们。</p>
<p><code>@ControllerAdvice</code>标有<code>@Component</code>，这意味着这样的 classes 可以通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-ann-controller-advice">component 扫描</a>注册为 Spring beans。 <code>@RestControllerAdvice</code>也是 meta-annotation 标有<code>@ControllerAdvice</code>和<code>@ResponseBody</code>，这实质上意味着通过消息转换(与视图分辨率或模板渲染相比)将<code>@ExceptionHandler</code>方法呈现给响应主体。</p>
<p>在启动时，<code>@RequestMapping</code>和<code>@ExceptionHandler</code>方法的基础结构 classes 检测<code>@ControllerAdvice</code>类型的 Spring beans，然后在运行时应用它们的方法。 Global <code>@ExceptionHandler</code>方法(来自<code>@ControllerAdvice</code>)在本地方法(来自<code>@Controller</code>)之后应用。相比之下，global <code>@ModelAttribute</code>和<code>@InitBinder</code>方法在本地方法之前应用。</p>
<p>默认情况下，<code>@ControllerAdvice</code>方法适用于每个请求(即所有控制器)，但您可以使用 annotation 上的属性将其缩小到控制器的子集，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Target all Controllers annotated with @RestController</span><br><span class="line">@ControllerAdvice(annotations &#x3D; RestController.class)</span><br><span class="line">public class ExampleAdvice1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers within specific packages</span><br><span class="line">@ControllerAdvice(&quot;org.example.controllers&quot;)</span><br><span class="line">public class ExampleAdvice2 &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers assignable to specific classes</span><br><span class="line">@ControllerAdvice(assignableTypes &#x3D; &#123;ControllerInterface.class, AbstractController.class&#125;)</span><br><span class="line">public class ExampleAdvice3 &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 example 中的 selectors 在运行时进行评估，如果广泛使用，可能会对 performance 产生负面影响。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/ControllerAdvice.html">@ControllerAdvice</a> javadoc。</p>
<h3 id="URI链接"><a href="#URI链接" class="headerlink" title="URI链接"></a>URI链接</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#beans-java-instantiating-container-scan">与 Spring WebFlux 相同</a></p>
<p>本节介绍 Spring Framework 中可用于处理 URI 的各种选项。</p>
<h4 id="UriComponents"><a href="#UriComponents" class="headerlink" title="UriComponents"></a>UriComponents</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>有助于使用变量从 URI 模板中构建 URI，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)  (1)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)  (2)</span><br><span class="line">        .encode() (3)</span><br><span class="line">        .build(); (4)</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriComponents.expand(&quot;Westin&quot;, &quot;123&quot;).toUri();  (5)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>带有 URI 模板的静态工厂方法。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>添加或替换 URI 组件。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>请求编码 URI 模板和 URI 变量。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td>Build a <code>UriComponents</code>。</td>
</tr>
<tr>
<td><strong>5</strong></td>
<td>展开变量并获取<code>URI</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>前面的 example 可以合并为一个链并用<code>buildAndExpand</code>缩短，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .encode()</span><br><span class="line">        .buildAndExpand(&quot;Westin&quot;, &quot;123&quot;)</span><br><span class="line">        .toUri();</span><br></pre></td></tr></table></figure>
<p>您可以通过直接转到 URI(这意味着编码)来进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>
<p>您可以使用完整的 URI 模板进一步缩短它，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder</span><br><span class="line">        .fromUriString(&quot;http:&#x2F;&#x2F;example.com&#x2F;hotels&#x2F;&#123;hotel&#125;?q&#x3D;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="UriBuilder"><a href="#UriBuilder" class="headerlink" title="UriBuilder"></a>UriBuilder</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-uri-building">UriComponentsBuilder</a>实现<code>UriBuilder</code>。您可以使用<code>UriBuilderFactory</code>创建<code>UriBuilder</code>。 <code>UriBuilderFactory</code>和<code>UriBuilder</code>一起提供了一种可插入机制，可以根据共享配置(例如基本 URL，编码首选项和其他详细信息)从 URI 模板中构建 URI。</p>
<p>您可以使用<code>UriBuilderFactory</code>配置<code>RestTemplate</code>和<code>WebClient</code>以自定义 URI 的准备。 <code>DefaultUriBuilderFactory</code>是<code>UriBuilderFactory</code>的默认_impleration，它在内部使用<code>UriComponentsBuilder</code>并公开共享 configuration 选项。</p>
<p>以下 example 显示了如何配置<code>RestTemplate</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="line"></span><br><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.org&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">RestTemplate restTemplate &#x3D; new RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br></pre></td></tr></table></figure>
<p>以下 example 配置<code>WebClient</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;</span><br><span class="line"></span><br><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.org&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);</span><br><span class="line"></span><br><span class="line">WebClient client &#x3D; WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>
<p>此外，您还可以直接使用<code>DefaultUriBuilderFactory</code>。它类似于使用<code>UriComponentsBuilder</code>但是，它不是静态工厂方法，而是一个包含 configuration 和 preferences 的实际实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.com&quot;;</span><br><span class="line">DefaultUriBuilderFactory uriBuilderFactory &#x3D; new DefaultUriBuilderFactory(baseUrl);</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriBuilderFactory.uriString(&quot;&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">        .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">        .build(&quot;Westin&quot;, &quot;123&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="URI编码"><a href="#URI编码" class="headerlink" title="URI编码"></a>URI编码</h4><p>Spring MVC 和 Spring WebFlux</p>
<p><code>UriComponentsBuilder</code>在两个级别公开编码选项：</p>
<ul>
<li>首先<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponentsBuilder.html#web-uricomponents">UriComponentsBuilder#encode()</a>：Pre-encodes URI 模板，然后在扩展时严格编码 URI 变量。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/util/UriComponents.html#encode--">UriComponents#encode()</a>：扩展 URI 变量后对 URI 组件进行编码。</li>
</ul>
<p>这两个选项都使用转义的八位字节替换 non-ASCII 和非法字符。但是，第一个选项还会替换出现在 URI 变量中的保留含义的字符。</p>
<blockquote>
<p>考虑“;”，这在路径中是合法的但具有保留意义。第一个选项取代“;”在 URI 变量中使用“％3B”但在 URI 模板中没有。相比之下，第二个选项永远不会替换“;”，因为它是路径中的合法字符。</p>
</blockquote>
<p>对于大多数情况，第一个选项可能会给出预期结果，因为它将 URI 变量视为完全编码的不透明数据，而选项 2 仅在 URI 变量故意包含保留字符时才有用。</p>
<p>以下 example 使用第一个选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;&quot;)</span><br><span class="line">            .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">            .encode()</span><br><span class="line">            .buildAndExpand(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br><span class="line">            .toUri();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Result is &quot;&#x2F;hotel%20list&#x2F;New%20York?q&#x3D;foo%2Bbar&quot;</span><br></pre></td></tr></table></figure>
<p>您可以通过直接转到 URI(这意味着编码)来缩短前面的 example，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;&quot;)</span><br><span class="line">            .queryParam(&quot;q&quot;, &quot;&#123;q&#125;&quot;)</span><br><span class="line">            .build(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br></pre></td></tr></table></figure>
<p>您可以使用完整的 URI 模板进一步缩短它，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">URI uri &#x3D; UriComponentsBuilder.fromPath(&quot;&#x2F;hotel list&#x2F;&#123;city&#125;?q&#x3D;&#123;q&#125;&quot;)</span><br><span class="line">            .build(&quot;New York&quot;, &quot;foo+bar&quot;)</span><br></pre></td></tr></table></figure>
<p><code>WebClient</code>和<code>RestTemplate</code>通过<code>UriBuilderFactory</code>策略在内部扩展和编码 URI 模板。两者都可以配置自定义策略。如下例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl &#x3D; &quot;http:&#x2F;&#x2F;example.com&quot;;</span><br><span class="line">DefaultUriBuilderFactory factory &#x3D; new DefaultUriBuilderFactory(baseUrl)</span><br><span class="line">factory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Customize the RestTemplate..</span><br><span class="line">RestTemplate restTemplate &#x3D; new RestTemplate();</span><br><span class="line">restTemplate.setUriTemplateHandler(factory);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Customize the WebClient..</span><br><span class="line">WebClient client &#x3D; WebClient.builder().uriBuilderFactory(factory).build();</span><br></pre></td></tr></table></figure>
<p><code>DefaultUriBuilderFactory</code> implementation 在内部使用<code>UriComponentsBuilder</code>来扩展和编码 URI 模板。作为工厂，它提供了一个单独的位置来配置编码方法，基于以下编码模式之一：</p>
<ul>
<li><code>TEMPLATE_AND_VALUES</code>：使用<code>UriComponentsBuilder#encode()</code>(对应于前面列表中的第一个选项)pre-encode URI 模板，并在扩展时严格编码 URI 变量。</li>
<li><code>VALUES_ONLY</code>：不对 URI 模板进行编码，而是在将 URI 变量扩展到模板之前，通过<code>UriUtils#encodeUriUriVariables</code>对 URI 变量应用严格编码。</li>
<li><code>URI_COMPONENTS</code>：使用<code>UriComponents#encode()</code>(对应于前面列表中的第二个选项)，在扩展 URI 变量后对 URI component value 进行编码。</li>
<li><code>NONE</code>：未应用编码。</li>
</ul>
<p>出于历史原因和向后兼容性，<code>RestTemplate</code>设置为<code>EncodingMode.URI_COMPONENTS</code>。 <code>WebClient</code>依赖于<code>DefaultUriBuilderFactory</code>中的默认 value，它在 5.0.x 中从<code>EncodingMode.URI_COMPONENTS</code>更改为 5.1 中的<code>EncodingMode.TEMPLATE_AND_VALUES</code>。</p>
<h4 id="相对Servlet请求"><a href="#相对Servlet请求" class="headerlink" title="相对Servlet请求"></a>相对Servlet请求</h4><p>您可以使用<code>ServletUriComponentsBuilder</code>创建相对于当前请求的 URI，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest request &#x3D; ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Re-uses host, scheme, port, path and query string...</span><br><span class="line"></span><br><span class="line">ServletUriComponentsBuilder ucb &#x3D; ServletUriComponentsBuilder.fromRequest(request)</span><br><span class="line">        .replaceQueryParam(&quot;accountId&quot;, &quot;&#123;id&#125;&quot;).build()</span><br><span class="line">        .expand(&quot;123&quot;)</span><br><span class="line">        .encode();</span><br></pre></td></tr></table></figure>
<p>您可以创建相对于 context 路径的 URI，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Re-uses host, port and context path...</span><br><span class="line"></span><br><span class="line">ServletUriComponentsBuilder ucb &#x3D; ServletUriComponentsBuilder.fromContextPath(request)</span><br><span class="line">        .path(&quot;&#x2F;accounts&quot;).build()</span><br></pre></td></tr></table></figure>
<p>您可以创建相对于 Servlet 的 URI(对于 example，<code>/main/*</code>)，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Re-uses host, port, context path, and Servlet prefix...</span><br><span class="line"></span><br><span class="line">ServletUriComponentsBuilder ucb &#x3D; ServletUriComponentsBuilder.fromServletMapping(request)</span><br><span class="line">        .path(&quot;&#x2F;accounts&quot;).build()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从 5.1 开始，<code>ServletUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code> headers 的信息，这些信息指定了 client-originated 地址。考虑使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#encode--">ForwardedHeaderFilter</a>来提取和使用或丢弃此类_header。</p>
</blockquote>
<h4 id="控制器的链接"><a href="#控制器的链接" class="headerlink" title="控制器的链接"></a>控制器的链接</h4><p>Spring MVC 提供了一种准备控制器方法链接的机制。对于 example，以下 MVC 控制器允许创建链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;hotels&#x2F;&#123;hotel&#125;&quot;)</span><br><span class="line">public class BookingController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;bookings&#x2F;&#123;booking&#125;&quot;)</span><br><span class="line">    public ModelAndView getBooking(@PathVariable Long booking) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以通过 name 引用方法来准备链接，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents &#x3D; MvcUriComponentsBuilder</span><br><span class="line">    .fromMethodName(BookingController.class, &quot;getBooking&quot;, 21).buildAndExpand(42);</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，我们提供了实际的方法参数值(在本例中为 long value：<code>21</code>)，用作路径变量并插入到 URL 中。此外，我们提供 value，<code>42</code>来填充任何剩余的 URI 变量，例如从 type-level 请求映射继承的<code>hotel</code>变量。如果方法有更多的 arguments，我们可以为 URL 不需要的 arguments 提供 null。通常，只有<code>@PathVariable</code>和<code>@RequestParam</code> arguments 与构造 URL 相关。</p>
<p>还有其他方法可以使用<code>MvcUriComponentsBuilder</code>。对于 example，您可以使用类似于通过代理进行 mock 测试的技术，以避免通过 name 引用控制器方法，如下面的 example 所示(example 假定<code>MvcUriComponentsBuilder.on</code>的静态 import)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UriComponents uriComponents &#x3D; MvcUriComponentsBuilder</span><br><span class="line">    .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当控制器方法签名可用于与<code>fromMethodCall</code>创建链接时，它们的设计受到限制。除了需要正确的参数签名之外，return 类型还存在技术限制(即，为链接构建器调用生成运行时代理)，因此 return 类型不能是<code>final</code>。特别是，视图名称的 common <code>String</code> return 类型在此处不起作用。您应该使用<code>ModelAndView</code>或甚至普通的<code>Object</code>(带有<code>String</code> return value)。</p>
</blockquote>
<p>前面的示例在<code>MvcUriComponentsBuilder</code>中使用静态方法。在内部，它们依赖<code>ServletUriComponentsBuilder</code>从当前请求的 scheme，host，port，context 路径和 servlet 路径准备基本 URL。这在大多数情况下效果很好。但是，有时，它可能是不够的。例如，您可能位于请求的 context 之外(例如，准备链接的批处理 process)，或者您可能需要插入路径前缀(例如从请求路径中删除的 locale 前缀，并且需要 re-inserted 进入链接)。</p>
<p>对于这种情况，您可以使用接受<code>UriComponentsBuilder</code>的静态<code>fromXxx</code>重载方法来使用基本 URL。或者，您可以使用基本 URL 创建<code>MvcUriComponentsBuilder</code>的实例，然后使用 instance-based <code>withXxx</code>方法。对于 example，以下列表使用<code>withMethodCall</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UriComponentsBuilder base &#x3D; ServletUriComponentsBuilder.fromCurrentContextPath().path(&quot;&#x2F;en&quot;);</span><br><span class="line">MvcUriComponentsBuilder builder &#x3D; MvcUriComponentsBuilder.relativeTo(base);</span><br><span class="line">builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);</span><br><span class="line"></span><br><span class="line">URI uri &#x3D; uriComponents.encode().toUri();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从 5.1 开始，<code>MvcUriComponentsBuilder</code>忽略来自<code>Forwarded</code>和<code>X-Forwarded-*</code> headers 的信息，这些信息指定了 client-originated 地址。考虑使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-forwarded-headers">ForwardedHeaderFilter</a>来提取和使用或丢弃此类_header。</p>
</blockquote>
<h4 id="视图中的链接"><a href="#视图中的链接" class="headerlink" title="视图中的链接"></a>视图中的链接</h4><p>在 Thymeleaf，FreeMarker 或 JSP 等视图中，您可以通过引用每个请求映射的隐式或显式分配的 name 来构建指向已注释控制器的链接。</p>
<p>考虑以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;people&#x2F;&#123;id&#125;&#x2F;addresses&quot;)</span><br><span class="line">public class PersonAddressController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&#123;country&#125;&quot;)</span><br><span class="line">    public HttpEntity getAddress(@PathVariable String country) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给定前面的控制器，您可以从 JSP 准备链接，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&quot; prefix&#x3D;&quot;s&quot; %&gt;</span><br><span class="line">...</span><br><span class="line">&lt;a href&#x3D;&quot;$&#123;s:mvcUrl(&#39;PAC#getAddress&#39;).arg(0,&#39;US&#39;).buildAndExpand(&#39;123&#39;)&#125;&quot;&gt;Get Address&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 依赖于 Spring 标记 library(即 META-INF/spring.tld)中声明的<code>mvcUrl</code> function，但很容易定义自己的 function 或为其他模板技术准备类似的函数。</p>
<p>这是如何工作的。在启动时，每个<code>@RequestMapping</code>都通过<code>HandlerMethodMappingNamingStrategy</code>分配一个默认 name，其默认 implementation 使用 class 的大写字母和方法 name(对于 example，<code>ThingController</code>中的<code>getThing</code>方法变为“TC#getThing”)。如果存在 name 冲突，则可以使用<code>@RequestMapping(name=&quot;..&quot;)</code>分配显式 name 或实现自己的<code>HandlerMethodMappingNamingStrategy</code>。</p>
<h3 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-forwarded-headers">与 WebFlux 相比</a></p>
<p>Spring MVC 与 Servlet 3.0 异步请求<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-vs-webflux">处理</a>有一个广泛的 integration：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-processing">DeferredResult</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-deferredresult">可赎回</a> return 控制器方法中的值，并为单个异步 return value 提供基本支持。</li>
<li>控制器可以<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-callable">流</a>多个值，包括<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-http-streaming">SSE</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-sse">原始数据</a>。</li>
<li>控制器可以使用 reactive clients 和 return <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-output-stream">reactive 类型</a>进行响应处理。</li>
</ul>
<h4 id="DeferredResult"><a href="#DeferredResult" class="headerlink" title="DeferredResult"></a>DeferredResult</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-reactive-types">与 WebFlux 相比</a></p>
<p>一旦异步请求处理 feature 在 Servlet 容器中<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-vs-webflux">启用</a>，控制器方法就可以用<code>DeferredResult</code>包装任何支持的控制器方法 return value，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;quotes&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public DeferredResult&lt;String&gt; quotes() &#123;</span><br><span class="line">    DeferredResult&lt;String&gt; deferredResult &#x3D; new DeferredResult&lt;String&gt;();</span><br><span class="line">    &#x2F;&#x2F; Save the deferredResult somewhere..</span><br><span class="line">    return deferredResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; From some other thread...</span><br><span class="line">deferredResult.setResult(data);</span><br></pre></td></tr></table></figure>
<p>控制器可以从不同的线程异步生成 return value - 例如，响应外部 event(JMS 消息)，计划任务或其他 event。</p>
<h4 id="可赎回"><a href="#可赎回" class="headerlink" title="可赎回"></a>可赎回</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-configuration">与 WebFlux 相比</a></p>
<p>控制器可以使用<code>java.util.concurrent.Callable</code>包装任何受支持的 return value，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@PostMapping</span><br><span class="line">public Callable&lt;String&gt; processUpload(final MultipartFile file) &#123;</span><br><span class="line"></span><br><span class="line">    return new Callable&lt;String&gt;() &#123;</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            &#x2F;&#x2F; ...</span><br><span class="line">            return &quot;someView&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-vs-webflux">配置</a> <code>TaskExecutor</code>运行给定任务来获得 return value。</p>
<h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-configuration-spring-mvc">与 WebFlux 相比</a></p>
<p>以下是 Servlet 异步请求处理的简要概述：</p>
<ul>
<li>通过调用<code>request.startAsync()</code>可以将<code>ServletRequest</code>置于异步模式。这样做的主要作用是 Servlet(以及任何过滤器)可以退出，但响应保持打开状态以便稍后处理完成。</li>
<li>对<code>request.startAsync()</code>的调用返回<code>AsyncContext</code>，您可以使用它来进一步控制异步处理。对于 example，它提供<code>dispatch</code>方法，类似于 Servlet API 中的 forward，除了它允许 Servlet 容器线程上的 application resume request 处理。</li>
<li><code>ServletRequest</code>提供对当前<code>DispatcherType</code>的访问，您可以使用它来区分处理初始请求，异步调度，转发和其他调度程序类型。</li>
</ul>
<p><code>DeferredResult</code>处理工作如下：</p>
<ul>
<li>控制器返回<code>DeferredResult</code>并将其保存在可以访问的某个 in-memory 队列或列表中。</li>
<li>Spring MVC calls <code>request.startAsync()</code>。</li>
<li>同时，<code>DispatcherServlet</code>和所有已配置的过滤器退出请求处理线程，但响应仍保持打开状态。</li>
<li>application 从某个线程设置<code>DeferredResult</code>，Spring MVC 将请求调度回 Servlet 容器。</li>
<li>再次调用<code>DispatcherServlet</code>，并使用异步生成的 return value 继续处理。</li>
</ul>
<p><code>Callable</code>处理工作如下：</p>
<ul>
<li>控制器返回<code>Callable</code>。</li>
<li>Spring MVC calls <code>request.startAsync()</code>并将<code>Callable</code>提交给<code>TaskExecutor</code>以便在单独的线程中进行处理。</li>
<li>同时，<code>DispatcherServlet</code>和所有过滤器退出 Servlet 容器线程，但响应仍保持打开状态。</li>
<li>最终<code>Callable</code>产生一个结果，Spring MVC 将请求发送回 Servlet 容器以完成处理。</li>
<li>再次调用<code>DispatcherServlet</code>，并使用<code>Callable</code>中异步生成的 return value 继续处理。</li>
</ul>
<p>对于更多背景和 context，您还可以阅读在 Spring MVC 3.2 中引入异步请求处理支持的<a target="_blank" rel="noopener" href="https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support">博客文章</a>。</p>
<h5 id="Exception处理"><a href="#Exception处理" class="headerlink" title="Exception处理"></a>Exception处理</h5><p>使用<code>DeferredResult</code>时，可以选择是否使用 exception 调用<code>setResult</code>或<code>setErrorResult</code>。在这两种情况下，Spring MVC 都会将请求调度回 Servlet 容器以完成处理。然后将其视为控制器方法返回给定的 value 或者就像它产生给定的 exception 一样。然后 exception 遍历常规 exception 处理机制(对于 example，调用<code>@ExceptionHandler</code>方法)。</p>
<p>当你使用<code>Callable</code>时，会出现类似的处理逻辑，主要区别在于结果是从<code>Callable</code>返回的，或者是由它引发的 exception。</p>
<h5 id="拦截"><a href="#拦截" class="headerlink" title="拦截"></a>拦截</h5><p><code>HandlerInterceptor</code>实例可以是<code>AsyncHandlerInterceptor</code>类型，以便在启动异步处理的初始请求(而不是<code>postHandle</code>和<code>afterCompletion</code>)上接收<code>afterConcurrentHandlingStarted</code>回调。</p>
<p><code>HandlerInterceptor</code> implementations 还可以注册<code>CallableProcessingInterceptor</code>或<code>DeferredResultProcessingInterceptor</code>，以更深入地集成异步请求的生命周期(例如，处理超时 event)。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/AsyncHandlerInterceptor.html">AsyncHandlerInterceptor</a>。</p>
<p><code>DeferredResult</code>提供<code>onTimeout(Runnable)</code>和<code>onCompletion(Runnable)</code>回调。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/request/async/DeferredResult.html">DeferredResult 的 javadoc</a>。 <code>Callable</code>可以替换<code>WebAsyncTask</code>，它为超时和完成回调公开了其他方法。</p>
<h5 id="与-WebFlux-相比"><a href="#与-WebFlux-相比" class="headerlink" title="与 WebFlux 相比"></a>与 WebFlux 相比</h5><p>Servlet API 最初是为了通过 Filter-Servlet 链进行单次传递而构建的。在 Servlet 3.0 中添加的异步请求处理允许 applications 退出 Filter-Servlet 链但保持响应打开以进行进一步处理。 Spring MVC 异步支持是围绕该机制构建的。当控制器返回<code>DeferredResult</code>时，退出 Filter-Servlet 链，并释放 Servlet 容器线程。稍后，当设置<code>DeferredResult</code>时，会进行<code>ASYNC</code>调度(到同一个 URL)，在此期间再次映射控制器，但不使用调用它，而是使用<code>DeferredResult</code> value(就像控制器返回它一样)以恢复处理。</p>
<p>相比之下，Spring WebFlux 既不构建在 Servlet API 上，也不需要这样的异步请求处理 feature，因为它是异步的设计。异步处理内置于所有 framework contracts 中，并通过请求处理的所有阶段进行内在支持。</p>
<p>从编程 model 的角度来看，Spring MVC 和 Spring WebFlux 在控制器方法中都支持异步和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-vs-webflux">Reactive 类型</a>作为 return 值。 Spring MVC 甚至支持流媒体，包括 reactive 背压。但是，对响应的单独写入仍然是阻塞(并且在单独的线程上执行)，这与 WebFlux 不同，WebFlux 依赖于 non-blocking I/O 并且每次写入不需要额外的线程。</p>
<p>另一个根本区别是 Spring MVC 不支持控制器方法 arguments 中的异步或 reactive 类型(对于 example，<code>@RequestBody</code>，<code>@RequestPart</code>和其他)，也不支持异步和 reactive 类型作为 model 属性。 Spring WebFlux 确实支持所有这些。</p>
<h4 id="HTTP-流媒体"><a href="#HTTP-流媒体" class="headerlink" title="HTTP 流媒体"></a>HTTP 流媒体</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-async-reactive-types">与 Spring WebFlux 相同</a></p>
<p>您可以将<code>DeferredResult</code>和<code>Callable</code>用于单个异步 return value。如果要生成多个异步值并将其写入响应，该怎么办？本节介绍如何执行此操作。</p>
<h5 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h5><p>您可以使用<code>ResponseBodyEmitter</code> return value 生成 objects 流，其中每个 object 都使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-codecs-streaming">HttpMessageConverter</a>序列化并写入响应，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;events&quot;)</span><br><span class="line">public ResponseBodyEmitter handle() &#123;</span><br><span class="line">    ResponseBodyEmitter emitter &#x3D; new ResponseBodyEmitter();</span><br><span class="line">    &#x2F;&#x2F; Save the emitter somewhere..</span><br><span class="line">    return emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In some other thread</span><br><span class="line">emitter.send(&quot;Hello once&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; and again later on</span><br><span class="line">emitter.send(&quot;Hello again&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; and done at some point</span><br><span class="line">emitter.complete();</span><br></pre></td></tr></table></figure>
<p>您还可以在<code>ResponseEntity</code>中使用<code>ResponseBodyEmitter</code>作为正文，以便自定义响应的状态和 headers。</p>
<p>当<code>emitter</code>抛出<code>IOException</code>时(对于 example，如果 remote client 消失了)，applications 不负责清理连接，不应该调用<code>emitter.complete</code>或<code>emitter.completeWithError</code>。相反，servlet 容器会自动启动<code>AsyncListener</code>错误通知，其中 Spring MVC 进行<code>completeWithError</code>调用。反过来，此调用会对 application 执行最后一次<code>ASYNC</code>调度，在此期间 Spring MVC 将调用已配置的 exception 解析器并完成请求。</p>
<h5 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h5><p><code>SseEmitter</code>(<code>ResponseBodyEmitter</code>的子类)提供对<a target="_blank" rel="noopener" href="https://www.w3.org/TR/eventsource/">Server-Sent Events</a>的支持，其中从服务器发送的 events 根据 W3C SSE 规范进行格式化。要从控制器生成 SSE 流，return <code>SseEmitter</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(path&#x3D;&quot;&#x2F;events&quot;, produces&#x3D;MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">public SseEmitter handle() &#123;</span><br><span class="line">    SseEmitter emitter &#x3D; new SseEmitter();</span><br><span class="line">    &#x2F;&#x2F; Save the emitter somewhere..</span><br><span class="line">    return emitter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; In some other thread</span><br><span class="line">emitter.send(&quot;Hello once&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; and again later on</span><br><span class="line">emitter.send(&quot;Hello again&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; and done at some point</span><br><span class="line">emitter.complete();</span><br></pre></td></tr></table></figure>
<p>虽然 SSE 是流式传输到浏览器的主要选项，但请注意 Internet Explorer 不支持 Server-Sent Events。考虑使用 Spring 的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#rest-message-conversion">WebSocket 消息传递</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket">SockJS 后备</a>传输(包括 SSE)，它们针对各种浏览器。</p>
<p>有关 exception 处理的注释，另请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-fallback">上一节</a>。</p>
<h5 id="原始数据"><a href="#原始数据" class="headerlink" title="原始数据"></a>原始数据</h5><p>有时，绕过消息转换并直接流式传输到响应<code>OutputStream</code>(对于 example，用于文件下载)非常有用。您可以使用<code>StreamingResponseBody</code> return value 类型执行此操作，如以下 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;download&quot;)</span><br><span class="line">public StreamingResponseBody handle() &#123;</span><br><span class="line">    return new StreamingResponseBody() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void writeTo(OutputStream outputStream) throws IOException &#123;</span><br><span class="line">            &#x2F;&#x2F; write...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在<code>ResponseEntity</code>中使用<code>StreamingResponseBody</code>作为正文来自定义响应的状态和 headers。</p>
<h4 id="Reactive类型"><a href="#Reactive类型" class="headerlink" title="Reactive类型"></a>Reactive类型</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-async-objects">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 支持在控制器中使用 reactive client libraries(也可以在 WebFlux 部分中读取<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-codecs-streaming">Reactive Libraries</a>)。这包括<code>spring-webflux</code>来自<code>spring-webflux</code>和其他，例如 Spring Data reactive data repositories。在这种情况下，能够从控制器方法 return reactive 类型很方便。</p>
<p>Reactive return 值按如下方式处理：</p>
<ul>
<li>single-value promise 适用于，类似于使用<code>DeferredResult</code>。示例包括<code>Mono</code>(Reactor)或<code>Single</code>(RxJava)。</li>
<li>具有流媒体类型(例如<code>application/stream+json</code>或<code>text/event-stream</code>)的 multi-value 流适用于，类似于使用<code>ResponseBodyEmitter</code>或<code>SseEmitter</code>。示例包括<code>Flux</code>(Reactor)或<code>Observable</code>(RxJava)。 Applications 也可以_ret <code>Flux&lt;ServerSentEvent&gt;</code>或<code>Observable&lt;ServerSentEvent&gt;</code>。</li>
<li>具有任何其他媒体类型(例如<code>application/json</code>)的 multi-value 流适用于，类似于使用<code>DeferredResult&lt;List&lt;?&gt;&gt;</code>。</li>
</ul>
<blockquote>
<p>Spring MVC 通过<code>spring-core</code>从<code>spring-core</code>支持 Reactor 和 RxJava，这使得它可以适应多个 reactive libraries。</p>
</blockquote>
<p>对于流式传输到响应，支持 reactive 背压，但是对响应的写入仍然是阻塞的，并且通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-reactive-libraries">配置</a> <code>TaskExecutor</code>在单独的线程上执行，以避免阻塞上游源(例如从<code>WebClient</code>返回的<code>Flux</code>)。默认情况下，<code>SimpleAsyncTaskExecutor</code>用于阻塞写入，但在加载时不适用。如果您计划使用 reactive 类型进行流式处理，则应使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-configuration-spring-mvc">MVC configuration</a>配置任务执行程序。</p>
<h4 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-async-configuration-spring-mvc">与 Spring WebFlux 相同</a></p>
<p>当 remote client 消失时，Servlet API 不会提供任何通知。因此，在流式传输到响应时，无论是通过<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-codecs-streaming">SseEmitter</a>还是&lt;&lt; mvc-ann-async-reactive-types ,reactive types&gt;，定期发送数据都很重要，因为如果 client 断开连接，则写入失败。发送可以采用空(comment-only)SSE event 或任何其他数据的形式，另一方必须将其解释为心跳并忽略。</p>
<p>或者，考虑使用具有 built-in 心跳机制的 web 消息传递解决方案(例如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-sse">STOMP over WebSocket</a>或带有<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp">SockJS</a>的 WebSocket)。</p>
<h4 id="组态"><a href="#组态" class="headerlink" title="组态"></a>组态</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-fallback">与 WebFlux 相比</a></p>
<p>必须在 Servlet 容器 level 上启用异步请求处理 feature。 MVC configuration 还为异步请求公开了几个选项。</p>
<h5 id="Servlet容器"><a href="#Servlet容器" class="headerlink" title="Servlet容器"></a>Servlet容器</h5><p>Filter 和 Servlet 声明的<code>asyncSupported</code> flag 需要设置为<code>true</code>以启用异步请求处理。此外，应声明 Filter 映射以处理<code>ASYNC</code> <code>javax.servlet.DispatchType</code>。</p>
<p>在 Java configuration 中，当您使用<code>AbstractAnnotationConfigDispatcherServletInitializer</code>初始化 Servlet 容器时，这将自动完成。</p>
<p>在<code>web.xml</code> configuration 中，您可以将<code>&lt;async-supported&gt;true&lt;/async-supported&gt;</code>添加到<code>DispatcherServlet</code>和<code>Filter</code>声明中，并将<code>&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;</code>添加到过滤器映射中。</p>
<h5 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h5><p>MVC configuration 公开了与异步请求处理相关的以下选项：</p>
<ul>
<li>Java configuration：在<code>WebMvcConfigurer</code>上使用<code>configureAsyncSupport</code>回调。</li>
<li>XML 命名空间：使用<code>&lt;mvc:annotation-driven&gt;</code>下的<code>&lt;async-support&gt;</code>元素。</li>
</ul>
<p>您可以配置以下内容：</p>
<ul>
<li>异步请求的默认超时 value，如果未设置，则取决于底层的 Servlet 容器(对于 example，Tomcat 上为 10 秒)。</li>
<li><code>AsyncTaskExecutor</code>用于在使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-ann-async-vs-webflux">Reactive 类型</a>进行流式传输时阻止写入以及用于执行从控制器方法返回的<code>Callable</code>实例。如果您使用 reactive 类型进行流式处理或者使用 return <code>Callable</code>的控制器方法，我们强烈建议您配置此 property，因为默认情况下它是<code>SimpleAsyncTaskExecutor</code>。</li>
<li><code>DeferredResultProcessingInterceptor</code> implementations 和<code>CallableProcessingInterceptor</code> __mplementations。</li>
</ul>
<p>请注意，您还可以在<code>DeferredResult</code>，<code>ResponseBodyEmitter</code>和<code>SseEmitter</code>上设置默认超时值。对于<code>Callable</code>，您可以使用<code>WebAsyncTask</code>来提供超时值。</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-async-reactive-types">与 Spring WebFlux 相同</a></p>
<p>Spring MVC 允许您处理 CORS(Cross-Origin 资源共享)。本节介绍如何执行此操作。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors">与 Spring WebFlux 相同</a></p>
<p>出于安全原因，浏览器禁止 AJAX calls 到当前源之外的资源。例如，您可以将您的银行帐户放在一个标签中，将 evil.com 放在另一个标签中。来自 evil.com 的脚本不应该使用您的凭据向您的银行 API 发出 AJAX 请求 - 例如从您的帐户中提取资金！</p>
<p>Cross-Origin 资源共享(CORS)是由<a target="_blank" rel="noopener" href="https://caniuse.com/#webflux-cors-intro">大多数浏览器</a>实现的<a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">W3C 规范</a>，它允许您指定授权的 cross-domain 请求类型，而不是使用基于 IFRAME 或 JSONP 的安全性较低且功能较弱的变通方法。</p>
<h4 id="Processing-1"><a href="#Processing-1" class="headerlink" title="Processing"></a>Processing</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#feat=cors">与 Spring WebFlux 相同</a></p>
<p>CORS 规范区分了预检，简单和实际请求。要了解 CORS 的工作原理，您可以阅读<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">本文</a>等许多其他内容，或者查看规范以获取更多详细信息。</p>
<p>Spring MVC <code>HandlerMapping</code> implementations 为 CORS 提供 built-in 支持。成功将请求映射到处理程序后，<code>HandlerMapping</code> implementations 检查给定请求和处理程序的 CORS configuration 并采取进一步操作。直接处理预检请求，同时拦截，验证简单和实际的 CORS 请求，并设置所需的 CORS 响应头。</p>
<p>在 order 中启用 cross-origin 请求(即，<code>Origin</code>标头存在且与请求的 host 不同)，您需要有一些显式声明的 CORS configuration。如果未找到匹配的 CORS configuration，则拒绝预检请求。没有 CORS headers 被添加到简单和实际 CORS 请求的响应中，因此浏览器拒绝它们。</p>
<p>每个<code>HandlerMapping</code>可以_11单独使用 URL pattern-based <code>CorsConfiguration</code>映射。在大多数情况下，applications 使用 MVC Java configuration 或 XML 命名空间来声明这样的映射，这会导致单个 global map 传递给所有<code>HandlerMappping</code>实例。</p>
<p>您可以将<code>HandlerMapping</code> level 上的 global CORS configuration 与更多 fine-grained，handler-level CORS configuration 结合使用。对于 example，带注释的控制器可以使用 class-或 method-level <code>@CrossOrigin</code> 注释(其他处理程序可以实现<code>CorsConfigurationSource</code>)。</p>
<p>组合 global 和 local configuration 的规则通常是加法的 - 例如，所有 global 和所有本地起源。对于只能接受单个 value 的属性(例如<code>allowCredentials</code>和<code>maxAge</code>)，本地会覆盖 global value。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/cors/CorsConfiguration.html#webflux-cors-processing">CorsConfiguration#combine(CorsConfiguration)</a>。</p>
<blockquote>
<p>要从源中了解更多信息或进行高级自定义，请检查后面的 code：</p>
</blockquote>
<ul>
<li><code>CorsConfiguration</code></li>
<li><code>CorsProcessor</code> , <code>DefaultCorsProcessor</code></li>
<li><code>AbstractHandlerMapping</code></li>
</ul>
<h4 id="CrossOrigin注解"><a href="#CrossOrigin注解" class="headerlink" title="CrossOrigin注解"></a>CrossOrigin注解</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#setCorsConfigurations-java.util.Map-">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html">@CrossOrigin</a> annotation 在带注释的控制器方法上启用 cross-origin 请求，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin</span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>@CrossOrigin</code>允许：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li>控制器方法映射到的所有 HTTP 方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的地方使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<p>class level 也支持<code>@CrossOrigin</code>，并且由所有方法继承，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(origins &#x3D; &quot;http:&#x2F;&#x2F;domain2.com&quot;, maxAge &#x3D; 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在 class level 和方法 level 中使用<code>@CrossOrigin</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@CrossOrigin(maxAge &#x3D; 3600)</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @CrossOrigin(&quot;http:&#x2F;&#x2F;domain2.com&quot;)</span><br><span class="line">    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public Account retrieve(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @DeleteMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public void remove(@PathVariable Long id) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#combine-org.springframework.web.cors.CorsConfiguration-">与 Spring WebFlux 相同</a></p>
<p>除了 fine-grained，控制器方法 level configuration 之外，您可能还想定义一些 global CORS configuration。您可以在任何<code>HandlerMapping</code>上单独设置 URL-based <code>CorsConfiguration</code>映射。但是，大多数 applications 使用 MVC Java configuration 或 MVC XNM 命名空间来执行此操作。</p>
<p>默认情况下，global configuration 启用以下内容：</p>
<ul>
<li>所有起源。</li>
<li>所有 headers。</li>
<li><code>GET</code>，<code>HEAD</code>和<code>POST</code>方法。</li>
</ul>
<p>默认情况下不启用<code>allowedCredentials</code>，因为它建立了一个公开敏感 user-specific 信息的信任 level(例如 cookies 和 CSRF 令牌)，并且只应在适当的地方使用。</p>
<p><code>maxAge</code>设置为 30 分钟。</p>
<h5 id="Java配置"><a href="#Java配置" class="headerlink" title="Java配置"></a>Java配置</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors-controller">与 Spring WebFlux 相同</a></p>
<p>要在 MVC Java 配置中启用 CORS，可以使用<code>CorsRegistry</code>回调，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">        registry.addMapping(&quot;&#x2F;api&#x2F;**&quot;)</span><br><span class="line">            .allowedOrigins(&quot;http:&#x2F;&#x2F;domain2.com&quot;)</span><br><span class="line">            .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;)</span><br><span class="line">            .allowedHeaders(&quot;header1&quot;, &quot;header2&quot;, &quot;header3&quot;)</span><br><span class="line">            .exposedHeaders(&quot;header1&quot;, &quot;header2&quot;)</span><br><span class="line">            .allowCredentials(true).maxAge(3600);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Add more mappings...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h5><p>要在 XML 命名空间中启用 CORS，可以使用<code>&lt;mvc:cors&gt;</code>元素，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:cors&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:mapping path&#x3D;&quot;&#x2F;api&#x2F;**&quot;</span><br><span class="line">        allowed-origins&#x3D;&quot;http:&#x2F;&#x2F;domain1.com, http:&#x2F;&#x2F;domain2.com&quot;</span><br><span class="line">        allowed-methods&#x3D;&quot;GET, PUT&quot;</span><br><span class="line">        allowed-headers&#x3D;&quot;header1, header2, header3&quot;</span><br><span class="line">        exposed-headers&#x3D;&quot;header1, header2&quot; allow-credentials&#x3D;&quot;true&quot;</span><br><span class="line">        max-age&#x3D;&quot;123&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:mapping path&#x3D;&quot;&#x2F;resources&#x2F;**&quot;</span><br><span class="line">        allowed-origins&#x3D;&quot;http:&#x2F;&#x2F;domain1.com&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mvc:cors&gt;</span><br></pre></td></tr></table></figure>
<h4 id="CORS过滤器"><a href="#CORS过滤器" class="headerlink" title="CORS过滤器"></a>CORS过滤器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors-global">与 Spring WebFlux 相同</a></p>
<p>您可以通过 built-in <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/filter/CorsFilter.html">CorsFilter</a>应用 CORS 支持。</p>
<blockquote>
<p>如果您尝试将<code>CorsFilter</code>与 Spring Security 一起使用，请记住 Spring Security 对于 CORS 有<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#webflux-cors-global">built-in 支持</a>。</p>
</blockquote>
<p>要配置过滤器，请将<code>CorsConfigurationSource</code>传递给其构造函数，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Possibly...</span><br><span class="line">&#x2F;&#x2F; config.applyPermitDefaultValues()</span><br><span class="line"></span><br><span class="line">config.setAllowCredentials(true);</span><br><span class="line">config.addAllowedOrigin(&quot;http:&#x2F;&#x2F;domain1.com&quot;);</span><br><span class="line">config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line">config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">CorsFilter filter &#x3D; new CorsFilter(source);</span><br></pre></td></tr></table></figure>
<h3 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-cors-webfilter">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security/">Spring Security</a>项目支持保护 web applications 免受恶意攻击。请参阅 Spring Security reference 文档，包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#cors">Spring MVC Security</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#webflux-web-security">Spring MVC 测试支持</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc">CSRF 保护</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#test-mockmvc">安全响应 Headers</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="http://hdiv.org/">HDIV</a>是另一个与 Spring MVC 集成的 web 安全 framework。</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#csrf">与 Spring WebFlux 相同</a></p>
<p>HTTP 缓存可以显着改善 web application 的 performance。 HTTP 缓存围绕<code>Cache-Control</code>响应头，随后是条件请求 headers(例如<code>Last-Modified</code>和<code>ETag</code>)。 <code>Cache-Control</code>建议私有(例如，浏览器)和公共(用于 example，代理)缓存如何缓存和 re-use 响应。如果内容未更改，<code>ETag</code>标头用于生成条件请求，该请求可能导致 304(NOT_MODIFIED)没有正文。 <code>ETag</code>可以被视为<code>Last-Modified</code>标题的更复杂的继承者。</p>
<p>本节介绍 Spring Web MVC 中可用的 HTTP caching-related 选项。</p>
<h4 id="CacheControl"><a href="#CacheControl" class="headerlink" title="CacheControl"></a>CacheControl</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#headers">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/CacheControl.html">CacheControl</a>支持配置与<code>Cache-Control</code>标头相关的设置，并且在许多地方被接受为参数：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/mvc/WebContentInterceptor.html">WebContentInterceptor</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/support/WebContentGenerator.html">WebContentGenerator</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-caching">控制器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-caching-cachecontrol">静态资源</a></li>
</ul>
<p>虽然<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7234#mvc-caching-etag-lastmodified">RFC 7234</a>描述了<code>Cache-Control</code>响应头的所有可能的指令，但<code>CacheControl</code>类型采用了一种使用 case-oriented 方法，该方法专注于 common 场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Cache for an hour - &quot;Cache-Control: max-age&#x3D;3600&quot;</span><br><span class="line">CacheControl ccCacheOneHour &#x3D; CacheControl.maxAge(1, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prevent caching - &quot;Cache-Control: no-store&quot;</span><br><span class="line">CacheControl ccNoStore &#x3D; CacheControl.noStore();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Cache for ten days in public and private caches,</span><br><span class="line">&#x2F;&#x2F; public caches should not transform the response</span><br><span class="line">&#x2F;&#x2F; &quot;Cache-Control: max-age&#x3D;864000, public, no-transform&quot;</span><br><span class="line">CacheControl ccCustom &#x3D; CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();</span><br></pre></td></tr></table></figure>
<p><code>WebContentGenerator</code>也接受一个更简单的<code>cachePeriod</code> property(以秒为单位定义)，其工作方式如下：</p>
<ul>
<li><code>-1</code> value 不会生成<code>Cache-Control</code>响应头。</li>
<li><code>0</code> value 通过使用<code>&#39;Cache-Control: no-store&#39;</code>指令来防止缓存。</li>
<li><code>n &gt; 0</code> value 使用<code>&#39;Cache-Control: max-age=n&#39;</code>指令缓存给定的响应<code>n</code>秒。</li>
</ul>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-caching-static-resources">与 Spring WebFlux 相同</a></p>
<p>控制器可以添加对 HTTP 缓存的显式支持。我们建议这样做，因为资源的<code>lastModified</code>或<code>ETag</code>value 需要先计算才能与条件请求 headers 进行比较。控制器可以将<code>ETag</code>标头和<code>Cache-Control</code>设置添加到<code>ResponseEntity</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;book&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">public ResponseEntity&lt;Book&gt; showBook(@PathVariable Long id) &#123;</span><br><span class="line"></span><br><span class="line">    Book book &#x3D; findBook(id);</span><br><span class="line">    String version &#x3D; book.getVersion();</span><br><span class="line"></span><br><span class="line">    return ResponseEntity</span><br><span class="line">            .ok()</span><br><span class="line">            .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))</span><br><span class="line">            .eTag(version) &#x2F;&#x2F; lastModified is also available</span><br><span class="line">            .body(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果与条件请求 headers 的比较表明内容未更改，则前面的 example 将发送一个 304(NOT_MODIFIED)响应与空体。否则，<code>ETag</code>和<code>Cache-Control</code> headers 将添加到响应中。</p>
<p>您还可以在控制器中对条件请求 headers 进行检查，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping</span><br><span class="line">public String myHandleMethod(WebRequest webRequest, Model model) &#123;</span><br><span class="line"></span><br><span class="line">    long eTag &#x3D; ... (1)</span><br><span class="line"></span><br><span class="line">    if (request.checkNotModified(eTag)) &#123;</span><br><span class="line">        return null; (2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    model.addAttribute(...); (3)</span><br><span class="line">    return &quot;myViewName&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Application-specific 计算。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>响应已设置为 304(NOT_MODIFIED) - 无需进一步处理。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>继续请求处理。</td>
</tr>
</tbody>
</table>
</div>
<p>有三种变体可用于检查针对<code>eTag</code>值，<code>lastModified</code>值或两者的条件请求。对于条件<code>GET</code>和<code>HEAD</code>请求，您可以将响应设置为 304(NOT_MODIFIED)。对于条件<code>POST</code>，<code>PUT</code>和<code>DELETE</code>，您可以将响应设置为 409(PRECONDITION_FAILED)，以防止并发修改。</p>
<h4 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#section-5.2.2">与 Spring WebFlux 相同</a></p>
<p>您应该使用<code>Cache-Control</code>和条件响应 headers 为静态资源提供最佳的 performance。请参阅有关配置<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-caching-etag-lastmodified">静态资源</a>的部分。</p>
<h4 id="ETag过滤器"><a href="#ETag过滤器" class="headerlink" title="ETag过滤器"></a>ETag过滤器</h4><p>您可以使用<code>ShallowEtagHeaderFilter</code>添加从响应内容计算的“浅”<code>eTag</code>值，从而节省带宽但不节省 CPU time。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-caching-static-resources">浅 ETag</a>。</p>
<h3 id="View技术"><a href="#View技术" class="headerlink" title="View技术"></a>View技术</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-config-static-resources">与 Spring WebFlux 相同</a></p>
<p>在 Spring MVC 中使用视图技术是可插拔的，无论您决定使用 Thymeleaf，Groovy 标记模板，JSP 还是其他技术，主要是配置更改的问题。本章介绍与 Spring MVC 集成的视图技术。我们假设您已经熟悉<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#filters-shallow-etag">查看分辨率</a>。</p>
<h4 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view">与 Spring WebFlux 相同</a></p>
<p>Thymeleaf 是一个现代的 server-side Java 模板引擎，它强调自然的 HTML 模板，可以通过 double-clicking 在浏览器中预览，这对于 UI 模板的独立工作非常有用(例如，设计者)，而不需要运行服务器。如果您想要替换 JSP，Thymeleaf 提供了一组最广泛的 features，以使这种转换更容易。 Thymeleaf 积极开发和维护。有关更完整的介绍，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a>项目主页。</p>
<p>Thymeleaf 与 Spring MVC 的整合由 Thymeleaf 项目管理。 configuration 涉及一些 bean 声明，例如<code>ServletContextTemplateResolver</code>，<code>SpringTemplateEngine</code>和<code>ThymeleafViewResolver</code>。有关详细信息，请参阅<a target="_blank" rel="noopener" href="http://www.thymeleaf.org/documentation.html">Thymeleaf Spring</a>。</p>
<h4 id="FreeMarker"><a href="#FreeMarker" class="headerlink" title="FreeMarker"></a>FreeMarker</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-viewresolver">与 Spring WebFlux 相同</a></p>
<p><a target="_blank" rel="noopener" href="http://www.freemarker.org/">Apache FreeMarker</a>是一个模板引擎，用于生成从 HTML 到电子邮件和其他人的任何类型的文本输出。 Spring Framework 有一个 built-in integration 用于使用带有 FreeMarker 模板的 Spring MVC。</p>
<h5 id="View配置"><a href="#View配置" class="headerlink" title="View配置"></a>View配置</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view-thymeleaf">与 Spring WebFlux 相同</a></p>
<p>以下 example 显示了如何将 FreeMarker 配置为视图技术：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.freemarker();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Configure FreeMarker...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer &#x3D; new FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(&quot;&#x2F;WEB-INF&#x2F;freemarker&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中配置相同的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:view-resolvers&gt;</span><br><span class="line">    &lt;mvc:freemarker&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:view-resolvers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Configure FreeMarker... --&gt;</span><br><span class="line">&lt;mvc:freemarker-configurer&gt;</span><br><span class="line">    &lt;mvc:template-loader-path location&#x3D;&quot;&#x2F;WEB-INF&#x2F;freemarker&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:freemarker-configurer&gt;</span><br></pre></td></tr></table></figure>
<p>或者，您也可以声明<code>FreeMarkerConfigurer</code> bean 以完全控制所有 properties，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;freemarkerConfig&quot; class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;templateLoaderPath&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;freemarker&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>您的模板需要存储在前面的 example 中显示的<code>FreeMarkerConfigurer</code>指定的目录中。给定前面的 configuration，如果控制器返回<code>welcome</code>的 view name，则解析器将查找<code>/WEB-INF/freemarker/welcome.ftl</code>模板。</p>
<h5 id="FreeMarker配置"><a href="#FreeMarker配置" class="headerlink" title="FreeMarker配置"></a>FreeMarker配置</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view-freemarker">与 Spring WebFlux 相同</a></p>
<p>您可以通过在<code>FreeMarkerConfigurer</code> bean 上设置相应的 bean properties，将 FreeMarker’Settings’和’SharedVariables’直接传递给 FreeMarker <code>Configuration</code> object(由 Spring 管理)。 <code>freemarkerSettings</code> property 需要<code>java.util.Properties</code> object，而<code>freemarkerVariables</code> property 需要<code>java.util.Map</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;freemarkerConfig&quot; class&#x3D;&quot;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;templateLoaderPath&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;freemarker&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;freemarkerVariables&quot;&gt;</span><br><span class="line">        &lt;map&gt;</span><br><span class="line">            &lt;entry key&#x3D;&quot;xml_escape&quot; value-ref&#x3D;&quot;fmXmlEscape&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;map&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;fmXmlEscape&quot; class&#x3D;&quot;freemarker.template.utility.XmlEscape&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>有关适用于<code>Configuration</code> object 的设置和变量的详细信息，请参阅 FreeMarker 文档。</p>
<h5 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h5><p>Spring 提供了一个标记 library，用于 JSP，其中包含<code>&lt;spring:bind/&gt;</code>元素。此元素主要允许表单显示 form-backing objects 中的值，并显示 web 或业务层中<code>Validator</code>的验证失败结果。 Spring 还支持 FreeMarker 中的相同功能，还有用于生成表单输入元素的额外便利宏。</p>
<h6 id="绑定宏"><a href="#绑定宏" class="headerlink" title="绑定宏"></a>绑定宏</h6><p>在两个语言的<code>spring-webmvc.jar</code>文件中维护一组标准宏，因此它们始终可用于适当配置的 application。</p>
<p>Spring libraries 中定义的一些宏被认为是内部(私有)，但宏定义中不存在这样的范围，使得所有宏都可以调用 code 和用户模板。以下部分仅关注您需要在模板中直接调用的宏。如果您希望直接查看宏 code，则该文件名为<code>spring.ftl</code>并位于<code>org.springframework.web.servlet.view.freemarker</code>包中。</p>
<h6 id="简单Binding"><a href="#简单Binding" class="headerlink" title="简单Binding"></a>简单Binding</h6><p>在作为 Spring MVC 控制器的表单视图的 HTML 表单(vm 或 ftl 模板)中，您可以使用类似于下一个 example 的 code 绑定到字段值，并以与 JSP 类似的方式显示每个输入字段的错误消息当量。以下 example 显示了之前配置的<code>personForm</code>视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- freemarker macros have to be imported into a namespace. We strongly</span><br><span class="line">recommend sticking to &#39;spring&#39; --&gt;</span><br><span class="line">&lt;#import &quot;&#x2F;spring.ftl&quot; as spring&#x2F;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;form action&#x3D;&quot;&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;@spring.bind &quot;myModelObject.name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot;</span><br><span class="line">            name&#x3D;&quot;$&#123;spring.status.expression&#125;&quot;</span><br><span class="line">            value&#x3D;&quot;$&#123;spring.status.value?html&#125;&quot;&#x2F;&gt;&lt;br&gt;</span><br><span class="line">        &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;$&#123;error&#125;&lt;&#x2F;b&gt; &lt;br&gt; &lt;&#x2F;#list&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line">        ...</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p><code>&lt;@spring.bind&gt;</code>需要一个’path’参数，它包含命令 object 的 name(它是’command’，除非你在<code>FormController</code> properties 中更改它)，后跟一个句点和_jject 命令 object 上的字段的 name 希望绑定。您还可以使用嵌套字段，例如<code>command.address.street</code>。 <code>bind</code>宏假定<code>web.xml</code>中 ServletContext 参数<code>defaultHtmlEscape</code>指定的默认 HTML 转义行为。</p>
<p>名为<code>&lt;@spring.bindEscaped&gt;</code>的宏的可选形式采用第二个参数，并明确指定是否应在状态错误消息或值中使用 HTML 转义。您可以根据需要将其设置为<code>true</code>或<code>false</code>。其他表单处理宏简化了 HTML 转义的使用，您应该尽可能使用这些宏。它们将在下一节中介绍。</p>
<h6 id="输入宏"><a href="#输入宏" class="headerlink" title="输入宏"></a>输入宏</h6><p>两种语言的附加便利宏简化了 binding 和表单生成(包括验证错误显示)。永远不必使用这些宏来生成表单输入字段，您可以将它们与简单的 HTML 混合和 match，或者直接 calls 到我们之前突出显示的 spring 绑定宏。</p>
<p>以下 table 可用宏显示 FTL 定义和每个参数列表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>宏</th>
<th>FTL 定义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message</code>(根据 code 参数从资源包中输出 string)</td>
<td>&lt; _1 code/&gt;</td>
</tr>
<tr>
<td><code>messageText</code>(根据 code 参数从资源包中输出 string，回退到默认参数的 value)</td>
<td>&lt; _1 code, text/&gt;</td>
</tr>
<tr>
<td><code>url</code>(使用 application 的 context 根作为相对 URL 的前缀)</td>
<td>&lt; <em>1</em> relativeUrl/&gt;</td>
</tr>
<tr>
<td><code>formInput</code>(用于收集用户输入的标准输入字段)</td>
<td>&lt; <em>1</em> path, attributes, fieldType/&gt;</td>
</tr>
<tr>
<td><code>formHiddenInput</code>(用于提交 non-user 输入的隐藏输入字段)</td>
<td>&lt; <em>1</em> path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formPasswordInput</code>(用于收集密码的标准输入字段.请注意，此 type.)的字段中不会填充 value</td>
<td>&lt; <em>1</em> path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formTextarea</code>(用于收集 long，自由格式文本输入的大文本字段)</td>
<td>&lt; <em>1</em> path, attributes/&gt;</td>
</tr>
<tr>
<td><code>formSingleSelect</code>(下拉框选项，允许选择一个必需的 value)</td>
<td>&lt; <em>1</em> path, options, attributes/&gt;</td>
</tr>
<tr>
<td><code>formMultiSelect</code>(允许用户选择 0 个或更多值的选项列表框)</td>
<td>&lt; <em>1</em> path, options, attributes/&gt;</td>
</tr>
<tr>
<td><code>formRadioButtons</code>(一组单选按钮，可以从可用选项中进行单个选择)</td>
<td>&lt; <em>1</em> path, options separator, attributes/&gt;</td>
</tr>
<tr>
<td><code>formCheckboxes</code>(一组允许选择 0 或更多值的复选框)</td>
<td>&lt; <em>1</em> path, options, separator, attributes/&gt;</td>
</tr>
<tr>
<td><code>formCheckbox</code>(单个复选框)</td>
<td>&lt; <em>1</em> path, attributes/&gt;</td>
</tr>
<tr>
<td><code>showErrors</code>(简化绑定字段的验证错误显示)</td>
<td>&lt; <em>1</em> separator, classOrStyle/&gt;</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在 FTL(FreeMarker)中，实际上不需要<code>formHiddenInput</code>和<code>formPasswordInput</code>，因为您可以使用普通的<code>formInput</code>宏，指定<code>hidden</code>或<code>password</code>作为<code>fieldType</code>参数的 value。</li>
</ul>
<p>任何上述宏的参数都具有一致的含义：</p>
<ul>
<li><code>path</code>：要绑定的字段的 name(即“command.name”)</li>
<li><code>options</code>：可以在输入字段中选择的所有可用值的<code>Map</code>。 map 的键表示从表单返回并绑定到命令 object 的值。针对键存储的 Map objects 是表单上显示给用户的标签，可能与表单发回的相应值不同。通常，这样的 map 由控制器作为 reference 数据提供。您可以使用任何<code>Map</code> implementation，具体取决于所需的行为。对于严格排序的 maps，您可以使用<code>SortedMap</code>(例如<code>TreeMap</code>)和合适的<code>Comparator</code>，对于任意 Maps 应该 return insert order 中的值，使用<code>LinkedHashMap</code>或<code>LinkedMap</code>来自<code>commons-collections</code>。</li>
<li><code>separator</code>：多个选项可用作谨慎元素(单选按钮或复选框)，用于分隔列表中每个元素的字符序列(例如<code>&lt;br&gt;</code>)。</li>
<li><code>attributes</code>：HTML 标记本身中包含的任意标记或文本的附加 string。这个 string 由宏按字面回显。例如，在<code>textarea</code>字段中，您可以提供属性(例如’rows =“5”cols =“60”’)，或者您可以传递样式信息，例如’style =“border:1px solid silver”’。</li>
<li><code>classOrStyle</code>：对于<code>showErrors</code>宏，包含每个错误的<code>span</code>元素使用的 CSS class 的 name。如果未提供任何信息(或 value 为空)，则错误将包含在<code>&lt;b&gt;&lt;/b&gt;</code>标记中。</li>
</ul>
<p>以下部分概述了宏的示例(一些在 FTL 中，一些在 VTL 中)。如果两种语言之间存在使用差异，则会在说明中对其进行说明。</p>
<p><span id="InputFields"></span><code>formInput</code>宏采用<code>path</code>参数(<code>command.name</code>)和一个额外的<code>attributes</code>参数(在即将发生的 example 中为空)。宏以及所有其他表单生成宏在 path 参数上执行隐式 Spring 绑定。 binding 在发生新绑定之前一直有效，因此<code>showErrors</code>宏不需要再次传递 path 参数 - 它在最后创建绑定的字段上运行。</p>
<p><code>showErrors</code>宏采用 separator 参数(用于分隔给定字段上的多个错误的字符)，还接受第二个参数 - 此 time，class name 或 style 属性。请注意，FreeMarker 可以为 attributes 参数指定默认值。以下 example 显示了如何使用<code>formInput</code>和<code>showWErrors</code>宏：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;@spring.formInput &quot;command.name&quot;&#x2F;&gt;</span><br><span class="line">&lt;@spring.showErrors &quot;&lt;br&gt;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>下一个 example 显示表单片段的输出，生成 name 字段并在提交表单后在字段中没有 value 时显示验证错误。验证通过 Spring 的验证 framework 进行。</p>
<p>生成的 HTML 类似于以下 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name:</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot; value&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">    &lt;b&gt;required&lt;&#x2F;b&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p><code>formTextarea</code>宏的工作方式与<code>formInput</code>宏的工作方式相同，并接受相同的参数列表。通常，第二个参数(属性)用于传递<code>textarea</code>的样式信息或<code>rows</code>和<code>cols</code>属性。</p>
<p>您可以使用四个<span id="SelectionFields"></span>选择字段宏在 HTML 表单中生成 common UI value 选择输入：</p>
<ul>
<li><code>formSingleSelect</code></li>
<li><code>formMultiSelect</code></li>
<li><code>formRadioButtons</code></li>
<li><code>formCheckboxes</code></li>
</ul>
<p>四个宏中的每一个都接受一个<code>Map</code>选项，其中包含表单字段的 value 和与该 value 对应的标签。 value 和标签可以相同。</p>
<p>下一个示例用于 FTL 中的单选按钮。 form-backing object 为此字段指定了“伦敦”的默认值值，因此无需进行验证。呈现表单时，可以在 name’cityMap’下的 model 中作为 reference 数据提供可供选择的整个城市列表。以下清单显示了 example：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Town:</span><br><span class="line">&lt;@spring.formRadioButtons &quot;command.address.town&quot;, cityMap, &quot;&quot;&#x2F;&gt;&lt;br&gt;&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>前面的列表呈现了一个 line 的单选按钮，<code>cityMap</code>中每个 value 一个，并使用<code>&quot;&quot;</code>的分隔符。没有提供其他属性(缺少宏的最后一个参数)。 <code>cityMap</code>对 map 中的每个 key-value 对使用相同的<code>String</code>。 map 的键是表单实际提交为 POSTed 请求参数的键。 map 值是用户看到的标签。在前面的示例中，给定一个包含三个众所周知的城市的列表以及支持 object 形式的默认 value，HTML 类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Town:</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;London&quot;&gt;London&lt;&#x2F;input&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;Paris&quot; checked&#x3D;&quot;checked&quot;&gt;Paris&lt;&#x2F;input&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;New York&quot;&gt;New York&lt;&#x2F;input&gt;</span><br></pre></td></tr></table></figure>
<p>如果您的 application 希望按内部代码处理城市(对于 example)，您可以使用合适的密钥创建代码的 map，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protected Map&lt;String, String&gt; referenceData(HttpServletRequest request) throws Exception &#123;</span><br><span class="line">    Map&lt;String, String&gt; cityMap &#x3D; new LinkedHashMap&lt;&gt;();</span><br><span class="line">    cityMap.put(&quot;LDN&quot;, &quot;London&quot;);</span><br><span class="line">    cityMap.put(&quot;PRS&quot;, &quot;Paris&quot;);</span><br><span class="line">    cityMap.put(&quot;NYC&quot;, &quot;New York&quot;);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; model &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">    model.put(&quot;cityMap&quot;, cityMap);</span><br><span class="line">    return model;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>code 现在生成输出，其中无线电值是相关代码，但用户仍然看到更多 user-friendly 城市名称，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Town:</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;LDN&quot;&gt;London&lt;&#x2F;input&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;PRS&quot; checked&#x3D;&quot;checked&quot;&gt;Paris&lt;&#x2F;input&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;address.town&quot; value&#x3D;&quot;NYC&quot;&gt;New York&lt;&#x2F;input&gt;</span><br></pre></td></tr></table></figure>
<h6 id="HTML转义"><a href="#HTML转义" class="headerlink" title="HTML转义"></a>HTML转义</h6><p>前面描述的表单宏的默认用法会导致符合 HTML 4.01 的 HTML 元素，并使用文件中定义的 HTML 转义的默认值，如 Spring 的绑定支持所使用的那样。要使元素符合 XHTML 要求或覆盖默认的 HTML 转义 value，您可以在模板中指定两个变量(或者在 model 中指定模板可见的变量)。在模板中指定它们的优点是，它们可以在模板处理中稍后更改为不同的值，以便为表单中的不同字段提供不同的行为。</p>
<p>要切换为标记的 XHTML 合规性，请为名为<code>xhtmlCompliant</code>的 model 或 context 变量指定的 value，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;#-- for FreeMarker --&gt;</span><br><span class="line">&lt;#assign xhtmlCompliant &#x3D; true&gt;</span><br></pre></td></tr></table></figure>
<p>处理完该指令后，Spring 宏生成的任何元素现在都符合 XHTML 标准。</p>
<p>以类似的方式，您可以指定每个字段的 HTML 转义，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#-- until this point, default HTML escaping is used --&gt;</span><br><span class="line"></span><br><span class="line">&lt;#assign htmlEscape &#x3D; true&gt;</span><br><span class="line">&lt;#-- next field will use HTML escaping --&gt;</span><br><span class="line">&lt;@spring.formInput &quot;command.name&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;#assign htmlEscape &#x3D; false in spring&gt;</span><br><span class="line">&lt;#-- all future fields will be bound with HTML escaping off --&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Groovy标记"><a href="#Groovy标记" class="headerlink" title="Groovy标记"></a>Groovy标记</h4><p><a target="_blank" rel="noopener" href="http://groovy-lang.org/templating.html#webflux-view-freemarker-contextconfig">Groovy 标记模板引擎</a>主要用于生成 XML-like 标记(XML，XHTML，HTML5 等)，但您可以使用它来生成任何 text-based 内容。 Spring Framework 有一个 built-in integration 用于将 Spring MVC 与 Groovy Markup 一起使用。</p>
<blockquote>
<p>Groovy 标记模板引擎需要 Groovy 2.3.1.</p>
</blockquote>
<h5 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h5><p>以下 example 显示了如何配置 Groovy 标记模板引擎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.groovy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Configure the Groovy Markup Template Engine...</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public GroovyMarkupConfigurer groovyMarkupConfigurer() &#123;</span><br><span class="line">        GroovyMarkupConfigurer configurer &#x3D; new GroovyMarkupConfigurer();</span><br><span class="line">        configurer.setResourceLoaderPath(&quot;&#x2F;WEB-INF&#x2F;&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中配置相同的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:view-resolvers&gt;</span><br><span class="line">    &lt;mvc:groovy&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:view-resolvers&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Configure the Groovy Markup Template Engine... --&gt;</span><br><span class="line">&lt;mvc:groovy-configurer resource-loader-path&#x3D;&quot;&#x2F;WEB-INF&#x2F;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>与传统的模板引擎不同，Groovy Markup 依赖于使用构建器语法的 DSL。以下 example 显示了 HTML 页面的 sample 模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yieldUnescaped &#39;&lt;!DOCTYPE html&gt;&#39;</span><br><span class="line">html(lang:&#39;en&#39;) &#123;</span><br><span class="line">    head &#123;</span><br><span class="line">        meta(&#39;http-equiv&#39;:&#39;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&#39;)</span><br><span class="line">        title(&#39;My page&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">        p(&#39;This is an example of HTML contents&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="脚本视图"><a href="#脚本视图" class="headerlink" title="脚本视图"></a>脚本视图</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-views-freemarker">与 Spring WebFlux 相同</a></p>
<p>Spring Framework 有一个 built-in integration 用于使用 Spring MVC 和任何可以在<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> Java 脚本引擎之上运行的模板 library。我们在不同的脚本引擎上测试了以下模板 libraries：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>脚本 Library</th>
<th>脚本引擎</th>
</tr>
</thead>
<tbody>
<tr>
<td><a target="_blank" rel="noopener" href="http://handlebarsjs.com/">把手</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://mustache.github.io/">胡子</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://facebook.github.io/react/">应对</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.embeddedjs.com/">EJS</a></td>
<td><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.stuartellis.eu/articles/erb/">ERB</a></td>
<td><a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.python.org/2/library/string.html#_the_markuptemplateengine">String 模板</a></td>
<td><a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">Kotlin 脚本模板</a></td>
<td><a target="_blank" rel="noopener" href="https://kotlinlang.org/">Kotlin</a></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>集成任何其他脚本引擎的基本规则是它必须实现<code>ScriptEngine</code>和<code>Invocable</code>接口。</p>
</blockquote>
<h5 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view-script">与 Spring WebFlux 相同</a></p>
<p>您需要在 classpath 上安装脚本引擎，其详细信息因脚本引擎而异：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/nashorn/">犀牛</a> JavaScript 引擎随 Java 8 一起提供。强烈建议使用最新的更新版本。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://jruby.org/">JRuby</a>作为 Ruby 支持的依赖项。</li>
<li>应该添加<a target="_blank" rel="noopener" href="http://www.jython.org/">Jython</a>作为 Python 支持的依赖项。</li>
<li>应为 Kotlin 脚本支持添加<code>org.jetbrains.kotlin:kotlin-script-util</code>依赖项和包含<code>org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory</code> line 的<code>META-INF/services/javax.script.ScriptEngineFactory</code>文件。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/sdeleuze/kotlin-script-templating">这个 example</a>。</li>
</ul>
<p>你需要有脚本模板 library。对 Javascript 执行此操作的一种方法是通过<a target="_blank" rel="noopener" href="http://www.webjars.org/">WebJars</a>。</p>
<h5 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#template-strings">与 Spring WebFlux 相同</a></p>
<p>您可以声明<code>ScriptTemplateConfigurer</code> bean 来指定要使用的脚本引擎，要加载的脚本 files，要调用渲染模板的 function，等等。以下 example 使用 Mustache 模板和 Nashorn JavaScript 引擎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ScriptTemplateConfigurer configurer() &#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer &#x3D; new ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(&quot;nashorn&quot;);</span><br><span class="line">        configurer.setScripts(&quot;mustache.js&quot;);</span><br><span class="line">        configurer.setRenderObject(&quot;Mustache&quot;);</span><br><span class="line">        configurer.setRenderFunction(&quot;render&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 在 XML 中显示相同的排列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:view-resolvers&gt;</span><br><span class="line">    &lt;mvc:script-template&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:view-resolvers&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:script-template-configurer engine-name&#x3D;&quot;nashorn&quot; render-object&#x3D;&quot;Mustache&quot; render-function&#x3D;&quot;render&quot;&gt;</span><br><span class="line">    &lt;mvc:script location&#x3D;&quot;mustache.js&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:script-template-configurer&gt;</span><br></pre></td></tr></table></figure>
<p>对于 Java 和 XML 配置，控制器看起来没有什么不同，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class SampleController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;sample&quot;)</span><br><span class="line">    public String test(Model model) &#123;</span><br><span class="line">        model.addObject(&quot;title&quot;, &quot;Sample title&quot;);</span><br><span class="line">        model.addObject(&quot;body&quot;, &quot;Sample body&quot;);</span><br><span class="line">        return &quot;template&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了 Mustache 模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;body&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>使用以下参数调用 render function：</p>
<ul>
<li><code>String template</code>：模板内容</li>
<li><code>Map model</code>：视图 model</li>
<li><code>RenderingContext renderingContext</code>：<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/view/script/RenderingContext.html">RenderingContext</a>可以访问 application context，locale，模板加载器和 URL(自 5.0 以来)</li>
</ul>
<p><code>Mustache.render()</code>本身与此签名兼容，因此您可以直接调用它。</p>
<p>如果您的模板技术需要一些自定义，您可以提供实现自定义 render function 的脚本。例如，<a target="_blank" rel="noopener" href="http://handlebarsjs.com/">Handlerbars</a>需要在使用它们之前编译模板，并且需要<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Polyfill">填充工具</a>来模拟 server-side 脚本引擎中不可用的某些浏览器工具。</p>
<p>以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.scriptTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ScriptTemplateConfigurer configurer() &#123;</span><br><span class="line">        ScriptTemplateConfigurer configurer &#x3D; new ScriptTemplateConfigurer();</span><br><span class="line">        configurer.setEngineName(&quot;nashorn&quot;);</span><br><span class="line">        configurer.setScripts(&quot;polyfill.js&quot;, &quot;handlebars.js&quot;, &quot;render.js&quot;);</span><br><span class="line">        configurer.setRenderFunction(&quot;render&quot;);</span><br><span class="line">        configurer.setSharedEngine(false);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当您使用 non-thread-safe 脚本引擎以及不是为并发而设计的模板 libraries 时，需要将<code>sharedEngine</code> property 设置为<code>false</code>，例如 Handlebars 或 Nactorn 上的 React running。在这种情况下，由于<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8076099">这个 bug</a>，需要 Java 8u60 或更高版本。</p>
</blockquote>
<p><code>polyfill.js</code>仅定义 Handlebars 所需的<code>window</code> object 以正确 run，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var window &#x3D; &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>这个基本的<code>render.js</code> implementation 在使用之前编译模板。 production-ready implementation 还应该存储任何重用的缓存模板或 pre-compiled 模板。您可以在脚本端执行此操作(并处理所需的任何自定义 - 管理模板引擎 configuration，用于 example)。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function render(template, model) &#123;</span><br><span class="line">    var compiledTemplate &#x3D; Handlebars.compile(template);</span><br><span class="line">    return compiledTemplate(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看 Spring Framework 单元测试，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script">Java</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script">资源</a>，了解更多 configuration 示例。</p>
<h4 id="JSP和JSTL"><a href="#JSP和JSTL" class="headerlink" title="JSP和JSTL"></a>JSP和JSTL</h4><p>Spring Framework 有一个 built-in integration 用于将 Spring MVC 与 JSP 和 JSTL 一起使用。</p>
<h5 id="View解析器-1"><a href="#View解析器-1" class="headerlink" title="View解析器"></a>View解析器</h5><p>使用 JSP 开发时，可以声明<code>InternalResourceViewResolver</code>或<code>ResourceBundleViewResolver</code> bean。</p>
<p><code>ResourceBundleViewResolver</code>依赖于 properties 文件来定义映射到 class 和 URL 的视图名称。使用<code>ResourceBundleViewResolver</code>，您可以通过仅使用一个解析器来混合不同类型的视图，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- the ResourceBundleViewResolver --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basename&quot; value&#x3D;&quot;views&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"># And a sample properties file is uses (views.properties in WEB-INF&#x2F;classes):</span><br><span class="line">welcome.(class)&#x3D;org.springframework.web.servlet.view.JstlView</span><br><span class="line">welcome.url&#x3D;&#x2F;WEB-INF&#x2F;jsp&#x2F;welcome.jsp</span><br><span class="line"></span><br><span class="line">productList.(class)&#x3D;org.springframework.web.servlet.view.JstlView</span><br><span class="line">productList.url&#x3D;&#x2F;WEB-INF&#x2F;jsp&#x2F;productlist.jsp</span><br></pre></td></tr></table></figure>
<p><code>InternalResourceBundleViewResolver</code>也可以用于 JSP。作为最佳实践，我们强烈建议将 JSP files 放在<code>&#39;WEB-INF&#39;</code>目录下的目录中，以便 clients 无法直接访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h5 id="JSPs与JSTL"><a href="#JSPs与JSTL" class="headerlink" title="JSPs与JSTL"></a>JSPs与JSTL</h5><p>使用 Java 标准标记 Library 时，必须使用特殊视图 class，<code>JstlView</code>，因为 JSTL 需要一些准备工作，比如 I18N features 之类的东西才能工作。</p>
<h5 id="Spring的JSP标签库"><a href="#Spring的JSP标签库" class="headerlink" title="Spring的JSP标签库"></a>Spring的JSP标签库</h5><p>Spring 为命令 objects 提供请求参数的数据 binding，如前面章节所述。为了便于 JSP 页面的开发与 binding features 数据的结合，Spring 提供了一些标签，使事情变得更加容易。所有 Spring 标签都具有 HTML 转义 features 以启用或禁用字符转义。</p>
<p><code>spring.tld</code>标签 library 描述符(TLD)包含在<code>spring-webmvc.jar</code>中。有关单个标记的综合参考，请浏览<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/package-summary.html#webflux-view-script-dependencies">API reference</a>或查看标记 library 描述。</p>
<h5 id="Spring的表单标签库"><a href="#Spring的表单标签库" class="headerlink" title="Spring的表单标签库"></a>Spring的表单标签库</h5><p>从 version 2.0 开始，Spring 提供了一组全面的数据 binding-aware 标签，用于在使用 JSP 和 Spring Web MVC 时处理表单元素。每个标记都支持其相应 HTML 标记对应的属性集，使标记熟悉且直观易用。 tag-generated HTML 符合 HTML 4.01/XHTML 1.0.</p>
<p>与其他 form/input tag libraries 不同，Spring 的表单标签 library 与 Spring Web MVC 集成，使标签可以访问控制器处理的命令 object 和 reference 数据。正如我们在以下示例中所示，表单标记使 JSP 更易于开发，读取和维护。</p>
<p>我们浏览表单标签，查看每个标签的使用方式的示例。我们已经包含生成的 HTML 代码段，其中某些代码需要进一步评论。</p>
<h6 id="Configuration-1"><a href="#Configuration-1" class="headerlink" title="Configuration"></a>Configuration</h6><p>表单标签 library 捆绑在<code>spring-webmvc.jar</code>中。 library 描述符称为<code>spring-form.tld</code>。</p>
<p>要使用此 library 中的标记，请将以下指令添加到 JSP 页面的顶部：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;form&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;tags&#x2F;form&quot; %&gt;</span><br></pre></td></tr></table></figure>
<p>其中<code>form</code>是您要用于此 library 的标记的标记 name 前缀。</p>
<h6 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h6><p>此标记呈现 HTML’form’元素，并为 binding 公开内部标记的 binding 路径。它将命令 object 放在<code>PageContext</code>中，以便内部标记可以访问命令 object。此 library 中的所有其他标记都是<code>form</code>标记的嵌套标记。</p>
<p>假设我们有一个名为<code>User</code>的域 object。它是一个带有 properties 的 JavaBean，例如<code>firstName</code>和<code>lastName</code>。我们可以将它用作表单控制器的 form-backing object，它返回<code>form.jsp</code>。以下 example 显示了<code>form.jsp</code>的样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p><code>firstName</code>和<code>lastName</code>值是从页面控制器放置在<code>PageContext</code>中的命令 object 中检索的。继续阅读以查看内部标记与<code>form</code>标记一起使用的更复杂示例。</p>
<p>以下清单显示了生成的 HTML，它看起来像标准表单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;firstName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;Harry&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;lastName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;Potter&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 JSP 假定 form-backing object 的变量 name 是<code>command</code>。如果已将 form-backing object 放入另一个 name 下的 model(绝对是最佳实践)，则可以将表单绑定到命名变量，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form modelAttribute&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;2&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<h6 id="输入标签"><a href="#输入标签" class="headerlink" title="输入标签"></a>输入标签</h6><p>此标记默认使用绑定 value 和<code>type=&#39;text&#39;</code>呈现 HTML <code>input</code>元素。有关此标记的 example，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-script-integrate">表格标签</a>。您还可以使用 HTML5-specific 类型，例如<code>email</code>，<code>tel</code>，<code>date</code>等。</p>
<h6 id="复选框标记"><a href="#复选框标记" class="headerlink" title="复选框标记"></a>复选框标记</h6><p>此标记呈现 HTML <code>input</code>标记，<code>type</code>设置为<code>checkbox</code>。</p>
<p>假设我们的<code>User</code>具有诸如简报订阅和爱好列表之类的偏好。以下 example 显示了<code>Preferences</code> class：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Preferences &#123;</span><br><span class="line"></span><br><span class="line">    private boolean receiveNewsletter;</span><br><span class="line">    private String[] interests;</span><br><span class="line">    private String favouriteWord;</span><br><span class="line"></span><br><span class="line">    public boolean isReceiveNewsletter() &#123;</span><br><span class="line">        return receiveNewsletter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setReceiveNewsletter(boolean receiveNewsletter) &#123;</span><br><span class="line">        this.receiveNewsletter &#x3D; receiveNewsletter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String[] getInterests() &#123;</span><br><span class="line">        return interests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setInterests(String[] interests) &#123;</span><br><span class="line">        this.interests &#x3D; interests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFavouriteWord() &#123;</span><br><span class="line">        return favouriteWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFavouriteWord(String favouriteWord) &#123;</span><br><span class="line">        this.favouriteWord &#x3D; favouriteWord;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的<code>form.jsp</code>可能类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Subscribe to newsletter?:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Approach 1: Property is of type java.lang.Boolean --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:checkbox path&#x3D;&quot;preferences.receiveNewsletter&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Interests:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Approach 2: Property is of an array or of type java.util.Collection --%&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                Quidditch: &lt;form:checkbox path&#x3D;&quot;preferences.interests&quot; value&#x3D;&quot;Quidditch&quot;&#x2F;&gt;</span><br><span class="line">                Herbology: &lt;form:checkbox path&#x3D;&quot;preferences.interests&quot; value&#x3D;&quot;Herbology&quot;&#x2F;&gt;</span><br><span class="line">                Defence Against the Dark Arts: &lt;form:checkbox path&#x3D;&quot;preferences.interests&quot; value&#x3D;&quot;Defence Against the Dark Arts&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Favourite Word:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Approach 3: Property is of type java.lang.Object --%&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                Magic: &lt;form:checkbox path&#x3D;&quot;preferences.favouriteWord&quot; value&#x3D;&quot;Magic&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p><code>checkbox</code>标签有三种方法，可满足您的所有复选框需求。</p>
<ul>
<li>方法一：当绑定 value 的类型为<code>java.lang.Boolean</code>时，如果绑定的 value 为<code>true</code>，则<code>input(checkbox)</code>标记为<code>checked</code>。 <code>value</code>属性对应于<code>setValue(Object)</code> value property 的已解析 value。</li>
<li>方法二：当绑定 value 的类型为<code>array</code>或<code>java.util.Collection</code>时，如果配置的<code>setValue(Object)</code> value 存在于绑定<code>Collection</code>中，<code>input(checkbox)</code>将标记为<code>checked</code>。</li>
<li>方法三：对于任何其他绑定 value 类型，如果配置的<code>setValue(Object)</code>等于绑定 value，<code>input(checkbox)</code>将标记为<code>checked</code>。</li>
</ul>
<p>请注意，无论采用何种方法，都会生成相同的 HTML 结构。以下 HTML 代码段定义了一些复选框：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Interests:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        Quidditch: &lt;input name&#x3D;&quot;preferences.interests&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;Quidditch&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;1&quot; name&#x3D;&quot;_preferences.interests&quot;&#x2F;&gt;</span><br><span class="line">        Herbology: &lt;input name&#x3D;&quot;preferences.interests&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;Herbology&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;1&quot; name&#x3D;&quot;_preferences.interests&quot;&#x2F;&gt;</span><br><span class="line">        Defence Against the Dark Arts: &lt;input name&#x3D;&quot;preferences.interests&quot; type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;Defence Against the Dark Arts&quot;&#x2F;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;hidden&quot; value&#x3D;&quot;1&quot; name&#x3D;&quot;_preferences.interests&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<p>您可能不希望在每个复选框后看到额外的隐藏字段。如果未检查 HTML 页面中的复选框，则在提交表单后，其 value 不会作为 HTTP 请求参数的一部分发送到服务器，因此我们需要为 HTML 中的这个怪癖提供一种解决方法，以便 Spring 表单数据 binding 工作。 <code>checkbox</code>标记遵循现有的 Spring 约定，包括每个复选框的下划线(<code>_</code>)前缀的隐藏参数。通过这样做，你实际上告诉 Spring“复选框在表单中是可见的，我希望表单数据绑定的 object 反映复选框的 state，无论如何。”</p>
<h6 id="复选框Tag"><a href="#复选框Tag" class="headerlink" title="复选框Tag"></a>复选框Tag</h6><p>此标记呈现多个 HTML <code>input</code>标记，<code>type</code>设置为<code>checkbox</code>。</p>
<p>此部分 build 位于前一个<code>checkbox</code>标记部分的 example 上。有时，您不希望在 JSP 页面中列出所有可能的爱好。您宁愿在运行时提供可用选项的列表，并将其传递给标记。这就是<code>checkboxes</code>标签的目的。您可以传入包含<code>items</code> property 中可用选项的<code>Array</code>，或<code>Map</code>。通常，绑定的 property 是一个集合，因此它可以包含用户选择的多个值。以下 example 显示了使用此标记的 JSP：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Interests:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;</span><br><span class="line">                &lt;%-- Property is of an array or of type java.util.Collection --%&gt;</span><br><span class="line">                &lt;form:checkboxes path&#x3D;&quot;preferences.interests&quot; items&#x3D;&quot;$&#123;interestList&#125;&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p>此 example 假定<code>interestList</code>是<code>List</code>可用作 model 属性，该属性包含要从中选择的值的 strings。如果使用<code>Map</code>，则 map 条目 key 用作 value，map 条目的 value 用作要显示的标签。您还可以使用自定义 object，您可以使用<code>itemValue</code>为 value 提供 property 名称，使用<code>itemLabel</code>提供标签。</p>
<h6 id="radiobutton标签"><a href="#radiobutton标签" class="headerlink" title="radiobutton标签"></a>radiobutton标签</h6><p>此标记呈现 HTML <code>input</code>元素，<code>type</code>设置为<code>radio</code>。</p>
<p>典型用法 pattern 涉及绑定到同一 property 但具有不同值的多个标记实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Sex:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        Male: &lt;form:radiobutton path&#x3D;&quot;sex&quot; value&#x3D;&quot;M&quot;&#x2F;&gt; </span><br><span class="line">        Female: &lt;form:radiobutton path&#x3D;&quot;sex&quot; value&#x3D;&quot;F&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<h6 id="radiobuttons标签"><a href="#radiobuttons标签" class="headerlink" title="radiobuttons标签"></a>radiobuttons标签</h6><p>此标记呈现多个 HTML <code>input</code>元素，<code>type</code>设置为<code>radio</code>。</p>
<p>与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#package.description">复选框标记</a>一样，您可能希望将可用选项作为运行时变量传递。对于此用法，您可以使用<code>radiobuttons</code>标记。传入<code>Array</code>，<code>List</code>或<code>Map</code>，其中包含<code>items</code> property 中的可用选项。如果使用<code>Map</code>，则 map 条目 key 用作 value，map 条目的 value 用作要显示的标签。您还可以使用自定义 object，您可以使用<code>itemValue</code>为 value 提供 property 名称，使用<code>itemLabel</code>提供标签，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Sex:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&lt;form:radiobuttons path&#x3D;&quot;sex&quot; items&#x3D;&quot;$&#123;sexOptions&#125;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<h6 id="密码标签"><a href="#密码标签" class="headerlink" title="密码标签"></a>密码标签</h6><p>此标记使用绑定 value 呈现类型设置为<code>password</code>的 HTML <code>input</code>标记。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Password:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;form:password path&#x3D;&quot;password&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，默认情况下，不显示密码 value。如果确实需要显示密码 value，可以将<code>showPassword</code>属性的 value 设置为<code>true</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Password:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;form:password path&#x3D;&quot;password&quot; value&#x3D;&quot;^76525bvHGq&quot; showPassword&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<h6 id="select标签"><a href="#select标签" class="headerlink" title="select标签"></a>select标签</h6><p>此标记呈现 HTML’select’元素。它支持所选选项的数据绑定以及嵌套<code>option</code>和<code>options</code>标记的使用。</p>
<p>假设<code>User</code>有一个技能列表。相应的 HTML 可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Skills:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&lt;form:select path&#x3D;&quot;skills&quot; items&#x3D;&quot;$&#123;skills&#125;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<p>如果<code>User&#39;s</code>技能在草药学中，则“技能”行的 HTML 源可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Skills:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;select name&#x3D;&quot;skills&quot; multiple&#x3D;&quot;true&quot;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Potions&quot;&gt;Potions&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Herbology&quot; selected&#x3D;&quot;selected&quot;&gt;Herbology&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Quidditch&quot;&gt;Quidditch&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<h6 id="选项标记"><a href="#选项标记" class="headerlink" title="选项标记"></a>选项标记</h6><p>此标记呈现 HTML <code>option</code>元素。它根据绑定的 value sets <code>selected</code>。以下 HTML 显示了它的典型输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;House:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;form:select path&#x3D;&quot;house&quot;&gt;</span><br><span class="line">            &lt;form:option value&#x3D;&quot;Gryffindor&quot;&#x2F;&gt;</span><br><span class="line">            &lt;form:option value&#x3D;&quot;Hufflepuff&quot;&#x2F;&gt;</span><br><span class="line">            &lt;form:option value&#x3D;&quot;Ravenclaw&quot;&#x2F;&gt;</span><br><span class="line">            &lt;form:option value&#x3D;&quot;Slytherin&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;form:select&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<p>如果<code>User&#39;s</code>房子在格兰芬多，那么’House’行的 HTML 源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;House:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;select name&#x3D;&quot;house&quot;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Gryffindor&quot; selected&#x3D;&quot;selected&quot;&gt;Gryffindor&lt;&#x2F;option&gt; (1)</span><br><span class="line">            &lt;option value&#x3D;&quot;Hufflepuff&quot;&gt;Hufflepuff&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Ravenclaw&quot;&gt;Ravenclaw&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;Slytherin&quot;&gt;Slytherin&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>请注意添加<code>selected</code>属性。</td>
</tr>
</tbody>
</table>
</div>
<h6 id="选项标签"><a href="#选项标签" class="headerlink" title="选项标签"></a>选项标签</h6><p>此标记呈现 HTML <code>option</code>元素的列表。它根据绑定的 value 设置<code>selected</code>属性。以下 HTML 显示了它的典型输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Country:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;form:select path&#x3D;&quot;country&quot;&gt;</span><br><span class="line">            &lt;form:option value&#x3D;&quot;-&quot; label&#x3D;&quot;--Please Select&quot;&#x2F;&gt;</span><br><span class="line">            &lt;form:options items&#x3D;&quot;$&#123;countryList&#125;&quot; itemValue&#x3D;&quot;code&quot; itemLabel&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;form:select&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<p>如果<code>User</code>位于英国，则“Country”行的 HTML 源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Country:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;</span><br><span class="line">        &lt;select name&#x3D;&quot;country&quot;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;-&quot;&gt;--Please Select&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;AT&quot;&gt;Austria&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;UK&quot; selected&#x3D;&quot;selected&quot;&gt;United Kingdom&lt;&#x2F;option&gt; (1)</span><br><span class="line">            &lt;option value&#x3D;&quot;US&quot;&gt;United States&lt;&#x2F;option&gt;</span><br><span class="line">        &lt;&#x2F;select&gt;</span><br><span class="line">    &lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>请注意添加<code>selected</code>属性。</td>
</tr>
</tbody>
</table>
</div>
<p>如前面的示例所示，<code>option</code>标记与<code>options</code>标记的组合使用生成相同的标准 HTML，但允许您在 JSP 中显式指定仅用于显示(它所属的位置)的 value，例如默认的 string example：“ - 请选择”。</p>
<p><code>items</code>属性通常填充 item objects 的集合或 array。 <code>itemValue</code>和<code>itemLabel</code>引用那些 item objects 的 bean properties，如果指定的话。否则，item objects 本身会变成 strings。或者，您可以指定<code>Map</code>项，在这种情况下，map 键被解释为选项值，map 值对应于选项标签。如果恰好也指定<code>itemValue</code>或<code>itemLabel</code>(或两者)，则 item value property 应用于 map key，item 标签 property 应用于 map value。</p>
<h6 id="textarea标签"><a href="#textarea标签" class="headerlink" title="textarea标签"></a>textarea标签</h6><p>此标记呈现 HTML <code>textarea</code>元素。以下 HTML 显示了它的典型输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;Notes:&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&lt;form:textarea path&#x3D;&quot;notes&quot; rows&#x3D;&quot;3&quot; cols&#x3D;&quot;20&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;&lt;form:errors path&#x3D;&quot;notes&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br></pre></td></tr></table></figure>
<h6 id="隐藏的标签"><a href="#隐藏的标签" class="headerlink" title="隐藏的标签"></a>隐藏的标签</h6><p>此标记将带有<code>type</code>的 HTML <code>input</code>标记设置为带有绑定 value 的<code>hidden</code>。要提交未绑定的隐藏 value，请使用设置为<code>hidden</code>的 HTML <code>input</code>标记。以下 HTML 显示了它的典型输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:hidden path&#x3D;&quot;house&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们选择将<code>house</code> value 作为隐藏提交，则 HTML 将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name&#x3D;&quot;house&quot; type&#x3D;&quot;hidden&quot; value&#x3D;&quot;Gryffindor&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h6 id="错误标签"><a href="#错误标签" class="headerlink" title="错误标签"></a>错误标签</h6><p>此标记在 HTML <code>span</code>元素中呈现字段错误。它可以访问控制器中创建的错误或由与控制器关联的任何验证器创建的错误。</p>
<p>假设我们要在提交表单后显示<code>firstName</code>和<code>lastName</code>字段的所有错误消息。我们有一个名为<code>UserValidator</code>的<code>User</code> class 实例的验证器，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class UserValidator implements Validator &#123;</span><br><span class="line"></span><br><span class="line">    public boolean supports(Class candidate) &#123;</span><br><span class="line">        return User.class.isAssignableFrom(candidate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void validate(Object obj, Errors errors) &#123;</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;firstName&quot;, &quot;required&quot;, &quot;Field is required.&quot;);</span><br><span class="line">        ValidationUtils.rejectIfEmptyOrWhitespace(errors, &quot;lastName&quot;, &quot;required&quot;, &quot;Field is required.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>form.jsp</code>可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Show errors for firstName field --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:errors path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Show errors for lastName field --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:errors path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;3&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们在<code>firstName</code>和<code>lastName</code>字段中提交带有空值的表单，则 HTML 将如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;firstName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Associated errors to firstName field displayed --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;span name&#x3D;&quot;firstName.errors&quot;&gt;Field is required.&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;lastName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;%-- Associated errors to lastName field displayed --%&gt;</span><br><span class="line">            &lt;td&gt;&lt;span name&#x3D;&quot;lastName.errors&quot;&gt;Field is required.&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;3&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>如果我们想显示给定页面的整个错误列表怎么办？下一个 example 显示<code>errors</code>标记还支持一些基本的通配符功能。</p>
<ul>
<li><code>path=&quot;*&quot;</code>：显示所有错误。</li>
<li><code>path=&quot;lastName&quot;</code>：显示与<code>lastName</code>字段关联的所有错误。</li>
<li>如果省略<code>path</code>，则仅显示 object 错误。</li>
</ul>
<p>以下 example 在页面顶部显示错误列表，然后在字段旁边显示 field-specific 错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form&gt;</span><br><span class="line">    &lt;form:errors path&#x3D;&quot;*&quot; cssClass&#x3D;&quot;errorBox&quot;&#x2F;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:errors path&#x3D;&quot;firstName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:input path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;form:errors path&#x3D;&quot;lastName&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;3&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p>HTML 将如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">    &lt;span name&#x3D;&quot;*.errors&quot; class&#x3D;&quot;errorBox&quot;&gt;Field is required.Field is required.&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;First Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;firstName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;span name&#x3D;&quot;firstName.errors&quot;&gt;Field is required.&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line"></span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Last Name:&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input name&#x3D;&quot;lastName&quot; type&#x3D;&quot;text&quot; value&#x3D;&quot;&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">            &lt;td&gt;&lt;span name&#x3D;&quot;lastName.errors&quot;&gt;Field is required.&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td colspan&#x3D;&quot;3&quot;&gt;</span><br><span class="line">                &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Save Changes&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;td&gt;</span><br><span class="line">        &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p><code>spring-form.tld</code>标签 library 描述符(TLD)包含在<code>spring-webmvc.jar</code>中。有关单个标记的综合参考，请浏览<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/tags/form/package-summary.html#mvc-view-jsp-formtaglib-formtag">API reference</a>或查看标记 library 描述。</p>
<h6 id="HTTP方法转换"><a href="#HTTP方法转换" class="headerlink" title="HTTP方法转换"></a>HTTP方法转换</h6><p>REST 的 key 原则是使用“Uniform Interface”。这意味着可以使用相同的四种 HTTP 方法操作所有资源(URL)：GET，PUT，POST 和 DELETE。对于每个方法，HTTP 规范定义了确切的语义。例如，GET 应始终是一个安全的操作，这意味着它没有副作用，PUT 或 DELETE 应该是幂等的，这意味着你可以反复重复这些操作，但最终结果应该是相同的。虽然 HTTP 定义了这四种方法，但 HTML 只支持两种：GET 和 POST。幸运的是，有两种可能的解决方法：您可以使用 JavaScript 来执行 PUT 或 DELETE，也可以使用“real”方法作为附加参数进行 POST(在 HTML 表单中建模为隐藏输入字段)。 Spring 的<code>HiddenHttpMethodFilter</code>使用后一种技巧。这个过滤器是一个普通的 Servlet 过滤器，因此，它可以与任何 web framework(不仅仅是 Spring MVC)结合使用。将此过滤器添加到 web.xml，并将具有隐藏<code>method</code>参数的 POST 转换为相应的 HTTP 方法请求。</p>
<p>为了支持 HTTP 方法转换，更新了 Spring MVC 表单标记以支持设置 HTTP 方法。对于 example，以下代码段来自 Pet Clinic sample：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form:form method&#x3D;&quot;delete&quot;&gt;</span><br><span class="line">    &lt;p class&#x3D;&quot;submit&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Delete Pet&quot;&#x2F;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;form:form&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 执行 HTTP POST，“real”DELETE 方法隐藏在请求参数后面。它由<code>HiddenHttpMethodFilter</code>拾取，它在 web.xml 中定义，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;httpMethodFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;httpMethodFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;servlet-name&gt;petclinic&lt;&#x2F;servlet-name&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了相应的<code>@Controller</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(method &#x3D; RequestMethod.DELETE)</span><br><span class="line">public String deletePet(@PathVariable int ownerId, @PathVariable int petId) &#123;</span><br><span class="line">    this.clinic.deletePet(petId);</span><br><span class="line">    return &quot;redirect:&#x2F;owners&#x2F;&quot; + ownerId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="HTML5标签"><a href="#HTML5标签" class="headerlink" title="HTML5标签"></a>HTML5标签</h6><p>Spring 表单标记 library 允许输入动态属性，这意味着您可以输入任何 HTML5 特定属性。</p>
<p>表单<code>input</code>标记支持输入<code>text</code>以外的类型属性。这旨在允许呈现新的 HTML5 特定输入类型，例如<code>email</code>，<code>date</code>，<code>range</code>等。请注意，不需要输入<code>type=&#39;text&#39;</code>，因为<code>text</code>是默认类型。</p>
<h4 id="瓷砖"><a href="#瓷砖" class="headerlink" title="瓷砖"></a>瓷砖</h4><p>您可以在使用 Spring 的 web applications 中集成 Tiles - 就像任何其他视图技术一样。本节以广泛的方式介绍了如何执行此操作。</p>
<blockquote>
<p>本节重点介绍 Spring 对<code>org.springframework.web.servlet.view.tiles3</code>包中 Tiles version 3 的支持。</p>
</blockquote>
<h5 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h5><p>为了能够使用 Tiles，您必须为 Tiles version 3.0.1 或更高版本以及<a target="_blank" rel="noopener" href="https://tiles.apache.org/framework/dependency-management.html">它的传递依赖</a>添加对项目的依赖性。</p>
<h5 id="Configuration-2"><a href="#Configuration-2" class="headerlink" title="Configuration"></a>Configuration</h5><p>为了能够使用 Tiles，您必须使用包含定义的 files 来配置它(有关定义和其他 Tiles 概念的基本信息，请参阅<a target="_blank" rel="noopener" href="https://tiles.apache.org/">http://tiles.apache.org</a>)。在 Spring 中，这是通过使用<code>TilesConfigurer</code>来完成的。以下 example <code>ApplicationContext</code> configuration 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;tilesConfigurer&quot; class&#x3D;&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;definitions&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;general.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;widgets.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;administrator.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;customer.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;templates.xml&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 定义了五个包含定义的 files。 files 都位于<code>WEB-INF/defs</code>目录中。在初始化<code>WebApplicationContext</code>时，将加载 files，并初始化定义工厂。完成之后，定义 files 中包含的 Tiles 可以用作 Spring web application 中的视图。为了能够使用视图，您必须使用<code>ViewResolver</code>与 Spring 使用的任何其他视图技术一样。您可以使用两个 implementations 中的任何一个，<code>UrlBasedViewResolver</code>和<code>ResourceBundleViewResolver</code>。</p>
<p>您可以通过添加下划线然后添加 locale 来指定 locale-specific Tiles 定义，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;tilesConfigurer&quot; class&#x3D;&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;definitions&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;tiles.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;tiles_fr_FR.xml&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<p>使用前面的 configuration，<code>tiles_fr_FR.xml</code>用于具有<code>fr_FR</code> locale 的请求，默认情况下使用<code>tiles.xml</code>。</p>
<blockquote>
<p>由于下划线用于表示区域设置，因此我们建议不要在 Tiles 定义的文件名中使用它们。</p>
</blockquote>
<h6 id="UrlBasedViewResolver"><a href="#UrlBasedViewResolver" class="headerlink" title="UrlBasedViewResolver"></a>UrlBasedViewResolver</h6><p><code>UrlBasedViewResolver</code>为它必须解析的每个视图实例化给定的<code>viewClass</code>。以下 bean 定义了一个<code>UrlBasedViewResolver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.tiles3.TilesView&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h6 id="ResourceBundleViewResolver"><a href="#ResourceBundleViewResolver" class="headerlink" title="ResourceBundleViewResolver"></a>ResourceBundleViewResolver</h6><p>必须为<code>ResourceBundleViewResolver</code>提供 property 文件，该文件包含解析程序可以使用的视图名称和视图 classes。以下 example 显示了<code>ResourceBundleViewResolver</code>的 bean 定义以及相应的视图名称和视图 classes(取自 Pet Clinic sample)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;viewResolver&quot; class&#x3D;&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;basename&quot; value&#x3D;&quot;views&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br><span class="line">...</span><br><span class="line">welcomeView.(class)&#x3D;org.springframework.web.servlet.view.tiles3.TilesView</span><br><span class="line">welcomeView.url&#x3D;welcome (this is the name of a Tiles definition)</span><br><span class="line"></span><br><span class="line">vetsView.(class)&#x3D;org.springframework.web.servlet.view.tiles3.TilesView</span><br><span class="line">vetsView.url&#x3D;vetsView (again, this is the name of a Tiles definition)</span><br><span class="line"></span><br><span class="line">findOwnersForm.(class)&#x3D;org.springframework.web.servlet.view.JstlView</span><br><span class="line">findOwnersForm.url&#x3D;&#x2F;WEB-INF&#x2F;jsp&#x2F;findOwners.jsp</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>使用<code>ResourceBundleViewResolver</code>时，可以轻松混合使用不同的视图技术。</p>
<p>请注意，<code>TilesView</code> class 支持 JSTL(JSP 标准标记 Library)。</p>
<h6 id="SimpleSpringPreparerFactory和SpringBeanPreparerFactory"><a href="#SimpleSpringPreparerFactory和SpringBeanPreparerFactory" class="headerlink" title="SimpleSpringPreparerFactory和SpringBeanPreparerFactory"></a>SimpleSpringPreparerFactory和SpringBeanPreparerFactory</h6><p>作为高级 feature，Spring 还支持两个特殊的 Tiles <code>PreparerFactory</code> implementations。有关如何在 Tiles 定义 files 中使用<code>ViewPreparer</code> references 的详细信息，请参阅 Tiles 文档。</p>
<p>您可以根据指定的 preparer classes 指定<code>SimpleSpringPreparerFactory</code>到 autowire <code>ViewPreparer</code>实例，应用 Spring 的容器回调以及应用已配置的 Spring BeanPostProcessors。如果已激活 Spring 的 context-wide annotation configuration，则会自动检测并应用<code>ViewPreparer</code> classes 中的注释。请注意，这需要 Tiles 定义 files 中的 preparer classes，如默认<code>PreparerFactory</code>所做的那样。</p>
<p>您可以指定<code>SpringBeanPreparerFactory</code>来操作指定的 preparer 名称(而不是 classes)，从 DispatcherServlet 的 application context 中获取相应的 Spring bean。在这种情况下，完整的 bean creation process 控制着 Spring application context，允许使用显式依赖注入 configuration，作用域 beans 等。请注意，您需要为每个 preparer name 定义一个 Spring bean 定义(在 Tiles 定义中使用)。以下 example 显示了如何在<code>TilesConfigurer</code> bean 上定义<code>SpringBeanPreparerFactory</code> property 集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;tilesConfigurer&quot; class&#x3D;&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;definitions&quot;&gt;</span><br><span class="line">        &lt;list&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;general.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;widgets.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;administrator.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;customer.xml&lt;&#x2F;value&gt;</span><br><span class="line">            &lt;value&gt;&#x2F;WEB-INF&#x2F;defs&#x2F;templates.xml&lt;&#x2F;value&gt;</span><br><span class="line">        &lt;&#x2F;list&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- resolving preparer names as Spring bean definition names --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;preparerFactoryClass&quot;</span><br><span class="line">            value&#x3D;&quot;org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="RSS和Atom"><a href="#RSS和Atom" class="headerlink" title="RSS和Atom"></a>RSS和Atom</h4><p><code>AbstractAtomFeedView</code>和<code>AbstractRssFeedView</code>都从<code>AbstractFeedView</code> base class 继承，分别用于提供 Atom 和 RSS Feed 视图。它们基于 java.net 的<a target="_blank" rel="noopener" href="https://rome.dev.java.net/">罗马</a>项目，位于包<code>org.springframework.web.servlet.view.feed</code>中。</p>
<p><code>AbstractAtomFeedView</code>要求您实现<code>buildFeedEntries()</code>方法并可选地覆盖<code>buildFeedMetadata()</code>方法(默认 implementation 为空)。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SampleContentAtomView extends AbstractAtomFeedView &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void buildFeedMetadata(Map&lt;String, Object&gt; model,</span><br><span class="line">            Feed feed, HttpServletRequest request) &#123;</span><br><span class="line">        &#x2F;&#x2F; implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected List&lt;Entry&gt; buildFeedEntries(Map&lt;String, Object&gt; model,</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的要求适用于实现<code>AbstractRssFeedView</code>，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SampleContentAtomView extends AbstractRssFeedView &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void buildFeedMetadata(Map&lt;String, Object&gt; model,</span><br><span class="line">            Channel feed, HttpServletRequest request) &#123;</span><br><span class="line">        &#x2F;&#x2F; implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected List&lt;Item&gt; buildFeedItems(Map&lt;String, Object&gt; model,</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; implementation omitted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要访问 Locale，<code>buildFeedItems()</code>和<code>buildFeedEntries()</code>方法会传入 HTTP 请求。 HTTP 响应仅传递给 cookies 或其他 HTTP headers 的设置。方法返回后，Feed 会自动写入响应 object。</p>
<p>有关创建 Atom 视图的示例，请参阅 Alef Arendsen 的 Spring 团队博客<a target="_blank" rel="noopener" href="https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support">条目</a>。</p>
<h4 id="PDF和Excel"><a href="#PDF和Excel" class="headerlink" title="PDF和Excel"></a>PDF和Excel</h4><p>Spring 提供了除 HTML 以外的 return 输出的方法，包括 PDF 和 Excel 电子表格。本节介绍如何使用这些 features。</p>
<h5 id="文档视图简介"><a href="#文档视图简介" class="headerlink" title="文档视图简介"></a>文档视图简介</h5><p>HTML 页面并不总是用户查看 model 输出的最佳方式，而 Spring 使得从 model 数据动态生成 PDF 文档或 Excel 电子表格变得简单。该文档是视图，并使用正确的 content type 从服务器流式传输，以(希望)使 client PC 能够运行其电子表格或 PDF 查看器应用程序作为响应。</p>
<p>在 order 中使用 Excel 视图，您需要将 Apache POI library 添加到 classpath，对于 PDF 生成，您需要添加(最好)OpenPDF library。</p>
<blockquote>
<p>如果可能，您应该使用底层 document-generation libraries 的最新版本。特别是，我们强烈建议使用 OpenPDF(例如，OpenPDF 1.0.5)而不是过时的原始 iText 2.1.7，因为 OpenPDF 是主动维护的，并修复了不受信任的 PDF 内容的重要漏洞。</p>
</blockquote>
<h5 id="PDF视图"><a href="#PDF视图" class="headerlink" title="PDF视图"></a>PDF视图</h5><p>单词列表的简单 PDF 视图可以扩展<code>org.springframework.web.servlet.view.document.AbstractPdfView</code>并实现<code>buildPdfDocument()</code>方法，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class PdfWordList extends AbstractPdfView &#123;</span><br><span class="line"></span><br><span class="line">    protected void buildPdfDocument(Map&lt;String, Object&gt; model, Document doc, PdfWriter writer,</span><br><span class="line">            HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; words &#x3D; (List&lt;String&gt;) model.get(&quot;wordList&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            doc.add(new Paragraph(word));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制器可以从外部视图定义(通过 name 引用它)或作为处理程序方法的<code>View</code>实例返回此类视图。</p>
<h5 id="Excel视图"><a href="#Excel视图" class="headerlink" title="Excel视图"></a>Excel视图</h5><p>自 Spring Framework 4.2 以来，<code>org.springframework.web.servlet.view.document.AbstractXlsView</code>作为 Excel 视图的 base class 提供。它基于 Apache POI，具有专门的子类(<code>AbstractXlsxView</code>和<code>AbstractXlsxStreamingView</code>)，取代过时的<code>AbstractExcelView</code> class。</p>
<p>编程 model 类似于<code>AbstractPdfView</code>，其中<code>buildExcelDocument()</code>作为中心模板方法，控制器能够从外部定义(通过 name)返回这样的视图，或者从处理程序方法返回<code>View</code>实例。</p>
<h4 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-view-jsp-formtaglib-checkboxestag">与 Spring WebFlux 相同</a></p>
<p>Spring 支持 Jackson JSON library。</p>
<h5 id="基于Jackson的JSON视图"><a href="#基于Jackson的JSON视图" class="headerlink" title="基于Jackson的JSON视图"></a>基于Jackson的JSON视图</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#package.description">与 Spring WebFlux 相同</a></p>
<p><code>MappingJackson2JsonView</code>使用 Jackson library 的<code>ObjectMapper</code>将响应内容呈现为 JSON。默认情况下，model map 的全部内容(类的 exception)被编码为 JSON。对于需要过滤 map 内容的情况，您可以使用<code>modelKeys</code> property 指定要编码的特定 model 属性集。您还可以使用<code>extractValueFromSingleKeyModel</code> property 直接提取和序列化 single-key 模型中的 value，而不是 model 属性的 map。</p>
<p>您可以使用 Jackson 提供的 annotations 根据需要自定义 JSON 映射。当您需要进一步控制时，您可以 inject <code>ObjectMapper</code>通过<code>ObjectMapper</code> property，以便您需要为特定类型提供自定义 JSON 序列化程序和反序列化程序。</p>
<h5 id="基于Jackson的XML视图"><a href="#基于Jackson的XML视图" class="headerlink" title="基于Jackson的XML视图"></a>基于Jackson的XML视图</h5><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-view-httpmessagewriter">与 Spring WebFlux 相同</a></p>
<p><code>MappingJackson2XmlView</code>使用<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-dataformat-xml">Jackson XML 扩展</a> <code>XmlMapper</code>将响应内容呈现为 XML。如果 model 包含多个条目，则应使用<code>modelKey</code> bean property 显式设置 object 以进行序列化。如果 model 包含单个条目，则会自动序列化。</p>
<p>您可以使用 JAXB 或 Jackson 提供的 annotations 根据需要自定义 XML 映射。当您需要进一步控制时，您可以 inject <code>XmlMapper</code>通过<code>ObjectMapper</code> property，以便自定义 XML 需要为特定类型提供序列化程序和反序列化程序。</p>
<h4 id="XML编组"><a href="#XML编组" class="headerlink" title="XML编组"></a>XML编组</h4><p><code>MarshallingView</code>使用 XML <code>Marshaller</code>(在<code>org.springframework.oxm</code>包中定义)将响应内容呈现为 XML。您可以使用<code>MarshallingView</code>实例的<code>modelKey</code> bean property 显式设置要被编组的对象。或者，视图迭代所有 model properties 并编组<code>Marshaller</code>支持的第一个类型。有关<code>org.springframework.oxm</code>包中功能的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#webflux-view-httpmessagewriter">使用 O/X Mappers 编组 XML</a>。</p>
<h4 id="XSLT视图"><a href="#XSLT视图" class="headerlink" title="XSLT视图"></a>XSLT视图</h4><p>XSLT 是 XML 的转换语言，在 web applications 中作为视图技术很受欢迎。如果您的 application 自然地处理 XML 或者您的 model 可以很容易地转换为 XML，那么 XSLT 可以作为一种视图技术。以下部分显示如何将 XML 文档生成为 model 数据，并在 Spring Web MVC application 中使用 XSLT 进行转换。</p>
<p>这个 example 是一个简单的 Spring application，可以在<code>Controller</code>中创建一个单词列表，并将它们添加到 model map 中。返回 map 以及 XSLT 视图的 view name。有关 Spring Web MVC 的<code>Controller</code>接口的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-view-httpmessagewriter">带注释的控制器</a>。 XSLT 控制器将单词列表转换为准备转换的简单 XML 文档。</p>
<h5 id="Beans"><a href="#Beans" class="headerlink" title="Beans"></a>Beans</h5><p>Configuration 是一个简单的 Spring web application 的标准：MVC configuration 必须定义<code>XsltViewResolver</code> bean 和常规的 MVC annotation configuration。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@EnableWebMvc</span><br><span class="line">@ComponentScan</span><br><span class="line">@Configuration</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public XsltViewResolver xsltViewResolver() &#123;</span><br><span class="line">        XsltViewResolver viewResolver &#x3D; new XsltViewResolver();</span><br><span class="line">        viewResolver.setPrefix(&quot;&#x2F;WEB-INF&#x2F;xsl&#x2F;&quot;);</span><br><span class="line">        viewResolver.setSuffix(&quot;.xslt&quot;);</span><br><span class="line">        return viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="控制器-1"><a href="#控制器-1" class="headerlink" title="控制器"></a>控制器</h5><p>我们还需要一个封装 word-generation 逻辑的 Controller。</p>
<p>控制器逻辑封装在<code>@Controller</code> class 中，处理程序方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class XsltController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String home(Model model) throws Exception &#123;</span><br><span class="line">        Document document &#x3D; DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span><br><span class="line">        Element root &#x3D; document.createElement(&quot;wordList&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; words &#x3D; Arrays.asList(&quot;Hello&quot;, &quot;Spring&quot;, &quot;Framework&quot;);</span><br><span class="line">        for (String word : words) &#123;</span><br><span class="line">            Element wordNode &#x3D; document.createElement(&quot;word&quot;);</span><br><span class="line">            Text textNode &#x3D; document.createTextNode(word);</span><br><span class="line">            wordNode.appendChild(textNode);</span><br><span class="line">            root.appendChild(wordNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;wordList&quot;, root);</span><br><span class="line">        return &quot;home&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到目前为止，我们只创建了一个 DOM 文档并将其添加到 Model map 中。请注意，您还可以将 XML 文件作为<code>Resource</code>加载，并使用它而不是自定义 DOM 文档。</p>
<p>有些软件包可以自动“统一”object 图形，但是，在 Spring 中，您可以完全灵活地以您选择的任何方式从 model 创建 DOM。这可以防止 XML 的转换在 model 数据的结构中扮演太大的角色，这在使用工具管理 DOMification process 时是一种危险。</p>
<h5 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h5><p>最后，<code>XsltViewResolver</code>解析“home”XSLT 模板文件并将 DOM 文档合并到其中以生成我们的视图。如<code>XsltViewResolver</code> configuration 中所示，XSLT 模板位于<code>WEB-INF/xsl</code>目录中的<code>war</code>文件中，并以<code>xslt</code>文件扩展名结尾。</p>
<p>以下 example 显示了一个 XSLT 转换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;xsl:stylesheet version&#x3D;&quot;1.0&quot; xmlns:xsl&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;XSL&#x2F;Transform&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;xsl:output method&#x3D;&quot;html&quot; omit-xml-declaration&#x3D;&quot;yes&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;xsl:template match&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">        &lt;html&gt;</span><br><span class="line">            &lt;head&gt;&lt;title&gt;Hello!&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">            &lt;body&gt;</span><br><span class="line">                &lt;h1&gt;My First Words&lt;&#x2F;h1&gt;</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;xsl:apply-templates&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;ul&gt;</span><br><span class="line">            &lt;&#x2F;body&gt;</span><br><span class="line">        &lt;&#x2F;html&gt;</span><br><span class="line">    &lt;&#x2F;xsl:template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;xsl:template match&#x3D;&quot;word&quot;&gt;</span><br><span class="line">        &lt;li&gt;&lt;xsl:value-of select&#x3D;&quot;.&quot;&#x2F;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;xsl:template&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;xsl:stylesheet&gt;</span><br></pre></td></tr></table></figure>
<p>前面的转换呈现为以下 HTML：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;META http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;&gt;</span><br><span class="line">        &lt;title&gt;Hello!&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;&#x2F;head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;My First Words&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;Hello&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;Spring&lt;&#x2F;li&gt;</span><br><span class="line">            &lt;li&gt;Framework&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="MVC配置"><a href="#MVC配置" class="headerlink" title="MVC配置"></a>MVC配置</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#oxm">与 Spring WebFlux 相同</a></p>
<p>MVC Java configuration 和 MVC XML 名称空间提供适用于大多数 applications 的默认 configuration 和用于自定义它的 configuration API。</p>
<p>有关 configuration API 中未提供的更高级自定义，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-controller">高级 Java 配置</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config">高级 XML 配置</a>。</p>
<p>您不需要了解 MVC Java configuration 和 MVC 名称空间创建的基础 beans。如果您想了解更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-advanced-java">特殊的 Bean 类型</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-config-advanced-xml">Web MVC 配置</a>。</p>
<h4 id="启用MVC配置"><a href="#启用MVC配置" class="headerlink" title="启用MVC配置"></a>启用MVC配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-servlet-special-bean-types">与 Spring WebFlux 相同</a></p>
<p>在 Java configuration 中，您可以使用<code>@EnableWebMvc</code> annotation 来启用 MVC configuration，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 XML configuration 中，您可以使用<code>&lt;mvc:annotation-driven&gt;</code>元素启用 MVC configuration，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 注册了许多 Spring MVC <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet-config">基础设施 beans</a>并适应 classpath 上可用的依赖项(对于示例，JSON，XML 和其他的有效负载转换器)。</p>
<h4 id="MVC配置API"><a href="#MVC配置API" class="headerlink" title="MVC配置API"></a>MVC配置API</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-enable">与 Spring WebFlux 相同</a></p>
<p>在 Java configuration 中，您可以实现<code>WebMvcConfigurer</code>接口，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Implement configuration methods...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 XML 中，您可以检查<code>&lt;mvc:annotation-driven/&gt;</code>的属性和 sub-elements。您可以查看<a target="_blank" rel="noopener" href="https://schema.spring.io/mvc/spring-mvc.xsd">Spring MVC XML schema</a>或使用 IDE 的 code completion feature 来发现可用的属性和 sub-elements。</p>
<h4 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-servlet-special-bean-types">与 Spring WebFlux 相同</a></p>
<p>默认格式化，安装了<code>Number</code>和<code>Date</code>类型，包括对<code>@NumberFormat</code>和<code>@DateTimeFormat</code> 注释的支持。如果 class 路径中存在 Joda-Time，则还会安装对 Joda-Time 格式 library 的完全支持。</p>
<p>在 Java configuration 中，您可以注册自定义格式化程序和转换器，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addFormatters(FormatterRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven conversion-service&#x3D;&quot;conversionService&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;conversionService&quot;</span><br><span class="line">            class&#x3D;&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;converters&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.example.MyConverter&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;set&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;formatters&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.example.MyFormatter&quot;&#x2F;&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.example.MyAnnotationFormatterFactory&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;set&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;formatterRegistrars&quot;&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;bean class&#x3D;&quot;org.example.MyFormatterRegistrar&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;set&gt;</span><br><span class="line">        &lt;&#x2F;property&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关何时使用 FormatterRegistrar implementations 的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-config-customize">FormatterRegistrar SPI</a>和<code>FormattingConversionServiceFactoryBean</code>。</p>
</blockquote>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-conversion">与 Spring WebFlux 相同</a></p>
<p>默认情况下，如果 class 路径上存在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#format-FormatterRegistrar-SPI">Bean 验证</a>(对于 example，Hibernate Validator)，则<code>LocalValidatorFactoryBean</code>将注册为 global <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#webflux-config-validation">验证器</a>，以便与控制器方法 arguments 上的<code>@Valid</code>和<code>Validated</code>一起使用。</p>
<p>在 Java configuration 中，您可以自定义 global <code>Validator</code>实例，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Validator getValidator(); &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mvc:annotation-driven validator&#x3D;&quot;globalValidator&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>请注意，您还可以在本地注册<code>Validator</code> implementations，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @InitBinder</span><br><span class="line">    protected void initBinder(WebDataBinder binder) &#123;</span><br><span class="line">        binder.addValidators(new FooValidator());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要在某处注入<code>LocalValidatorFactoryBean</code>，请创建 bean 并在 order 中使用<code>@Primary</code>标记它以避免与 MVC configuration 中声明的冲突。</p>
</blockquote>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>在 Java configuration 中，您可以注册拦截器以应用传入请求，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new LocaleChangeInterceptor());</span><br><span class="line">        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;).excludePathPatterns(&quot;&#x2F;admin&#x2F;**&quot;);</span><br><span class="line">        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns(&quot;&#x2F;secure&#x2F;*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;</span><br><span class="line">        &lt;mvc:exclude-mapping path&#x3D;&quot;&#x2F;admin&#x2F;**&quot;&#x2F;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.web.servlet.theme.ThemeChangeInterceptor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path&#x3D;&quot;&#x2F;secure&#x2F;*&quot;&#x2F;&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.example.SecurityInterceptor&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mvc:interceptor&gt;</span><br><span class="line">&lt;&#x2F;mvc:interceptors&gt;</span><br></pre></td></tr></table></figure>
<h4 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#validation-beanvalidation-overview">与 Spring WebFlux 相同</a></p>
<p>您可以配置 Spring MVC 如何根据请求确定所请求的媒体类型(对于 example，<code>Accept</code>标头，URL 路径扩展，查询参数等)。</p>
<p>默认情况下，首先检查 URL 路径扩展名 - 将<code>json</code>，<code>xml</code>，<code>rss</code>和<code>atom</code>注册为已知的 extensions(取决于 classpath 依赖项)。第二次检查<code>Accept</code>标题。</p>
<p>请考虑仅将这些默认值更改为<code>Accept</code>标头，如果必须使用 URL-based content type 解析，请考虑在路径 extensions 上使用查询参数策略。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#validator">后缀 Match</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-content-negotiation">后缀 Match 和 RFD</a>。</p>
<p>在 Java configuration 中，您可以自定义请求的 content type 解析，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) &#123;</span><br><span class="line">        configurer.mediaType(&quot;json&quot;, MediaType.APPLICATION_JSON);</span><br><span class="line">        configurer.mediaType(&quot;xml&quot;, MediaType.APPLICATION_XML);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven content-negotiation-manager&#x3D;&quot;contentNegotiationManager&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;contentNegotiationManager&quot; class&#x3D;&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mediaTypes&quot;&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            json&#x3D;application&#x2F;json</span><br><span class="line">            xml&#x3D;application&#x2F;xml</span><br><span class="line">        &lt;&#x2F;value&gt;</span><br><span class="line">    &lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h4 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-requestmapping-suffix-pattern-match">与 Spring WebFlux 相同</a></p>
<p>您可以通过覆盖<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#mvc-ann-requestmapping-rfd">configureMessageConverters()</a>(替换 Spring MVC 创建的默认转换器)或覆盖<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/WebMvcConfigurer.html#webflux-config-message-codecs">extendMessageConverters()</a>(自定义默认转换器或将其他转换器添加到默认转换器)来自定义 Java configuration 中的<code>HttpMessageConverter</code>。</p>
<p>以下 example 添加了带有自定义<code>ObjectMapper</code>而不是默认值的 XML 和 Jackson JSON 转换器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;</span><br><span class="line">        Jackson2ObjectMapperBuilder builder &#x3D; new Jackson2ObjectMapperBuilder()</span><br><span class="line">                .indentOutput(true)</span><br><span class="line">                .dateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd&quot;))</span><br><span class="line">                .modulesToInstall(new ParameterNamesModule());</span><br><span class="line">        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));</span><br><span class="line">        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/http/converter/json/Jackson2ObjectMapperBuilder.html">Jackson2ObjectMapperBuilder</a>用于为启用缩进的<code>MappingJackson2HttpMessageConverter</code>和<code>MappingJackson2XmlHttpMessageConverter</code>创建 common configuration，自定义 date 格式，以及<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-module-parameter-names">jackson-module-parameter-names</a>的注册，这增加了对访问参数名称的支持(在 Java 8 中添加了 feature)。</p>
<p>此构建器自定义 Jackson 的默认 properties，如下所示：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#configureMessageConverters-java.util.List-">DeserializationFeature.FAIL_ON_UNKNOWNPROPERTIES</a>已禁用。</li>
<li><a target="_blank" rel="noopener" href="https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#extendMessageConverters-java.util.List-">MapperFeature.DEFAULT_VIEW_INCLUSION</a>已禁用。</li>
</ul>
<p>如果在 classpath 上检测到以下 well-known 模块，它还会自动注册：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk7">jackson-datatype-jdk7</a>：支持 Java 7 类型，例如<code>java.nio.file.Path</code>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-joda">jackson-datatype-joda</a>：支持 Joda-Time 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jsr310">jackson-datatype-jsr310</a>：支持 Java 8 Date 和 Time API 类型。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-jdk8">jackson-datatype-jdk8</a>：支持其他 Java 8 类型，例如<code>Optional</code>。</li>
</ul>
<blockquote>
<p>使用 Jackson XML 支持启用缩进除了<a target="_blank" rel="noopener" href="https://search.maven.org/#FAIL_ON_UNKNOWN_PROPERTIES">jackson-dataformat-xml</a>之外还需要<a target="_blank" rel="noopener" href="https://search.maven.org/#DEFAULT_VIEW_INCLUSION">woodstox-core-asl</a>依赖。</p>
</blockquote>
<p>其他有趣的 Jackson 模块可用：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/zalando/jackson-datatype-money">jackson-datatype-money</a>：支持<code>javax.money</code>类型(非官方模块)。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-datatype-hibernate">jackson-datatype-hibernate</a>：支持 Hibernate-specific 类型和 properties(包括 lazy-loading 方面)。</li>
</ul>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;mvc:message-converters&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;objectMapper&quot; ref&#x3D;&quot;objectMapper&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;bean class&#x3D;&quot;org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;objectMapper&quot; ref&#x3D;&quot;xmlMapper&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;&#x2F;mvc:message-converters&gt;</span><br><span class="line">&lt;&#x2F;mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;objectMapper&quot; class&#x3D;&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span><br><span class="line">      p:indentOutput&#x3D;&quot;true&quot;</span><br><span class="line">      p:simpleDateFormat&#x3D;&quot;yyyy-MM-dd&quot;</span><br><span class="line">      p:modulesToInstall&#x3D;&quot;com.fasterxml.jackson.module.paramnames.ParameterNamesModule&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;xmlMapper&quot; parent&#x3D;&quot;objectMapper&quot; p:createXmlMapper&#x3D;&quot;true&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="View控制器"><a href="#View控制器" class="headerlink" title="View控制器"></a>View控制器</h4><p>这是一个快捷方式，用于定义在调用时立即转发到视图的<code>ParameterizableViewController</code>。如果在视图生成响应之前没有要执行的 Java 控制器逻辑，则可以在静态情况下使用它。</p>
<p>下面的 Java configuration 示例将<code>/</code>的请求转发给名为<code>home</code>的视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;&#x2F;&quot;).setViewName(&quot;home&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 与前面的 example 实现相同的功能，但使用 XML，使用<code>&lt;mvc:view-controller&gt;</code>元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:view-controller path&#x3D;&quot;&#x2F;&quot; view-name&#x3D;&quot;home&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="View解析器-2"><a href="#View解析器-2" class="headerlink" title="View解析器"></a>View解析器</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#search|gav|1|g%3A&quot;org.codehaus.woodstox&quot; AND a%3A&quot;woodstox-core-asl&quot;">与 Spring WebFlux 相同</a></p>
<p>MVC configuration 简化了视图解析器的注册。</p>
<p>以下 Java configuration example 使用 JSP 和 Jackson 作为 JSON 呈现的默认<code>View</code>配置内容 negotiation view resolution：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.enableContentNegotiation(new MappingJackson2JsonView());</span><br><span class="line">        registry.jsp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:view-resolvers&gt;</span><br><span class="line">    &lt;mvc:content-negotiation&gt;</span><br><span class="line">        &lt;mvc:default-views&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;mvc:default-views&gt;</span><br><span class="line">    &lt;&#x2F;mvc:content-negotiation&gt;</span><br><span class="line">    &lt;mvc:jsp&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:view-resolvers&gt;</span><br></pre></td></tr></table></figure>
<p>但请注意，FreeMarker，Tiles，Groovy Markup 和脚本模板也需要配置底层视图技术。</p>
<p>MVC 名称空间提供专用元素。以下 example 适用于 FreeMarker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:view-resolvers&gt;</span><br><span class="line">    &lt;mvc:content-negotiation&gt;</span><br><span class="line">        &lt;mvc:default-views&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;mvc:default-views&gt;</span><br><span class="line">    &lt;&#x2F;mvc:content-negotiation&gt;</span><br><span class="line">    &lt;mvc:freemarker cache&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:view-resolvers&gt;</span><br><span class="line"></span><br><span class="line">&lt;mvc:freemarker-configurer&gt;</span><br><span class="line">    &lt;mvc:template-loader-path location&#x3D;&quot;&#x2F;freemarker&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:freemarker-configurer&gt;</span><br></pre></td></tr></table></figure>
<p>在 Java configuration 中，您可以添加相应的<code>Configurer</code> bean，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureViewResolvers(ViewResolverRegistry registry) &#123;</span><br><span class="line">        registry.enableContentNegotiation(new MappingJackson2JsonView());</span><br><span class="line">        registry.freeMarker().cache(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FreeMarkerConfigurer freeMarkerConfigurer() &#123;</span><br><span class="line">        FreeMarkerConfigurer configurer &#x3D; new FreeMarkerConfigurer();</span><br><span class="line">        configurer.setTemplateLoaderPath(&quot;&#x2F;freemarker&quot;);</span><br><span class="line">        return configurer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态资源-1"><a href="#静态资源-1" class="headerlink" title="静态资源"></a>静态资源</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#search|ga|1|a%3A&quot;jackson-dataformat-xml&quot;">与 Spring WebFlux 相同</a></p>
<p>此选项提供了一种从<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/io/Resource.html">资源</a> -based 位置列表中提供静态资源的便捷方法。</p>
<p>在下一个示例中，给定以<code>/resources</code>开头的请求，相对路径用于在 web application 根目录下或<code>/static</code>下的 classpath 上查找和提供相对于<code>/public</code>的静态资源。资源的使用期限为 one-year，以确保最大程度地使用浏览器缓存并减少浏览器发出的 HTTP 请求。还会评估<code>Last-Modified</code>标头，如果存在，则返回<code>304</code> status code。</p>
<p>以下清单显示了如何使用 Java configuration 执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;resources&#x2F;**&quot;)</span><br><span class="line">            .addResourceLocations(&quot;&#x2F;public&quot;, &quot;classpath:&#x2F;static&#x2F;&quot;)</span><br><span class="line">            .setCachePeriod(31556926);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources mapping&#x3D;&quot;&#x2F;resources&#x2F;**&quot;</span><br><span class="line">    location&#x3D;&quot;&#x2F;public, classpath:&#x2F;static&#x2F;&quot;</span><br><span class="line">    cache-period&#x3D;&quot;31556926&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>另见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-view-resolvers">HTTP 缓存支持静态资源</a>。</p>
<p>资源处理程序还支持<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceResolver.html">ResourceResolver</a> <strong>mplementations 和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceTransformer.html">ResourceTransformer</a> </strong>mplementations 链，您可以使用它来创建工具链以使用优化的资源。</p>
<p>您可以将<code>VersionResourceResolver</code>用于基于从内容计算的 MD5 哈希，固定 application version 或其他的版本化资源 URL。 <code>ContentVersionStrategy</code>(MD5 哈希)是一个不错的选择 - 有一些值得注意的 exceptions，例如与模块加载器一起使用的 JavaScript 资源。</p>
<p>以下 example 显示了如何在 Java configuration 中使用<code>VersionResourceResolver</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addResourceHandler(&quot;&#x2F;resources&#x2F;**&quot;)</span><br><span class="line">                .addResourceLocations(&quot;&#x2F;public&#x2F;&quot;)</span><br><span class="line">                .resourceChain(true)</span><br><span class="line">                .addResolver(new VersionResourceResolver().addContentVersionStrategy(&quot;&#x2F;**&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:resources mapping&#x3D;&quot;&#x2F;resources&#x2F;**&quot; location&#x3D;&quot;&#x2F;public&#x2F;&quot;&gt;</span><br><span class="line">    &lt;mvc:resource-chain&gt;</span><br><span class="line">        &lt;mvc:resource-cache&#x2F;&gt;</span><br><span class="line">        &lt;mvc:resolvers&gt;</span><br><span class="line">            &lt;mvc:version-resolver&gt;</span><br><span class="line">                &lt;mvc:content-version-strategy patterns&#x3D;&quot;&#x2F;**&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;mvc:version-resolver&gt;</span><br><span class="line">        &lt;&#x2F;mvc:resolvers&gt;</span><br><span class="line">    &lt;&#x2F;mvc:resource-chain&gt;</span><br><span class="line">&lt;&#x2F;mvc:resources&gt;</span><br></pre></td></tr></table></figure>
<p>然后，您可以使用<code>ResourceUrlProvider</code>来 rewrite URL 并将完整的解析器和变换器链应用于 example，以插入版本。 MVC configuration 提供<code>ResourceUrlProvider</code> bean，以便可以将其注入其他人。您还可以使用<code>ResourceUrlEncodingFilter</code>使用<code>ResourceUrlEncodingFilter</code>透明化 Thymeleaf，JSP，FreeMarker 以及其他依赖<code>HttpServletResponse#encodeURL</code>的 URL 标记。</p>
<p>请注意，当同时使用<code>EncodedResourceResolver</code>(对于 example，用于提供 gzip 或 brotli-encoded 资源)和<code>VersionedResourceResolver</code>时，必须在此 order 中注册它们。这样可以确保始终根据未编码的文件可靠地计算 content-based 版本。</p>
<p><code>WebJarsResourceResolver</code>也通过<code>WebJarsResourceResolver</code>支持，并在 class 路径上存在<code>org.webjars:webjars-locator</code>时自动注册。解析器可以 re-write URL 包含 jar 的 version，也可以匹配到没有版本的传入 URL - 例如，<code>/jquery/jquery.min.js</code>到<code>/jquery/1.2.0/jquery.min.js</code>。</p>
<h4 id="默认Servlet"><a href="#默认Servlet" class="headerlink" title="默认Servlet"></a>默认Servlet</h4><p>Spring MVC 允许将<code>DispatcherServlet</code>映射到<code>/</code>(从而覆盖容器的默认 Servlet 的映射)，同时仍允许容器的默认 Servlet 处理静态资源请求。它使用<code>/**</code>的 URL 映射配置<code>DefaultServletHttpRequestHandler</code>，并将相对于其他 URL 映射的最低优先级配置为<code>DefaultServletHttpRequestHandler</code>。</p>
<p>此处理程序将所有请求转发到默认的 Servlet。因此，它必须保留在所有其他 URL <code>HandlerMappings</code>的 order 中的最后一个。如果你使用<code>&lt;mvc:annotation-driven&gt;</code>就是这种情况。或者，如果您设置自己的自定义<code>HandlerMapping</code>实例，请务必将其<code>order</code> property 设置为低于<code>DefaultServletHttpRequestHandler</code>的 value，即<code>Integer.MAX_VALUE</code>。</p>
<p>以下 example 显示了如何使用默认设置启用 feature：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>覆盖<code>/</code> Servlet 映射的警告是，必须通过 name 而不是 path 来检索默认 Servlet 的<code>RequestDispatcher</code>。 <code>DefaultServletHttpRequestHandler</code>使用大多数主要 Servlet 容器(包括 Tomcat，Jetty，GlassFish，JBoss，Resin，WebLogic 和 WebSphere)的已知名称列表，在启动 time 时尝试 auto-detect 为容器的默认 Servlet。如果默认 Servlet 是 custom-configured 且具有不同的 name，或者如果在默认的 Servlet name 未知的情况下使用了不同的 Servlet 容器，则必须显式提供默认的 Servlet 的 name，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123;</span><br><span class="line">        configurer.enable(&quot;myCustomDefaultServlet&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler default-servlet-name&#x3D;&quot;myCustomDefaultServlet&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-static-resources">与 Spring WebFlux 相同</a></p>
<p>您可以自定义与路径匹配和 URL 处理相关的选项。有关各个选项的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/config/annotation/PathMatchConfigurer.html">PathMatchConfigurer</a> javadoc。</p>
<p>以下 example 显示了如何在 Java configuration 中自定义路径匹配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class WebConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">        configurer</span><br><span class="line">            .setUseSuffixPatternMatch(true)</span><br><span class="line">            .setUseTrailingSlashMatch(false)</span><br><span class="line">            .setUseRegisteredSuffixPatternMatch(true)</span><br><span class="line">            .setPathMatcher(antPathMatcher())</span><br><span class="line">            .setUrlPathHelper(urlPathHelper())</span><br><span class="line">            .addPathPrefix(&quot;&#x2F;api&quot;,</span><br><span class="line">                    HandlerTypePredicate.forAnnotation(RestController.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UrlPathHelper urlPathHelper() &#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public PathMatcher antPathMatcher() &#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了如何在 XML 中实现相同的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;mvc:path-matching</span><br><span class="line">        suffix-pattern&#x3D;&quot;true&quot;</span><br><span class="line">        trailing-slash&#x3D;&quot;false&quot;</span><br><span class="line">        registered-suffixes-only&#x3D;&quot;true&quot;</span><br><span class="line">        path-helper&#x3D;&quot;pathHelper&quot;</span><br><span class="line">        path-matcher&#x3D;&quot;pathMatcher&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;mvc:annotation-driven&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id&#x3D;&quot;pathHelper&quot; class&#x3D;&quot;org.example.app.MyPathHelper&quot;&#x2F;&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;pathMatcher&quot; class&#x3D;&quot;org.example.app.MyPathMatcher&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="高级Java配置"><a href="#高级Java配置" class="headerlink" title="高级Java配置"></a>高级Java配置</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-caching-static-resources">与 Spring WebFlux 相同</a></p>
<p><code>@EnableWebMvc</code>进口<code>DelegatingWebMvcConfiguration</code>，其中：</p>
<ul>
<li>为 Spring MVC applications 提供默认的 Spring configuration</li>
<li>检测并委托<code>WebMvcConfigurer</code> implementations 来自定义 configuration。</li>
</ul>
<p>对于高级模式，您可以删除<code>@EnableWebMvc</code>并直接从<code>DelegatingWebMvcConfiguration</code>扩展而不是实现<code>WebMvcConfigurer</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebConfig extends DelegatingWebMvcConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在<code>WebConfig</code>中保留现有方法，但现在您也可以从 base class 覆盖 bean 声明，并且您仍然可以在 classpath 上包含任意数量的其他<code>WebMvcConfigurer</code> __mplement。</p>
<h4 id="高级XML配置"><a href="#高级XML配置" class="headerlink" title="高级XML配置"></a>高级XML配置</h4><p>MVC 命名空间没有高级模式。如果你需要在 bean 上自定义 property，否则你无法改变，你可以使用 Spring <code>ApplicationContext</code>的<code>BeanPostProcessor</code>生命周期 hook，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，您需要将<code>MyPostProcessor</code>声明为 bean，显式为 XML 或允许通过<code>&lt;component-scan/&gt;</code>声明进行检测。</p>
<h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-config-path-matching">与 Spring WebFlux 相同</a></p>
<p>Servlet 4 容器需要支持 HTTP/2，而 Spring Framework 5 与 Servlet API 兼容 4.从编程 model 的角度来看，没有特定的 applications 需要做的事情。但是，有一些与 server configuration 相关的注意事项。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support">HTTP/2 维基页面</a>。</p>
<p>Servlet API 确实公开了一个与 HTTP/2 相关的构造。您可以使用<code>javax.servlet.http.PushBuilder</code>主动将资源推送到 clients，并且它支持<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-config-advanced-java">方法论证</a>到<code>@RequestMapping</code>方法。</p>
<h2 id="REST-Clients"><a href="#REST-Clients" class="headerlink" title="REST-Clients"></a>REST-Clients</h2><p>本节介绍 client-side 访问 REST endpoints 的选项。</p>
<h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p><code>RestTemplate</code>是执行 HTTP 请求的同步 client。它是原始的 Spring REST client，并在底层的 HTTP client libraries 上公开了一个简单的 template-method API。</p>
<blockquote>
<p>从 5.0 开始，non-blocking，reactive <code>WebClient</code>提供了<code>RestTemplate</code>的现代替代方案，同时有效地支持同步和异步以及流方案。 <code>RestTemplate</code>将在未来的 version 中弃用，并且不会在未来添加主要的新 features。</p>
</blockquote>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#webflux-http2">REST Endpoints</a>。</p>
<h3 id="Web客户端"><a href="#Web客户端" class="headerlink" title="Web客户端"></a>Web客户端</h3><p><code>WebClient</code>是执行 HTTP 请求的 non-blocking，reactive client。它在 5.0 中引入并提供了<code>RestTemplate</code>的现代替代方案，同时有效支持同步和异步以及流方案。</p>
<p>与<code>RestTemplate</code>相反，<code>WebClient</code>支持以下内容：</p>
<ul>
<li>Non-blocking I/O。</li>
<li>Reactive Streams 背压。</li>
<li>高并发性，硬件资源更少。</li>
<li>Functional-style，fluent API 利用 Java 8 lambdas。</li>
<li>同步和异步交互。</li>
<li>从服务器流式传输或向下传输。</li>
</ul>
<p>有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#mvc-ann-arguments">Web 客户端</a>。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#rest-client-access">Spring WebFlux 中相同</a></p>
<p>本节总结了<code>spring-test</code>中可用于 Spring MVC applications 的选项。</p>
<ul>
<li>Servlet API 模拟：Mock _实现 Servlet API contracts 用于单元测试控制器，过滤器和其他 web 组件。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#webflux-client">Servlet API</a> mock objects。</li>
<li>TestContext Framework：支持在 JUnit 和 TestNG 测试中 loading Spring configuration，包括跨测试方法高效缓存已加载的 configuration，并支持使用<code>MockServletContext</code> 加载<code>WebApplicationContext</code>。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#webflux-test">TestContext Framework</a>。</li>
<li>Spring MVC 测试：framework，也称为<code>MockMvc</code>，用于通过<code>DispatcherServlet</code>(即支持 annotations)测试带注释的控制器，完成 Spring MVC 基础结构但没有 HTTP 服务器。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#mock-objects-servlet">Spring MVC 测试</a>。</li>
<li>Client-side REST：<code>spring-test</code>提供<code>MockRestServiceServer</code>，您可以将其用作 mock 服务器来测试内部使用<code>RestTemplate</code>的 client-side code。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-framework">Client REST 测试</a>。</li>
<li><code>WebTestClient</code>：专为测试 WebFlux applications 而构建，但它也可用于通过 HTTP 连接对任何服务器进行 end-to-end integration 测试。它是 non-blocking，reactive client，非常适合测试异步和流式方案。</li>
</ul>
<h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#spring-mvc-test-framework">与 Spring WebFlux 相同</a></p>
<p>reference 文档的这一部分包括对 Servlet 堆栈的支持，包括原始 WebSocket 交互的 WebSocket 消息传递，通过 SockJS 的 WebSocket 仿真，以及通过 STOMP 作为 sub-protocol over WebSocket 的 publish-subscribe 消息传递。</p>
<h3 id="WebSocket-简介"><a href="#WebSocket-简介" class="headerlink" title="WebSocket 简介"></a>WebSocket 简介</h3><p>WebSocket 协议<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>提供了一种标准方法，可以通过单个 TCP 连接在 client 和服务器之间建立 full-duplex，two-way 通信 channel。它是来自 HTTP 的不同 TCP 协议，但设计为使用端口 80 和 443 并允许 re-use 现有防火墙规则通过 HTTP 工作。</p>
<p>WebSocket 交互以 HTTP 请求开始，该 HTTP 请求使用 HTTP <code>Upgrade</code>标头进行升级，或者在这种情况下，切换到 WebSocket 协议。以下 example 显示了这样的交互：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;spring-websocket-portfolio&#x2F;portfolio HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Upgrade: websocket (1)</span><br><span class="line">Connection: Upgrade (2)</span><br><span class="line">Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp, v11.stomp</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;localhost:8080</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>Upgrade</code>标题。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>使用<code>Upgrade</code>连接。</td>
</tr>
</tbody>
</table>
</div>
<p>具有 WebSocket 支持的服务器返回类似于以下内容的输出，而不是通常的 200 状态 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols (1)</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: v10.stomp</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>协议切换</td>
</tr>
</tbody>
</table>
</div>
<p>成功握手后，HTTP 升级请求所基于的 TCP socket 将保持打开状态，以便 client 和服务器继续发送和接收消息。</p>
<p>有关 WebSockets 如何工作的完整介绍超出了本文档的范围。请参阅 RFC 6455，HTML5 的 WebSocket 章节，或者 Web 上的任何介绍和教程。</p>
<p>请注意，如果 WebSocket 服务器在 web 服务器(e.g. nginx)后面运行，则可能需要将其配置为将 WebSocket 升级请求传递到 WebSocket 服务器。同样，如果 application 在云环境中运行，请检查与 WebSocket 支持相关的云提供程序的说明。</p>
<h4 id="HTTP与WebSocket"><a href="#HTTP与WebSocket" class="headerlink" title="HTTP与WebSocket"></a>HTTP与WebSocket</h4><p>尽管 WebSocket 被设计为 HTTP-compatible 并以 HTTP 请求开始，但重要的是要理解这两种协议会导致非常不同的体系结构和 application 编程模型。</p>
<p>在 HTTP 和 REST 中，application 被建模为多个 URL。要与 application 进行交互，clients 访问这些 URL，request-response 样式。 Servers 根据 HTTP URL，方法和 headers 将请求路由到相应的处理程序。</p>
<p>相比之下，在 WebSockets 中，初始连接通常只有一个 URL。随后，所有 application 消息都在同一 TCP 连接上流动。这指向一个完全不同的异步，event-driven，messaging architecture。</p>
<p>WebSocket 也是一种 low-level 传输协议，与 HTTP 不同，它不对消息内容规定任何语义。这意味着除非 client 和服务器就消息语义达成一致，否则无法对路由进行 route 或 process。</p>
<p>WebSocket clients 和服务器可以通过 HTTP 握手请求上的<code>Sec-WebSocket-Protocol</code>标头协商使用 higher-level，消息传递协议(对于 example，STOMP)。如果没有，他们需要提出自己的惯例。</p>
<h4 id="何时使用WebSockets"><a href="#何时使用WebSockets" class="headerlink" title="何时使用WebSockets"></a>何时使用WebSockets</h4><p>WebSockets 可以使 web 页面成为动态和交互式的。但是，在许多情况下，Ajax 和 HTTP 流式传输或 long 轮询的组合可以提供简单有效的解决方案。</p>
<p>例如，新闻，邮件和社交订阅源需要动态更新，但每隔几分钟就可以完全正常更新。另一方面，协作，游戏和财务应用程序需要更接近 real-time。</p>
<p>仅延迟不是决定因素。如果消息量相对较低(例如，监视网络故障)，HTTP 流式传输或轮询可以提供有效的解决方案。它是低延迟，高频率和高容量的组合，是使用 WebSocket 的最佳选择。</p>
<p>还要记住，在 Internet 上，超出控制范围的限制性代理可能会阻止 WebSocket 交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭 long-lived 连接，这些连接显示为 idle。这意味着在防火墙内部使用 WebSocket 进行内部应用比使用面向公众的应用程序更直接。</p>
<h3 id="WebSocketAPI"><a href="#WebSocketAPI" class="headerlink" title="WebSocketAPI"></a>WebSocketAPI</h3><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#spring-mvc-test-client">与 Spring WebFlux 相同</a></p>
<p>Spring Framework 提供了一个 WebSocket API，您可以使用它来编写处理 WebSocket 消息的 client-和 server-side applications。</p>
<h4 id="WebSocketHandler"><a href="#WebSocketHandler" class="headerlink" title="WebSocketHandler"></a>WebSocketHandler</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-websocket">与 Spring WebFlux 相同</a></p>
<p>创建 WebSocket 服务器就像实现<code>WebSocketHandler</code>一样简单，或者更有可能扩展<code>TextWebSocketHandler</code>或<code>BinaryWebSocketHandler</code>。以下 example 使用<code>TextWebSocketHandler</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.socket.WebSocketHandler;</span><br><span class="line">import org.springframework.web.socket.WebSocketSession;</span><br><span class="line">import org.springframework.web.socket.TextMessage;</span><br><span class="line"></span><br><span class="line">public class MyHandler extends TextWebSocketHandler &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleTextMessage(WebSocketSession session, TextMessage message) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有专门的 WebSocket Java configuration 和 XML 名称空间支持，用于将前面的 WebSocket 处理程序映射到特定的 URL，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(myHandler(), &quot;&#x2F;myHandler&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler myHandler() &#123;</span><br><span class="line">        return new MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:handlers&gt;</span><br><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;myHandler&quot; handler&#x3D;&quot;myHandler&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myHandler&quot; class&#x3D;&quot;org.springframework.samples.MyHandler&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>pereceding example 用于 Spring MVC applications，应该包含在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-websocket-server">DispatcherServlet</a>的 configuration 中。但是，Spring 的 WebSocket 支持不依赖于 Spring MVC。在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/socket/server/support/WebSocketHttpRequestHandler.html">WebSocketHttpRequestHandler</a>的帮助下将<code>WebSocketHandler</code>集成到其他 HTTP-serving 环境中相对简单。</p>
<h4 id="WebSocket信号交换"><a href="#WebSocket信号交换" class="headerlink" title="WebSocket信号交换"></a>WebSocket信号交换</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-websocket-server-handler">与 Spring WebFlux 相同</a></p>
<p>自定义初始 HTTP WebSocket 握手请求的最简单方法是通过<code>HandshakeInterceptor</code>，它在握手之前“之前”和“之后”暴露方法。您可以使用此类拦截器来阻止握手或使<code>WebSocketSession</code>可以使用任何属性。以下 example 使用 built-in 拦截器将 HTTP session 属性传递给 WebSocket session：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(new MyHandler(), &quot;&#x2F;myHandler&quot;)</span><br><span class="line">            .addInterceptors(new HttpSessionHandshakeInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:handlers&gt;</span><br><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;myHandler&quot; handler&#x3D;&quot;myHandler&quot;&#x2F;&gt;</span><br><span class="line">        &lt;websocket:handshake-interceptors&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;websocket:handshake-interceptors&gt;</span><br><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myHandler&quot; class&#x3D;&quot;org.springframework.samples.MyHandler&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>更高级的选项是扩展执行 WebSocket 握手步骤的<code>DefaultHandshakeHandler</code>，包括验证 client 原点，协商 sub-protocol 和其他详细信息。如果需要在 order 中配置自定义<code>RequestUpgradeStrategy</code>以适应 WebSocket 服务器引擎和尚未支持的 version，则 application 可能还需要使用此选项(有关此主题的更多信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet">部署</a>)。 Java configuration 和 XML 命名空间都可以配置自定义<code>HandshakeHandler</code>。</p>
<blockquote>
<p>Spring 提供<code>WebSocketHandlerDecorator</code> base class，您可以使用它来装饰带有其他行为的<code>WebSocketHandler</code>。使用 WebSocket Java configuration 或 XML 命名空间时，默认情况下会提供并添加 Logging 和 exception 处理 implementations。 <code>ExceptionWebSocketHandlerDecorator</code>捕获由任何<code>WebSocketHandler</code>方法引起的所有未捕获的 exceptions，并以状态<code>1011</code>关闭 WebSocket session，这表示服务器错误。</p>
</blockquote>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>Spring WebSocket API 易于集成到 Spring MVC application 中，其中<code>DispatcherServlet</code>同时提供 HTTP WebSocket 握手和其他 HTTP 请求。通过调用<code>WebSocketHttpRequestHandler</code>也可以轻松地集成到其他 HTTP 处理场景中。这很方便易懂。但是，有关 JSR-356 运行时的特殊注意事项。</p>
<p>Java WebSocket API(JSR-356)提供了两种部署机制。第一个涉及启动时的 Servlet 容器 classpath 扫描(Servlet 3 feature)。另一个是在 Servlet 容器初始化时使用的注册 API。这些机制都不能使用单个“前端控制器”进行所有 HTTP 处理 - 包括 WebSocket 握手和所有其他 HTTP 请求 - 例如 Spring MVC 的<code>DispatcherServlet</code>。</p>
<p>这是 JSR-356 的一个重要限制，Spring 的 WebSocket 支持使用 server-specific <code>RequestUpgradeStrategy</code> __mplement 进行地址，即使在 JSR-356 运行时运行时也是如此。目前，Tomcat，Jetty，GlassFish，WebLogic，WebSphere 和 Undertow(以及 WildFly)都有这样的策略。</p>
<blockquote>
<p>已经创建了一个克服 Java WebSocket API 中的上述限制的请求，可以在<a target="_blank" rel="noopener" href="https://github.com/eclipse-ee4j/websocket-api/issues/211">eclipse-ee4j/websocket-api#211</a>处遵循。 Tomcat，Undertow 和 WebSphere 提供了自己的 API 替代方案，可以实现这一点，并且 Jetty 也可以。我们希望更多的服务器能够做到这一点。</p>
</blockquote>
<p>第二个考虑因素是具有 JSR-356 支持的 Servlet 容器应该执行<code>ServletContainerInitializer</code>(SCI)扫描，这可以减慢 application 启动速度 - 在某些情况下，显着。如果在使用 JSR-356 支持升级到 Servlet 容器 version 后观察到重大影响，则应该可以通过使用<code>web.xml</code>中的<code>&lt;absolute-ordering /&gt;</code>元素选择性地启用或禁用 web 片段(和 SCI 扫描)，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee</span><br><span class="line">        http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;</span><br><span class="line">    version&#x3D;&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;absolute-ordering&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p>然后，您可以通过 name 选择性地启用 web 片段，例如 Spring 自己的<code>SpringServletContainerInitializer</code>，它提供对 Servlet 3 Java 初始化 API 的支持。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee</span><br><span class="line">        http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_3_0.xsd&quot;</span><br><span class="line">    version&#x3D;&quot;3.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;absolute-ordering&gt;</span><br><span class="line">        &lt;name&gt;spring_web&lt;&#x2F;name&gt;</span><br><span class="line">    &lt;&#x2F;absolute-ordering&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<h4 id="服务器Configuration"><a href="#服务器Configuration" class="headerlink" title="服务器Configuration"></a>服务器Configuration</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#webflux-websocket-server-handshake">与 Spring WebFlux 相同</a></p>
<p>每个底层 WebSocket 引擎都会公开控制运行时特征的 configuration properties，例如消息缓冲区大小，idle 超时等等。</p>
<p>对于 Tomcat，WildFly 和 GlassFish，您可以将<code>ServletServerContainerFactoryBean</code>添加到 WebSocket Java 配置中，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletServerContainerFactoryBean createWebSocketContainer() &#123;</span><br><span class="line">        ServletServerContainerFactoryBean container &#x3D; new ServletServerContainerFactoryBean();</span><br><span class="line">        container.setMaxTextMessageBufferSize(8192);</span><br><span class="line">        container.setMaxBinaryMessageBufferSize(8192);</span><br><span class="line">        return container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework...ServletServerContainerFactoryBean&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;maxTextMessageBufferSize&quot; value&#x3D;&quot;8192&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;maxBinaryMessageBufferSize&quot; value&#x3D;&quot;8192&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 client-side WebSocket configuration，您应该使用<code>WebSocketContainerFactoryBean</code>(XML)或<code>ContainerProvider.getWebSocketContainer()</code>(Java configuration)。</p>
</blockquote>
<p>对于 Jetty，您需要提供 pre-configured Jetty <code>WebSocketServerFactory</code>并通过 WebSocket Java 配置将其插入 Spring 的<code>DefaultHandshakeHandler</code>。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(echoWebSocketHandler(),</span><br><span class="line">            &quot;&#x2F;echo&quot;).setHandshakeHandler(handshakeHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultHandshakeHandler handshakeHandler() &#123;</span><br><span class="line"></span><br><span class="line">        WebSocketPolicy policy &#x3D; new WebSocketPolicy(WebSocketBehavior.SERVER);</span><br><span class="line">        policy.setInputBufferSize(8192);</span><br><span class="line">        policy.setIdleTimeout(600000);</span><br><span class="line"></span><br><span class="line">        return new DefaultHandshakeHandler(</span><br><span class="line">                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:handlers&gt;</span><br><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;echo&quot; handler&#x3D;&quot;echoHandler&quot;&#x2F;&gt;</span><br><span class="line">        &lt;websocket:handshake-handler ref&#x3D;&quot;handshakeHandler&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;handshakeHandler&quot; class&#x3D;&quot;org.springframework...DefaultHandshakeHandler&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref&#x3D;&quot;upgradeStrategy&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;upgradeStrategy&quot; class&#x3D;&quot;org.springframework...JettyRequestUpgradeStrategy&quot;&gt;</span><br><span class="line">        &lt;constructor-arg ref&#x3D;&quot;serverFactory&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;serverFactory&quot; class&#x3D;&quot;org.eclipse.jetty...WebSocketServerFactory&quot;&gt;</span><br><span class="line">        &lt;constructor-arg&gt;</span><br><span class="line">            &lt;bean class&#x3D;&quot;org.eclipse.jetty...WebSocketPolicy&quot;&gt;</span><br><span class="line">                &lt;constructor-arg value&#x3D;&quot;SERVER&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;inputBufferSize&quot; value&#x3D;&quot;8092&quot;&#x2F;&gt;</span><br><span class="line">                &lt;property name&#x3D;&quot;idleTimeout&quot; value&#x3D;&quot;600000&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;bean&gt;</span><br><span class="line">        &lt;&#x2F;constructor-arg&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h4 id="允许Origins"><a href="#允许Origins" class="headerlink" title="允许Origins"></a>允许Origins</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web-reactive.html#websocket-server-deployment">与 Spring WebFlux 相同</a></p>
<p>从 Spring Framework 4.1.5 开始，WebSocket 和 SockJS 的默认行为是仅接受 same-origin 请求。也可以允许所有或指定的起源列表。此检查主要是为浏览器客户端设计的。没有什么可以阻止其他类型的 clients 修改<code>Origin</code>标头 value(有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6454">RFC 6454：Web Origin 概念</a>)。</p>
<p>三种可能的行为是：</p>
<ul>
<li>仅允许 same-origin 个请求(默认)：在此模式下，启用 SockJS 时，Iframe HTTP 响应头<code>X-Frame-Options</code>设置为<code>SAMEORIGIN</code>，并且禁用 JSONP 传输，因为它不允许检查请求的来源。因此，启用此模式时不支持 IE6 和 IE7。</li>
<li>允许指定的原始列表：每个允许的原点必须以<code>http://</code>或<code>https://</code>开头。在此模式下，启用 SockJS 时，将禁用 IFrame 传输。因此，启用此模式时，不支持 IE6 到 IE9。</li>
<li>允许所有来源：要启用此模式，您应提供<code>*</code>作为允许的原始值。在此模式下，所有传输都可用。</li>
</ul>
<p>您可以配置 WebSocket 和 SockJS 允许的源，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line">import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(myHandler(), &quot;&#x2F;myHandler&quot;).setAllowedOrigins(&quot;http:&#x2F;&#x2F;mydomain.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler myHandler() &#123;</span><br><span class="line">        return new MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:handlers allowed-origins&#x3D;&quot;http:&#x2F;&#x2F;mydomain.com&quot;&gt;</span><br><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;myHandler&quot; handler&#x3D;&quot;myHandler&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myHandler&quot; class&#x3D;&quot;org.springframework.samples.MyHandler&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<h3 id="SockJS后备"><a href="#SockJS后备" class="headerlink" title="SockJS后备"></a>SockJS后备</h3><p>在公共 Internet 上，受控制之外的限制性代理可能会阻止 WebSocket 交互，因为它们未配置为传递<code>Upgrade</code>标头，或者因为它们关闭似乎为 idle 的 long-lived 连接。</p>
<p>这个问题的解决方案是 WebSocket 仿真 - 也就是说，首先尝试使用 WebSocket，然后再依靠 HTTP-based 技术来模拟 WebSocket 交互并公开相同的 application-level API。</p>
<p>在 Servlet 堆栈上，Spring Framework 为 SockJS 协议提供服务器(以及 client)支持。</p>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SockJS 的目标是让 applications 使用 WebSocket API，但在运行时必要时可以回退到 non-WebSocket 替代品，而无需更改 application code。</p>
<p>SockJS 包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-protocol">SockJS 协议</a>以可执行文件<a target="_blank" rel="noopener" href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">叙述测试</a>的形式定义。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">SockJS JavaScript client</a> - 用于浏览器的 client library。</li>
<li>SockJS 服务器 implementations，包括 Spring Framework <code>spring-websocket</code>模块中的一个。</li>
<li><code>spring-websocket</code>模块中的 SockJS Java client(自 version 4.1 起)。</li>
</ul>
<p>SockJS 专为在浏览器中使用而设计。它使用各种技术来支持各种浏览器版本。有关 SockJS 传输类型和浏览器的完整列表，请参阅<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">SockJS client</a>页面。传输分为三大类：WebSocket，HTTP Streaming 和 HTTP Long Polling。有关这些类别的概述，请参阅<a target="_blank" rel="noopener" href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">这篇博文</a>。</p>
<p>SockJS client 首先发送<code>GET /info</code>以从服务器获取基本信息。之后，它必须决定使用什么传输。如果可能，使用 WebSocket。如果没有，在大多数浏览器中，至少有一个 HTTP 流选项。如果不是，则使用 HTTP(long)轮询。</p>
<p>所有传输请求都具有以下 URL 结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;host:port&#x2F;myApp&#x2F;myEndpoint&#x2F;&#123;server-id&#125;&#x2F;&#123;session-id&#125;&#x2F;&#123;transport&#125;</span><br></pre></td></tr></table></figure>
<p>哪里：</p>
<ul>
<li><code>&#123;server-id&#125;</code>对于在 cluster 中路由请求很有用，但是否则不会使用。</li>
<li><code>&#123;session-id&#125;</code>关联属于 SockJS session 的 HTTP 请求。</li>
<li><code>&#123;transport&#125;</code>表示传输类型(对于 example，<code>websocket</code>，<code>xhr-streaming</code>和其他)。</li>
</ul>
<p>WebSocket 传输只需要一个 HTTP 请求即可进行 WebSocket 握手。之后的所有消息都在该 socket 上交换。</p>
<p>HTTP 传输需要更多请求。 Ajax/XHR streaming，对于 example，依赖于 server-to-client 消息的 long-running 请求和 client-to-server 消息的其他 HTTP POST 请求。 Long 轮询类似，只是它在每次 server-to-client 发送后_end 当前请求。</p>
<p>SockJS 增加了最小的消息框架。例如，服务器最初发送字母<code>o</code>(“打开”框架)，如果没有消息流动 25 秒(默认情况下)，消息将发送为<code>a[&quot;message1&quot;,&quot;message2&quot;]</code>(JSON-encoded array)，字母<code>h</code>(“心跳”帧)，以及字母<code>c</code>(“关闭”框架)关闭 session。</p>
<p>要了解更多信息，请在浏览器中运行 example 并查看 HTTP 请求。 SockJS client 允许修复传输列表，因此可以在 time 时查看每个传输。 SockJS client 还提供了一个 debug flag，它在浏览器 console 中启用了有用的消息。在服务器端，您可以为<code>org.springframework.web.socket</code>启用<code>TRACE</code> logging。有关更多详细信息，请参阅 SockJS 协议<a target="_blank" rel="noopener" href="https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html">叙述测试</a>。</p>
<h4 id="启用SockJS"><a href="#启用SockJS" class="headerlink" title="启用SockJS"></a>启用SockJS</h4><p>您可以通过 Java configuration 启用 SockJS，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">        registry.addHandler(myHandler(), &quot;&#x2F;myHandler&quot;).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebSocketHandler myHandler() &#123;</span><br><span class="line">        return new MyHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:handlers&gt;</span><br><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;myHandler&quot; handler&#x3D;&quot;myHandler&quot;&#x2F;&gt;</span><br><span class="line">        &lt;websocket:sockjs&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id&#x3D;&quot;myHandler&quot; class&#x3D;&quot;org.springframework.samples.MyHandler&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 example 用于 Spring MVC applications，应该包含在<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#webflux-websocket-server-config">DispatcherServlet</a>的 configuration 中。但是，Spring 的 WebSocket 和 SockJS 支持并不依赖于 Spring MVC。在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/socket/sockjs/support/SockJsHttpRequestHandler.html">SockJsHttpRequestHandler</a>的帮助下集成到其他 HTTP 服务环境相对简单。</p>
<p>在浏览器端，applications 可以使用<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">sockjs-client</a>(version 1.0.x)。它模拟 W3C WebSocket API 并与服务器通信以选择最佳传输选项，具体取决于运行它的浏览器。请参阅<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">sockjs-client</a>页面和浏览器支持的传输类型列表。 client 还提供了几个 configuration 选项 - 对于 example，指定要包含的传输。</p>
<h4 id="IE8和9"><a href="#IE8和9" class="headerlink" title="IE8和9"></a>IE8和9</h4><p>Internet Explorer 8 和 9 仍在使用中。他们是拥有 SockJS 的关键原因。本节介绍有关在这些浏览器中运行的重要注意事项。</p>
<p>SockJS client 通过使用 Microsoft 的<a target="_blank" rel="noopener" href="https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx">XDomainRequest</a>支持 IE 8 和 9 中的 Ajax/XHR 流式传输。这适用于跨域但不支持发送 cookies。 Cookies 通常对 Java applications 很重要。但是，由于 SockJS client 可以与许多服务器类型(不仅仅是 Java 类型)一起使用，因此需要知道 cookies 是否重要。如果是这样，SockJS client 更喜欢 Ajax/XHR 进行流式传输。否则，它依赖于 iframe-based 技术。</p>
<p>来自 SockJS client 的第一个<code>/info</code>请求是对可能影响客户端传输选择的信息的请求。其中一个细节是 server application 是否依赖于 cookies(用于 example，用于身份验证或使用粘性会话进行群集)。 Spring 的 SockJS 支持包括一个名为<code>sessionCookieNeeded</code>的 property。默认情况下启用它，因为大多数 Java applications 依赖于<code>JSESSIONID</code> cookie。如果您的 application 不需要它，您可以关闭此选项，然后 SockJS client 应该在 IE 8 和 9 中选择<code>xdr-streaming</code>。</p>
<p>如果您确实使用 iframe-based 传输，请记住，可以通过将 HTTP 响应头<code>X-Frame-Options</code>设置为<code>DENY</code>，<code>SAMEORIGIN</code>或<code>ALLOW-FROM &lt;origin&gt;</code>来指示浏览器阻止在给定页面上使用 IFrame。这用于防止<a target="_blank" rel="noopener" href="https://www.owasp.org/index.php/Clickjacking">点击劫持</a>。</p>
<blockquote>
<p>Spring Security 3.2 支持在每个响应上设置<code>X-Frame-Options</code>。默认情况下，Spring Security Java configuration 将其设置为<code>DENY</code>。在 3.2 中，Spring Security XML 命名空间默认情况下不设置该标头，但可以配置为执行此操作。将来，它可以默认设置它。</p>
</blockquote>
<p>有关如何配置<code>X-Frame-Options</code>标头设置的详细信息，请参阅 Spring Security 文档的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#webflux-websocket-server-cors">默认安全 Headers</a>。您还可以查看<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SEC-2501">SEC-2501</a>以获取更多背景信息。</p>
<p>如果你的 application 添加<code>X-Frame-Options</code>响应头(因为它应该！)并依赖于 iframe-based 传输，你需要将头 value 设置为<code>SAMEORIGIN</code>或<code>ALLOW-FROM &lt;origin&gt;</code>。 Spring SockJS 支持还需要知道 SockJS client 的位置，因为它是从 iframe 加载的。默认情况下，iframe 设置为从 CDN 位置下载 SockJS client。配置此选项以使用与 application 相同的源的 URL 是一个很好的 idea。</p>
<p>以下 example 显示了如何在 Java configuration 中执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocket</span><br><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;portfolio&quot;).withSockJS()</span><br><span class="line">                .setClientLibraryUrl(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;myapp&#x2F;js&#x2F;sockjs-client.js&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>XML 命名空间通过<code>&lt;websocket:sockjs&gt;</code>元素提供类似的选项。</p>
<blockquote>
<p>在初始开发期间，请启用 SockJS client <code>devel</code>模式，以防止浏览器缓存否则将被缓存的 SockJS 请求(如 iframe)。有关如何启用它的详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/">SockJS client</a>页面。</p>
</blockquote>
<h4 id="心跳"><a href="#心跳" class="headerlink" title="心跳"></a>心跳</h4><p>SockJS 协议要求服务器发送心跳消息以阻止代理断定连接已挂起。 Spring SockJS configuration 有一个名为<code>heartbeatTime</code>的 property，可用于自定义频率。默认情况下，假设在该连接上没有发送其他消息，则会在 25 秒后发送心跳。对于公共 Internet 应用，此 25-second value 位于 line 中，以下<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6202">IETF 推荐</a>。</p>
<blockquote>
<p>当通过 WebSocket 和 SockJS 使用 STOMP 时，如果 STOMP client 和服务器协商要交换的心跳，则禁用 SockJS 心跳。</p>
</blockquote>
<p>Spring SockJS 支持还允许您配置<code>TaskScheduler</code>来安排心跳任务。任务计划程序由线程池支持，默认设置基于可用处理器的数量。您应该考虑根据您的特定需求自定义设置。</p>
<h4 id="Client断开连接"><a href="#Client断开连接" class="headerlink" title="Client断开连接"></a>Client断开连接</h4><p>HTTP 流和 HTTP long 轮询 SockJS 传输要求连接保持打开时间比平时长。有关这些技术的概述，请参阅<a target="_blank" rel="noopener" href="https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/">这篇博文</a>。</p>
<p>在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，它允许退出 Servlet 容器线程，处理请求，并继续写入来自另一个线程的响应。</p>
<p>一个特定的问题是 Servlet API 不为已经消失的客户端提供通知。见<a target="_blank" rel="noopener" href="https://github.com/eclipse-ee4j/servlet-api/issues/44">eclipse-ee4j/servlet-api#44</a>。但是，Servlet 容器会在后续尝试写入响应时引发 exception。由于 Spring 的 SockJS 服务支持 server-sent 心跳(默认情况下每 25 秒)，这意味着通常会在_time 期间(或更早，如果更频繁地发送消息)检测到 client 断开连接。</p>
<blockquote>
<p>因此，可能会发生网络 I/O 故障，因为 client 已断开连接，这可能会使用不必要的堆栈跟踪填充 log。 Spring 尽最大努力识别代表 client 断开连接(特定于每个服务器)的此类网络故障，并使用专用 log 类别(在<code>AbstractSockJsSession</code>中定义)log 记录最小消息。如果需要查看堆栈跟踪，可以将 log 类别设置为 TRACE。</p>
</blockquote>
<h4 id="SockJS和CORS"><a href="#SockJS和CORS" class="headerlink" title="SockJS和CORS"></a>SockJS和CORS</h4><p>如果允许 cross-origin 请求(请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#mvc-servlet">允许起源</a>)，则 SockJS 协议在 XHR 流和轮询传输中使用 CORS 进行 cross-domain 支持。因此，除非检测到响应中存在 CORS headers，否则会自动添加 CORS headers。因此，如果已经将 application 配置为提供 CORS 支持(对于 example，通过 Servlet 过滤器)，Spring 的<code>SockJsService</code>将跳过此部分。</p>
<p>也可以通过在 Spring 的 SockJsService 中设置<code>suppressCors</code> property 来禁用这些 CORS _header 的添加。</p>
<p>SockJS 期望以下 headers 和值：</p>
<ul>
<li><code>Access-Control-Allow-Origin</code>：从<code>Origin</code>请求标头的 value 初始化。</li>
<li><code>Access-Control-Allow-Credentials</code>：始终设置为<code>true</code>。</li>
<li><code>Access-Control-Request-Headers</code>：从等效请求标头中的值初始化。</li>
<li><code>Access-Control-Allow-Methods</code>：传输支持的 HTTP 方法(请参阅<code>TransportType</code> enum)。</li>
<li><code>Access-Control-Max-Age</code>：设置为 31536000(1 年)。</li>
</ul>
<p>对于确切的 implementation，请参阅<code>AbstractSockJsService</code>中的<code>addCorsHeaders</code>和 source code 中的<code>TransportType</code> enum。</p>
<p>或者，如果 CORS configuration 允许，请考虑使用 SockJS 端点前缀排除 URL，从而让 Spring 的<code>SockJsService</code>处理它。</p>
<h4 id="SockJsClient"><a href="#SockJsClient" class="headerlink" title="SockJsClient"></a>SockJsClient</h4><p>Spring 提供了一个 SockJS Java client，无需使用浏览器即可连接到 remote SockJS endpoints。当需要通过公共网络在两个服务器之间进行双向通信时(即，网络代理可以排除使用 WebSocket 协议的情况下)，这尤其有用。 SockJS Java client 对于测试目的也非常有用(例如，模拟大量并发用户)。</p>
<p>SockJS Java client 支持<code>websocket</code>，<code>xhr-streaming</code>和<code>xhr-polling</code>传输。其余的仅适用于浏览器。</p>
<p>您可以使用以下命令配置<code>WebSocketTransport</code>：</p>
<ul>
<li>在 JSR-356 运行时<code>StandardWebSocketClient</code>。</li>
<li><code>JettyWebSocketClient</code>使用 Jetty 9 本机 WebSocket API。</li>
<li>Spring 的<code>WebSocketClient</code>的任何 implementation。</li>
</ul>
<p>根据定义，<code>XhrTransport</code>支持<code>xhr-streaming</code>和<code>xhr-polling</code>，因为从 client 的角度来看，除了用于连接服务器的 URL 之外没有其他区别。目前有两个_Implempleations：</p>
<ul>
<li><code>RestTemplateXhrTransport</code>对 HTTP 请求使用 Spring 的<code>RestTemplate</code>。</li>
<li><code>JettyXhrTransport</code>使用 Jetty 的<code>HttpClient</code>进行 HTTP 请求。</li>
</ul>
<p>以下 example 显示了如何创建 SockJS client 并连接到 SockJS 端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Transport&gt; transports &#x3D; new ArrayList&lt;&gt;(2);</span><br><span class="line">transports.add(new WebSocketTransport(new StandardWebSocketClient()));</span><br><span class="line">transports.add(new RestTemplateXhrTransport());</span><br><span class="line"></span><br><span class="line">SockJsClient sockJsClient &#x3D; new SockJsClient(transports);</span><br><span class="line">sockJsClient.doHandshake(new MyWebSocketHandler(), &quot;ws:&#x2F;&#x2F;example.com:8080&#x2F;sockjs&quot;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SockJS 使用 JSON 格式的数组进行消息传递。默认情况下，使用 Jackson 2 并且需要在 classpath 上。或者，您可以配置<code>SockJsMessageCodec</code>的自定义 implementation 并在<code>SockJsClient</code>上配置它。</p>
</blockquote>
<p>要使用<code>SockJsClient</code>模拟大量并发用户，您需要配置基础 HTTP client(用于 XHR 传输)以允许足够数量的连接和线程。以下 example 显示了如何使用 Jetty 执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpClient jettyHttpClient &#x3D; new HttpClient();</span><br><span class="line">jettyHttpClient.setMaxConnectionsPerDestination(1000);</span><br><span class="line">jettyHttpClient.setExecutor(new QueuedThreadPool(1000));</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了您应该考虑自定义的 server-side SockJS-related properties(请参阅 javadoc 以获取详细信息)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;sockjs&quot;).withSockJS()</span><br><span class="line">            .setStreamBytesLimit(512 * 1024) (1)</span><br><span class="line">            .setHttpMessageCacheSize(1000) (2)</span><br><span class="line">            .setDisconnectDelay(30 * 1000); (3)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将<code>streamBytesLimit</code> property 设置为 512KB(默认值为 128KB - <code>128 * 1024</code>)。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>将<code>httpMessageCacheSize</code> property 设置为 1,000(默认值为<code>100</code>)。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>将<code>disconnectDelay</code> property 设置为 30 property 秒(默认值为 5 秒 - <code>5 * 1000</code>)。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="STOMP"><a href="#STOMP" class="headerlink" title="STOMP"></a>STOMP</h3><p>WebSocket 协议定义了两种类型的消息(文本和二进制)，但它们的内容是未定义的。该协议定义了 client 和服务器协商 sub-protocol(即 higher-level 消息传递协议)以在 WebSocket 之上使用的机制，以定义每个消息可以发送什么类型的消息，格式是什么，每条消息的内容，以及等等。使用 sub-protocol 是可选的，但无论如何，client 和服务器需要就定义消息内容的某些协议达成一致。</p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><a target="_blank" rel="noopener" href="https://stomp.github.io/stomp-specification-1.2.html#headers">STOMP</a>(简单文本导向的消息传递协议)最初是为脚本语言(如 Ruby，Python 和 Perl)创建的，用于连接企业消息代理。它旨在解决常用消息传递模式的最小子集。 STOMP 可用于任何可靠的 two-way 流网络协议，例如 TCP 和 WebSocket。虽然 STOMP 是 text-oriented 协议，但消息有效负载可以是文本或二进制。</p>
<p>STOMP 是一个 frame-based 协议，其帧在 HTTP 上建模。以下清单显示了 STOMP 框架的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">COMMAND</span><br><span class="line">header1:value1</span><br><span class="line">header2:value2</span><br><span class="line"></span><br><span class="line">Body^@</span><br></pre></td></tr></table></figure>
<p>Clients 可以使用<code>SEND</code>或<code>SUBSCRIBE</code>命令发送或订阅消息，以及描述消息内容和应该接收消息的<code>destination</code>标头。这启用了一个简单的 publish-subscribe 机制，您可以使用该机制通过 broker 将消息发送到其他连接的客户端，或者向服务器发送消息以请求执行某些工作。</p>
<p>当您使用 Spring 的 STOMP 支持时，Spring WebSocket application 充当客户端的 STOMP broker。消息被路由到<code>@Controller</code> message-handling 方法或简单的 in-memory broker，它跟踪订阅并向订阅用户广播消息。您还可以将 Spring 配置为使用专用的 STOMP broker(例如 RabbitMQ，ActiveMQ 和其他)来实现消息的实际 broadcasting。在这种情况下，Spring 维护与 broker 的 TCP 连接，将消息中继到它，并将消息从它传递给连接的 WebSocket clients。因此，Spring web applications 可以依赖统一的 HTTP-based 安全性，common 验证和熟悉的编程 model 来进行消息处理。</p>
<p>以下 example 显示了一个 client 订阅接收股票报价，服务器可以定期发出(例如，通过_11向 broker 发送消息的计划任务)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE</span><br><span class="line">id:sub-1</span><br><span class="line">destination:&#x2F;topic&#x2F;price.stock.*</span><br><span class="line"></span><br><span class="line">^@</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了一个发送交易请求的客户端，服务器可以通过<code>@MessageMapping</code>方法处理该请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SEND</span><br><span class="line">destination:&#x2F;queue&#x2F;trade</span><br><span class="line">content-type:application&#x2F;json</span><br><span class="line">content-length:44</span><br><span class="line"></span><br><span class="line">&#123;&quot;action&quot;:&quot;BUY&quot;,&quot;ticker&quot;:&quot;MMM&quot;,&quot;shares&quot;,44&#125;^@</span><br></pre></td></tr></table></figure>
<p>在执行之后，服务器可以_b 广播交易确认消息并向 client 详细说明。</p>
<p>目的地的含义在 STOMP 规范中故意保持不透明。它可以是任何 string，完全取决于 STOMP 服务器来定义它们支持的目标的语义和语法。然而，非常常见的是，目标是 path-like strings，其中<code>/topic/..</code>暗示 publish-subscribe(one-to-many)，<code>/queue/</code>暗示 point-to-point(one-to-one)消息交换。</p>
<p>STOMP 服务器可以使用<code>MESSAGE</code>命令向所有订户 broadcast 消息。以下 example 显示了服务器向订阅的 client 发送股票报价：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MESSAGE</span><br><span class="line">message-id:nxahklf6-1</span><br><span class="line">subscription:sub-1</span><br><span class="line">destination:&#x2F;topic&#x2F;price.stock.MMM</span><br><span class="line"></span><br><span class="line">&#123;&quot;ticker&quot;:&quot;MMM&quot;,&quot;price&quot;:129.45&#125;^@</span><br></pre></td></tr></table></figure>
<p>服务器无法发送未经请求的消息。来自服务器的所有消息必须响应特定的 client 订阅，并且服务器消息的<code>subscription-id</code>标头必须 match client 订阅的<code>id</code>标头。</p>
<p>前面的概述旨在提供对 STOMP 协议的最基本的了解。我们建议全面审查协议<a target="_blank" rel="noopener" href="https://stomp.github.io/stomp-specification-1.2.html">规格</a>。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>使用 STOMP 作为 sub-protocol 可以让 Spring Framework 和 Spring Security 提供更丰富的编程模型，而不是使用原始 WebSockets。关于 HTTP 与原始 TCP 以及如何让 Spring MVC 和其他 web 框架提供丰富的功能，可以做出同样的观点。以下是一系列好处：</p>
<ul>
<li>无需发明自定义消息传递协议和消息格式。</li>
<li>STOMP clients，包括 Spring Framework 中的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-server-allowed-origins">Java client</a>，可用。</li>
<li>您可以(可选)使用消息代理(例如 RabbitMQ，ActiveMQ 等)来管理订阅和 broadcast 消息。</li>
<li>Application 逻辑可以组织在任意数量的<code>@Controller</code>实例中，并且可以根据 STOMP 目标标头将消息路由到它们，而不是使用单个<code>WebSocketHandler</code>处理给定连接的原始 WebSocket 消息。</li>
<li>您可以使用 Spring Security 来保护基于 STOMP 目标和消息类型的消息。</li>
</ul>
<h4 id="启用STOMP"><a href="#启用STOMP" class="headerlink" title="启用STOMP"></a>启用STOMP</h4><p>在<code>spring-messaging</code>和<code>spring-websocket</code>模块中提供了对 WebSocket 支持的 STOMP。一旦拥有了这些依赖项，就可以通过 WebSocket 使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#Abstract">SockJS 后备</a>公开 STOMP endpoints，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;</span><br><span class="line">import org.springframework.web.socket.config.annotation.StompEndpointRegistry;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;portfolio&quot;).withSockJS();  (1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry config) &#123;</span><br><span class="line">        config.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;); (2)</span><br><span class="line">        config.enableSimpleBroker(&quot;&#x2F;topic&quot;, &quot;&#x2F;queue&quot;); (3)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>/portfolio</code>是 WebSocket(或 SockJS)客户端为 WebSocket 握手需要连接的端点的 HTTP URL。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>目标头以<code>/app</code>开头的 STOMP 消息将路由到<code>@Controller</code> classes 中的<code>@MessageMapping</code>方法。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>使用 built-in message broker 进行订阅，并使用 broadcasting 和 route 将目标标题以<code>/topic</code>或<code>/queue</code>开头的消息发送到 broker。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker application-destination-prefix&#x3D;&quot;&#x2F;app&quot;&gt;</span><br><span class="line">        &lt;websocket:stomp-endpoint path&#x3D;&quot;&#x2F;portfolio&quot;&gt;</span><br><span class="line">            &lt;websocket:sockjs&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;websocket:stomp-endpoint&gt;</span><br><span class="line">        &lt;websocket:simple-broker prefix&#x3D;&quot;&#x2F;topic, &#x2F;queue&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 built-in simple broker，<code>/topic</code>和<code>/queue</code>前缀没有任何特殊含义。它们只是区分 pub-sub 与 point-to-point 消息传递的惯例(即许多订阅者与一个消费者)。当您使用外部 broker 时，请检查 broker 的 STOMP 页面以了解它支持的 STOMP 目标和前缀类型。</p>
</blockquote>
<p>要从浏览器连接，对于 SockJS，您可以使用<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client">sockjs-client</a>。对于 STOMP，许多 applications 使用了<a target="_blank" rel="noopener" href="https://github.com/jmesnil/stomp-websocket">jmesnil/stomp-websocket</a> library(也称为 stomp.js)，这是 feature-complete 并且已经在 production 中使用了多年但不再维护。目前，<a target="_blank" rel="noopener" href="https://github.com/JSteunou/webstomp-client">JSteunou/webstomp-client</a>是该图书馆中最积极维护和不断发展的继承者。以下 example code 基于它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var socket &#x3D; new SockJS(&quot;&#x2F;spring-websocket-portfolio&#x2F;portfolio&quot;);</span><br><span class="line">var stompClient &#x3D; webstomp.over(socket);</span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，如果通过 WebSocket 连接(没有 SockJS)，则可以使用以下 code：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var socket &#x3D; new WebSocket(&quot;&#x2F;spring-websocket-portfolio&#x2F;portfolio&quot;);</span><br><span class="line">var stompClient &#x3D; Stomp.over(socket);</span><br><span class="line"></span><br><span class="line">stompClient.connect(&#123;&#125;, function(frame) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，前面的 example 中的<code>stompClient</code>不需要指定<code>login</code>和<code>passcode</code> headers。即使它确实如此，它们也会在服务器端被忽略(或者更确切地说，被覆盖)。有关身份验证的详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-client">连接到 Broker</a>和<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-fallback">认证</a>。</p>
<p>有关更多 example code，请参阅：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-stomp-websocket/">使用 WebSocket build 交互式 web application</a> - 入门指南。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/rstoyanchev/spring-websocket-portfolio">股票投资组合</a> - 一个 sample application。</li>
</ul>
<h4 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h4><p>要配置基础 WebSocket 服务器，<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-handle-broker-relay-configure">服务器 Configuration</a>中的信息适用。对于 Jetty，您需要通过<code>StompEndpointRegistry</code>设置<code>HandshakeHandler</code>和<code>WebSocketPolicy</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;portfolio&quot;).setHandshakeHandler(handshakeHandler());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public DefaultHandshakeHandler handshakeHandler() &#123;</span><br><span class="line"></span><br><span class="line">        WebSocketPolicy policy &#x3D; new WebSocketPolicy(WebSocketBehavior.SERVER);</span><br><span class="line">        policy.setInputBufferSize(8192);</span><br><span class="line">        policy.setIdleTimeout(600000);</span><br><span class="line"></span><br><span class="line">        return new DefaultHandshakeHandler(</span><br><span class="line">                new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="消息流"><a href="#消息流" class="headerlink" title="消息流"></a>消息流</h4><p>一旦暴露了 STOMP 端点，Spring application 就成为连接的 clients 的 STOMP broker。本节介绍服务器端的消息流。</p>
<p><code>spring-messaging</code>模块包含对源自<a target="_blank" rel="noopener" href="https://spring.io/spring-integration">Spring Integration</a>的消息传递应用程序的基础支持，后来被提取并合并到 Spring Framework 中，以便在许多<a target="_blank" rel="noopener" href="https://spring.io/projects">Spring 项目</a>和 application 场景中得到更广泛的使用。以下列表简要介绍了一些可用的消息传递抽象：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/Message.html">信息</a>：消息的简单表示，包括 headers 和 payload。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a>：Contract 用于处理消息。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/MessageChannel.html">MessageChannel</a>：Contract 用于发送允许生产者和消费者之间松散耦合的消息。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/SubscribableChannel.html">SubscribableChannel</a>：<code>MessageChannel</code>与<code>MessageHandler</code>订阅者。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/support/ExecutorSubscribableChannel.html">ExecutorSubscribableChannel</a>：<code>SubscribableChannel</code>使用<code>Executor</code>传递消息。</li>
</ul>
<p>Java configuration(即<code>@EnableWebSocketMessageBroker</code>)和 XML 名称空间 configuration(即<code>&lt;websocket:message-broker&gt;</code>)都使用前面的组件来组合消息工作流。下图显示了启用简单 built-in 消息 broker 时使用的组件：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/message-flow-simple-broker.jpg" alt="消息流简单 broker"></p>
<p>上图显示了三个消息 channels：</p>
<ul>
<li><code>clientInboundChannel</code>：用于传递从 WebSocket clients 收到的消息。</li>
<li><code>clientOutboundChannel</code>：用于将服务器消息发送到 WebSocket clients。</li>
<li><code>brokerChannel</code>：用于从 server-side application code 中发送消息 broker。</li>
</ul>
<p>下图显示了配置外部 broker(例如 RabbitMQ)以管理订阅和 broadcasting 消息时使用的组件：</p>
<p><img src="https://www.docs4dev.com/images/spring-framework/5.1.3.RELEASE/message-flow-broker-relay.jpg" alt="消息流 broker relay"></p>
<p>前两个图的主要区别在于使用“broker relay”将消息通过 TCP 传递到外部 STOMP broker，并将消息从 broker 传递到订阅的 clients。</p>
<p>当从 WebSocket 连接接收消息时，它们被解码为 STOMP 帧，变成 Spring <code>Message</code>表示，并发送到<code>clientInboundChannel</code>以进行进一步处理。对于 example，目标 headers 以<code>/app</code>开头的 STOMP 消息可以路由到带注释的控制器中的<code>@MessageMapping</code>方法，而<code>/topic</code>和<code>/queue</code>消息可以直接路由到消息 broker。</p>
<p>处理来自 client 的 STOMP 消息的带注释的<code>@Controller</code>可以通过<code>brokerChannel</code>向消息 broker 发送消息，broker 通过<code>clientOutboundChannel</code>将消息广播给匹配的订阅者。同一个控制器也可以响应 HTTP 请求，因此 client 可以执行 HTTP POST，然后<code>@PostMapping</code>方法可以向消息 broker 发送消息以 broadcast 发送给订阅的 clients。</p>
<p>我们可以通过一个简单的 example 跟踪流程。考虑以下 example，它设置服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;portfolio&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        registry.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;);</span><br><span class="line">        registry.enableSimpleBroker(&quot;&#x2F;topic&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class GreetingController &#123;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;&#x2F;greeting&quot;) &#123;</span><br><span class="line">    public String handle(String greeting) &#123;</span><br><span class="line">        return &quot;[&quot; + getTimestamp() + &quot;: &quot; + greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 example 支持以下流程：</p>
<ul>
<li>client 连接到<code>http://localhost:8080/portfolio</code>，并且一旦建立 WebSocket 连接，STOMP 帧就开始在其上流动。</li>
<li>client 发送一个 SUBSCRIBE 帧，其目标头为<code>/topic/greeting</code>。收到并解码后，消息将发送到<code>clientInboundChannel</code>，然后路由到消息 broker，log 存储 client 订阅。</li>
<li>client 将_SEND 帧发送到<code>/app/greeting</code>。 <code>/app</code>前缀有助于将其路由到带注释的控制器。删除<code>/app</code>前缀后，目标的剩余<code>/greeting</code>部分将映射到<code>GreetingController</code>中的<code>@MessageMapping</code>方法。</li>
<li>从<code>GreetingController</code>返回的 value 变为 Spring <code>Message</code>，其有效负载基于 return value 和<code>/topic/greeting</code>的默认目标头(从输入目标派生，<code>/app</code>替换为<code>/topic</code>)。生成的消息将发送到<code>brokerChannel</code>并由消息 broker 处理。</li>
<li>消息 broker 找到所有匹配的订阅者，并通过<code>clientOutboundChannel</code>向每个订阅者发送一个 MESSAGE 帧，消息被编码为 STOMP 帧并在 WebSocket 连接上发送。</li>
</ul>
<p>下一节提供了有关注释方法的更多详细信息，包括支持的 arguments 和 return 值的类型。</p>
<h4 id="带注解的控制器-1"><a href="#带注解的控制器-1" class="headerlink" title="带注解的控制器"></a>带注解的控制器</h4><p>Applications 可以使用带注释的<code>@Controller</code> classes 来处理来自 clients 的消息。这样的 classes 可以声明<code>@MessageMapping</code>，<code>@SubscribeMapping</code>和<code>@ExceptionHandler</code>方法，如以下主题中所述：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-authentication">@MessageMapping</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-server-runtime-configuration">@SubscribeMapping</a></li>
<li><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-message-mapping">@MessageExceptionHandler</a></li>
</ul>
<h5 id="MessageMapping注解"><a href="#MessageMapping注解" class="headerlink" title="MessageMapping注解"></a>MessageMapping注解</h5><p>您可以使用<code>@MessageMapping</code>来注释根据目的地 route 消息的方法。方法 level 和 level 类型都支持它。在 level 类型中，<code>@MessageMapping</code>用于表示控制器中所有方法的共享映射。</p>
<p>默认情况下，映射值为 Ant-style 路径模式(对于 example <code>/thing*</code>，<code>/thing/**</code>)，包括对模板变量的支持(对于 example，<code>/thing/&#123;id&#125;</code>)。可以通过<code>@DestinationVariable</code> method arguments 引用这些值。 Applications 还可以切换到映射的 dot-separated 目标约定，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-subscribe-mapping">点作为分隔符</a>中所述。</p>
<h6 id="支持的方法Arguments"><a href="#支持的方法Arguments" class="headerlink" title="支持的方法Arguments"></a>支持的方法Arguments</h6><p>以下 table 描述了方法 arguments：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法论证</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Message</code></td>
<td>用于访问完整的消息。</td>
</tr>
<tr>
<td><code>MessageHeaders</code></td>
<td>用于访问<code>Message</code>中的 headers。</td>
</tr>
<tr>
<td><code>MessageHeaderAccessor</code>，<code>SimpMessageHeaderAccessor</code>和<code>StompHeaderAccessor</code></td>
<td>用于通过类型化访问器方法访问 headers。</td>
</tr>
<tr>
<td><code>@Payload</code></td>
<td>用于访问消息的有效负载，由已配置的<code>MessageConverter</code>转换(对于 example，来自 JSON)。 不需要此 annotation 的存在，因为默认情况下，假设没有其他参数匹配。 您可以使用<code>@javax.validation.Valid</code>或 Spring 的<code>@Validated</code>注释有效负载 arguments，以自动验证有效负载 arguments。</td>
</tr>
<tr>
<td><code>@Header</code></td>
<td>用于访问特定标头 value - 以及使用<code>org.springframework.core.convert.converter.Converter</code>进行类型转换(如有必要)。</td>
</tr>
<tr>
<td><code>@Headers</code></td>
<td>用于访问消息中的所有 headers。此参数必须可分配给<code>java.util.Map</code>。</td>
</tr>
<tr>
<td><code>@DestinationVariable</code></td>
<td>用于访问从消息目标中提取的模板变量。根据需要将值转换为声明的方法参数类型。</td>
</tr>
<tr>
<td><code>java.security.Principal</code></td>
<td>反映在 WebSocket HTTP 握手的 time 登录的用户。</td>
</tr>
</tbody>
</table>
</div>
<h6 id="Return值-1"><a href="#Return值-1" class="headerlink" title="Return值"></a>Return值</h6><p>默认情况下，<code>@MessageMapping</code>方法的 return value 通过匹配<code>MessageConverter</code>序列化为有效负载，并作为<code>Message</code>发送到<code>brokerChannel</code>，从_b 广播到订阅者。出站消息的目的地与入站消息的目的地相同，但前缀为<code>/topic</code>。</p>
<p>您可以使用<code>@SendTo</code>和<code>@SendToUser</code> 注释来自定义输出消息的目标。 <code>@SendTo</code>用于自定义目标目标或指定多个目标。 <code>@SendToUser</code>用于将输出消息仅定向到与输入消息关联的用户。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-exception-handler">用户目的地</a>。</p>
<p>您可以在同一个方法上同时使用<code>@SendTo</code>和<code>@SendToUser</code>，并且 class level 都支持它们，在这种情况下它们作为 class 中方法的默认值。但是，请记住，任何 method-level <code>@SendTo</code>或<code>@SendToUser</code> 注释都会覆盖 class level 上的任何此类注释。</p>
<p>消息可以异步处理，<code>@MessageMapping</code>方法可以_ret ，<code>CompletableFuture</code>或<code>CompletionStage</code>。</p>
<p>请注意，<code>@SendTo</code>和<code>@SendToUser</code>仅仅是一种便利，相当于使用<code>SimpMessagingTemplate</code>发送消息。如有必要，对于更高级的方案，<code>@MessageMapping</code>方法可以直接使用<code>SimpMessagingTemplate</code>。这可以代替返回 value，或者可能另外返回 value。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-destination-separator">发送消息</a>。</p>
<h5 id="SubscribeMapping注解"><a href="#SubscribeMapping注解" class="headerlink" title="SubscribeMapping注解"></a>SubscribeMapping注解</h5><p><code>@SubscribeMapping</code>类似于<code>@MessageMapping</code>，但仅将映射缩小为订阅消息。它支持与<code>@MessageMapping</code>相同的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-user-destination">方法 arguments</a>。但是对于 return value，默认情况下，消息会直接发送到 client(通过<code>clientOutboundChannel</code>，以响应订阅)而不是 broker(通过<code>brokerChannel</code>，作为 broadcast 到匹配的订阅)。添加<code>@SendTo</code>或<code>@SendToUser</code>会覆盖此行为并发送到 broker。</p>
<p>什么时候有用？假设 broker 映射到<code>/topic</code>和<code>/queue</code>，而 application 控制器映射到<code>/app</code>。在此设置中，broker store 对<code>/topic</code>和<code>/queue</code>的所有订阅都用于重复广播，并且不需要涉及 application。 client 也可以订阅某个<code>/app</code>目的地，并且控制器可以 return 一个 value 以响应该订阅而不涉及 broker 而不再存储或使用订阅(实际上是 one-time request-reply 交换)。一个用例是在启动时使用初始数据填充 UI。</p>
<p>这什么时候没用？不要尝试将 broker 和控制器 map 映射到相同的目标前缀，除非您由于某种原因希望两者都独立处理消息，包括订阅。入站消息在 parallel 中处理。无法保证 broker 或控制器是否首先处理给定的消息。如果在存储订阅并准备好广播时通知目标，则 client 应该在服务器支持时询问收据(简单的 broker 不支持)。对于 example，使用 Java <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-handle-send">STOMP client</a>，您可以执行以下操作来添加收据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private TaskScheduler messageBrokerTaskScheduler;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; During initialization..</span><br><span class="line">stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; When subscribing..</span><br><span class="line">StompHeaders headers &#x3D; new StompHeaders();</span><br><span class="line">headers.setDestination(&quot;&#x2F;topic&#x2F;...&quot;);</span><br><span class="line">headers.setReceipt(&quot;r1&quot;);</span><br><span class="line">FrameHandler handler &#x3D; ...;</span><br><span class="line">stompSession.subscribe(headers, handler).addReceiptTask(() -&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; Subscription ready...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>服务器端选项是<code>brokerChannel</code>上的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-message-mapping">注册</a>和<code>ExecutorChannelInterceptor</code>，并实现在处理完消息(包括订阅)后调用的<code>afterMessageHandled</code>方法。</p>
<h5 id="MessageExceptionHandler注解"><a href="#MessageExceptionHandler注解" class="headerlink" title="MessageExceptionHandler注解"></a>MessageExceptionHandler注解</h5><p>application 可以使用<code>@MessageExceptionHandler</code>方法来处理<code>@MessageMapping</code>方法的 exceptions。如果要访问 exception 实例，可以在 annotation 本身或通过方法参数声明 exceptions。以下 example 通过方法参数声明 exception：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @MessageExceptionHandler</span><br><span class="line">    public ApplicationError handleException(MyException exception) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        return appError;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@MessageExceptionHandler</code>方法支持灵活的方法签名，并支持与<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-client">@MessageMapping</a>方法相同的方法参数类型和 return 值。</p>
<p>通常，<code>@MessageExceptionHandler</code>方法适用于声明它们的<code>@Controller</code> class(或 class 层次结构)。如果您希望此类方法更全局地应用(跨控制器)，则可以在标有<code>@ControllerAdvice</code>的 class 中声明它们。这与 Spring MVC 中可用的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-interceptors">类似的支持</a>相当。</p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>如果要从 application 的任何部分向连接的 clients 发送消息，该怎么办？任何 application component 都可以向<code>brokerChannel</code>发送消息。最简单的方法是 inject <code>SimpMessagingTemplate</code>并使用它来发送消息。通常，您可以按类型对其进行注入，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class GreetingController &#123;</span><br><span class="line"></span><br><span class="line">    private SimpMessagingTemplate template;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public GreetingController(SimpMessagingTemplate template) &#123;</span><br><span class="line">        this.template &#x3D; template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(path&#x3D;&quot;&#x2F;greetings&quot;, method&#x3D;POST)</span><br><span class="line">    public void greet(String greeting) &#123;</span><br><span class="line">        String text &#x3D; &quot;[&quot; + getTimestamp() + &quot;]:&quot; + greeting;</span><br><span class="line">        this.template.convertAndSend(&quot;&#x2F;topic&#x2F;greetings&quot;, text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，如果存在另一个相同类型的 bean，您也可以通过 name(<code>brokerMessagingTemplate</code>)限定它。</p>
<h4 id="简单的Broker"><a href="#简单的Broker" class="headerlink" title="简单的Broker"></a>简单的Broker</h4><p>built-in 简单消息 broker 处理来自 clients 的订阅请求，将它们存储在 memory 中，并将消息广播到具有匹配目标的已连接客户端。 broker 支持 path-like 目的地，包括对 Ant-style 目的地模式的订阅。</p>
<blockquote>
<p>Applications 也可以使用 dot-separated(而不是 slash-separated)目的地。见<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-message-mapping">点作为分隔符</a>。</p>
</blockquote>
<p>如果配置了任务调度程序，则简单的 broker 支持<a target="_blank" rel="noopener" href="https://stomp.github.io/stomp-specification-1.2.html#mvc-ann-controller-advice">STOMP 心跳</a>。为此，您可以声明自己的调度程序或使用在内部自动声明和使用的调度程序。以下 example 显示了如何声明自己的调度程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    private TaskScheduler messageBrokerTaskScheduler;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) &#123;</span><br><span class="line">        this.messageBrokerTaskScheduler &#x3D; taskScheduler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line"></span><br><span class="line">        registry.enableSimpleBroker(&quot;&#x2F;queue&#x2F;&quot;, &quot;&#x2F;topic&#x2F;&quot;)</span><br><span class="line">                .setHeartbeatValue(new long[] &#123;10000, 20000&#125;)</span><br><span class="line">                .setTaskScheduler(this.messageBrokerTaskScheduler);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外部Broker"><a href="#外部Broker" class="headerlink" title="外部Broker"></a>外部Broker</h4><p>简单的 broker 非常适合入门，但仅支持 STOMP 命令的子集(它不支持 ack，收据和其他一些 features)，依赖于简单的 message-sending 循环，不适合群集。作为替代方案，您可以升级 applications 以使用 full-featured 消息 broker。</p>
<p>请参阅 STOMP 文档以获取您选择的消息 broker(例如<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/stomp.html">RabbitMQ</a>，<a target="_blank" rel="noopener" href="http://activemq.apache.org/stomp.html">ActiveMQ</a>和其他)，安装 broker，并在启用 STOMP 支持的情况下运行它。然后，您可以在 Spring configuration 中启用 STOMP broker 中继(而不是简单的 broker)。</p>
<p>以下 example configuration 启用 full-featured broker：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void registerStompEndpoints(StompEndpointRegistry registry) &#123;</span><br><span class="line">        registry.addEndpoint(&quot;&#x2F;portfolio&quot;).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        registry.enableStompBrokerRelay(&quot;&#x2F;topic&quot;, &quot;&#x2F;queue&quot;);</span><br><span class="line">        registry.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker application-destination-prefix&#x3D;&quot;&#x2F;app&quot;&gt;</span><br><span class="line">        &lt;websocket:stomp-endpoint path&#x3D;&quot;&#x2F;portfolio&quot; &#x2F;&gt;</span><br><span class="line">            &lt;websocket:sockjs&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;websocket:stomp-endpoint&gt;</span><br><span class="line">        &lt;websocket:stomp-broker-relay prefix&#x3D;&quot;&#x2F;topic,&#x2F;queue&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>前面的 configuration 中的 STOMP broker 中继是一个 Spring <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/messaging/MessageHandler.html">MessageHandler</a>，它通过将消息转发到外部消息 broker 来处理消息。为此，它建立与 broker 的 TCP 连接，将所有消息转发给它，然后通过其 WebSocket 会话将从 broker 接收的所有消息转发给 clients。从本质上讲，它充当“转发”，可以在两个方向上转发消息。</p>
<blockquote>
<p>将<code>io.projectreactor.netty:reactor-netty</code>和<code>io.netty:netty-all</code>依赖项添加到项目以进行 TCP 连接管理。</p>
</blockquote>
<p>此外，application 组件(例如 HTTP 请求处理方法，业务服务等)也可以向 broker 中继发送消息，如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-destination-separator">发送消息</a>中所述，将 broadcast 消息发送到订阅的 WebSocket clients。</p>
<p>实际上，broker 中继实现了健壮且可扩展的消息广播。</p>
<h4 id="连接到Broker"><a href="#连接到Broker" class="headerlink" title="连接到Broker"></a>连接到Broker</h4><p>STOMP broker 中继维护与 broker 的单个“系统”TCP 连接。此连接仅用于源自 server-side application 的消息，而不用于接收消息。您可以为此连接配置 STOMP 凭据(即 STOMP 帧<code>login</code>和<code>passcode</code> headers)。这在 XML 命名空间和 Java configuration 中都显示为<code>systemLogin</code>和<code>systemPasscode</code> properties，默认值为<code>guest</code>和<code>guest</code>。</p>
<p>STOMP broker 中继还为每个连接的 WebSocket client 创建单独的 TCP 连接。您可以配置用于代表 clients 创建的所有 TCP 连接的 STOMP 凭据。这在 XML 命名空间和 Java configuration 中都公开为<code>clientLogin and</code> clientPasscode <code>properties with default values of</code> guest <code>and</code> guest`。</p>
<blockquote>
<p>STOMP broker 中继始终在每个<code>CONNECT</code>帧上设置<code>login</code>和<code>passcode</code> headers，它们代表 clients 转发给 broker。因此，WebSocket clients 不需要设置那些 headers。他们被忽略了。正如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#Heart-beating">认证</a>部分所解释的那样，WebSocket clients 应该依赖 HTTP 身份验证来保护 WebSocket 端点并建立 client 身份。</p>
</blockquote>
<p>STOMP broker 中继还通过“系统”TCP 连接向消息 broker 发送和接收心跳。您可以配置发送和接收心跳的间隔(默认情况下每个 10 秒)。如果与 broker 的连接丢失，broker 中继将继续尝试每 5 秒重新连接一次，直到成功为止。</p>
<p>任何 Spring bean 都可以实现<code>ApplicationListener&lt;BrokerAvailabilityEvent&gt;</code>以在与 broker 的“系统”连接丢失和 re-established 时接收通知。例如，广播股票报价的股票报价服务可以在没有 active“系统”连接时停止尝试发送消息。</p>
<p>默认情况下，STOMP broker 中继始终连接，并在连接丢失时根据需要重新连接到同一个 host 和 port。如果您希望提供多个地址，则在每次尝试连接时，您都可以配置地址供应商，而不是固定的 host 和 port。以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        registry.enableStompBrokerRelay(&quot;&#x2F;queue&#x2F;&quot;, &quot;&#x2F;topic&#x2F;&quot;).setTcpClient(createTcpClient());</span><br><span class="line">        registry.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ReactorNettyTcpClient&lt;byte[]&gt; createTcpClient() &#123;</span><br><span class="line">        return new ReactorNettyTcpClient&lt;&gt;(</span><br><span class="line">                client -&gt; client.addressSupplier(() -&gt; ... ),</span><br><span class="line">                new StompReactorNettyCodec());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用<code>virtualHost</code> property 配置 STOMP broker 中继。此 property 的 value 被设置为每个<code>CONNECT</code>帧的<code>host</code>标头，并且可能很有用(例如，在云环境中，建立 TCP 连接的实际 host 与提供 cloud-basedSTOMP 服务的 host 不同)。</p>
<h4 id="点作为分隔符"><a href="#点作为分隔符" class="headerlink" title="点作为分隔符"></a>点作为分隔符</h4><p>当消息路由到<code>@MessageMapping</code>方法时，它们与<code>AntPathMatcher</code>匹配。默认情况下，模式应使用斜杠(<code>/</code>)作为分隔符。这是 web applications 中的一个很好的约定，类似于 HTTP URL。但是，如果您更习惯于消息传递约定，则可以切换到使用点(<code>.</code>)作为分隔符。</p>
<p>以下 example 显示了如何在 Java configuration 中执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        registry.setPathMatcher(new AntPathMatcher(&quot;.&quot;));</span><br><span class="line">        registry.enableStompBrokerRelay(&quot;&#x2F;queue&quot;, &quot;&#x2F;topic&quot;);</span><br><span class="line">        registry.setApplicationDestinationPrefixes(&quot;&#x2F;app&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">        xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">        xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">        xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">                http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">                http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">                http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">                http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker application-destination-prefix&#x3D;&quot;&#x2F;app&quot; path-matcher&#x3D;&quot;pathMatcher&quot;&gt;</span><br><span class="line">        &lt;websocket:stomp-endpoint path&#x3D;&quot;&#x2F;stomp&quot;&#x2F;&gt;</span><br><span class="line">        &lt;websocket:stomp-broker-relay prefix&#x3D;&quot;&#x2F;topic,&#x2F;queue&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;bean id&#x3D;&quot;pathMatcher&quot; class&#x3D;&quot;org.springframework.util.AntPathMatcher&quot;&gt;</span><br><span class="line">        &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;.&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>之后，控制器可以使用点(<code>.</code>)作为<code>@MessageMapping</code>方法中的分隔符，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@MessageMapping(&quot;erd&quot;)</span><br><span class="line">public class RedController &#123;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;blue.&#123;green&#125;&quot;)</span><br><span class="line">    public void handleGreen(@DestinationVariable String green) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client 现在可以向<code>/app/red.blue.green123</code>发送消息。</p>
<p>在前面的示例中，我们没有更改“broker relay”上的前缀，因为这些前缀完全依赖于外部消息 broker。请参阅您使用的 broker 的 STOMP 文档页面，以查看它为目标标头支持的约定。</p>
<p>另一方面，“simple broker”依赖于配置的<code>PathMatcher</code>，因此，如果切换分隔符，则该更改也适用于 broker 以及 broker 将消息中的目标与预订中的模式匹配的方式。</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>WebSocket 消息传递 session 上的每个 STOMP 都以 HTTP 请求开头。这可以是升级到 WebSockets 的请求(即 WebSocket 握手)，或者在 SockJS 回退的情况下，是一系列 SockJS HTTP 传输请求。</p>
<p>许多 web applications 已经具有用于保护 HTTP 请求的身份验证和授权。通常，通过使用某种机制(如登录页面，HTTP 基本身份验证或其他方式)通过 Spring Security 对用户进行身份验证。经过身份验证的用户的 security context 保存在 HTTP session 中，并与同一 cookie-based session 中的后续请求相关联。</p>
<p>因此，对于 WebSocket 握手或 SockJS HTTP 传输请求，通常已经通过<code>HttpServletRequest#getUserPrincipal()</code>可访问经过身份验证的用户。 Spring 会自动将该用户与为其创建的 WebSocket 或 SockJS session 相关联，然后通过用户标头与通过该 session 传输的所有 STOMP 消息相关联。</p>
<p>简而言之，一个典型的 web application 除了它已经为安全做的事情之外什么都不做。用户在 HTTP 请求 level 上通过安全 context 进行身份验证，该安全 context 通过 cookie-based HTTP session 进行维护(然后与为该用户创建的 WebSocket 或 SockJS 会话相关联)，并导致每个<code>Message</code>上标记的用户标头流经应用。</p>
<p>请注意，STOMP 协议在<code>CONNECT</code>帧上确实有<code>login</code>和<code>passcode</code> headers。这些最初设计用于并且仍然需要，例如，用于 TCP 上的 STOMP。但是，对于 STOMP over WebSocket，默认情况下，Spring 忽略 STOMP 协议 level 上的授权 headers，假定用户已经在 HTTP 传输 level 上进行了身份验证，并期望 WebSocket 或 SockJS session 包含经过身份验证的用户。</p>
<blockquote>
<p>Spring Security 提供了<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket-stomp-handle-send">WebSocket sub-protocol 授权</a>，它使用<code>ChannelInterceptor</code>根据其中的用户头来授权消息。此外，Spring Session 提供了一个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket-stomp-authentication">WebSocket integration</a>，确保当 WebSocket session 仍处于 active 时，用户 HTTP session 不会过期。</p>
</blockquote>
<h4 id="令牌认证"><a href="#令牌认证" class="headerlink" title="令牌认证"></a>令牌认证</h4><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-security-oauth">Spring Security OAuth</a>提供对基于令牌的安全性的支持，包括 JSON Web Token(JWT)。您可以将此作为 Web applications 中的身份验证机制，包括 STOMP over WebSocket 交互，如上一节所述(即通过 cookie-based session 维护身份)。</p>
<p>在同一时间，cookie-based 会话并不总是最合适的(例如，在 applications 中不保持 server-side session 或在移动应用程序中，common 使用 headers 进行身份验证)。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455#websocket">WebSocket 协议，RFC 6455</a>“没有规定服务器在 WebSocket 握手期间可以对 clients 进行身份验证的任何特定方式。”但实际上，浏览器客户端只能使用标准身份验证 headers(即基本 HTTP 身份验证)或 cookies，而不能(用于 example)提供自定义 headers。同样，SockJS JavaScript client 不提供使用 SockJS 传输请求发送 HTTP headers 的方法。见<a target="_blank" rel="noopener" href="https://github.com/sockjs/sockjs-client/issues/196">sockjs-client issue 196</a>。相反，它允许发送可用于发送令牌的查询参数，但这有其自身的缺点(例如，令牌可能无意中使用服务器日志中的 URL 记录)。</p>
<blockquote>
<p>上述限制适用于 browser-based clients，不适用于 Spring Java-based STOMP client，它支持使用 WebSocket 和 SockJS 请求发送 headers。</p>
</blockquote>
<p>因此，希望避免使用 cookies 的应用程序可能没有任何好的替代方法来进行 HTTP 协议 level 的身份验证。他们可能更喜欢在 STOMP 消息传递协议中使用 headers 进行身份验证，而不是使用 cookies。这样做需要两个简单的步骤：</p>
<ul>
<li>使用 STOMP client 在 connect time 传递 authentication headers。</li>
<li>使用<code>ChannelInterceptor</code>处理身份验证 headers。</li>
</ul>
<p>下一个 example 使用 server-side configuration 来注册自定义身份验证拦截器。请注意，拦截器只需要在 CONNECT <code>Message</code>上进行身份验证并设置用户头。 Spring 记录并保存经过身份验证的用户，并将其与同一 session 上的后续 STOMP 消息相关联。以下 example 显示了如何注册自定义身份验证拦截器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class MyConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureClientInboundChannel(ChannelRegistration registration) &#123;</span><br><span class="line">        registration.interceptors(new ChannelInterceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">                StompHeaderAccessor accessor &#x3D;</span><br><span class="line">                        MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);</span><br><span class="line">                if (StompCommand.CONNECT.equals(accessor.getCommand())) &#123;</span><br><span class="line">                    Authentication user &#x3D; ... ; &#x2F;&#x2F; access authentication header(s)</span><br><span class="line">                    accessor.setUser(user);</span><br><span class="line">                &#125;</span><br><span class="line">                return message;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另请注意，当您使用 Spring Security 的邮件授权时，您需要确保在 Spring Security 之前排序身份验证<code>ChannelInterceptor</code> config。最好通过在<code>WebSocketMessageBrokerConfigurer</code>标记为<code>@Order(Ordered.HIGHEST_PRECEDENCE + 99)</code>的 implementation implementation 中声明自定义拦截器来完成。</p>
<h4 id="用户目的地"><a href="#用户目的地" class="headerlink" title="用户目的地"></a>用户目的地</h4><p>application 可以发送针对特定用户的消息，并且 Spring 的 STOMP 支持可以识别以<code>/user/</code>为前缀的目标。对于 example，client 可能订阅<code>/user/queue/position-updates</code>目标。此目标由<code>UserDestinationMessageHandler</code>处理并转换为用户 session 唯一的目标(例如<code>/queue/position-updates-user123</code>)。这提供了订阅一般命名目的地的便利，同时在同一时间确保不与订阅相同目的地的其他用户发生冲突，以便每个用户可以接收唯一的库存位置更新。</p>
<p>在发送方，消息可以被发送到诸如<code>/user/&#123;username&#125;/queue/position-updates</code>的目的地，而<code>/user/&#123;username&#125;/queue/position-updates</code>又由<code>UserDestinationMessageHandler</code>转换成一个或多个目的地，一个用于与用户相关联的每个 session。这使得 application 中的任何 component 都可以发送针对特定用户的消息，而不必了解其 name 和通用目标。通过 annotation 和消息传递模板也支持此功能。</p>
<p>message-handling 方法可以向通过<code>@SendToUser</code> annotation 处理的消息关联的用户发送消息(class-level 也支持共享 common 目的地)，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class PortfolioController &#123;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;&#x2F;trade&quot;)</span><br><span class="line">    @SendToUser(&quot;&#x2F;queue&#x2F;position-updates&quot;)</span><br><span class="line">    public TradeResult executeTrade(Trade trade, Principal principal) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        return tradeResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户具有多个 session，则默认情况下，订阅给定目标的所有会话都是目标。但是，有时可能需要仅定位发送正在处理的消息的 session。您可以通过将<code>broadcast</code>属性设置为 false 来实现，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;&#x2F;action&quot;)</span><br><span class="line">    public void handleAction() throws Exception&#123;</span><br><span class="line">        &#x2F;&#x2F; raise MyBusinessException here</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MessageExceptionHandler</span><br><span class="line">    @SendToUser(destinations&#x3D;&quot;&#x2F;queue&#x2F;errors&quot;, broadcast&#x3D;false)</span><br><span class="line">    public ApplicationError handleException(MyBusinessException exception) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        return appError;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然用户目的地通常意味着经过身份验证的用户，但并不是严格要求的。与经过身份验证的用户无关的 WebSocket session 可以订阅用户目标。在这种情况下，<code>@SendToUser</code> annotation 的行为与<code>broadcast=false</code>完全相同(即，仅定位发送正在处理的消息的 session)。</p>
</blockquote>
<p>您可以从任何 application component 向用户目标发送消息，例如，注入由 Java configuration 或 XML 命名空间创建的<code>SimpMessagingTemplate</code>。 (如果需要<code>@Qualifier</code> .)，则 bean name 为<code>&quot;brokerMessagingTemplate&quot;</code>以下 example 显示了如何执行此操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class TradeServiceImpl implements TradeService &#123;</span><br><span class="line"></span><br><span class="line">    private final SimpMessagingTemplate messagingTemplate;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) &#123;</span><br><span class="line">        this.messagingTemplate &#x3D; messagingTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    public void afterTradeExecuted(Trade trade) &#123;</span><br><span class="line">        this.messagingTemplate.convertAndSendToUser(</span><br><span class="line">                trade.getUserName(), &quot;&#x2F;queue&#x2F;position-updates&quot;, trade.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当您将用户目标与外部消息 broker 一起使用时，应检查 broker 文档，了解如何管理非活动队列，以便在用户 session 结束时删除所有唯一用户队列。对于 example，当您使用<code>/exchange/amq.direct/position-updates</code>等目标时，RabbitMQ 会创建 auto-delete 队列。因此，在这种情况下，client 可以订阅<code>/user/exchange/amq.direct/position-updates</code>。同样，ActiveMQ 有<a target="_blank" rel="noopener" href="http://activemq.apache.org/delete-inactive-destinations.html">configuration 选项</a>用于清除非活动目标。</p>
</blockquote>
<p>在 multi-application 服务器方案中，用户目标可能仍未解析，因为用户已连接到其他服务器。在这种情况下，您可以将目标配置为 broadcast 未解析的消息，以便其他服务器有机会尝试。这可以通过 Java configuration 中<code>MessageBrokerRegistry</code>的<code>userDestinationBroadcast</code> property 和 XML 中<code>message-broker</code>元素的<code>user-destination-broadcast</code>属性来完成。</p>
<h4 id="消息的订单"><a href="#消息的订单" class="headerlink" title="消息的订单"></a>消息的订单</h4><p>来自 broker 的消息将发布到<code>clientOutboundChannel</code>，从而将它们写入 WebSocket 会话。由于 channel 由<code>ThreadPoolExecutor</code>支持，因此消息在不同的线程中处理，client 接收的结果序列可能不匹配发布的确切 order。</p>
<p>如果这是一个问题，请启用<code>setPreservePublishOrder</code> flag，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class MyConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configureMessageBroker(MessageBrokerRegistry registry) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        registry.setPreservePublishOrder(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker preserve-publish-order&#x3D;&quot;true&quot;&gt;</span><br><span class="line">        &lt;!-- ... --&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>设置 flag 时，同一 client session 中的消息将在 time 发布到<code>clientOutboundChannel</code>，以便保证发布的 order。请注意，这会产生很小的性能开销，因此只有在需要时才应启用它。</p>
<h4 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h4><p>发布了几个<code>ApplicationContext</code> events，可以通过实现 Spring 的<code>ApplicationListener</code>接口来接收：</p>
<ul>
<li><code>BrokerAvailabilityEvent</code>：表示 broker 何时可用或不可用。虽然“简单”broker 在启动时立即可用，并且在 application 运行时仍然如此，但 STOMP“broker relay”可能会失去与全功能 broker 的连接(对于 example，如果 broker 重新启动)。 broker 中继重新连接逻辑，re-establishes 与 broker 的“系统”连接返回时。因此，只要 state 从连接变为 disconnected 和 vice-versa，就会发布此 event。使用<code>SimpMessagingTemplate</code>的组件应订阅此 event，并避免在 broker 不可用时发送消息。无论如何，他们应该准备好在发送消息时处理<code>MessageDeliveryException</code>。</li>
<li><code>SessionConnectEvent</code>：收到新的 STOMP CONNECT 时发布，表示新 client session 的开始。 event 包含表示连接的消息，包括 session ID，用户信息(如果有)以及 client 发送的任何自定义 headers。这对于跟踪 client 会话非常有用。订阅此 event 的组件可以使用<code>SimpMessageHeaderAccessor</code>或<code>StompMessageHeaderAccessor</code>包装所包含的消息。</li>
<li><code>SessionConnectedEvent</code>：当 broker 发送 STOMP CONNECTED 帧以响应 CONNECT 时后不久发布。此时，可以认为 STOMP session 已完全建立。</li>
<li><code>SessionSubscribeEvent</code>：收到新的 STOMP SUBSCRIBE 时发布。</li>
<li><code>SessionUnsubscribeEvent</code>：收到新的 STOMP UNSUBSCRIBE 时发布。</li>
<li><code>SessionDisconnectEvent</code>：在 STOMP session ends 时发布。 DISCONNECT 可能已从 client 发送，或者可能在 WebSocket session 关闭时自动生成。在某些情况下，每个 session 都会多次发布此 event。对于多个 disconnect events，组件应该是幂等的。</li>
</ul>
<blockquote>
<p>当您使用 full-featured broker 时，如果 broker 暂时不可用，则 STOMP“broker relay”会自动重新连接“系统”连接。但是，Client 连接不会自动重新连接。假设启用了心跳，client 通常会注意到 broker 在 10 秒内没有响应。 Clients 需要实现自己的重新连接逻辑。</p>
</blockquote>
<h4 id="截击-1"><a href="#截击-1" class="headerlink" title="截击"></a>截击</h4><p><a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket">Events</a>提供 STOMP 连接生命周期的通知，但不提供每个 client 消息的通知。 Applications 还可以注册<code>ChannelInterceptor</code>来拦截任何消息以及处理链的任何部分。以下 example 显示了如何拦截来自 clients 的入站邮件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureClientInboundChannel(ChannelRegistration registration) &#123;</span><br><span class="line">        registration.interceptors(new MyChannelInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义<code>ChannelInterceptor</code>可以使用<code>StompHeaderAccessor</code>或<code>SimpMessageHeaderAccessor</code>来访问有关邮件的信息，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class MyChannelInterceptor implements ChannelInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Message&lt;?&gt; preSend(Message&lt;?&gt; message, MessageChannel channel) &#123;</span><br><span class="line">        StompHeaderAccessor accessor &#x3D; StompHeaderAccessor.wrap(message);</span><br><span class="line">        StompCommand command &#x3D; accessor.getStompCommand();</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Applications 也可以实现<code>ExecutorChannelInterceptor</code>，这是一个 sub-interface <code>ChannelInterceptor</code>，在处理消息的线程中有回调。虽然为发送到 channel 的每条消息调用<code>ChannelInterceptor</code>一次，但<code>ExecutorChannelInterceptor</code>在每个<code>MessageHandler</code>的线程中提供了挂钩，这些挂钩订阅了来自 channel 的消息。</p>
<p>请注意，与前面描述的<code>SesionDisconnectEvent</code>一样，DISCONNECT 消息可以来自 client，也可以在 WebSocket session 关闭时自动生成。在某些情况下，拦截器可能会为每个 session 多次拦截此消息。对于多个 disconnect events，组件应该是幂等的。</p>
<h4 id="STOMP-Client"><a href="#STOMP-Client" class="headerlink" title="STOMP-Client"></a>STOMP-Client</h4><p>Spring 通过 WebSocket client 提供 STOMP，通过 TCP client 提供 STOMP。</p>
<p>首先，您可以创建和配置<code>WebSocketStompClient</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebSocketClient webSocketClient &#x3D; new StandardWebSocketClient();</span><br><span class="line">WebSocketStompClient stompClient &#x3D; new WebSocketStompClient(webSocketClient);</span><br><span class="line">stompClient.setMessageConverter(new StringMessageConverter());</span><br><span class="line">stompClient.setTaskScheduler(taskScheduler); &#x2F;&#x2F; for heartbeats</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，您可以将<code>StandardWebSocketClient</code>替换为<code>SockJsClient</code>，因为它也是<code>WebSocketClient</code>的 implementation。 <code>SockJsClient</code>可以使用 WebSocket 或 HTTP-based transport 作为后备。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#section-10.5">SockJsClient</a>。</p>
<p>接下来，您可以建立连接并为 STOMP session 提供处理程序，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String url &#x3D; &quot;ws:&#x2F;&#x2F;127.0.0.1:8080&#x2F;endpoint&quot;;</span><br><span class="line">StompSessionHandler sessionHandler &#x3D; new MyStompSessionHandler();</span><br><span class="line">stompClient.connect(url, sessionHandler);</span><br></pre></td></tr></table></figure>
<p>当 session 准备好使用时，将通知处理程序，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class MyStompSessionHandler extends StompSessionHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterConnected(StompSession session, StompHeaders connectedHeaders) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立 session 后，可以发送任何有效负载并使用配置的<code>MessageConverter</code>进行序列化，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.send(&quot;&#x2F;topic&#x2F;something&quot;, &quot;payload&quot;);</span><br></pre></td></tr></table></figure>
<p>您也可以订阅目的地。 <code>subscribe</code>方法需要处理订阅消息的处理程序，并返回一个可用于取消订阅的<code>Subscription</code>句柄。对于每个收到的消息，处理程序可以指定有效负载应反序列化的目标<code>Object</code>类型，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">session.subscribe(&quot;&#x2F;topic&#x2F;something&quot;, new StompFrameHandler() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Type getPayloadType(StompHeaders headers) &#123;</span><br><span class="line">        return String.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleFrame(StompHeaders headers, Object payload) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>要启用 STOMP 心跳，可以使用<code>TaskScheduler</code>配置<code>WebSocketStompClient</code>，并可选择自定义心跳间隔(写入不活动 10 秒，导致心跳发送，读取不活动 10 秒，关闭连接)。</p>
<blockquote>
<p>当您使用<code>WebSocketStompClient</code>进行 performance 测试来模拟来自同一台计算机的数千个 clients 时，请考虑关闭心跳，因为每个连接都会安排自己的心跳任务，并且不会针对同一台计算机上的大量客户端进行优化。</p>
</blockquote>
<p>STOMP 协议还支持收据，其中 client 必须添加<code>receipt</code>标头，服务器在处理发送或订阅后用 RECEIPT 帧响应。为了支持这一点，<code>StompSession</code>提供<code>setAutoReceipt(boolean)</code>，导致在每个后续发送或订阅 event 上添加<code>receipt</code>标头。或者，您也可以手动将收据标题添加到<code>StompHeaders</code>。发送和订阅 return 都会返回<code>Receiptable</code>的实例，您可以使用它来注册接收成功和失败回调。对于此 feature，您必须在收据到期前(默认为 15 秒)为 client 配置<code>TaskScheduler</code>和 time 的数量。</p>
<p>注意<code>StompSessionHandler</code>本身是一个<code>StompFrameHandler</code>，它允许它处理 ERROR 帧以及<code>handleException</code>回调来处理消息的 exceptions 和<code>handleTransportError</code>来处理 transport-level 错误，包括<code>ConnectionLostException</code>。</p>
<h4 id="WebSocket范围"><a href="#WebSocket范围" class="headerlink" title="WebSocket范围"></a>WebSocket范围</h4><p>每个 WebSocket session 都有一个属性 map。 map 作为标题附加到入站 client 消息，可以从控制器方法访问，如下面的示例所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;&#x2F;action&quot;)</span><br><span class="line">    public void handle(SimpMessageHeaderAccessor headerAccessor) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; attrs &#x3D; headerAccessor.getSessionAttributes();</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在<code>websocket</code>范围内声明 Spring-managed bean。您可以 inject WebSocket-scoped beans 到控制器和<code>clientInboundChannel</code>上注册的任何 channel 拦截器。这些通常是单身，比任何单独的 WebSocket session 都更长寿。因此，您需要为 WebSocket-scoped beans 使用范围代理模式，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Scope(scopeName &#x3D; &quot;websocket&quot;, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line">public class MyBean &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        &#x2F;&#x2F; Invoked after dependencies injected</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">    @PreDestroy</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">        &#x2F;&#x2F; Invoked when the WebSocket session ends</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class MyController &#123;</span><br><span class="line"></span><br><span class="line">    private final MyBean myBean;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public MyController(MyBean myBean) &#123;</span><br><span class="line">        this.myBean &#x3D; myBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @MessageMapping(&quot;&#x2F;action&quot;)</span><br><span class="line">    public void handle() &#123;</span><br><span class="line">        &#x2F;&#x2F; this.myBean from the current WebSocket session</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与任何自定义作用域一样，Spring 在从控制器访问第一个 time 时初始化一个新的<code>MyBean</code>实例，并在 WebSocket session 属性中存储实例。随后返回相同的实例，直到 session ends。 WebSocket-scoped beans 调用了所有 Spring 生命周期方法，如前面的示例所示。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>在绩效方面没有灵丹妙药。许多因素会影响它，包括消息的大小和数量，application 方法是否执行需要阻塞的工作，以及外部因素(如网络速度和其他问题)。本节的目标是提供可用 configuration 选项的概述以及有关如何推理扩展的一些想法。</p>
<p>在消息传递 application 中，消息通过 channels 传递给由线程池支持的异步执行。配置这样的 application 需要充分了解 channels 和消息流。因此，建议审核<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-appplication-context-events">消息流</a>。</p>
<p>显而易见的起点是配置支持<code>clientInboundChannel</code>和<code>clientOutboundChannel</code>的线程池。默认情况下，两者都配置为可用处理器数量的两倍。</p>
<p>如果注释方法中的消息处理主要是 CPU-bound，则<code>clientInboundChannel</code>的线程数应保持接近处理器数。如果他们所做的工作更多 IO-bound 并且需要阻塞或等待数据库或其他外部系统，则可能需要增加线程池大小。</p>
<blockquote>
<p><code>ThreadPoolExecutor</code>有三个重要的 properties：核心线程池大小，最大线程池大小，以及队列为 store 任务没有可用线程的任务的容量。</p>
</blockquote>
<p>一个常见的混淆点是，配置核心池大小(对于 example，10)和最大池大小(对于 example，20)会导致一个具有 10 到 20 个线程的线程池。实际上，如果容量保留为 Integer.MAXVALUE 的默认值_，则线程池永远不会超出核心池大小，因为所有其他任务都排队。</p>
<p>请参阅<code>ThreadPoolExecutor</code>的 javadoc 以了解这些 properties 如何工作并理解各种排队策略。</p>
<p>在<code>clientOutboundChannel</code>方面，它是关于向 WebSocket clients 发送消息的全部内容。如果 clients 位于快速网络上，则线程数应保持接近可用处理器的数量。如果它们很慢或带宽较低，则消耗消息所需的时间会更长，并给线程池带来负担。因此，增加线程池大小变得必要。</p>
<p>虽然<code>clientInboundChannel</code>的工作负载可以预测 - 毕竟，它基于 application 的作用 - 如何配置“clientOutboundChannel”更难，因为它基于 application 无法控制的因素。因此，另外两个 properties 与发送消息有关：<code>sendTimeLimit</code>和<code>sendBufferSizeLimit</code>。您可以使用这些方法配置允许发送 long 的时间以及向 client 发送消息时可以缓冲的数据量。</p>
<p>一般 idea 是，在任何给定的 time，只有一个线程可用于发送到 client。同时，所有其他消息都会被缓冲，您可以使用这些 properties 来决定如何允许发送消息的长度以及在此期间可以缓冲多少数据。有关重要的其他详细信息，请参阅 XML schema 的 javadoc 和文档。</p>
<p>以下 example 显示了可能的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureWebSocketTransport(WebSocketTransportRegistration registration) &#123;</span><br><span class="line">        registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker&gt;</span><br><span class="line">        &lt;websocket:transport send-timeout&#x3D;&quot;15000&quot; send-buffer-size&#x3D;&quot;524288&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- ... --&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>您还可以使用前面显示的 WebSocket 传输 configuration 配置传入 STOMP 消息的最大允许大小。理论上，WebSocket 消息的大小几乎是无限的。在实践中，WebSocket 服务器强加限制 - 例如，Tomcat 上的 8K 和 Jetty 上的 64K。出于这个原因，STOMP clients(例如 JavaScript <a target="_blank" rel="noopener" href="https://github.com/JSteunou/webstomp-client">webstomp-client</a>和其他)在 16K 边界处拆分较大的 STOMP 消息，并将它们作为多个 WebSocket 消息发送，这需要服务器缓冲和 re-assemble。</p>
<p>Spring 的 STOMP-over-WebSocket 支持执行此操作，因此 applications 可以配置 STOMP 消息的最大大小，而不管 WebSocket server-specific 消息大小如何。请记住，如有必要，WebSocket 消息大小会自动调整，以确保它们至少可以携带 16K WebSocket 消息。</p>
<p>以下 example 显示了一个可能的 configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableWebSocketMessageBroker</span><br><span class="line">public class WebSocketConfig implements WebSocketMessageBrokerConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configureWebSocketTransport(WebSocketTransportRegistration registration) &#123;</span><br><span class="line">        registration.setMessageSizeLimit(128 * 1024);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 example 显示了前面的 example 的 XML configuration 等效项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;websocket:message-broker&gt;</span><br><span class="line">        &lt;websocket:transport message-size&#x3D;&quot;131072&quot; &#x2F;&gt;</span><br><span class="line">        &lt;!-- ... --&gt;</span><br><span class="line">    &lt;&#x2F;websocket:message-broker&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>关于扩展的一个重要问题涉及使用多个 application 实例。目前，你不能用简单的 broker 做到这一点。但是，当您使用 full-featured broker(例如 RabbitMQ)时，每个 application 实例都连接到 broker，而来自一个 application 实例的消息 broadcast 可以通过 broker broadcast 到通过任何其他 application 实例连接的 WebSocket clients。</p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>当您使用<code>@EnableWebSocketMessageBroker</code>或<code>&lt;websocket:message-broker&gt;</code>时， key 基础结构组件会自动收集统计信息和计数器，以便对 application 的内部 state 提供重要的信息。 configuration 还声明一个类型的 bean，它在一个地方收集所有可用信息，默认情况下，每 30 分钟收集一次<code>INFO</code> level。这个 bean 可以通过 Spring 的<code>MBeanExporter</code>导出到 JMX，以便在运行时查看(对于 example，通过 JDK 的<code>jconsole</code>)。以下列表总结了可用信息：</p>
<ul>
<li>Client WebSocket 会话<ul>
<li><ul>
<li>当前</li>
</ul>
</li>
<li>指示当前有多少个 client 会话，其中计数进一步按 WebSocket 与 HTTP 流式传输和轮询 SockJS 会话进行细分。</li>
</ul>
</li>
<li>总<ul>
<li>表示已建立的会话总数。</li>
</ul>
</li>
<li>异常关闭<ul>
<li><ul>
<li>连接失败</li>
</ul>
</li>
<li>已建立但在 60 秒内未收到任何消息后关闭的会话。这通常表示代理或网络问题。</li>
</ul>
</li>
<li>超出发送限制<ul>
<li>超过配置的发送超时或发送缓冲区限制后，会话关闭，这可能发生在慢客户端(请参阅上一节)。</li>
</ul>
</li>
<li>运输错误<ul>
<li>传输错误后会话关闭，例如无法读取或写入 WebSocket 连接或 HTTP 请求或响应。</li>
</ul>
</li>
<li>STOMP 框架<ul>
<li>处理的 CONNECT，CONNECTED 和 DISCONNECT 帧的总数，表示 STOMP level 上连接了多少个 clients。请注意，当会话异常关闭或 clients 关闭而不发送 DISCONNECT 帧时，DISCONNECT 计数可能会更低。</li>
</ul>
</li>
<li>STOMP Broker Relay<ul>
<li><ul>
<li>TCP 连接</li>
</ul>
</li>
<li>表示为 broker 建立了代表 client WebSocket 会话的 TCP 连接数。这应该等于 client WebSocket 会话的数量 1 个额外的共享“系统”连接，用于从 application 中发送消息。</li>
</ul>
</li>
<li>STOMP 框架<ul>
<li>代表 clients 转发到 broker 或从 broker 接收的 CONNECT，CONNECTED 和 DISCONNECT 帧的总数。请注意，无论 client WebSocket session 如何关闭，都会向 broker 发送 DISCONNECT 帧。因此，较低的 DISCONNECT 帧计数表示 broker 是 pro-actively 关闭连接(可能是因为心跳未在 time 到达，无效的输入帧或其他问题)。</li>
</ul>
</li>
<li>Client Inbound Channel<ul>
<li>来自支持<code>clientInboundChannel</code>的线程池的统计信息，用于深入了解传入消息处理的运行状况。在此排队的任务表明 application 可能太慢而无法处理消息。如果有 I/O 绑定任务(对于 example，慢速数据库查询，对第三方 REST API 的 HTTP 请求等)，请考虑增加线程池大小。</li>
</ul>
</li>
<li>Client Outbound Channel<ul>
<li>来自支持<code>clientOutboundChannel</code>的线程池的统计信息，可以深入了解 broadcasting 消息到 clients 的运行状况。在这里排队的任务表明客户端太慢而无法使用消息。解决此问题的一种方法是增加线程池大小以适应预期的并发慢客户端数。另一种选择是减少发送超时和发送缓冲区大小限制(参见上一节)。</li>
</ul>
</li>
<li>SockJS 任务计划程序<ul>
<li>来自用于发送心跳的 SockJS 任务调度程序的线程池的统计信息。请注意，在 STOMP level 上协商心跳时，将禁用 SockJS 心跳。</li>
</ul>
</li>
</ul>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>当您使用 Spring 的 STOMP-over-WebSocket 支持时，有两种主要的方法来测试 applications。第一种是编写 server-side 测试来验证控制器及其带注释的 message-handling 方法的功能。第二个是编写完整的 end-to-end 测试，涉及运行 client 和服务器。</p>
<p>这两种方法并不相互排斥。相反，每个人都在整体测试策略中占有一席之地。 Server-side 测试更集中，更容易编写和维护。另一方面，End-to-end integration 测试更完整，测试更多，但它们也更多地参与编写和维护。</p>
<p>最简单的 server-side 测试形式是编写控制器单元测试。但是，这还不够用，因为控制器的大部分功能取决于它的注释。纯单元测试根本无法测试。</p>
<p>理想情况下，测试中的控制器应该在运行时调用，就像测试使用 Spring MVC Test framework 处理 HTTP 请求的控制器的方法一样 - 也就是说，没有 running Servlet 容器但是依赖于 Spring Framework 来调用带注释的控制器。与 Spring MVC Test 一样，这里有两个可能的替代方案，使用“context-based”或使用“独立”设置：</p>
<ul>
<li>在 Spring TestContext framework，inject <code>clientInboundChannel</code>作为测试字段的帮助下加载实际的 Spring configuration，并使用它来发送要由控制器方法处理的消息。</li>
<li>手动设置调用控制器(即<code>SimpAnnotationMethodMessageHandler</code>)所需的最小 Spring framework 基础结构，并将控制器的消息直接传递给它。</li>
</ul>
<p>这两种设置方案都在<a target="_blank" rel="noopener" href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试股票投资组合</a> sample application 中进行了演示。</p>
<p>第二种方法是创建 end-to-end integration 测试。为此，您需要以嵌入模式运行 WebSocket 服务器并将其作为 WebSocket client 连接到它，以发送包含 STOMP 帧的 WebSocket 消息。 <a target="_blank" rel="noopener" href="https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web">测试股票投资组合</a> sample application 还通过使用 Tomcat 作为嵌入式 WebSocket 服务器和用于测试目的的简单 STOMP client 来演示此方法。</p>
<h2 id="其他Web框架"><a href="#其他Web框架" class="headerlink" title="其他Web框架"></a>其他Web框架</h2><p>本章详细介绍了 Spring 与第三方 web 框架的整合。</p>
<p>Spring Framework 的核心 value 命题之一是支持选择。从一般意义上讲，Spring 并不强迫您使用或购买任何特定的 architecture，技术或方法(尽管它肯定会推荐一些其他的)。这种自由选择与开发人员及其开发团队最相关的 architecture，技术或方法可以说是最明显的 web 区域，其中 Spring 提供了自己的 web framework(<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-fallback-sockjs-client">Spring MVC</a>)，而在同一时间，提供与一些流行的第三方 web 框架的整合。</p>
<h3 id="Common配置"><a href="#Common配置" class="headerlink" title="Common配置"></a>Common配置</h3><p>在深入研究每个支持的 web framework 的 integration 细节之前，让我们先看一下 Spring configuration，它不是任何一个 web framework 特有的。 (本节同样适用于 Spring 自己的 web framework，Spring MVC.)</p>
<p>Spring 的轻量级 application model 支持的一个概念(想要一个更好的词)是一个分层的 architecture。请记住，在“经典”分层 architecture 中，web 图层只是众多图层中的一个。它充当 server-side application 的入口点之一，并且它委托服务层中定义的服务 objects(Facade)以满足 business-specific(和 presentation-technology 不可知)用例。在 Spring 中，这些服务 objects，任何其他 business-specific objects，data-accessobjects 和其他服务存在于不同的“business context”中，其中不包含 web 或表示层 objects(表示 objects，例如 Spring MVC 控制器，通常以不同的方式配置) “presentation context”)。本节详细介绍了如何配置包含 application 中所有’business beans’的 Spring 容器(<code>WebApplicationContext</code>)。</p>
<p>转到具体细节，您需要做的就是在 web application 的标准 Java EE servlet <code>web.xml</code>文件中声明一个<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/ContextLoaderListener.html">ContextLoaderListener</a>并添加一个<code>contextConfigLocation</code> <context-param/>部分(在同一个文件中)，该部分定义要加载的 Spring XML configuration files 集合。</p>
<p>考虑以下<code>&lt;listener/&gt;</code> configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure>
<p>进一步考虑以下<code>&lt;context-param/&gt;</code> configuration：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">    &lt;param-value&gt;&#x2F;WEB-INF&#x2F;applicationContext*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">&lt;&#x2F;context-param&gt;</span><br></pre></td></tr></table></figure>
<p>如果未指定<code>contextConfigLocation</code> context 参数，则<code>ContextLoaderListener</code>将查找要加载的名为<code>/WEB-INF/applicationContext.xml</code>的文件。加载 context files 后，Spring 会根据 bean 定义创建<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/WebApplicationContext.html">WebApplicationContext</a> object，并将 store 存储在 web application 的<code>ServletContext</code>中。</p>
<p>所有 Java web 框架都构建在 Servlet API 之上，因此您可以使用以下 code 代码段来访问<code>ContextLoaderListener</code>创建的“business context”<code>ApplicationContext</code>。</p>
<p>以下 example 显示了如何获取<code>WebApplicationContext</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext ctx &#x3D; WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/context/support/WebApplicationContextUtils.html">WebApplicationContextUtils</a> class 是为了方便起见，因此您无需记住<code>ServletContext</code>属性的 name。如果<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</code> key 下不存在 object，则<code>getWebApplicationContext()</code>方法返回<code>null</code>。而不是冒险在 application 中获取<code>NullPointerExceptions</code>，最好使用<code>getRequiredWebApplicationContext()</code>方法。当<code>ApplicationContext</code>缺失时，此方法抛出 exception。</p>
<p>一旦你的 reference，你可以通过 name 或类型检索 beans。大多数开发人员通过 name 检索 beans，然后将它们转换为其实现的接口之一。</p>
<p>幸运的是，本节中的大多数框架都有更简单的查找 beans 的方法。它们不仅可以轻松地从 Spring 容器中获取 beans，而且还允许您在其控制器上使用依赖注入。每个 web framework 部分都有关于其特定 integration 策略的更多细节。</p>
<h3 id="JSF"><a href="#JSF" class="headerlink" title="JSF"></a>JSF</h3><p>JavaServer Faces(JSF)是 JCP 的标准 component-based，event-driven web 用户界面 framework。从 Java EE 5 开始，它是 Java EE 保护伞的官方部分。</p>
<p>对于流行的 JSF 运行时以及流行的 JSF component libraries，请查看<a target="_blank" rel="noopener" href="https://myfaces.apache.org/">Apache MyFaces 项目</a>。 MyFaces 项目还提供了 common JSF extensions，例如<a target="_blank" rel="noopener" href="https://myfaces.apache.org/orchestra/">MyFaces Orchestra</a>(一个提供丰富的会话范围支持的 Spring-based JSF 扩展)。</p>
<blockquote>
<p>Spring Web Flow 2.0 通过其新建立的 Spring Faces 模块提供丰富的 JSF 支持，包括 JSF-centric 用法(如本节所述)和 Spring-centric 用法(使用 Spring MVC 调度程序中的 JSF 视图)。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-webflow">Spring Web Flow 网站</a>。</p>
</blockquote>
<p>Spring 的 JSF integration 中的 key 元素是 JSF <code>ELResolver</code>机制。</p>
<h4 id="SpringBeanResolver"><a href="#SpringBeanResolver" class="headerlink" title="SpringBeanResolver"></a>SpringBeanResolver</h4><p><code>SpringBeanFacesELResolver</code>是符合 JSF 1.2 的<code>ELResolver</code> implementation，与 JSF 1.2 和 JSP 2.1 使用的标准 Unified EL 集成。作为<code>SpringBeanVariableResolver</code>，它首先委托 Spring 的“business context”<code>WebApplicationContext</code>，然后委托给底层 JSF implementation 的默认解析器。</p>
<p>Configuration-wise，您可以在 JSF <code>faces-context.xml</code>文件中定义<code>SpringBeanFacesELResolver</code>，如下面的 example 所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;faces-config&gt;</span><br><span class="line">    &lt;application&gt;</span><br><span class="line">        &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;&#x2F;el-resolver&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;&#x2F;application&gt;</span><br><span class="line">&lt;&#x2F;faces-config&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用FacesContextUtils"><a href="#使用FacesContextUtils" class="headerlink" title="使用FacesContextUtils"></a>使用FacesContextUtils</h4><p>在<code>faces-config.xml</code>中将 properties 映射到 beans 时，自定义<code>VariableResolver</code>可以正常工作，但有时，您可能需要显式 grab bean。 <a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/jsf/FacesContextUtils.html">这时，FacesContextUtils</a> class 使这很容易。它类似于<code>WebApplicationContextUtils</code>，除了它采用<code>FacesContext</code>参数而不是<code>ServletContext</code>参数。</p>
<p>以下 example 显示了如何使用<code>FacesContextUtils</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx &#x3D; FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</span><br></pre></td></tr></table></figure>
<h3 id="ApacheStruts-2-x"><a href="#ApacheStruts-2-x" class="headerlink" title="ApacheStruts 2.x"></a>ApacheStruts 2.x</h3><p>由 Craig McClanahan 发明，<a target="_blank" rel="noopener" href="https://struts.apache.org/">支柱</a>是由 Apache 软件基金会主办的 open-source 项目。在 time，它大大简化了 JSP/Servlet 编程范例，赢得了许多使用专有框架的开发人员。它简化了编程 model，它是开源的(因此在啤酒中是免费的)，它有一个庞大的社区，让项目在 Java web 开发人员中成长并变得流行。</p>
<p>查看 Struts <a target="_blank" rel="noopener" href="https://struts.apache.org/release/2.3.x/docs/spring-plugin.html">Spring 插件</a>，了解 Struts 附带的 built-in Spring integration。</p>
<h3 id="挂毯5-x"><a href="#挂毯5-x" class="headerlink" title="挂毯5.x"></a>挂毯5.x</h3><p><a target="_blank" rel="noopener" href="https://tapestry.apache.org/">挂毯</a>是一个“Component 为 framework”，用于在 Java 中创建动态，健壮，高度可扩展的 web applications。“</p>
<p>虽然 Spring 有自己的<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/web.html#websocket-stomp-message-flow">强大的 web 层</a>，但通过使用 Tapestry 用于 web 用户界面和 Spring 容器用于较低层，构建企业 Java 应用程序有许多独特的优势。</p>
<p>有关更多信息，请参阅 Tapestry 的专用<a target="_blank" rel="noopener" href="https://tapestry.apache.org/integrating-with-spring-framework.html">Spring 的 integration 模块</a>。</p>
<h3 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h3><p>以下链接转到有关本章所述的各种 web 框架的更多资源。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.oracle.com/technetwork/java/javaee/javaserverfaces-139869.html">JSF</a>主页</li>
<li><a target="_blank" rel="noopener" href="https://struts.apache.org/">支柱</a>主页</li>
<li><a target="_blank" rel="noopener" href="https://tapestry.apache.org/">挂毯</a>主页</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" rel="prev" title="SpringFramework官方文档翻译-数据访问">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-数据访问
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Web-on-Reactive-Stack/" rel="next" title="SpringFramework官方文档翻译-Web on Reactive Stack">
      SpringFramework官方文档翻译-Web on Reactive Stack <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Servlet-Stack-%E4%B8%8A%E7%9A%84-Web"><span class="nav-number">1.</span> <span class="nav-text">Servlet Stack 上的 Web</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Web-MVC"><span class="nav-number">1.1.</span> <span class="nav-text">Spring Web MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DispatcherServlet"><span class="nav-number">1.1.1.</span> <span class="nav-text">DispatcherServlet</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Context-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Context 层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84Bean%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">特殊的Bean类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebMVC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">WebMVC配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">Servlet配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Processing"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">Processing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E5%87%BB"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">截击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exceptions"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A6%E8%BD%AE%E6%89%8B%E6%9E%AA%E9%93%BE"><span class="nav-number">1.1.1.7.1.</span> <span class="nav-text">左轮手枪链</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="nav-number">1.1.1.7.2.</span> <span class="nav-text">容器错误页面</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.1.8.</span> <span class="nav-text">View解析器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Handling"><span class="nav-number">1.1.1.8.1.</span> <span class="nav-text">Handling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="nav-number">1.1.1.8.2.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91"><span class="nav-number">1.1.1.8.3.</span> <span class="nav-text">转发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="nav-number">1.1.1.8.4.</span> <span class="nav-text">内容协商</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#locale"><span class="nav-number">1.1.1.9.</span> <span class="nav-text">locale</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%B6%E5%8C%BA"><span class="nav-number">1.1.1.9.1.</span> <span class="nav-text">时区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E9%A2%98%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.1.9.2.</span> <span class="nav-text">标题解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Cookie%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.1.9.3.</span> <span class="nav-text">Cookie解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Session%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.1.9.4.</span> <span class="nav-text">Session解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Locale%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">1.1.1.9.5.</span> <span class="nav-text">Locale拦截器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%A2%98"><span class="nav-number">1.1.1.10.</span> <span class="nav-text">主题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98"><span class="nav-number">1.1.1.10.1.</span> <span class="nav-text">定义主题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E4%B8%BB%E9%A2%98"><span class="nav-number">1.1.1.10.2.</span> <span class="nav-text">解决主题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Multipart%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="nav-number">1.1.1.11.</span> <span class="nav-text">Multipart解析器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Apache%E5%B8%B8%E8%A7%84FileUpload"><span class="nav-number">1.1.1.11.1.</span> <span class="nav-text">Apache常规FileUpload</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet3-0"><span class="nav-number">1.1.1.11.2.</span> <span class="nav-text">Servlet3.0</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Logging"><span class="nav-number">1.1.1.12.</span> <span class="nav-text">Logging</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.1.12.1.</span> <span class="nav-text">敏感数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">表单数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91Headers"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">转发Headers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85ETag"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">浅ETag</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">1.1.2.4.</span> <span class="nav-text"> </span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.1.3.</span> <span class="nav-text">带注解的控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A3%E8%A8%80"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">宣言</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AOPProxies"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">AOPProxies</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">请求映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URI%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">URI模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Pattern%E6%AF%94%E8%BE%83"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">Pattern比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E7%BC%80-Match"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">后缀 Match</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D%E5%92%8C-RFD"><span class="nav-number">1.1.3.2.4.</span> <span class="nav-text">后缀匹配和 RFD</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.2.5.</span> <span class="nav-text">可消费的媒体类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E7%94%9F%E4%BA%A7%E7%9A%84%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.3.2.6.</span> <span class="nav-text">可生产的媒体类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%92%8CHeaders"><span class="nav-number">1.1.3.2.7.</span> <span class="nav-text">参数和Headers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HTTP%E5%A4%B4-OPTIONS"><span class="nav-number">1.1.3.2.8.</span> <span class="nav-text">HTTP头,OPTIONS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.2.9.</span> <span class="nav-text">自定义注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E6%B3%A8%E5%86%8C"><span class="nav-number">1.1.3.2.10.</span> <span class="nav-text">显式注册</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">处理程序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95Arguments"><span class="nav-number">1.1.3.3.1.</span> <span class="nav-text">方法Arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Return%E5%80%BC"><span class="nav-number">1.1.3.3.2.</span> <span class="nav-text">Return值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.3.3.3.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9F%A9%E9%98%B5%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.3.3.4.</span> <span class="nav-text">矩阵变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestParam%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.5.</span> <span class="nav-text">RequestParam注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestHeader%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.6.</span> <span class="nav-text">RequestHeader注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CookieValue%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.7.</span> <span class="nav-text">CookieValue注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ModelAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.8.</span> <span class="nav-text">ModelAttribute注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionAttributes%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.9.</span> <span class="nav-text">SessionAttributes注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SessionAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.10.</span> <span class="nav-text">SessionAttribute注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestAttribute%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.11.</span> <span class="nav-text">RequestAttribute注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.3.3.12.</span> <span class="nav-text">重定向属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Flash-%E5%B1%9E%E6%80%A7"><span class="nav-number">1.1.3.3.13.</span> <span class="nav-text">Flash 属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Multipart"><span class="nav-number">1.1.3.3.14.</span> <span class="nav-text">Multipart</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RequestBody%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.15.</span> <span class="nav-text">RequestBody注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HttpEntity"><span class="nav-number">1.1.3.3.16.</span> <span class="nav-text">HttpEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResponseBody%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.3.3.17.</span> <span class="nav-text">ResponseBody注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResponseEntity"><span class="nav-number">1.1.3.3.18.</span> <span class="nav-text">ResponseEntity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JacksonJSON"><span class="nav-number">1.1.3.3.19.</span> <span class="nav-text">JacksonJSON</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Jackson%E5%BA%8F%E5%88%97%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.3.3.19.1.</span> <span class="nav-text">Jackson序列化视图</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Model"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Model</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataBinder"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">DataBinder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exceptions-1"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">Exceptions</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95-Arguments"><span class="nav-number">1.1.3.6.1.</span> <span class="nav-text">方法 Arguments</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Return-%E5%80%BC"><span class="nav-number">1.1.3.6.2.</span> <span class="nav-text">Return 值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#REST-API%E5%BC%82%E5%B8%B8"><span class="nav-number">1.1.3.6.3.</span> <span class="nav-text">REST-API异常</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ControllerAdvice"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">ControllerAdvice</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.4.</span> <span class="nav-text">URI链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UriComponents"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">UriComponents</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UriBuilder"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">UriBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#URI%E7%BC%96%E7%A0%81"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">URI编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9Servlet%E8%AF%B7%E6%B1%82"><span class="nav-number">1.1.4.4.</span> <span class="nav-text">相对Servlet请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.4.5.</span> <span class="nav-text">控制器的链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="nav-number">1.1.4.6.</span> <span class="nav-text">视图中的链接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="nav-number">1.1.5.</span> <span class="nav-text">异步请求</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DeferredResult"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">DeferredResult</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%B5%8E%E5%9B%9E"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">可赎回</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Exception%E5%A4%84%E7%90%86"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">Exception处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">拦截</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8E-WebFlux-%E7%9B%B8%E6%AF%94"><span class="nav-number">1.1.5.3.3.</span> <span class="nav-text">与 WebFlux 相比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-%E6%B5%81%E5%AA%92%E4%BD%93"><span class="nav-number">1.1.5.4.</span> <span class="nav-text">HTTP 流媒体</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Objects"><span class="nav-number">1.1.5.4.1.</span> <span class="nav-text">Objects</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SSE"><span class="nav-number">1.1.5.4.2.</span> <span class="nav-text">SSE</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">1.1.5.4.3.</span> <span class="nav-text">原始数据</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reactive%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.5.5.</span> <span class="nav-text">Reactive类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%AD%E5%BC%80"><span class="nav-number">1.1.5.6.</span> <span class="nav-text">断开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E6%80%81"><span class="nav-number">1.1.5.7.</span> <span class="nav-text">组态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Servlet%E5%AE%B9%E5%99%A8"><span class="nav-number">1.1.5.7.1.</span> <span class="nav-text">Servlet容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringMVC"><span class="nav-number">1.1.5.7.2.</span> <span class="nav-text">SpringMVC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS"><span class="nav-number">1.1.6.</span> <span class="nav-text">CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Processing-1"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">Processing</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CrossOrigin%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">CrossOrigin注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.6.4.</span> <span class="nav-text">全局配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Java%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.6.4.1.</span> <span class="nav-text">Java配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.6.4.2.</span> <span class="nav-text">XML配置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CORS%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.1.6.5.</span> <span class="nav-text">CORS过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E5%AE%89%E5%85%A8"><span class="nav-number">1.1.7.</span> <span class="nav-text">Web安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%BC%93%E5%AD%98"><span class="nav-number">1.1.8.</span> <span class="nav-text">HTTP缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheControl"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">CacheControl</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.1.8.2.</span> <span class="nav-text">控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">1.1.8.3.</span> <span class="nav-text">静态资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ETag%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">1.1.8.4.</span> <span class="nav-text">ETag过滤器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#View%E6%8A%80%E6%9C%AF"><span class="nav-number">1.1.9.</span> <span class="nav-text">View技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Thymeleaf"><span class="nav-number">1.1.9.1.</span> <span class="nav-text">Thymeleaf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FreeMarker"><span class="nav-number">1.1.9.2.</span> <span class="nav-text">FreeMarker</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.9.2.1.</span> <span class="nav-text">View配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FreeMarker%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.9.2.2.</span> <span class="nav-text">FreeMarker配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86"><span class="nav-number">1.1.9.2.3.</span> <span class="nav-text">表单处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%AE%8F"><span class="nav-number">1.1.9.2.3.1.</span> <span class="nav-text">绑定宏</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95Binding"><span class="nav-number">1.1.9.2.3.2.</span> <span class="nav-text">简单Binding</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%AE%8F"><span class="nav-number">1.1.9.2.3.3.</span> <span class="nav-text">输入宏</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTML%E8%BD%AC%E4%B9%89"><span class="nav-number">1.1.9.2.3.4.</span> <span class="nav-text">HTML转义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Groovy%E6%A0%87%E8%AE%B0"><span class="nav-number">1.1.9.3.</span> <span class="nav-text">Groovy标记</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Configuration"><span class="nav-number">1.1.9.3.1.</span> <span class="nav-text">Configuration</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.1.9.3.2.</span> <span class="nav-text">示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.4.</span> <span class="nav-text">脚本视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E6%B1%82"><span class="nav-number">1.1.9.4.1.</span> <span class="nav-text">需求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.1.9.4.2.</span> <span class="nav-text">脚本模板</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSP%E5%92%8CJSTL"><span class="nav-number">1.1.9.5.</span> <span class="nav-text">JSP和JSTL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#View%E8%A7%A3%E6%9E%90%E5%99%A8-1"><span class="nav-number">1.1.9.5.1.</span> <span class="nav-text">View解析器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSPs%E4%B8%8EJSTL"><span class="nav-number">1.1.9.5.2.</span> <span class="nav-text">JSPs与JSTL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring%E7%9A%84JSP%E6%A0%87%E7%AD%BE%E5%BA%93"><span class="nav-number">1.1.9.5.3.</span> <span class="nav-text">Spring的JSP标签库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring%E7%9A%84%E8%A1%A8%E5%8D%95%E6%A0%87%E7%AD%BE%E5%BA%93"><span class="nav-number">1.1.9.5.4.</span> <span class="nav-text">Spring的表单标签库</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Configuration-1"><span class="nav-number">1.1.9.5.4.1.</span> <span class="nav-text">Configuration</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A8%E6%A0%BC%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.2.</span> <span class="nav-text">表格标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.3.</span> <span class="nav-text">输入标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%8D%E9%80%89%E6%A1%86%E6%A0%87%E8%AE%B0"><span class="nav-number">1.1.9.5.4.4.</span> <span class="nav-text">复选框标记</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%8D%E9%80%89%E6%A1%86Tag"><span class="nav-number">1.1.9.5.4.5.</span> <span class="nav-text">复选框Tag</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#radiobutton%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.6.</span> <span class="nav-text">radiobutton标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#radiobuttons%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.7.</span> <span class="nav-text">radiobuttons标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.8.</span> <span class="nav-text">密码标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#select%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.9.</span> <span class="nav-text">select标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E6%A0%87%E8%AE%B0"><span class="nav-number">1.1.9.5.4.10.</span> <span class="nav-text">选项标记</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%80%89%E9%A1%B9%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.11.</span> <span class="nav-text">选项标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#textarea%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.12.</span> <span class="nav-text">textarea标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.13.</span> <span class="nav-text">隐藏的标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.14.</span> <span class="nav-text">错误标签</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTTP%E6%96%B9%E6%B3%95%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.1.9.5.4.15.</span> <span class="nav-text">HTTP方法转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HTML5%E6%A0%87%E7%AD%BE"><span class="nav-number">1.1.9.5.4.16.</span> <span class="nav-text">HTML5标签</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%93%B7%E7%A0%96"><span class="nav-number">1.1.9.6.</span> <span class="nav-text">瓷砖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.9.6.1.</span> <span class="nav-text">依赖关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Configuration-2"><span class="nav-number">1.1.9.6.2.</span> <span class="nav-text">Configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#UrlBasedViewResolver"><span class="nav-number">1.1.9.6.2.1.</span> <span class="nav-text">UrlBasedViewResolver</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ResourceBundleViewResolver"><span class="nav-number">1.1.9.6.2.2.</span> <span class="nav-text">ResourceBundleViewResolver</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#SimpleSpringPreparerFactory%E5%92%8CSpringBeanPreparerFactory"><span class="nav-number">1.1.9.6.2.3.</span> <span class="nav-text">SimpleSpringPreparerFactory和SpringBeanPreparerFactory</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RSS%E5%92%8CAtom"><span class="nav-number">1.1.9.7.</span> <span class="nav-text">RSS和Atom</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PDF%E5%92%8CExcel"><span class="nav-number">1.1.9.8.</span> <span class="nav-text">PDF和Excel</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E6%A1%A3%E8%A7%86%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="nav-number">1.1.9.8.1.</span> <span class="nav-text">文档视图简介</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#PDF%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.8.2.</span> <span class="nav-text">PDF视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Excel%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.8.3.</span> <span class="nav-text">Excel视图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jackson"><span class="nav-number">1.1.9.9.</span> <span class="nav-text">Jackson</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EJackson%E7%9A%84JSON%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.9.1.</span> <span class="nav-text">基于Jackson的JSON视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EJackson%E7%9A%84XML%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.9.2.</span> <span class="nav-text">基于Jackson的XML视图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML%E7%BC%96%E7%BB%84"><span class="nav-number">1.1.9.10.</span> <span class="nav-text">XML编组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XSLT%E8%A7%86%E5%9B%BE"><span class="nav-number">1.1.9.11.</span> <span class="nav-text">XSLT视图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Beans"><span class="nav-number">1.1.9.11.1.</span> <span class="nav-text">Beans</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8-1"><span class="nav-number">1.1.9.11.2.</span> <span class="nav-text">控制器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E5%9E%8B"><span class="nav-number">1.1.9.11.3.</span> <span class="nav-text">转型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.10.</span> <span class="nav-text">MVC配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8MVC%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">启用MVC配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC%E9%85%8D%E7%BD%AEAPI"><span class="nav-number">1.1.10.2.</span> <span class="nav-text">MVC配置API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-1"><span class="nav-number">1.1.10.3.</span> <span class="nav-text">类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">1.1.10.4.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">1.1.10.5.</span> <span class="nav-text">拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.10.6.</span> <span class="nav-text">内容类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="nav-number">1.1.10.7.</span> <span class="nav-text">消息转换器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.1.10.8.</span> <span class="nav-text">View控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#View%E8%A7%A3%E6%9E%90%E5%99%A8-2"><span class="nav-number">1.1.10.9.</span> <span class="nav-text">View解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90-1"><span class="nav-number">1.1.10.10.</span> <span class="nav-text">静态资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4Servlet"><span class="nav-number">1.1.10.11.</span> <span class="nav-text">默认Servlet</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D"><span class="nav-number">1.1.10.12.</span> <span class="nav-text">路径匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7Java%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.10.13.</span> <span class="nav-text">高级Java配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7XML%E9%85%8D%E7%BD%AE"><span class="nav-number">1.1.10.14.</span> <span class="nav-text">高级XML配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-2"><span class="nav-number">1.1.11.</span> <span class="nav-text">HTTP&#x2F;2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REST-Clients"><span class="nav-number">1.2.</span> <span class="nav-text">REST-Clients</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RestTemplate"><span class="nav-number">1.2.1.</span> <span class="nav-text">RestTemplate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">Web客户端</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">1.3.</span> <span class="nav-text">测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebSockets"><span class="nav-number">1.4.</span> <span class="nav-text">WebSockets</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket-%E7%AE%80%E4%BB%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">WebSocket 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E4%B8%8EWebSocket"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">HTTP与WebSocket</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8WebSockets"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">何时使用WebSockets</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocketAPI"><span class="nav-number">1.4.2.</span> <span class="nav-text">WebSocketAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocketHandler"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">WebSocketHandler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket%E4%BF%A1%E5%8F%B7%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">WebSocket信号交换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">部署</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8Configuration"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">服务器Configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%81%E8%AE%B8Origins"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">允许Origins</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SockJS%E5%90%8E%E5%A4%87"><span class="nav-number">1.4.3.</span> <span class="nav-text">SockJS后备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8SockJS"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">启用SockJS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IE8%E5%92%8C9"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">IE8和9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">心跳</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Client%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">Client断开连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SockJS%E5%92%8CCORS"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">SockJS和CORS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SockJsClient"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">SockJsClient</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#STOMP"><span class="nav-number">1.4.4.</span> <span class="nav-text">STOMP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8STOMP"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">启用STOMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">WebSocket服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%B5%81"><span class="nav-number">1.4.4.5.</span> <span class="nav-text">消息流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8-1"><span class="nav-number">1.4.4.6.</span> <span class="nav-text">带注解的控制器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MessageMapping%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.4.6.1.</span> <span class="nav-text">MessageMapping注解</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95Arguments"><span class="nav-number">1.4.4.6.1.1.</span> <span class="nav-text">支持的方法Arguments</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Return%E5%80%BC-1"><span class="nav-number">1.4.4.6.1.2.</span> <span class="nav-text">Return值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SubscribeMapping%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.4.6.2.</span> <span class="nav-text">SubscribeMapping注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MessageExceptionHandler%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.4.4.6.3.</span> <span class="nav-text">MessageExceptionHandler注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">1.4.4.7.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84Broker"><span class="nav-number">1.4.4.8.</span> <span class="nav-text">简单的Broker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E9%83%A8Broker"><span class="nav-number">1.4.4.9.</span> <span class="nav-text">外部Broker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Broker"><span class="nav-number">1.4.4.10.</span> <span class="nav-text">连接到Broker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%82%B9%E4%BD%9C%E4%B8%BA%E5%88%86%E9%9A%94%E7%AC%A6"><span class="nav-number">1.4.4.11.</span> <span class="nav-text">点作为分隔符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A4%E8%AF%81"><span class="nav-number">1.4.4.12.</span> <span class="nav-text">认证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A4%E7%89%8C%E8%AE%A4%E8%AF%81"><span class="nav-number">1.4.4.13.</span> <span class="nav-text">令牌认证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%9B%AE%E7%9A%84%E5%9C%B0"><span class="nav-number">1.4.4.14.</span> <span class="nav-text">用户目的地</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E8%AE%A2%E5%8D%95"><span class="nav-number">1.4.4.15.</span> <span class="nav-text">消息的订单</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Events"><span class="nav-number">1.4.4.16.</span> <span class="nav-text">Events</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E5%87%BB-1"><span class="nav-number">1.4.4.17.</span> <span class="nav-text">截击</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STOMP-Client"><span class="nav-number">1.4.4.18.</span> <span class="nav-text">STOMP-Client</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WebSocket%E8%8C%83%E5%9B%B4"><span class="nav-number">1.4.4.19.</span> <span class="nav-text">WebSocket范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">1.4.4.20.</span> <span class="nav-text">性能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7"><span class="nav-number">1.4.4.21.</span> <span class="nav-text">监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="nav-number">1.4.4.22.</span> <span class="nav-text">测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96Web%E6%A1%86%E6%9E%B6"><span class="nav-number">1.5.</span> <span class="nav-text">其他Web框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Common%E9%85%8D%E7%BD%AE"><span class="nav-number">1.5.1.</span> <span class="nav-text">Common配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSF"><span class="nav-number">1.5.2.</span> <span class="nav-text">JSF</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringBeanResolver"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">SpringBeanResolver</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8FacesContextUtils"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">使用FacesContextUtils</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ApacheStruts-2-x"><span class="nav-number">1.5.3.</span> <span class="nav-text">ApacheStruts 2.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%82%E6%AF%AF5-x"><span class="nav-number">1.5.4.</span> <span class="nav-text">挂毯5.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-number">1.5.5.</span> <span class="nav-text">更多资源</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-Servlet-Stack%E4%B8%8A%E7%9A%84Web/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-Servlet-Stack上的Web/";
    this.page.title = "SpringFramework官方文档翻译-Servlet Stack上的Web";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
