<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="测试测试是企业软件开发不可或缺的一部分。本章重点介绍 IoC 原则为单元测试添加的 value 以及 Spring Framework 对整合测试的支持的好处。 (对企业中的测试进行全面处理超出了本次参考的范围 manual.)">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringFramework官方文档翻译-测试">
<meta property="og:url" content="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="测试测试是企业软件开发不可或缺的一部分。本章重点介绍 IoC 原则为单元测试添加的 value 以及 Spring Framework 对整合测试的支持的好处。 (对企业中的测试进行全面处理超出了本次参考的范围 manual.)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-25T00:25:31.000Z">
<meta property="article:modified_time" content="2020-09-15T00:21:35.582Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringFramework">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringFramework官方文档翻译-测试 | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringFramework官方文档翻译-测试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-25 08:25:31" itemprop="dateCreated datePublished" datetime="2020-08-25T08:25:31+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-15 08:21:35" itemprop="dateModified" datetime="2020-09-15T08:21:35+08:00">2020-09-15</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/25/SpringFramework官方文档翻译-测试/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试是企业软件开发不可或缺的一部分。本章重点介绍 IoC 原则为<a href="#单元测试">单元测试</a>添加的 value 以及 Spring Framework 对<a href="#集成测试">整合测试</a>的支持的好处。 (对企业中的测试进行全面处理超出了本次参考的范围 manual.)</p>
<a id="more"></a>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>与传统的 Java EE 开发相比，依赖注入应该使 code 对容器的依赖性降低。构成 application 的 POJO 应该在 JUnit 或 TestNG 测试中可测试，使用<code>new</code> operator 实例化 object，不使用 Spring 或任何其他容器。您可以使用<a href="#MockObjects">mock objects</a>(与其他有价值的测试技术结合使用)来单独测试您的 code。如果您遵循 Spring 的 architecture 建议，那么代码库的干净分层和组件化便于单元测试。例如，您可以通过存根或 mocking DAO 或 repository 接口来测试服务层 objects，而无需在 running 单元测试时访问持久数据。</p>
<p>True 单元测试通常非常快速地运行，因为没有要设置的运行时基础结构。强调 true 单元测试作为开发方法的一部分可以提高您的工作效率。您可能不需要测试章节的这一部分来帮助您为 IoC-based applications 编写有效的单元测试。但是，对于某些单元测试场景，Spring Framework 提供了 mock objects 和测试支持 classes，本章对此进行了描述。</p>
<h3 id="MockObjects"><a href="#MockObjects" class="headerlink" title="MockObjects"></a>MockObjects</h3><p>Spring 包含许多专用于 mocking 的包：</p>
<ul>
<li><a href="#环境">环境</a></li>
<li><a href="#JNDI">JNDI</a></li>
<li><a href="#ServletAPI">Servlet API</a></li>
<li><a href="#SpringWebReactive">Spring Web Reactive</a></li>
</ul>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p><code>org.springframework.mock.env</code>包包含<code>Environment</code>和<code>PropertySource</code>抽象的 mock implementations(参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Bean定义Profiles">Bean 定义 Profiles</a>和<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#PropertySource抽象">PropertySource 抽象</a>)。 <code>MockEnvironment</code>和<code>MockPropertySource</code>对于 code 开发 out-of-container 测试很有用，因为 code 取决于 environment-specific properties。</p>
<h4 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h4><p><code>org.springframework.mock.jndi</code>包中包含 JNDI SPI 的 实现，您可以使用它为测试套件或 stand-alone applications 设置简单的 JNDI 环境。例如，如果 JDBC <code>DataSource</code>实例在 test code 中绑定到与 Java EE 容器中相同的 JNDI 名称，则可以在测试方案中重复使用 application code 和 configuration 而无需修改。</p>
<h4 id="ServletAPI"><a href="#ServletAPI" class="headerlink" title="ServletAPI"></a>ServletAPI</h4><p><code>org.springframework.mock.web</code>包中包含一组全面的 Servlet API mock objects，可用于测试 web 上下文，控制器和过滤器。这些 mock objects 的目标是使用 Spring 的 Web MVC framework，并且通常比动态 mock objects(例如<a target="_blank" rel="noopener" href="http://www.easymock.org/">EasyMock</a>)或替代 Servlet API mock objects(例如<a target="_blank" rel="noopener" href="http://www.mockobjects.com/">MockObjects</a>)更方便使用。</p>
<blockquote>
<p>从 Spring Framework 5.0 开始，<code>org.springframework.mock.web</code>中的 mock objects 基于 Servlet 4.0 API。</p>
</blockquote>
<p>Spring MVC Test framework 构建在 mock Servlet API objects 之上，为 Spring MVC 提供 integration 测试 framework。见<a href="#SpringMVC测试框架">Spring MVC Test Framework</a>。</p>
<h4 id="SpringWebReactive"><a href="#SpringWebReactive" class="headerlink" title="SpringWebReactive"></a>SpringWebReactive</h4><p><code>org.springframework.mock.http.server.reactive</code>包中包含_m mplemplements of <code>ServerHttpRequest</code>和<code>ServerHttpResponse</code>，用于 WebFlux applications。 <code>org.springframework.mock.web.server</code>包中包含 mock <code>ServerWebExchange</code>，它取决于那些 mock 请求和响应 objects。</p>
<p><code>MockServerHttpRequest</code>和<code>MockServerHttpResponse</code>都从与 server-specific __mplementations 相同的抽象 base classes 扩展，并与它们共享行为。对于 example，mock 请求一旦创建就是不可变的，但您可以使用<code>ServerHttpRequest</code>中的<code>mutate()</code>方法创建修改后的实例。</p>
<p>在 mock 响应的 order 中正确实现 write contract 和 return 一个写完成句柄(即<code>Mono&lt;Void&gt;</code>)，它默认使用<code>Flux</code>和<code>cache().then()</code>，它缓冲数据并使其可用于测试中的断言。 Applications 可以设置自定义写入 function(对于 example，以测试无限流)。</p>
<p><a href="#WebTestClient">WebTestClient</a>构建在 mock 请求和响应之上，以支持在没有 HTTP 服务器的情况下测试 WebFlux applications。 client 也可用于 running 服务器的 end-to-end 测试。</p>
<h3 id="单元测试支持Classes"><a href="#单元测试支持Classes" class="headerlink" title="单元测试支持Classes"></a>单元测试支持Classes</h3><p>Spring 包含许多可以帮助进行单元测试的 classes。它们分为两类：</p>
<ul>
<li><a href="#一般测试实用程序">一般测试实用程序</a></li>
<li><a href="#SpringMVC测试实用程序">Spring MVC 测试实用程序</a></li>
</ul>
<h4 id="一般测试实用程序"><a href="#一般测试实用程序" class="headerlink" title="一般测试实用程序"></a>一般测试实用程序</h4><p><code>org.springframework.test.util</code>包中包含几个用于单元和 integration 测试的通用实用程序。</p>
<p><code>ReflectionTestUtils</code>是 reflection-based 实用程序方法的集合。您可以在测试需要更改常量的 value，设置非<code>public</code>字段，调用非<code>public</code> setter 方法，或在测试 application code 时调用非<code>public</code> configuration 或生命周期回调方法时使用这些方法用例如下：</p>
<ul>
<li>ORM 框架(例如 JPA 和 Hibernate)容忍<code>private</code>或<code>protected</code>字段访问，而不是域实体中 properties 的<code>public</code> setter 方法。</li>
<li>Spring 支持 annotations(例如<code>@Autowired</code>，<code>@Inject</code>和<code>@Resource</code>)，它们为<code>private</code>或<code>protected</code>字段，setter 方法和 configuration 方法提供依赖注入。</li>
<li>使用_an和<code>@PreDestroy</code>这样的 annotations 进行生命周期回调方法。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/util/AopTestUtils.html">AopTestUtils</a>是 AOP-related 实用程序方法的集合。您可以使用这些方法获取隐藏在一个或多个 Spring 代理后面的基础目标 object 的 reference。例如，如果您使用 library(例如 EasyMock 或 Mockito)将 bean 配置为动态 mock，并且 mock 包含在 Spring 代理中，则可能需要直接访问底层 mock 以配置对它的期望并执行验证。对于 Spring 的核心 AOP 实用程序，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/support/AopUtils.html">AopUtils</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/framework/AopProxyUtils.html">AopProxyUtils</a>。</p>
<h4 id="SpringMVC测试实用程序"><a href="#SpringMVC测试实用程序" class="headerlink" title="SpringMVC测试实用程序"></a>SpringMVC测试实用程序</h4><p><code>org.springframework.test.web</code>包中包含<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/web/ModelAndViewAssert.html">ModelAndViewAssert</a>，您可以将其与 JUnit，TestNG 或任何其他测试 framework 结合使用，以进行处理 Spring MVC <code>ModelAndView</code> objects 的单元测试。</p>
<blockquote>
<p>单元测试 Spring MVC 控制器 要将 Spring MVC <code>Controller</code> classes 作为 POJO 进行单元测试，请在 Spring 的<a href="#ServletAPI">Servlet API 模拟</a>中使用<code>ModelAndViewAssert</code>与<code>MockHttpServletRequest</code>，<code>MockHttpSession</code>等结合使用。要对 Spring MVC 和 REST <code>Controller</code> classes 与 Spring MVC 的<code>WebApplicationContext</code> configuration 一起进行彻底的 integration 测试，请改用<a href="#SpringMVC测试框架">Spring MVC Test Framework</a>。</p>
</blockquote>
<h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>本节(本章的大部分内容)涵盖了 Spring applications 的 integration 测试。它包括以下主题：</p>
<ul>
<li><a href="#概述">概观</a></li>
<li><a href="#集成测试的目标">Integration 测试的目标</a></li>
<li><a href="#JDBC测试支持">JDBC 测试支持</a></li>
<li><a href="#Annotations">Annotations</a></li>
<li><a href="#SpringTestContext框架">Spring TestContext Framework</a></li>
<li><a href="#SpringMVC测试框架">Spring MVC Test Framework</a></li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>能够执行某些 integration 测试非常重要，无需部署到 application 服务器或连接到其他企业基础结构。这样做可以让您测试以下内容：</p>
<ul>
<li>Spring IoC 容器上下文的正确连线。</li>
<li>使用 JDBC 或 ORM 工具进行数据访问。这可以包括诸如 SQL statements，Hibernate 查询，JPA 实体映射等的正确性。</li>
</ul>
<p>Spring Framework 为<code>spring-test</code>模块中的 integration 测试提供 first-class 支持。实际的 JAR 文件的 name 可能包含 release version，也可能是 long <code>org.springframework.test</code>形式，具体取决于你从哪里得到它(参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/">关于依赖管理的部分</a>的解释)。这个 library 包含<code>org.springframework.test</code>包，其中包含用于 Spring 容器的 integration 测试的有价值的 classes。此测试不依赖于 application 服务器或其他部署环境。这些测试比单元测试慢得多，但比依赖部署到 application 服务器的等效 Selenium 测试或 remote 测试要快得多。</p>
<p>在 Spring 2.5 及更高版本中，单元和 integration 测试支持以 annotation-driven <a href="#SpringTestContext框架">Spring TestContext Framework</a>的形式提供。 TestContext framework 与所使用的实际测试 framework 无关，它允许在各种环境中检测测试，包括 JUnit，TestNG 等。</p>
<h3 id="集成测试的目标"><a href="#集成测试的目标" class="headerlink" title="集成测试的目标"></a>集成测试的目标</h3><p>Spring 的集成测试支持有以下主要目标：</p>
<ul>
<li>在测试之间管理<a href="#上下文管理和缓存">Spring IoC 容器缓存</a>。</li>
<li>提供<a href="#测试fixture实例的依赖注入">测试fixture实例的依赖注入</a>。</li>
<li>提供<a href="#TransactionManagement">transaction management</a>适合整合测试。</li>
<li>提供<a href="#集成测试的支持类">Spring-specific base classes</a>，帮助开发人员编写集成测试。</li>
</ul>
<p>接下来的几节将介绍每个目标，并提供指向 implementation 和 configuration 详细信息的链接。</p>
<h4 id="上下文管理和缓存"><a href="#上下文管理和缓存" class="headerlink" title="上下文管理和缓存"></a>上下文管理和缓存</h4><p>Spring TestContext Framework 提供 Spring <code>ApplicationContext</code>实例和<code>WebApplicationContext</code>实例的一致 loading 以及这些上下文的缓存。支持缓存加载的上下文非常重要，因为启动 time 可能会成为一个问题 - 不是因为 Spring 本身的开销，而是因为 Spring 容器实例化的 objects 需要 time 来实例化。例如，具有 50 到 100 个 Hibernate 映射 files 的项目可能需要 10 到 20 秒来加载映射 files，并且在每个测试夹具中运行每个测试之前产生该成本会导致整体测试运行速度变慢，从而降低开发人员的工作效率。</p>
<p>Test classes 通常声明 XML 的资源位置的 array 或 Groovy configuration 元数据 - 通常在 classpath 中 - 或者用于配置 application 的带注释的 class 的 array。这些位置或 classes 与<code>web.xml</code>或 production 部署的其他 configuration files 中指定的位置或 classes 相同或相似。</p>
<p>默认情况下，一旦加载，配置的<code>ApplicationContext</code>将被重用于每个测试。因此，每个测试套件仅产生一次设置成本，并且后续测试执行要快得多。在此 context 中，术语“测试套件”表示在同一 JVM 中运行所有测试 - 例如，对于给定项目或模块，所有测试都来自 Ant，Maven 或 Gradle build。在不太可能的情况下，测试会破坏 application context 并需要重新加载(例如，通过修改 bean 定义或 application object 的 state)，TestContext framework 可以配置为重新加载 configuration 并重建 application context，然后再执行下一个测试。</p>
<p>请参阅带有 TestContext framework 的<a href="#Context管理">Context Management</a>和<a href="#Context缓存">Context 缓存</a>。</p>
<h4 id="测试fixture实例的依赖注入"><a href="#测试fixture实例的依赖注入" class="headerlink" title="测试fixture实例的依赖注入"></a>测试fixture实例的依赖注入</h4><p>当 TestContext framework 加载 application context 时，它可以选择使用依赖注入来配置 test classes 的实例。这提供了一种方便的机制，通过使用 application context 中的预配置 beans 来设置测试装置。这里的一个强大好处是您可以在各种测试场景中重用 application 上下文(例如，用于配置 Spring-managed object 图，transactional proxies，<code>DataSource</code>实例等)，从而避免了为单个测试用例复制复杂测试夹具设置的需要。</p>
<p>作为一个例子，考虑一个我们有一个 class(<code>HibernateTitleRepository</code>)实现<code>Title</code>域实体的数据访问逻辑的场景。我们想编写测试以下方面的 integration 测试：</p>
<ul>
<li>Spring configuration：基本上，与<code>HibernateTitleRepository</code> bean 的 configuration 相关的所有内容是否正确并且存在？</li>
<li>Hibernate 映射文件 configuration：是否所有映射都正确并且是否正确设置了 lazy-loading 设置？</li>
<li><code>HibernateTitleRepository</code>的逻辑：此 class 的已配置实例是否按预期执行？</li>
</ul>
<p>请参阅使用<a href="#测试fixture的依赖注入">TestContext framework</a>依赖注入测试夹具。</p>
<h4 id="TransactionManagement"><a href="#TransactionManagement" class="headerlink" title="TransactionManagement"></a>TransactionManagement</h4><p>访问真实数据库的测试中的一个常见问题是它们对持久性 store 的 state 的影响。即使您使用开发数据库，对 state 的更改也可能会影响将来的测试。此外，许多操作(例如插入或修改持久数据)无法在 transaction 之外执行(或验证)。</p>
<p>TestContext framework 解决了这个问题。默认情况下，framework 为每个测试创建并回滚 transaction。您可以编写可以假设存在 transaction 的 code。如果在测试中调用事务代理的 objects，则根据其配置的 transactional 语义，它们的行为正确。此外，如果测试方法在为测试管理的 transaction 中运行时删除所选表的内容，则 transaction 默认回滚，并且数据库在执行测试之前返回其 state。通过使用测试的 application context 中定义的<code>PlatformTransactionManager</code> bean 为测试提供 Transactional 支持。</p>
<p>如果您希望 transaction 提交(异常，但在您希望特定测试填充或修改数据库时偶尔有用)，您可以通过使用<a href="#Annotations">@Commit</a> annotation 告诉 TestContext framework 使 transaction 提交而不是回滚。</p>
<p>请参阅<a href="#事务管理">TestContext framework</a>的transaction management。</p>
<h4 id="集成测试的支持类"><a href="#集成测试的支持类" class="headerlink" title="集成测试的支持类"></a>集成测试的支持类</h4><p>Spring TestContext Framework 提供了几个<code>abstract</code>支持 classes，简化了 integration 测试的编写。这些基本测试 classes 为测试 framework 提供了 well-defined 钩子以及方便的实例变量和方法，使您可以访问：</p>
<ul>
<li><code>ApplicationContext</code>，用于执行显式 bean 查找或测试 context 的 state 作为整体。</li>
<li>一个<code>JdbcTemplate</code>，用于执行 SQL statements 来查询数据库。您可以在执行 database-related application code 之前和之后使用此类查询来确认数据库 state，并且 Spring 确保此类查询在与 application code 相同的 transaction 范围内运行。与 ORM 工具结合使用时，请务必避免使用<a href="#AvoidFalse">误报</a>。</li>
</ul>
<p>此外，您可能希望使用特定于项目的实例变量和方法创建自己的自定义 application-wide 超类。</p>
<p>请参阅<a href="#TestContext框架支持Classes">TestContext framework</a>的支持 classes。</p>
<h3 id="JDBC测试支持"><a href="#JDBC测试支持" class="headerlink" title="JDBC测试支持"></a>JDBC测试支持</h3><p><code>org.springframework.test.jdbc</code>包中包含<code>JdbcTestUtils</code>，它是 JDBC-related 实用程序函数的集合，旨在简化标准数据库测试方案。具体来说，<code>JdbcTestUtils</code>提供以下静态实用程序方法。</p>
<ul>
<li><code>countRowsInTable(..)</code>：计算给定 table 中的行数。</li>
<li><code>countRowsInTableWhere(..)</code>：使用提供的<code>WHERE</code>子句计算给定 table 中的行数。</li>
<li><code>deleteFromTables(..)</code>：删除指定表中的所有行。</li>
<li><code>deleteFromTableWhere(..)</code>：使用提供的<code>WHERE</code>子句删除给定 table 中的行。</li>
<li><code>dropTables(..)</code>：删除指定的表。</li>
</ul>
<blockquote>
<p><a href="#Junit4支持Classes">AbstractTransactionalJUnit4SpringContextTests</a>和<a href="#TestNG支持Classes">AbstractTransactionalTestNGSpringContextTests</a>提供了方便的方法，委托<code>JdbcTestUtils</code>中的上述方法。</p>
</blockquote>
<p><code>spring-jdbc</code>模块支持配置和启动嵌入式数据库，您可以在与数据库交互的 integration 测试中使用它。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-数据访问/#嵌入式数据库支持">嵌入式数据库支持</a>和<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-数据访问/#使用嵌入式数据库测试数据访问逻辑">使用嵌入式数据库测试数据访问逻辑</a>。</p>
<h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h3><p>本节介绍了在测试 Spring applications 时可以使用的注释。它包括以下主题：</p>
<ul>
<li><a href="#SpringTestingAnnotations">Spring Testing Annotations</a></li>
<li><a href="#标准Annotation支持">标准 Annotation 支持</a></li>
<li><a href="#SpringJUnit4测试注解">Spring JUnit 4 测试注释</a></li>
<li><a href="#SpringJUnitJupiterTestingAnnotations">Spring JUnit Jupiter Testing Annotations</a></li>
<li><a href="#Meta-Annotation支持测试">Meta-Annotation 支持测试</a></li>
</ul>
<h4 id="SpringTestingAnnotations"><a href="#SpringTestingAnnotations" class="headerlink" title="SpringTestingAnnotations"></a>SpringTestingAnnotations</h4><p>Spring Framework 提供了以下一组 Spring-specific注解，您可以在单元和集成测试中结合 TestContext framework 使用它们。有关详细信息，请参阅相应的 javadoc，包括默认属性值，属性别名和其他详细信息。</p>
<p>Spring 的测试注解包括以下内容：</p>
<ul>
<li><a href="#BootstrapWith注解">@BootstrapWith</a></li>
<li><a href="#ContextConfiguration注解">@ContextConfiguration</a></li>
<li><a href="#WebAppConfiguration注解">@WebAppConfiguration</a></li>
<li><a href="#ContextHierarchy注解">@ContextHierarchy</a></li>
<li><a href="#ActiveProfiles注解">@ActiveProfiles</a></li>
<li><a href="#TestPropertySource注解">@TestPropertySource</a></li>
<li><a href="#DirtiesContext注解">@DirtiesContext</a></li>
<li><a href="#TestExecutionListeners注解">@TestExecutionListeners</a></li>
<li><a href="#Commit注解">@Commit</a></li>
<li><a href="#Rollback注解">@Rollback</a></li>
<li><a href="#BeforeTransaction注解">@BeforeTransaction</a></li>
<li><a href="#AfterTransaction注解">@AfterTransaction</a></li>
<li><a href="#Sql注解">@Sql</a></li>
<li><a href="#SqlConfig注解">@SqlConfig</a></li>
<li><a href="#SqlGroup注解">@SqlGroup</a></li>
</ul>
<h5 id="BootstrapWith注解"><a href="#BootstrapWith注解" class="headerlink" title="BootstrapWith注解"></a>BootstrapWith注解</h5><p><code>@BootstrapWith</code>是一个 class-level 注释，可用于配置 Spring TestContext Framework 的引导方式。具体来说，您可以使用<code>@BootstrapWith</code>指定自定义<code>TestContextBootstrapper</code>。有关详细信息，请参阅<a href="#引导TestContextFramework">引导 TestContext framework</a>部分。</p>
<h5 id="ContextConfiguration注解"><a href="#ContextConfiguration注解" class="headerlink" title="ContextConfiguration注解"></a>ContextConfiguration注解</h5><p><code>@ContextConfiguration</code>定义 class-level 元数据，用于确定如何加载和配置<code>ApplicationContext</code> for integration 测试。具体来说，<code>@ContextConfiguration</code>声明 application context 资源<code>locations</code>或用于加载 context 的带注释的<code>classes</code>。</p>
<p>资源位置通常是位于 classpath 中的 XML configuration files 或 Groovy 脚本，而带注释的 classes 通常是<code>@Configuration</code> classes。但是，资源位置也可以引用文件系统中的 files 和脚本，带注释的 classes 可以是 component classes，依此类推。</p>
<p>以下 example 显示引用 XML 文件的<code>@ContextConfiguration</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(&quot;/test-config.xml&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlApplicationContextTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>参考 XML 文件。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 显示引用 class 的<code>@ContextConfiguration</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = TestConfig.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClassApplicationContextTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>参考 class。</td>
</tr>
</tbody>
</table>
</div>
<p>作为声明资源位置或带注释的 classes 的替代或补充，您可以使用<code>@ContextConfiguration</code>来声明<code>ApplicationContextInitializer</code> classes。以下 example 显示了这样的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(initializers = CustomContextIntializer.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextInitializerTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明初始化程序 class。</td>
</tr>
</tbody>
</table>
</div>
<p>您也可以选择使用<code>@ContextConfiguration</code>来声明<code>ContextLoader</code>策略。但请注意，您通常不需要显式配置加载器，因为默认加载器支持<code>initializers</code>和资源<code>locations</code>或带注释的<code>classes</code>。</p>
<p>以下 example 使用位置和加载器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(locations = &quot;/test-context.xml&quot;, loader = CustomContextLoader.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomLoaderXmlApplicationContextTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>配置位置和自定义加载程序。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>@ContextConfiguration</code>支持继承资源位置或 configuration classes 以及超类声明的 context 初始值设定项。</p>
</blockquote>
<p>有关详细信息，请参阅<a href="#Context管理">Context Management</a>和<code>@ContextConfiguration</code> javadocs。</p>
<h5 id="WebAppConfiguration注解"><a href="#WebAppConfiguration注解" class="headerlink" title="WebAppConfiguration注解"></a>WebAppConfiguration注解</h5><p><code>@WebAppConfiguration</code>是一个 class-level annotation，可以用来声明为 integration 测试加载的<code>ApplicationContext</code>应该是<code>WebApplicationContext</code>。仅仅在测试 class 上存在<code>@WebAppConfiguration</code>就可以确保为测试加载<code>WebApplicationContext</code>，使用<code>&quot;file:src/main/webapp&quot;</code>的默认 value 作为 web application 根目录的路径(即资源库路径)。在幕后使用资源基本路径来创建<code>MockServletContext</code>，其用作测试<code>WebApplicationContext</code>的<code>ServletContext</code>。</p>
<p>以下 example 显示了如何使用<code>@WebAppConfiguration</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>@WebAppConfiguration</code> annotation。</td>
</tr>
</tbody>
</table>
</div>
<p>要覆盖缺省值，可以使用隐式<code>value</code>属性指定不同的基本资源路径。支持<code>classpath:</code>和<code>file:</code>资源前缀。如果未提供资源前缀，则假定该路径是文件系统资源。以下 example 显示了如何指定 classpath 资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 classpath 资源。</td>
</tr>
</tbody>
</table>
</div>
<p>请注意，<code>@WebAppConfiguration</code>必须与<code>@ContextConfiguration</code>结合使用，可以在单个测试 class 中，也可以在 test class 层次结构中使用。有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a> javadoc。</p>
<h5 id="ContextHierarchy注解"><a href="#ContextHierarchy注解" class="headerlink" title="ContextHierarchy注解"></a>ContextHierarchy注解</h5><p><code>@ContextHierarchy</code>是一个 class-level annotation，用于为 integration 测试定义<code>ApplicationContext</code>实例的层次结构。 <code>@ContextHierarchy</code>应该使用一个或多个<code>@ContextConfiguration</code>实例的列表声明，每个实例在 context 层次结构中定义 level。以下示例演示了在单个测试 class 中使用<code>@ContextHierarchy</code>(<code>@ContextHierarchy</code>也可以在测试 class 层次结构中使用)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(&quot;/parent-config.xml&quot;),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(&quot;/child-config.xml&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextHierarchyTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(classes = AppConfig.class),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(classes = WebConfig.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果需要合并或覆盖 test class 层次结构中 context 层次结构的给定 level 的 configuration，则必须通过向 class 层次结构中每个对应 level 的<code>@ContextConfiguration</code>中的<code>name</code>属性提供相同的 value 来显式 name 该 level。有关更多示例，请参阅<a href="#Context层次结构">Context Hierarchies</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/ContextHierarchy.html">@ContextHierarchy</a> javadoc。</p>
<h5 id="ActiveProfiles注解"><a href="#ActiveProfiles注解" class="headerlink" title="ActiveProfiles注解"></a>ActiveProfiles注解</h5><p><code>@ActiveProfiles</code>是一个 class-level annotation，用于声明</p>
<p>以下 example 表明<code>dev</code> profile 应该是 active：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeveloperTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指示<code>dev</code> profile 应为 active。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 表示<code>dev</code>和<code>integration</code> profiles 都应该是 active：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&#123;&quot;dev&quot;, &quot;integration&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeveloperIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指示<code>dev</code>和<code>integration</code> profiles 应为 active。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>@ActiveProfiles</code>默认提供对继承超类声明的 active bean 定义 profiles 的支持。您还可以通过实现自定义<a href="#ActiveProfiles解析器">ActiveProfilesResolver</a>并使用<code>@ActiveProfiles</code>的<code>resolver</code>属性进行注册来以编程方式解析 active bean definition profiles。</p>
</blockquote>
<p>有关示例和更多详细信息，请参阅<a href="#使用环境配置文件进行上下文配置">Context Configuration with Environment Profiles</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfiles.html">@ActiveProfiles</a> javadoc。</p>
<h5 id="TestPropertySource注解"><a href="#TestPropertySource注解" class="headerlink" title="TestPropertySource注解"></a>TestPropertySource注解</h5><p><code>@TestPropertySource</code>是一个 class-level 注释，您可以使用它来配置 properties files 和内联 properties 的位置，以便将<code>Environment</code>添加到<code>Environment</code>的<code>PropertySources</code>中，以便为 integration 测试加载<code>ApplicationContext</code>。</p>
<p>Test property 源的优先级高于从操作系统环境或 Java 系统 properties 加载的源以及 application 以声明方式通过<code>@PropertySource</code>或以编程方式添加的 property 源。因此，test property 源可用于有选择地覆盖 system 和 application property 源中定义的 properties。此外，内联 properties 的优先级高于从资源位置加载的 properties。</p>
<p>以下 example 演示了如何从 classpath 声明 properties 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestPropertySource(&quot;/test.properties&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从 classpath 的根目录中的<code>test.properties</code>获取 properties。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 演示了如何声明内联 properties：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123; &quot;timezone = GMT&quot;, &quot;port: 4242&quot; &#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明<code>timezone</code>和<code>port</code> properties。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="DirtiesContext注解"><a href="#DirtiesContext注解" class="headerlink" title="DirtiesContext注解"></a>DirtiesContext注解</h5><p><code>@DirtiesContext</code>表示在执行测试期间底层 Spring <code>ApplicationContext</code>已被弄脏(即，测试以某种方式修改或损坏它 - 例如，通过更改 singleton bean 的 state)并且应该关闭。当 application context 被标记为脏时，它将从测试 framework 的缓存中删除并关闭。因此，对于需要具有相同 configuration 元数据的 context 的任何后续测试，都会重建基础 Spring 容器。</p>
<p>您可以在同一 class 或 class 层次结构中使用<code>@DirtiesContext</code>作为 class-level 和 method-level annotation。在这种情况下，<code>ApplicationContext</code>在任何此类带注释的方法之前或之后以及当前测试 class 之前或之后被标记为脏，具体取决于配置的<code>methodMode</code>和<code>classMode</code>。</p>
<p>以下示例说明 context 何时会因各种 configuration 方案而变脏：</p>
<ul>
<li>在当前测试 class 之前，当 class 上的 class 模式设置为<code>BEFORE_CLASS</code>时声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = BEFORE_CLASS)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshContextTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some tests that require a new Spring container</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在当前测试 class 之前弄脏了 context。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在当前测试 class 之后，在 class 上声明 class 模式时设置为<code>AFTER_CLASS</code>(i.e.，默认为 class 模式)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextDirtyingTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some tests that result in the Spring container being dirtied</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在当前测试 class 之后弄脏了 context。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在当前测试 class 中的每个测试方法之前，当 class 上的 class 模式设置为<code>BEFORE_EACH_TEST_METHOD.</code>时声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FreshContextTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some tests that require a new Spring container</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在每个测试方法之前弄脏 context。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在当前测试 class 中的每个测试方法之后，当 class 上的 class 模式设置为<code>AFTER_EACH_TEST_METHOD.</code>时声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(classMode = AFTER_EACH_TEST_METHOD)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextDirtyingTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some tests that result in the Spring container being dirtied</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在每个测试方法之后弄脏 context。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在当前测试之前，在方法模式设置为<code>BEFORE_METHOD</code>的方法上声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext(methodMode = BEFORE_METHOD)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWhichRequiresFreshAppCtx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic that requires a new Spring container</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在当前测试方法之前弄脏 context。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>在当前测试之后，在方法模式设置为<code>AFTER_METHOD</code>(i.e.，默认方法模式)的方法上声明。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DirtiesContext</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWhichDirtiesAppCtx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic that results in the Spring container being dirtied</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在当前测试方法之后弄脏 context。</td>
</tr>
</tbody>
</table>
</div>
<p>如果在 context 配置为带<code>@ContextHierarchy</code>的 context 层次结构的一部分的测试中使用<code>@DirtiesContext</code>，则可以使用<code>hierarchyMode</code> flag 来控制 context 缓存的清除方式。默认情况下，使用详尽的算法来清除 context 缓存，不仅包括当前 level，还包括与当前测试共享祖先 context common 的所有其他 context 层次结构。驻留在 common 祖先 context 的 sub-hierarchy 中的所有<code>ApplicationContext</code>实例将从 context 缓存中删除并关闭。如果穷举算法对于特定用例而言过度，则可以指定更简单的当前 level 算法，如下面的 example 所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(&quot;/parent-config.xml&quot;),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(&quot;/child-config.xml&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTests</span> <span class="keyword">extends</span> <span class="title">BaseTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DirtiesContext(hierarchyMode = CURRENT_LEVEL)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some logic that results in the child context being dirtied</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用 current-level 算法。</td>
</tr>
</tbody>
</table>
</div>
<p>有关<code>EXHAUSTIVE</code>和<code>CURRENT_LEVEL</code>算法的更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.HierarchyMode.html">DirtiesContext.HierarchyMode</a> javadoc。</p>
<h5 id="TestExecutionListeners注解"><a href="#TestExecutionListeners注解" class="headerlink" title="TestExecutionListeners注解"></a>TestExecutionListeners注解</h5><p><code>@TestExecutionListeners</code>定义了 class-level 元数据，用于配置应该使用<code>TestContextManager</code>注册的<code>TestExecutionListener</code> __mplement。通常，<code>@TestExecutionListeners</code>与<code>@ContextConfiguration</code>一起使用。</p>
<p>以下 example 显示了如何注册两个<code>TestExecutionListener</code> implementations：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(&#123;CustomTestExecutionListener.class, AnotherTestExecutionListener.class&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomTestExecutionListenerTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>注册两个<code>TestExecutionListener</code> implementations。</td>
</tr>
</tbody>
</table>
</div>
<p>默认情况下，<code>@TestExecutionListeners</code>支持继承的 listeners。有关 example 和更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">javadoc</a>。</p>
<h5 id="Commit注解"><a href="#Commit注解" class="headerlink" title="Commit注解"></a>Commit注解</h5><p><code>@Commit</code>表示应在测试方法完成后提交 transactional 测试方法的 transaction。您可以使用<code>@Commit</code>作为<code>@Rollback(false)</code>的直接替换来更明确地传达 code 的意图。类似于<code>@Rollback</code>，<code>@Commit</code>也可以声明为 class-level 或 method-level 注释。</p>
<p>以下 example 显示了如何使用<code>@Commit</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Commit</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWithoutRollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将测试结果提交给数据库。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Rollback注解"><a href="#Rollback注解" class="headerlink" title="Rollback注解"></a>Rollback注解</h5><p><code>@Rollback</code>表示在测试方法完成后是否应回滚 transactional 测试方法的 transaction。如果是<code>true</code>，transaction 将被回滚。否则，提交 transaction(另请参见<a href="#Commit注解">@Commit</a>)。即使没有显式声明<code>@Rollback</code>，Spring TestContext Framework 中的 integration 测试的回滚默认为<code>true</code>。</p>
<p>声明为 class-level annotation 时，<code>@Rollback</code>定义 test class 层次结构中所有测试方法的默认回滚语义。当声明为 method-level annotation 时，<code>@Rollback</code>定义特定测试方法的回滚语义，可能会覆盖 class-level <code>@Rollback</code>或<code>@Commit</code>语义。</p>
<p>以下 example 导致测试方法的结果不被回滚(即，结果被提交到数据库)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Rollback(false)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWithoutRollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>不要回滚结果。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="BeforeTransaction注解"><a href="#BeforeTransaction注解" class="headerlink" title="BeforeTransaction注解"></a>BeforeTransaction注解</h5><p><code>@BeforeTransaction</code>表示在 transaction 启动之前_11方法应该是 run，对于已经使用 Spring 的<code>@Transactional</code> annotation 在 transaction 中配置为 run 的测试方法。从 Spring Framework 4.3 开始，<code>@BeforeTransaction</code>方法不需要<code>public</code>，可以在 Java 8-based 接口默认方法中声明。</p>
<p>以下 example 显示了如何使用<code>@BeforeTransaction</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BeforeTransaction</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logic to be executed before a transaction is started</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在 transaction 之前运行此方法。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="AfterTransaction注解"><a href="#AfterTransaction注解" class="headerlink" title="AfterTransaction注解"></a>AfterTransaction注解</h5><p><code>@AfterTransaction</code>表示在 transaction 结束后，对于已在 transaction 中使用 Spring 的<code>@Transactional</code> annotation 配置为 run 的测试方法，应该 run 注释<code>void</code>方法。从 Spring Framework 4.3 开始，<code>@AfterTransaction</code>方法不需要<code>public</code>，可以在 Java 8-based 接口默认方法中声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterTransaction</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// logic to be executed after a transaction has ended</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在 transaction 之后运行此方法。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Sql注解"><a href="#Sql注解" class="headerlink" title="Sql注解"></a>Sql注解</h5><p><code>@Sql</code>用于注释测试 class 或测试方法，以便在 integration 测试期间将 SQL 脚本配置为针对给定数据库运行。以下 example 显示了如何使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(&#123;&quot;/test-schema.sql&quot;, &quot;/test-user-data.sql&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that relies on the test schema and test data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>运行此测试的两个脚本。</td>
</tr>
</tbody>
</table>
</div>
<p>有关详细信息，请参阅<a href="#使用Sql注解以声明方式执行SQL脚本">使用 @Sql 以声明方式执行 SQL 脚本</a>。</p>
<h5 id="SqlConfig注解"><a href="#SqlConfig注解" class="headerlink" title="SqlConfig注解"></a>SqlConfig注解</h5><p><code>@SqlConfig</code>定义元数据，用于确定如何解析和运行使用<code>@Sql</code> annotation 配置的 SQL 脚本。以下 example 显示了如何使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(</span></span><br><span class="line"><span class="meta">    scripts = &quot;/test-user-data.sql&quot;,</span></span><br><span class="line"><span class="meta">    config = @SqlConfig(commentPrefix = &quot;`&quot;, separator = &quot;@@&quot;) (1)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that relies on the test data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在 SQL 脚本中设置 comment 前缀和分隔符。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="SqlGroup注解"><a href="#SqlGroup注解" class="headerlink" title="SqlGroup注解"></a>SqlGroup注解</h5><p><code>@SqlGroup</code>是一个容器 annotation，它聚合了几个<code>@Sql</code> 注释。您可以使用<code>@SqlGroup</code>本机声明几个嵌套的<code>@Sql</code> 注释，或者可以将它与 Java 8 对可重复注释的支持结合使用，其中<code>@Sql</code>可以在同一个 class 或方法上多次声明，隐式生成此容器 annotation。以下 example 显示了如何声明 SQL group：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SqlGroup(&#123; (1)</span></span><br><span class="line"><span class="meta">    @Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;`&quot;)),</span></span><br><span class="line"><span class="meta">    @Sql(&quot;/test-user-data.sql&quot;)</span></span><br><span class="line"><span class="meta">)</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that uses the test schema and test data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>声明一组 SQL 脚本。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="标准注解支持"><a href="#标准注解支持" class="headerlink" title="标准注解支持"></a>标准注解支持</h4><p>对于 Spring TestContext Framework 的所有配置，标准语义支持以下注释。请注意，这些注释并非特定于测试，可以在 Spring Framework 中的任何位置使用。</p>
<ul>
<li><code>@Autowired</code></li>
<li><code>@Qualifier</code></li>
<li>如果 JSR-250 存在，<code>@Resource</code>(javax.annotation)</li>
<li>如果 JSR-250 存在，<code>@ManagedBean</code>(javax.annotation)</li>
<li>如果 JSR-330 存在，<code>@Inject</code>(javax.inject)</li>
<li>如果 JSR-330 存在，<code>@Named</code>(javax.inject)</li>
<li>如果存在 JPA，<code>@PersistenceContext</code>(javax.persistence)</li>
<li>如果存在 JPA，<code>@PersistenceUnit</code>(javax.persistence)</li>
<li><code>@Required</code></li>
<li><code>@Transactional</code></li>
</ul>
<blockquote>
<p>JSR-250 生命周期注释</p>
</blockquote>
<p>在 Spring TestContext Framework 中，您可以在<code>ApplicationContext</code>中配置的任何 application 组件上使用<code>@PostConstruct</code>和<code>@PreDestroy</code>标准语义。但是，这些生命周期注释在实际测试 class 中的使用受到限制。</p>
<p>如果 test class 中的方法使用<code>@PostConstruct</code>注释，则该方法在基础测试 framework 的任何 before 方法之前运行(对于 example，使用 JUnit Jupiter 的<code>@BeforeEach</code>注释的方法)，并且这适用于 test class 中的每个测试方法。另一方面，如果测试 class 中的方法使用<code>@PreDestroy</code>注释，则该方法永远不会运行。因此，在 test class 中，我们建议您使用基础测试 framework 而不是<code>@PostConstruct</code>和<code>@PreDestroy</code>的测试生命周期回调。</p>
<h4 id="SpringJUnit4测试注解"><a href="#SpringJUnit4测试注解" class="headerlink" title="SpringJUnit4测试注解"></a>SpringJUnit4测试注解</h4><p>仅当与<a href="#SpringJunit4Runner">SpringRunner</a>，<a href="#SpringJunit4规则">Spring 的 JUnit 4 规则</a>或<a href="#JUnit4支持classes">Spring 的 JUnit 4 支持 classes</a>一起使用时，才支持以下注解：</p>
<ul>
<li><a href="#IfProfileValue注解">@IfProfileValue</a></li>
<li><a href="#ProfileValueSourceConfiguration注解">@ProfileValueSourceConfiguration</a></li>
<li><a href="#Timed注解">@Timed</a></li>
<li><a href="#Repeat注解">@Repeat</a></li>
</ul>
<h5 id="IfProfileValue注解"><a href="#IfProfileValue注解" class="headerlink" title="IfProfileValue注解"></a>IfProfileValue注解</h5><p><code>@IfProfileValue</code>表示为特定测试环境启用了带注释的测试。如果配置的<code>ProfileValueSource</code>为提供的<code>name</code>返回匹配的<code>value</code>，则启用测试。否则，测试被禁用，并且有效地被忽略。</p>
<p>您可以在 class level，方法 level 或两者中应用<code>@IfProfileValue</code>。对于 class 或其子类中的任何方法，<code>@IfProfileValue</code>的使用优先于 method-level 用法。具体来说，如果在 class level 和 level 方法中都启用了测试，则启用测试。缺少<code>@IfProfileValue</code>意味着隐式启用了测试。这类似于 JUnit 4 的<code>@Ignore</code> annotation 的语义，除了<code>@Ignore</code>的存在总是禁用测试。</p>
<p>以下 example 显示了具有<code>@IfProfileValue</code> annotation 的测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IfProfileValue(name=&quot;java.vendor&quot;, value=&quot;Oracle Corporation&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWhichRunsOnlyOnOracleJvm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic that should run only on Java VMs from Oracle Corporation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>仅在 Java 供应商为“Oracle Corporation”时运行此测试。</td>
</tr>
</tbody>
</table>
</div>
<p>或者，您可以使用<code>values</code>(带<code>OR</code>语义)列表配置<code>@IfProfileValue</code>，以便在 JUnit 4 环境中实现对测试组的 TestNG-like 支持。考虑以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IfProfileValue(name=&quot;test-groups&quot;, values=&#123;&quot;unit-tests&quot;, &quot;integration-tests&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWhichRunsForUnitOrIntegrationTestGroups</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic that should run only for unit and integration test groups</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>运行此测试以进行单元测试和 integration 测试。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="ProfileValueSourceConfiguration注解"><a href="#ProfileValueSourceConfiguration注解" class="headerlink" title="ProfileValueSourceConfiguration注解"></a>ProfileValueSourceConfiguration注解</h5><p><code>@ProfileValueSourceConfiguration</code>是一个 class-level annotation，它指定在检索通过<code>@IfProfileValue</code> annotation 配置的 profile 值时要使用的<code>ProfileValueSource</code>类型。如果未为测试声明<code>@ProfileValueSourceConfiguration</code>，则默认使用<code>SystemProfileValueSource</code>。以下 example 显示了如何使用<code>@ProfileValueSourceConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ProfileValueSourceConfiguration(CustomProfileValueSource.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomProfileValueSourceTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用自定义 profile value 源。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Timed注解"><a href="#Timed注解" class="headerlink" title="Timed注解"></a>Timed注解</h5><p><code>@Timed</code>表示带注释的测试方法必须在指定的 time 时间段内(以毫秒为单位)完成执行。如果文本执行 time 超过指定的 time 时间段，则测试失败。</p>
<p>time 时间段包括运行测试方法本身，测试的任何重复(参见<code>@Repeat</code>)，以及测试夹具的任何设置或拆除。以下 example 显示了如何使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Timed(millis = 1000)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessWithOneSecondTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some logic that should not take longer than 1 second to execute</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将测试的 time 周期设置为一秒。</td>
</tr>
</tbody>
</table>
</div>
<p>Spring 的<code>@Timed</code> annotation 具有与 JUnit 4 的<code>@Test(timeout=…)</code>支持不同的语义。具体来说，由于 JUnit 4 处理测试执行超时的方式(即，通过在单独的<code>Thread</code>中执行测试方法)，如果测试花费太长，则<code>@Test(timeout=…)</code>抢先未通过测试。另一方面，Spring 的<code>@Timed</code>并没有先发制人地失败，而是在失败之前等待测试完成。</p>
<h5 id="Repeat注解"><a href="#Repeat注解" class="headerlink" title="Repeat注解"></a>Repeat注解</h5><p><code>@Repeat</code>表示注释的测试方法必须重复 run。在 annotation 中指定执行测试方法的次数。</p>
<p>要重复的执行范围包括执行测试方法本身以及测试夹具的任何设置或拆除。以下 example 显示了如何使用<code>@Repeat</code> annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeat(10)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProcessRepeatedly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>重复此测试十次。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="SpringJUnitJupiterTestingAnnotations"><a href="#SpringJUnitJupiterTestingAnnotations" class="headerlink" title="SpringJUnitJupiterTestingAnnotations"></a>SpringJUnitJupiterTestingAnnotations</h4><p>仅当与<a href="#JUnitJupiter的SpringExtension">SpringExtension</a>和 JUnit Jupiter(即 JUnit 5 中的编程 model)一起使用时，才支持以下注释：</p>
<ul>
<li><a href="#SpringJUnitConfig注解">@SpringJUnitConfig</a></li>
<li><a href="#SpringJUnitWebConfig注解">@SpringJUnitWebConfig</a></li>
<li><a href="#EnabledIf注解">@EnabledIf</a></li>
<li><a href="#DisabledIf注解">@DisabledIf</a></li>
</ul>
<h5 id="SpringJUnitConfig注解"><a href="#SpringJUnitConfig注解" class="headerlink" title="SpringJUnitConfig注解"></a>SpringJUnitConfig注解</h5><p><code>@SpringJUnitConfig</code>是一个组合的 annotation，它将 JUnit Jupiter 中的<code>@ExtendWith(SpringExtension.class)</code>与 Spring TestContext Framework 中的<code>@ContextConfiguration</code>组合在一起。它可以在 class level 中用作<code>@ContextConfiguration</code>的 drop-in 替换。关于 configuration 选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitConfig</code>之间的唯一区别是可以使用<code>@SpringJUnitConfig</code>中的<code>value</code>属性声明带注释的 classes。</p>
<p>以下 example 显示了如何使用<code>@SpringJUnitConfig</code> annotation 指定 configuration class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(TestConfig.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassJUnitJupiterSpringTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 configuration class。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 显示了如何使用<code>@SpringJUnitConfig</code> annotation 指定 configuration 文件的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;/test-config.xml&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlJUnitJupiterSpringTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 configuration 文件的位置。</td>
</tr>
</tbody>
</table>
</div>
<p>有关详细信息，请参阅<a href="#Context管理">Context Management</a>以及<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/SpringJUnitConfig.html">@SpringJUnitConfig</a>和<code>@ContextConfiguration</code>的 javadoc。</p>
<h5 id="SpringJUnitWebConfig注解"><a href="#SpringJUnitWebConfig注解" class="headerlink" title="SpringJUnitWebConfig注解"></a>SpringJUnitWebConfig注解</h5><p><code>@SpringJUnitWebConfig</code>是一个组合注释，它将 JUnit Jupiter 中的<code>@ExtendWith(SpringExtension.class)</code>与来自 Spring TestContext Framework 的<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>组合在一起。您可以在 class level 中将其用作<code>@ContextConfiguration</code>和<code>@WebAppConfiguration</code>的 drop-in 替换。关于 configuration 选项，<code>@ContextConfiguration</code>和<code>@SpringJUnitWebConfig</code>之间的唯一区别是您可以使用<code>@SpringJUnitWebConfig</code>中的<code>value</code>属性声明带注释的 classes bu。此外，只能使用<code>@SpringJUnitWebConfig</code>中的<code>resourcePath</code>属性覆盖<code>value</code>中的<code>value</code>属性。</p>
<p>以下 example 显示了如何使用<code>@SpringJUnitWebConfig</code> annotation 指定 configuration class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitWebConfig(TestConfig.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurationClassJUnitJupiterSpringWebTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 configuration class。</td>
</tr>
</tbody>
</table>
</div>
<p>以下 example 显示了如何使用<code>@SpringJUnitWebConfig</code> annotation 指定 configuration 文件的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitWebConfig(locations = &quot;/test-config.xml&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlJUnitJupiterSpringWebTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 configuration 文件的位置。</td>
</tr>
</tbody>
</table>
</div>
<p>有关详细信息，请参阅<a href="#Context管理">Context Management</a>以及<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/junit/jupiter/web/SpringJUnitWebConfig.html">@SpringJUnitWebConfig</a>，<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/ContextConfiguration.html">@ContextConfiguration</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/web/WebAppConfiguration.html">@WebAppConfiguration</a>的 javadoc。</p>
<h5 id="EnabledIf注解"><a href="#EnabledIf注解" class="headerlink" title="EnabledIf注解"></a>EnabledIf注解</h5><p><code>@EnabledIf</code>用于表示已注释的 JUnit Jupiter 测试 class 或测试方法已启用，如果提供的<code>expression</code>求值为<code>true</code>，则应为 run。具体来说，如果表达式求值为<code>Boolean.TRUE</code>或<code>String</code>等于<code>true</code>(忽略大小写)，则启用测试。当应用于 class level 时，默认情况下也会自动启用该 class 中的所有测试方法。</p>
<p>表达式可以是以下任何一种：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Spring表达语言SpEL">Spring 表达语言</a>(SpEL)表达式。对于 example：<code>@EnabledIf(&quot;#&#123;systemProperties[&#39;os.name&#39;].toLowerCase().contains(&#39;mac&#39;)&#125;&quot;)</code></li>
<li>Spring <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#环境抽象">环境</a>中可用 property 的占位符。对于 example：<code>@EnabledIf(&quot;$&#123;smoke.tests.enabled&#125;&quot;)</code></li>
<li>文字文字。对于 example：<code>@EnabledIf(&quot;true&quot;)</code></li>
</ul>
<p>但请注意，不是 property 占位符动态解析结果的文本文字是零实用 value，因为<code>@EnabledIf(&quot;false&quot;)</code>等同于<code>@Disabled</code>，<code>@EnabledIf(&quot;true&quot;)</code>在逻辑上没有意义。</p>
<p>您可以使用<code>@EnabledIf</code>作为 meta-annotation 来创建自定义组合注释。对于 example，您可以创建自定义<code>@EnabledOnMac</code> annotation，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@EnabledIf(</span></span><br><span class="line"><span class="meta">    expression = &quot;#&#123;systemProperties[&#x27;os.name&#x27;].toLowerCase().contains(&#x27;mac&#x27;)&#125;&quot;,</span></span><br><span class="line"><span class="meta">    reason = &quot;Enabled on Mac OS&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnabledOnMac &#123;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DisabledIf注解"><a href="#DisabledIf注解" class="headerlink" title="DisabledIf注解"></a>DisabledIf注解</h5><p><code>@DisabledIf</code>用于表示已禁用带注释的 JUnit Jupiter 测试 class 或测试方法，如果提供的<code>expression</code>求值为<code>true</code>，则不应执行。具体来说，如果表达式求值为<code>Boolean.TRUE</code>或<code>String</code>等于<code>true</code>(忽略大小写)，则禁用测试。当应用于 class level 时，该 class 中的所有测试方法也会自动禁用。</p>
<p>表达式可以是以下任何一种：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Spring表达语言SpEL">Spring 表达语言</a>(SpEL)表达式。对于 example：<code>@DisabledIf(&quot;#&#123;systemProperties[&#39;os.name&#39;].toLowerCase().contains(&#39;mac&#39;)&#125;&quot;)</code></li>
<li>Spring <a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions">环境</a>中可用 property 的占位符。对于 example：<code>@DisabledIf(&quot;$&#123;smoke.tests.disabled&#125;&quot;)</code></li>
<li>文字文字。对于 example：<code>@DisabledIf(&quot;true&quot;)</code></li>
</ul>
<p>但请注意，不是 property 占位符动态解析结果的文本文字是零实用 value，因为<code>@DisabledIf(&quot;true&quot;)</code>等同于<code>@Disabled</code>，<code>@DisabledIf(&quot;false&quot;)</code>在逻辑上没有意义。</p>
<p>您可以使用<code>@DisabledIf</code>作为 meta-annotation 来创建自定义组合注释。对于 example，您可以创建自定义<code>@DisabledOnMac</code> annotation，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@DisabledIf(</span></span><br><span class="line"><span class="meta">    expression = &quot;#&#123;systemProperties[&#x27;os.name&#x27;].toLowerCase().contains(&#x27;mac&#x27;)&#125;&quot;,</span></span><br><span class="line"><span class="meta">    reason = &quot;Disabled on Mac OS&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DisabledOnMac &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Meta-Annotation支持测试"><a href="#Meta-Annotation支持测试" class="headerlink" title="Meta-Annotation支持测试"></a>Meta-Annotation支持测试</h4><p>您可以使用大多数 test-related annotations 作为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#使用元注解和复合注解">meta-annotations</a>来创建自定义组合注释并减少测试套件中的配置重复。</p>
<p>您可以将以下各项与<a href="#SpringTestContext框架">Spring TestContext Framework</a>一起用作 meta-annotation。</p>
<ul>
<li><code>@BootstrapWith</code></li>
<li><code>@ContextConfiguration</code></li>
<li><code>@ContextHierarchy</code></li>
<li><code>@ActiveProfiles</code></li>
<li><code>@TestPropertySource</code></li>
<li><code>@DirtiesContext</code></li>
<li><code>@WebAppConfiguration</code></li>
<li><code>@TestExecutionListeners</code></li>
<li><code>@Transactional</code></li>
<li><code>@BeforeTransaction</code></li>
<li><code>@AfterTransaction</code></li>
<li><code>@Commit</code></li>
<li><code>@Rollback</code></li>
<li><code>@Sql</code></li>
<li><code>@SqlConfig</code></li>
<li><code>@SqlGroup</code></li>
<li><code>@Repeat</code>(仅在 JUnit 4 上受支持)</li>
<li><code>@Timed</code>(仅在 JUnit 4 上受支持)</li>
<li><code>@IfProfileValue</code>(仅在 JUnit 4 上受支持)</li>
<li><code>@ProfileValueSourceConfiguration</code>(仅在 JUnit 4 上受支持)</li>
<li><code>@SpringJUnitConfig</code>(仅在 JUnit Jupiter 上受支持)</li>
<li><code>@SpringJUnitWebConfig</code>(仅在 JUnit Jupiter 上受支持)</li>
<li><code>@EnabledIf</code>(仅在 JUnit Jupiter 上受支持)</li>
<li><code>@DisabledIf</code>(仅在 JUnit Jupiter 上受支持)</li>
</ul>
<p>考虑以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRepositoryTests</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTests</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们发现我们在 JUnit 4-based 测试套件中重复了前面的 configuration，我们可以通过引入一个自定义组合 annotation 来集中 Spring 的 common test configuration 来减少重复，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalDevTestConfig &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code> annotation 来简化基于 JUnit 4 的各个 test classes 的 configuration 配置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@TransactionalDevTestConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderRepositoryTests</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@TransactionalDevTestConfig</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTests</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们编写使用 JUnit Jupiter 的测试，我们可以进一步减少 code 重复，因为 JUnit 5 中的 annotations 也可以用作 meta-annotations。考虑以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderRepositoryTests</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTests</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>如果我们发现我们在 JUnit Jupiter-based 测试套件中重复了前面的 configuration，我们可以通过引入一个自定义组合的 annotation 来集中 Spring 和 JUnit Jupiter 的 common test configuration 来减少重复，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-data-access-config.xml&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalDevTestConfig &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用我们的自定义<code>@TransactionalDevTestConfig</code> annotation 来简化基于 JUnit Jupiter 的各个 test classes 的 configuration 配置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TransactionalDevTestConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderRepositoryTests</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TransactionalDevTestConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRepositoryTests</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>由于 JUnit Jupiter 支持使用<code>@Test</code>，<code>@RepeatedTest</code>，<code>ParameterizedTest</code>和其他作为 meta-annotations，因此您还可以在测试方法 level 中创建自定义组合注释。例如，如果我们希望创建一个组合的 annotation，它将来自 JUnit Jupiter 的<code>@Test</code>和<code>@Tag</code> 注释与来自 Spring 的<code>@Transactional</code> annotation 结合起来，我们可以创建<code>@TransactionalIntegrationTest</code> annotation，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Tag(&quot;integration-test&quot;)</span> <span class="comment">// org.junit.jupiter.api.Tag</span></span><br><span class="line"><span class="meta">@Test</span> <span class="comment">// org.junit.jupiter.api.Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TransactionalIntegrationTest &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以使用我们的自定义<code>@TransactionalIntegrationTest</code> annotation 来简化基于 JUnit Jupiter 的测试方法的配置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TransactionalIntegrationTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TransactionalIntegrationTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOrder</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>有关更多详细信息，请参阅<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a> wiki 页面。</p>
<h3 id="SpringTestContext框架"><a href="#SpringTestContext框架" class="headerlink" title="SpringTestContext框架"></a>SpringTestContext框架</h3><p>Spring TestContext Framework(位于<code>org.springframework.test.context</code>包中)提供了通用的 annotation-driven 单元和 integration 测试支持，它与正在使用的测试 framework 无关。 TestContext framework 在 configuration 上的约定上也非常重要，你可以通过 annotation-based configuration 覆盖合理的默认值。</p>
<p>除了通用测试基础结构之外，TestContext framework 还为 JUnit 4，JUnit Jupiter(AKA JUnit 5)和 TestNG 提供了显式支持。对于 JUnit 4 和 TestNG，Spring 提供<code>abstract</code>支持 classes。此外，Spring 为 JUnit 4 提供了一个自定义 JUnit <code>Runner</code>和自定义 JUnit <code>Rules</code>，为 JUnit Jupiter 提供了一个自定义<code>Extension</code>，可以让你编写 so-called POJO test classes。 POJO test classes 不需要扩展特定的 class 层次结构，例如<code>abstract</code> support classes。</p>
<p>以下部分概述了 TestContext framework 的内部结构。如果您只对使用 framework 感兴趣并且不想使用自己的自定义 listeners 或自定义加载器扩展它，请随意直接转到 configuration(<a href="#Context管理">context management</a>，<a href="#测试fixture的依赖注入">依赖注入</a>，<a href="#事务管理">transaction management</a>)，<a href="#TestContext框架支持Classes">支持 classes</a>和<a href="#Annotations">annotation 支持</a>部分。</p>
<h4 id="Key抽象"><a href="#Key抽象" class="headerlink" title="Key抽象"></a>Key抽象</h4><p>framework 的核心由<code>TestContextManager</code> class 和<code>TestContext</code>，<code>TestExecutionListener</code>和<code>SmartContextLoader</code>接口组成。为每个测试 class 创建<code>TestContextManager</code>(对于 example，用于执行 JUnit Jupiter 中单个测试 class 中的所有测试方法)。反过来，<code>TestContextManager</code>管理一个<code>TestContext</code>，它保存当前测试的 context。 <code>TestContextManager</code>还会在测试进行时更新<code>TestContext</code>的 state，并委托<code>TestExecutionListener</code> implementations，它通过提供依赖注入，管理 transactions 等来检测实际的测试执行情况。 <code>SmartContextLoader</code>负责为给定的测试 class 加载<code>ApplicationContext</code>。有关各种 implementations 的更多信息和示例，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/package-summary.html">javadoc</a>和 Spring 测试套件。</p>
<h5 id="TestContext"><a href="#TestContext" class="headerlink" title="TestContext"></a>TestContext</h5><p><code>TestContext</code>封装了执行测试的 context(与使用中的实际测试 framework 无关)，并为其负责的测试实例提供 context management 和缓存支持。如果请求，<code>TestContext</code>还委托<code>SmartContextLoader</code>加载<code>ApplicationContext</code>。</p>
<h5 id="TestContextManager"><a href="#TestContextManager" class="headerlink" title="TestContextManager"></a>TestContextManager</h5><p><code>TestContextManager</code>是 Spring TestContext Framework 的主要入口点，负责在 well-defined 测试执行点管理每个注册<code>TestExecutionListener</code>的单个<code>TestContext</code>和信令 events：</p>
<ul>
<li>在特定测试 framework 之前的任何“before class”或“before all”方法之前。</li>
<li>测试实例 post-processing。</li>
<li>在特定测试 framework 之前的任何“之前”或“之前”方法之前。</li>
<li>在执行测试方法之前，但在测试设置之后。</li>
<li>在执行测试方法之后但在测试之前立即拆除。</li>
<li>在特定测试 framework 之后的任何“之后”或“之后”方法之后。</li>
<li>经过特定测试 framework 的任何“after class”或“after all”方法之后。</li>
</ul>
<h5 id="TestExecutionListener"><a href="#TestExecutionListener" class="headerlink" title="TestExecutionListener"></a>TestExecutionListener</h5><p><code>TestExecutionListener</code>定义 API 以响应_l发布的<code>TestContextManager</code>发布的 test-execution events。见<a href="#TestExecutionListener配置">TestExecutionListener Configuration</a>。</p>
<h5 id="Context加载器"><a href="#Context加载器" class="headerlink" title="Context加载器"></a>Context加载器</h5><p><code>ContextLoader</code>是 Spring 2.5 中引入的策略接口，用于为 Spring TestContext Framework 管理的 integration 测试加载<code>ApplicationContext</code>。您应该实现<code>SmartContextLoader</code>而不是此接口，以提供对带注释的 classes，active bean definition profiles，test property sources，context 层次结构和<code>WebApplicationContext</code>支持的支持。</p>
<p><code>SmartContextLoader</code>是 Spring 3.1 中引入的<code>ContextLoader</code>接口的扩展。 <code>SmartContextLoader</code> SPI 取代 Spring 2.5 中引入的<code>ContextLoader</code> SPI。具体来说，<code>SmartContextLoader</code>可以选择 process 资源位置，带注释的 classes 或 context 初始值设定项。此外，<code>SmartContextLoader</code>可以在其加载的 context 中设置 active bean definition profiles 和 test property sources。</p>
<p>Spring 提供以下 implementations：</p>
<ul>
<li><code>DelegatingSmartContextLoader</code>：两个默认加载器之一，它内部委托给<code>AnnotationConfigContextLoader</code>，<code>GenericXmlContextLoader</code>或<code>GenericGroovyXmlContextLoader</code>，这取决于为 test class 声明的 configuration 或默认位置或默认 configuration classes 的存在。仅当 Groovy 位于 classpath 时才启用 Groovy 支持。</li>
<li><code>WebDelegatingSmartContextLoader</code>：两个默认加载器之一，它内部委托给<code>AnnotationConfigWebContextLoader</code>，<code>GenericXmlWebContextLoader</code>或<code>GenericGroovyXmlWebContextLoader</code>，这取决于为 test class 声明的 configuration 或默认位置或默认 configuration classes 的存在。仅当 Class 上存在<code>@WebAppConfiguration</code>时才使用 web <code>ContextLoader</code>。仅当 Groovy 位于 classpath 时才启用 Groovy 支持。</li>
<li><code>AnnotationConfigContextLoader</code>：从带注释的 classes 中加载标准<code>ApplicationContext</code>。</li>
<li><code>AnnotationConfigWebContextLoader</code>：从带注释的 classes 中加载<code>WebApplicationContext</code>。</li>
<li><code>GenericGroovyXmlContextLoader</code>：从 Groovy 脚本或 XML configuration files 的资源位置加载标准<code>ApplicationContext</code>。</li>
<li><code>GenericGroovyXmlWebContextLoader</code>：从 Groovy 脚本或 XML configuration files 的资源位置加载<code>WebApplicationContext</code>。</li>
<li><code>GenericXmlContextLoader</code>：从 XML 资源位置加载标准<code>ApplicationContext</code>。</li>
<li><code>GenericXmlWebContextLoader</code>：从 XML 资源位置加载<code>WebApplicationContext</code>。</li>
<li><code>GenericPropertiesContextLoader</code>：从 Java properties files 加载标准<code>ApplicationContext</code>。</li>
</ul>
<h4 id="引导TestContextFramework"><a href="#引导TestContextFramework" class="headerlink" title="引导TestContextFramework"></a>引导TestContextFramework</h4><p>Spring TestContext Framework 内部的默认 configuration 足以用于所有 common 用例。但是，有时开发团队或第三方 framework 要更改默认<code>ContextLoader</code>，实现自定义<code>TestContext</code>或<code>ContextCache</code>，增加<code>ContextCustomizerFactory</code>和<code>TestExecutionListener</code> 实现的默认 sets，依此类推。对于 TestContext framework 如何操作的 low-level 控制，Spring 提供了一个自举策略。</p>
<p><code>TestContextBootstrapper</code>定义 SPI 以引导 TestContext framework。 <code>TestContextManager</code>使用<code>TestContextBootstrapper</code>来加载当前测试的<code>TestExecutionListener</code> 实现并build它管理的<code>TestContext</code>。您可以使用<code>@BootstrapWith</code>直接或作为 meta-annotation 为 test class(或 test class 层次结构)配置自定义引导策略。如果未使用<code>@BootstrapWith</code>显式配置引导程序，则使用<code>DefaultTestContextBootstrapper</code>或<code>WebTestContextBootstrapper</code>，具体取决于是否存在<code>@WebAppConfiguration</code>。</p>
<p>由于<code>TestContextBootstrapper</code> SPI 将来可能会发生变化(以适应新的要求)，因此我们强烈建议实施者不要直接实现此接口，而应扩展<code>AbstractTestContextBootstrapper</code>或其中一个具体的子类。</p>
<h4 id="TestExecutionListener配置"><a href="#TestExecutionListener配置" class="headerlink" title="TestExecutionListener配置"></a>TestExecutionListener配置</h4><p>Spring 提供以下默认注册的<code>TestExecutionListener</code> __mplementations，完全在以下 order 中：</p>
<ul>
<li><code>ServletTestExecutionListener</code>：为<code>WebApplicationContext</code>配置 Servlet API 模拟。</li>
<li><code>DirtiesContextBeforeModesTestExecutionListener</code>：处理“之前”模式的<code>@DirtiesContext</code> 注释。</li>
<li><code>DependencyInjectionTestExecutionListener</code>：为测试实例提供依赖注入。</li>
<li><code>DirtiesContextTestExecutionListener</code>：处理“后”模式的<code>@DirtiesContext</code> 注释。</li>
<li><code>TransactionalTestExecutionListener</code>：使用默认回滚语义提供 transactional 测试执行。</li>
<li><code>SqlScriptsTestExecutionListener</code>：运行使用<code>@Sql</code> annotation 配置的 SQL 脚本。</li>
</ul>
<h5 id="注册TestExecutionListener实现"><a href="#注册TestExecutionListener实现" class="headerlink" title="注册TestExecutionListener实现"></a>注册TestExecutionListener实现</h5><p>您可以使用<code>@TestExecutionListeners</code> annotation 为 test class 及其子类注册自定义<code>TestExecutionListener</code> __mplement。有关详细信息和示例，请参阅<a href="#Annotations">annotation 支持</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestExecutionListeners.html">@TestExecutionListeners</a>的 javadoc。</p>
<h5 id="自动发现默认的TestExecutionListener实现"><a href="#自动发现默认的TestExecutionListener实现" class="headerlink" title="自动发现默认的TestExecutionListener实现"></a>自动发现默认的TestExecutionListener实现</h5><p>使用<code>@TestExecutionListeners</code>注册自定义<code>TestExecutionListener</code> 实现适用于在有限测试场景中使用的自定义 listener。但是，如果需要在测试套件中使用自定义 listener，则会变得很麻烦。自 Spring Framework 4.1 以来，通过支持通过<code>SpringFactoriesLoader</code>机制自动发现默认<code>TestExecutionListener</code> 实现来解决此问题。</p>
<p>具体来说，<code>spring-test</code>模块在org.springframework.test.context下声明所有核心的默认<code>TestExecutionListener</code>实现。TestExecutionListener键的<code>META-INF/spring.factories</code>属性文件。第三方框架和开发人员可以通过他们自己的<code>META-INF/spring.factories</code>以同样的方式将他们自己的TestExecutionListener实现贡献给默认侦听器列表。工厂的属性文件。</p>
<h5 id="OrderingTestExecutionListener实现"><a href="#OrderingTestExecutionListener实现" class="headerlink" title="OrderingTestExecutionListener实现"></a>OrderingTestExecutionListener实现</h5><p>当的 TestContext framework 通过<a href="#自动发现默认的TestExecutionListener实现">前述</a> <code>SpringFactoriesLoader</code>机制发现默认<code>TestExecutionListener</code> 实现，实例化 listeners 通过使用 Spring 的<code>AnnotationAwareOrderComparator</code>，里面供奉 Spring 的<code>Ordered</code>接口和<code>@Order</code> annotation 为 ordering 排序。 <code>AbstractTestExecutionListener</code>和 Spring 提供的所有默认<code>TestExecutionListener</code> 实现将使用适当的值实现<code>Ordered</code>。因此，Third-party 框架和开发人员应确保通过实现<code>Ordered</code>或声明<code>@Order</code>来确保其默认的<code>TestExecutionListener</code> 实现在正确的 order 中注册。有关为每个核心 listener 分配的值的详细信息，请参阅 javadoc 以获取核心缺省<code>TestExecutionListener</code> 实现的<code>getOrder()</code>方法。</p>
<h5 id="合并TestExecutionListener实现"><a href="#合并TestExecutionListener实现" class="headerlink" title="合并TestExecutionListener实现"></a>合并TestExecutionListener实现</h5><p>如果通过<code>@TestExecutionListeners</code>注册了自定义<code>TestExecutionListener</code>，则不会注册默认的 listener。在大多数 common 测试场景中，这有效地迫使开发人员除了任何自定义 listener 之外还手动声明所有默认 listener。以下清单演示了这种 configuration 方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(&#123;</span></span><br><span class="line"><span class="meta">    MyCustomTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    ServletTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    DirtiesContextBeforeModesTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    DependencyInjectionTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    DirtiesContextTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    TransactionalTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    SqlScriptsTestExecutionListener.class</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法的挑战在于它要求开发人员确切地知道默认情况下注册了哪些 listeners。此外，默认 listeners 的集合可以在发行版之间更改 - 例如，在 Spring Framework 4.1 中引入，而<code>DirtiesContextBeforeModesTestExecutionListener</code>在 Spring Framework 4.2 中引入。此外，像 Spring Security 这样的 third-party 框架通过使用前面提到的<a href="#自动发现默认的TestExecutionListener实现">自动发现机制</a>来注册它们自己的默认<code>TestExecutionListener</code> 实现。</p>
<p>为避免必须知道和 re-declare 所有默认 listeners，您可以将<code>@TestExecutionListeners</code>的<code>mergeMode</code>属性设置为<code>MergeMode.MERGE_WITH_DEFAULTS</code>。 <code>MERGE_WITH_DEFAULTS</code>表示本地声明的 listeners 应该与默认的 listeners 合并。合并算法确保从列表中删除重复项，并根据<code>AnnotationAwareOrderComparator</code>的语义对生成的合并 listeners 组进行排序，如<a href="#OrderingTestExecutionListener实现">Ordering TestExecutionListener Implementations</a>中所述。如果 listener 实现<code>Ordered</code>或使用<code>@Order</code>注解，它可以影响它与默认值合并的位置。否则，在合并时，本地声明的 listeners 将附加到默认 listeners 列表中。</p>
<p>对于 example，如果<code>MyCustomTestExecutionListener</code> class 在先前 example 配置其<code>order</code> value(对于 example，<code>500</code>)至小于<code>ServletTestExecutionListener</code>的 order(这恰好是<code>1000</code>)，则<code>MyCustomTestExecutionListener</code>然后可以自动地与默认列表合并在<code>ServletTestExecutionListener</code>前面，前一个 example 可以替换为以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(</span></span><br><span class="line"><span class="meta">    listeners = MyCustomTestExecutionListener.class,</span></span><br><span class="line"><span class="meta">    mergeMode = MERGE_WITH_DEFAULTS</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Context管理"><a href="#Context管理" class="headerlink" title="Context管理"></a>Context管理</h4><p>每个<code>TestContext</code>为其负责的测试实例提供 context management 和缓存支持。测试实例不会自动接收对已配置的<code>ApplicationContext</code>的访问权限。但是，如果测试 class 实现了<code>ApplicationContextAware</code>接口，则会向测试实例提供<code>ApplicationContext</code>的 reference。请注意<code>AbstractJUnit4SpringContextTests</code>和<code>AbstractTestNGSpringContextTests</code>实现了<code>ApplicationContextAware</code>，因此可以自动提供对<code>ApplicationContext</code>的访问。</p>
<blockquote>
<p>@Autowired ApplicationContext</p>
</blockquote>
<p>作为实现<code>ApplicationContextAware</code>接口的替代方法，您可以通过字段或 setter 方法上的<code>@Autowired</code> annotation 为您的 test class 注入 application context，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>注入<code>ApplicationContext</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>同样，如果您的测试配置为加载<code>WebApplicationContext</code>，您可以 inject web application context 进入测试，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> (<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>配置<code>WebApplicationContext</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>注入<code>WebApplicationContext</code>。</td>
</tr>
</tbody>
</table>
</div>
<p>使用<code>@Autowired</code>的依赖注入由<code>DependencyInjectionTestExecutionListener</code>提供，默认配置为<code>DependencyInjectionTestExecutionListener</code>(参见<a href="#测试fixture的依赖注入">测试夹具的依赖注入</a>)。</p>
<p>使用 TestContext framework 的 Test classes 不需要扩展任何特定的 class 或实现特定的接口来配置它们的 application context。相反，configuration 是通过在 class level 处声明<code>@ContextConfiguration</code> annotation 来实现的。如果 test class 没有显式声明 application context 资源位置或带注释的 classes，则配置的<code>ContextLoader</code>确定如何从默认位置加载 context 或默认 configuration classes。除了 context 资源位置和带注释的 classes 之外，还可以通过 application context 初始化程序配置 application context。</p>
<p>以下部分说明如何使用 Spring 的<code>@ContextConfiguration</code> annotation 通过使用 XML configuration files，Groovy 脚本，带注释的 classes(通常为<code>@Configuration</code> classes)或 context 初始化程序来配置测试<code>ApplicationContext</code>。或者，您可以为高级用例实现和配置自己的自定义<code>SmartContextLoader</code>。</p>
<ul>
<li><a href="#使用XML资源配置Context">Context Configuration with XML resources</a></li>
<li><a href="#使用Groovy脚本配置Context">Context Configuration with Groovy Scripts</a></li>
<li><a href="#使用Annotated类配置Context">Context Configuration with Annotated Classes</a></li>
<li><a href="#混合XML,Groovy脚本和带注解的Classes">混合 XML，Groovy 脚本和带注释的 Classes</a></li>
<li><a href="#使用Context初始化器配置Context">Context Configuration with Context Initializers</a></li>
<li><a href="#Context配置继承">Context Configuration 继承</a></li>
<li><a href="#使用环境配置文件进行上下文配置">Context Configuration with Environment Profiles</a></li>
<li><a href="#使用测试Property资源配置Context">Context Configuration with Test Property Sources</a></li>
<li><a href="#加载WebApplicationContext">Loading WebApplicationContext</a></li>
<li><a href="#Context缓存">Context 缓存</a></li>
<li><a href="#Context层次结构">Context Hierarchies</a></li>
</ul>
<h5 id="使用XML资源配置Context"><a href="#使用XML资源配置Context" class="headerlink" title="使用XML资源配置Context"></a>使用XML资源配置Context</h5><p>要使用 XML configuration files 为测试加载<code>ApplicationContext</code>，请使用<code>@ContextConfiguration</code>注释 test class，并使用包含 XML configuration 元数据的资源位置的 array 配置<code>locations</code>属性。普通路径或相对路径(对于 example，<code>context.xml</code>)被视为 classpath 资源，该资源相对于定义 test class 的包。以斜杠开头的路径被视为绝对 classpath 位置(对于 example，<code>/org/example/config.xml</code>)。表示资源 URL 的路径(i.e.，前缀为<code>classpath:</code>，<code>file:</code>，<code>http:</code>，etc.)的路径按原样使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from &quot;/app-config.xml&quot; and</span></span><br><span class="line"><span class="comment">// &quot;/test-config.xml&quot; in the root of the classpath</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&#123;&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>将 locations 属性设置为 XML files 列表。</td>
</tr>
</tbody>
</table>
</div>
<p><code>@ContextConfiguration</code>通过标准 Java <code>value</code>属性支持<code>locations</code>属性的别名。因此，如果您不需要在<code>@ContextConfiguration</code>中声明其他属性，则可以省略<code>locations</code>属性 name 的声明，并使用以下 example 中演示的缩写格式声明资源位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/app-config.xml&quot;, &quot;/test-config.xml&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>在不使用<code>location</code>属性的情况下指定 XML files。</td>
</tr>
</tbody>
</table>
</div>
<p>如果省略<code>@ContextConfiguration</code> annotation 中的<code>locations</code>和<code>value</code>属性，则 TestContext framework 会尝试检测默认的 XML 资源位置。具体来说，<code>GenericXmlContextLoader</code>和<code>GenericXmlWebContextLoader</code>根据 test class 的 name 检测默认位置。如果 class 被命名为<code>com.example.MyTest</code>，则<code>GenericXmlContextLoader</code>从<code>&quot;classpath:com/example/MyTest-context.xml&quot;</code>加载 application context。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from</span></span><br><span class="line"><span class="comment">// &quot;classpath:com/example/MyTest-context.xml&quot;</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从默认位置加载 configuration。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="使用Groovy脚本配置Context"><a href="#使用Groovy脚本配置Context" class="headerlink" title="使用Groovy脚本配置Context"></a>使用Groovy脚本配置Context</h5><p>要使用使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#GroovyBean定义DSL">Groovy Bean 定义 DSL</a>的 Groovy 脚本为测试加载<code>ApplicationContext</code>，可以使用<code>@ContextConfiguration</code>注释 test class，并使用包含 Groovy 脚本资源位置的 array 配置<code>locations</code>或<code>value</code>属性。 Groovy 脚本的资源查找语义与<a href="#使用XML资源配置Context">XML configuration files</a>中描述的相同。</p>
<blockquote>
<p>启用 Groovy 脚本支持 如果 Groovy 位于 classpath 上，则支持使用 Groovy 脚本加载 Spring TestContext Framework 中的<code>ApplicationContext</code>。</p>
</blockquote>
<p>以下 example 显示了如何指定 Groovy configuration files：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from &quot;/AppConfig.groovy&quot; and</span></span><br><span class="line"><span class="comment">// &quot;/TestConfig.groovy&quot; in the root of the classpath</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123;&quot;/AppConfig.groovy&quot;, &quot;/TestConfig.Groovy&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定 Groovy configuration files 的位置。</td>
</tr>
</tbody>
</table>
</div>
<p>如果省略<code>@ContextConfiguration</code> annotation 中的<code>locations</code>和<code>value</code>属性，则 TestContext framework 会尝试检测默认的 Groovy 脚本。具体来说，<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>根据 test class 的 name 检测默认位置。如果您的 class 名为<code>com.example.MyTest</code>，则 Groovy context 加载程序会从<code>&quot;classpath:com/example/MyTestContext.groovy&quot;</code>加载 application context。以下 example 显示了如何使用默认值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from</span></span><br><span class="line"><span class="comment">// &quot;classpath:com/example/MyTestContext.groovy&quot;</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从默认位置加载 configuration。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>同时声明 XML configuration 和 Groovy 脚本</p>
</blockquote>
<p>您可以使用<code>@ContextConfiguration</code>的<code>locations</code>或<code>value</code>属性同时声明 XML configuration files 和 Groovy 脚本。如果配置的资源位置的路径_end 为<code>.xml</code>，则使用<code>XmlBeanDefinitionReader</code>加载。否则，使用<code>GroovyBeanDefinitionReader</code>加载它。</p>
<p>以下清单显示了如何在 integration 测试中组合两者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from</span></span><br><span class="line"><span class="comment">// &quot;/app-config.xml&quot; and &quot;/TestConfig.groovy&quot;</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&#123; &quot;/app-config.xml&quot;, &quot;/TestConfig.groovy&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用Annotated类配置Context"><a href="#使用Annotated类配置Context" class="headerlink" title="使用Annotated类配置Context"></a>使用Annotated类配置Context</h5><p>要使用带注释的 classes(请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#基于Java的容器配置">Java-based container configuration</a>)为测试加载<code>ApplicationContext</code>，可以使用<code>@ContextConfiguration</code>注释 test class，并使用 array 配置包含引用 classes 的 references 的_ar属性。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from AppConfig and TestConfig</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;AppConfig.class, TestConfig.class&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定带注释的 classes。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>带注释的 Classes</p>
</blockquote>
<p>术语“带注释的 class”可以指以下任何一种：</p>
<ul>
<li>用<code>@Configuration</code>注释的 class。</li>
<li>一个 component(即 class 用<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>或其他构造型 annotations 注释)。</li>
<li>一个符合 JSR-330 的 class，用<code>javax.inject</code> annotations 注释。</li>
<li>包含<code>@Bean</code>方法的任何其他 class。</li>
</ul>
<p>有关注释 classes 的 configuration 和语义的更多信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html">@Bean</a>的 javadoc，特别注意<code>@Bean</code> Lite 模式的讨论。</p>
<p>如果省略<code>@ContextConfiguration</code> annotation 中的<code>classes</code>属性，则 TestContext framework 会尝试检测是否存在 default configuration classes。具体来说，<code>AnnotationConfigContextLoader</code>和<code>AnnotationConfigWebContextLoader</code>检测符合<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Configuration.html">@Configuration</a> javadoc 中指定的 configuration class implementations 要求的 test class 的所有<code>static</code>嵌套 classes。请注意 configuration class 的 name 是任意的。此外，如果需要，test class 可以包含多个<code>static</code>嵌套 configuration class。在下面的示例中，<code>OrderServiceTest</code> class 声明一个名为<code>Config</code>的<code>static</code>嵌套 configuration class，它自动用于加载测试 class 的<code>ApplicationContext</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from the</span></span><br><span class="line"><span class="comment">// static nested Config class</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// this bean will be injected into the OrderServiceTest class</span></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> OrderService <span class="title">orderService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderService orderService = <span class="keyword">new</span> OrderServiceImpl();</span><br><span class="line">            <span class="comment">// set properties, etc.</span></span><br><span class="line">            <span class="keyword">return</span> orderService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrderService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test the orderService</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>_Lading 来自嵌套 class 的 configuration 信息。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="混合XML-Groovy脚本和带注解的Classes"><a href="#混合XML-Groovy脚本和带注解的Classes" class="headerlink" title="混合XML,Groovy脚本和带注解的Classes"></a>混合XML,Groovy脚本和带注解的Classes</h5><p>有时可能需要混合使用 XML configuration files，Groovy 脚本和带注释的 classes(通常为<code>@Configuration</code> classes)来为测试配置<code>ApplicationContext</code>。例如，如果在 production 中使用 XML configuration，则可能决定要使用<code>@Configuration</code> classes 为测试配置特定的 Spring-managed 组件，反之亦然。</p>
<p>此外，一些 third-party 框架(例如 Spring Boot)提供 first-class 支持同时从不同类型的资源中加载<code>ApplicationContext</code>(例如，XML configuration files，Groovy 脚本和<code>@Configuration</code> classes)。历史上，Spring Framework 对标准部署不支持此功能。因此，Spring Framework 在<code>spring-test</code>模块中提供的大多数<code>SmartContextLoader</code> 实现只支持每个测试 context 的一种资源类型。但是，这并不意味着您不能同时使用两者。一般规则的一个例外是<code>GenericGroovyXmlContextLoader</code>和<code>GenericGroovyXmlWebContextLoader</code>同时支持 XML configuration files 和 Groovy 脚本。此外，third-party 框架可以选择支持<code>locations</code>和<code>classes</code>到<code>@ContextConfiguration</code>的声明，并且，通过 TestContext framework 中的标准测试支持，您有以下选项。</p>
<p>如果要使用资源位置(对于 example，XML 或 Groovy)和<code>@Configuration</code> classes 来配置测试，则必须选择一个作为入口点，并且必须包含或 import 另一个。例如，在 XML 或 Groovy 脚本中，您可以通过使用 component 扫描包含<code>@Configuration</code> classes 或将它们定义为普通的 Spring beans，而在<code>@Configuration</code> class 中，您可以使用<code>@ImportResource</code>来 import XML configuration files 或 Groovy 脚本。请注意，此行为在语义上等同于在 production 中配置 application 的方式：在 production configuration 中，您可以定义一组 XML 或 Groovy 资源位置，或者从中加载 production <code>ApplicationContext</code>的一组<code>@Configuration</code> classes，但是您仍然拥有自由包含或 import 其他类型的 configuration。</p>
<h5 id="使用Context初始化器配置Context"><a href="#使用Context初始化器配置Context" class="headerlink" title="使用Context初始化器配置Context"></a>使用Context初始化器配置Context</h5><p>要使用 context 初始化程序为测试配置<code>ApplicationContext</code>，请使用<code>@ContextConfiguration</code>注释 test class，并使用包含 references 的 array 配置<code>initializers</code>属性以实现<code>ApplicationContextInitializer</code>。然后使用声明的 context 初始值设定项初始化为测试加载的<code>ConfigurableApplicationContext</code>。请注意，每个声明的初始化程序支持的具体<code>ConfigurableApplicationContext</code>类型必须与正在使用的<code>SmartContextLoader</code>(通常为<code>GenericApplicationContext</code>)创建的<code>ApplicationContext</code>类型兼容。此外，调用初始值设定项的 order 取决于它们是实现 Spring 的<code>Ordered</code>接口还是使用 Spring 的<code>@Order</code> annotation 或标准<code>@Priority</code> annotation 注释。以下 example 显示了如何使用初始值设定项：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from TestConfig</span></span><br><span class="line"><span class="comment">// and initialized by TestAppCtxInitializer</span></span><br><span class="line"><span class="meta">@ContextConfiguration(</span></span><br><span class="line"><span class="meta">    classes = TestConfig.class,</span></span><br><span class="line"><span class="meta">    initializers = TestAppCtxInitializer.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用 configuration class 和初始化程序指定 configuration。</td>
</tr>
</tbody>
</table>
</div>
<p>你也可以在<code>@ContextConfiguration</code>中完全省略 XML configuration files，Groovy 脚本或带注释的 classes 的声明，而只是声明<code>ApplicationContextInitializer</code> classes，它们负责在 context 中注册 beans - for example，通过从 XML files 编程 loading bean 定义或 configuration classes。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be initialized by EntireAppInitializer</span></span><br><span class="line"><span class="comment">// which presumably registers beans in the context</span></span><br><span class="line"><span class="meta">@ContextConfiguration(initializers = EntireAppInitializer.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>仅使用初始化程序指定 configuration。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="Context配置继承"><a href="#Context配置继承" class="headerlink" title="Context配置继承"></a>Context配置继承</h5><p><code>@ContextConfiguration</code>支持 boolean <code>inheritLocations</code>和<code>inheritInitializers</code>属性，这些属性表示是否应继承资源位置或由超类声明的带注释的 classes 和 context 初始值设定项。两个标志的默认 value 是<code>true</code>。这意味着 test class 继承资源位置或带注释的 classes 以及任何超类声明的 context 初始值设定项。具体而言，test class 的资源位置或带注释的 classes 将附加到资源位置列表或超类声明的带注释的 classes。类似地，给定测试 class 的初始化器被添加到由测试超类定义的初始化器集合中。因此，子类可以选择扩展资源位置，带注释的 classes 或 context 初始值设定项。</p>
<p>如果<code>@ContextConfiguration</code>中的<code>inheritLocations</code>或<code>inheritInitializers</code>属性设置为<code>false</code>，则资源位置或带注释的 classes 和 context 初始值分别为 test class 阴影，并有效地替换超类定义的 configuration。</p>
<p>在下一个使用 XML 资源位置的 example 中，<code>ApplicationContext</code> for <code>ExtendedTest</code>是从<code>base-config.xml</code>和<code>extended-config.xml</code>加载到该 order 中的。因此，在<code>extended-config.xml</code>中定义的 Beans 可以覆盖(即替换)<code>base-config.xml</code>中定义的那些。以下 example 显示了一个 class 如何扩展另一个 class 并使用它自己的 configuration 文件和超类的 configuration 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from &quot;/base-config.xml&quot;</span></span><br><span class="line"><span class="comment">// in the root of the classpath</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/base-config.xml&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from &quot;/base-config.xml&quot; and</span></span><br><span class="line"><span class="comment">// &quot;/extended-config.xml&quot; in the root of the classpath</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/extended-config.xml&quot;)</span> (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>超类中定义的配置文件。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>子类中定义的配置文件。</td>
</tr>
</tbody>
</table>
</div>
<p>类似地，在使用带注释的 classes 的下一个 example 中，<code>ApplicationContext</code> for <code>ExtendedTest</code>是从<code>BaseConfig</code>和<code>ExtendedConfig</code> classes 中加载的，在 order 中。因此，在<code>ExtendedConfig</code>中定义的 Beans 可以覆盖(即替换)<code>BaseConfig</code>中定义的那些。以下 example 显示了一个 class 如何扩展另一个 class 并使用它自己的 configuration class 和超类的 configuration class：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from BaseConfig</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = BaseConfig.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from BaseConfig and ExtendedConfig</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = ExtendedConfig.class)</span> (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>Configuration class 在超类中定义。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Configuration class 在子类中定义。</td>
</tr>
</tbody>
</table>
</div>
<p>在使用 context 初始值设定项的下一个 example 中，使用<code>BaseInitializer</code>和<code>ExtendedInitializer</code>初始化<code>ApplicationContext</code> for <code>ExtendedTest</code>。但请注意，调用初始值设定项的 order 取决于它们是实现 Spring 的<code>Ordered</code>接口还是使用 Spring 的<code>@Order</code> annotation 或标准<code>@Priority</code> annotation 注释。下面的 example 显示了一个 class 如何扩展另一个 class 并使用它自己的初始化器和超类的初始化器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be initialized by BaseInitializer</span></span><br><span class="line"><span class="meta">@ContextConfiguration(initializers = BaseInitializer.class)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ApplicationContext will be initialized by BaseInitializer</span></span><br><span class="line"><span class="comment">// and ExtendedInitializer</span></span><br><span class="line"><span class="meta">@ContextConfiguration(initializers = ExtendedInitializer.class)</span> (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>初始化程序在超类中定义。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>初始化器在子类中定义。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="使用环境配置文件进行上下文配置"><a href="#使用环境配置文件进行上下文配置" class="headerlink" title="使用环境配置文件进行上下文配置"></a>使用环境配置文件进行上下文配置</h5><p>Spring 3.1 在 framework 中引入了 first-class 支持环境概念和 profiles(AKA“ bean definition profiles”)，并且 integration 测试可以配置为激活特定的 bean 定义 profiles 用于各种测试场景。这是通过使用<code>@ActiveProfiles</code> annotation 注释 test class 并提供_ _ofofiles 列表来实现的，这些 profiles 列表应该在为测试加载时激活。</p>
<blockquote>
<p>您可以将<code>@ActiveProfiles</code>用于新<code>SmartContextLoader</code> SPI 的任何 implementation，但<code>ContextLoader</code> SPI 的 implementations 不支持<code>@ActiveProfiles</code>。</p>
</blockquote>
<p>考虑使用 XML configuration 和<code>@Configuration</code> classes 的两个示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- app-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">&quot;http://www.springframework.org/schema/jee&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;com.bank.service.internal.DefaultTransferService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;accountRepository&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;feePolicy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountRepository&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;com.bank.repository.internal.JdbcAccountRepository&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;feePolicy&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;com.bank.service.internal.ZeroFeePolicy&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span></span></span><br><span class="line"><span class="tag">                <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span></span></span><br><span class="line"><span class="tag">                <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;production&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">jndi-name</span>=<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span></span></span><br><span class="line"><span class="tag">                <span class="attr">location</span>=<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// ApplicationContext will be loaded from &quot;classpath:/app-config.xml&quot;</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/app-config.xml&quot;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransferService transferService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test the transferService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>TransferServiceTest</code>是 run 时，它的<code>ApplicationContext</code>从 classpath 的根目录中的<code>app-config.xml</code> configuration 文件加载。如果检查<code>app-config.xml</code>，则可以看到<code>accountRepository</code> bean 依赖于<code>dataSource</code> bean。但是，<code>dataSource</code>未定义为 top-level bean。相反，<code>dataSource</code>被定义三次：在<code>production</code> profile 中，在<code>dev</code> profile 中，以及<code>default</code> profile 中。</p>
<p>通过使用<code>@ActiveProfiles(&quot;dev&quot;)</code>注释<code>TransferServiceTest</code>，我们指示 Spring TestContext Framework 加载<code>ApplicationContext</code>并将 active profiles 设置为<code>&#123;&quot;dev&quot;&#125;</code>。因此，创建嵌入式数据库并使用测试数据填充，<code>accountRepository</code> bean 与_re开发<code>DataSource</code>连接。这可能是我们在 integration 测试中想要的。</p>
<p>将 beans 分配给<code>default</code> profile 有时很有用。仅当没有专门激活其他 profile 时，才会包含默认 profile 中的 Beans。您可以使用它来定义要在 application 的默认 state 中使用的“fallback”beans。对于 example，您可以显式提供<code>dev</code>和<code>production</code> profiles 的数据源，但如果这两个数据源都不是 active，则将 in-memory 数据源定义为默认值。</p>
<p>以下 code 列表演示了如何使用<code>@Configuration</code> classes 而不是 XML 实现相同的 configuration 和 integration 测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandaloneDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/test-data.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JndiDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod=&quot;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="keyword">return</span> (DataSource) ctx.lookup(<span class="string">&quot;java:comp/env/jdbc/datasource&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;default&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultDataConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmbeddedDatabaseBuilder()</span><br><span class="line">            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class="line">            .addScript(<span class="string">&quot;classpath:com/bank/config/sql/schema.sql&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferServiceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultTransferService(accountRepository(), feePolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountRepository <span class="title">accountRepository</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcAccountRepository(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FeePolicy <span class="title">feePolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZeroFeePolicy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        TransferServiceConfig.class,</span></span><br><span class="line"><span class="meta">        StandaloneDataConfig.class,</span></span><br><span class="line"><span class="meta">        JndiDataConfig.class,</span></span><br><span class="line"><span class="meta">        DefaultDataConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransferService transferService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test the transferService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此变体中，我们将 XML configuration 拆分为四个独立的<code>@Configuration</code> classes：</p>
<ul>
<li><code>TransferServiceConfig</code>：使用<code>@Autowired</code>通过依赖注入获取<code>dataSource</code>。</li>
<li><code>StandaloneDataConfig</code>：为适合开发人员测试的嵌入式数据库定义<code>dataSource</code>。</li>
<li><code>JndiDataConfig</code>：定义在 production 环境中从 JNDI 检索的<code>dataSource</code>。</li>
<li><code>DefaultDataConfig</code>：如果没有 profile 是 active，则为默认的嵌入式数据库定义<code>dataSource</code>。</li>
</ul>
<p>与 XML-based configuration example 一样，我们仍然使用<code>@ActiveProfiles(&quot;dev&quot;)</code>注释<code>TransferServiceTest</code>，但是这个 time 我们使用<code>@ContextConfiguration</code> annotation 指定所有四个 configuration classes。测试 class 本身保持完全不变。</p>
<p>通常情况下，在给定项目中的多个 test classes 中使用一组 profiles。因此，为了避免<code>@ActiveProfiles</code> annotation 的重复声明，您可以在 base class 上声明<code>@ActiveProfiles</code>一次，并且子类自动从 base class 继承<code>@ActiveProfiles</code> configuration。在下面的示例中，<code>@ActiveProfiles</code>(以及其他 annotations)的声明已被移动到抽象超类<code>AbstractIntegrationTest</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;</span></span><br><span class="line"><span class="meta">        TransferServiceConfig.class,</span></span><br><span class="line"><span class="meta">        StandaloneDataConfig.class,</span></span><br><span class="line"><span class="meta">        JndiDataConfig.class,</span></span><br><span class="line"><span class="meta">        DefaultDataConfig.class&#125;)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;dev&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractIntegrationTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;dev&quot; profile inherited from superclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferServiceTest</span> <span class="keyword">extends</span> <span class="title">AbstractIntegrationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransferService transferService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// test the transferService</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@ActiveProfiles</code>还支持可用于禁用 active profiles 继承的<code>inheritProfiles</code>属性，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;dev&quot; profile overridden with &quot;production&quot;</span></span><br><span class="line"><span class="meta">@ActiveProfiles(profiles = &quot;production&quot;, inheritProfiles = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionTransferServiceTest</span> <span class="keyword">extends</span> <span class="title">AbstractIntegrationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span id="ActiveProfiles解析器"></span></p>
<p>此外，有时需要以编程方式而不是声明性地为测试解析 active profiles - 例如，基于：</p>
<ul>
<li>目前的操作系统。</li>
<li>是否在连续的 integration build 服务器上执行测试。</li>
<li>存在某些环境变量。</li>
<li>自定义 class-level 注释的存在。</li>
<li>其他问题。</li>
</ul>
<p>要以编程方式解析 active bean definition profiles，您可以实现自定义<code>ActiveProfilesResolver</code>并使用<code>@ActiveProfiles</code>的<code>resolver</code>属性进行注册。有关详细信息，请参阅相应的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/ActiveProfilesResolver.html">javadoc</a>。以下 example 演示了如何实现和注册自定义<code>OperatingSystemActiveProfilesResolver</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bank.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;dev&quot; profile overridden programmatically via a custom resolver</span></span><br><span class="line"><span class="meta">@ActiveProfiles(</span></span><br><span class="line"><span class="meta">    resolver = OperatingSystemActiveProfilesResolver.class,</span></span><br><span class="line"><span class="meta">    inheritProfiles = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferServiceTest</span> <span class="keyword">extends</span> <span class="title">AbstractIntegrationTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.bank.service.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatingSystemActiveProfilesResolver</span> <span class="keyword">implements</span> <span class="title">ActiveProfilesResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String[] resolve(Class&lt;?&gt; testClass) &#123;</span><br><span class="line">        String profile = ...;</span><br><span class="line">        <span class="comment">// determine the value of profile based on the operating system</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;profile&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用测试Property资源配置Context"><a href="#使用测试Property资源配置Context" class="headerlink" title="使用测试Property资源配置Context"></a>使用测试Property资源配置Context</h5><p>Spring 3.1 在 framework 中引入了 first-class 支持，用于具有 property 源层次结构的环境的概念。从 Spring 4.1 开始，您可以使用 test-specific property 源配置 integration 测试。与<code>@Configuration</code> classes 上使用的<code>@PropertySource</code> annotation 相比，您可以在 test class 上声明<code>@TestPropertySource</code> annotation，以声明 test properties files 或 inlined properties 的资源位置。这些测试 property 源被添加到<code>Environment</code>中<code>PropertySources</code>的集合中，用于为注释的 integration 测试加载的<code>ApplicationContext</code>。</p>
<blockquote>
<p>您可以将<code>@TestPropertySource</code>与<code>SmartContextLoader</code> SPI 的任何 implementation 一起使用，但<code>ContextLoader</code> SPI 的 implementations 不支持<code>@TestPropertySource</code>。</p>
</blockquote>
<p>的实现通过<code>MergedContextConfiguration</code>中的<code>getPropertySourceLocations()</code>和<code>getPropertySourceProperties()</code>方法获得对合并的测试属性源值的访问。</p>
<h6 id="声明测试属性来源"><a href="#声明测试属性来源" class="headerlink" title="声明测试属性来源"></a>声明测试属性来源</h6><p>您可以使用<code>@TestPropertySource</code>的<code>locations</code>或<code>value</code>属性配置 test properties files。</p>
<p>支持传统和 XML-based properties 文件格式 - 例如，<code>&quot;classpath:/com/example/test.properties&quot;</code>或<code>&quot;file:///path/to/file.xml&quot;</code>。</p>
<p>每个路径都被解释为 Spring <code>Resource</code>。普通路径(对于 example，<code>&quot;test.properties&quot;</code>)被视为 classpath 资源，该资源相对于定义 test class 的包。以斜杠开头的路径被视为绝对 classpath 资源(对于 example：<code>&quot;/org/example/test.xml&quot;</code>)。使用指定的资源协议加载 references URL(对于 example，前缀为<code>classpath:</code>，<code>file:</code>或<code>http:</code>的路径)的路径。不允许使用资源位置通配符(例如<code>*/.properties</code>)：每个位置必须仅评估一个<code>.properties</code>或<code>.xml</code>资源。</p>
<p>以下 example 使用 test properties 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestPropertySource(&quot;/test.properties&quot;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用绝对路径指定 properties 文件。</td>
</tr>
</tbody>
</table>
</div>
<p>您可以使用<code>@TestPropertySource</code>的<code>properties</code>属性以 key-value 对的形式配置内联 properties，如下一个 example 所示。所有 key-value 对都作为具有最高优先级的单个测试<code>PropertySource</code>添加到封闭的<code>Environment</code>中。</p>
<p>key-value 对支持的语法与为 Java properties 文件中的条目定义的语法相同：</p>
<ul>
<li><code>key=value</code></li>
<li><code>key:value</code></li>
<li><code>key value</code></li>
</ul>
<p>以下 example sets 两个内联 properties：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &#123;&quot;timezone = GMT&quot;, &quot;port: 4242&quot;&#125;)</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>使用 key-value 语法的两个变体设置两个 properties。</td>
</tr>
</tbody>
</table>
</div>
<h6 id="默认Properties文件检测"><a href="#默认Properties文件检测" class="headerlink" title="默认Properties文件检测"></a>默认Properties文件检测</h6><p>如果将<code>@TestPropertySource</code>声明为空 annotation(即，没有<code>locations</code>或<code>properties</code>属性的显式值)，则会尝试检测相对于声明 annotation 的 class 的默认 properties 文件。例如，如果带注释的测试 class 为<code>com.example.MyTest</code>，则相应的默认 properties 文件为<code>classpath:com/example/MyTest.properties</code>。如果无法检测到默认值，则抛出<code>IllegalStateException</code>。</p>
<h6 id="优先"><a href="#优先" class="headerlink" title="优先"></a>优先</h6><p>测试 property 源的优先级高于从操作系统环境加载的源，Java 系统 properties 或_appperty 源由 application 以声明方式使用<code>@PropertySource</code>或以编程方式添加。因此，test property 源可用于有选择地覆盖 system 和 application property 源中定义的 properties。此外，内联 properties 的优先级高于从资源位置加载的 properties。</p>
<p>在下一个示例中，<code>&quot;/test.properties&quot;</code>和<code>port</code> properties 以及<code>&quot;/test.properties&quot;</code>中定义的任何 properties 都会覆盖在 system 和 application property 源中定义的同一 name 的任何 properties。此外，如果<code>&quot;/test.properties&quot;</code>文件定义了<code>timezone</code>和<code>port</code> properties 的条目，那么这些条目将被使用<code>properties</code>属性声明的内联 properties 覆盖。以下 example 显示了如何在文件和内联中指定 properties：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@TestPropertySource(</span></span><br><span class="line"><span class="meta">    locations = &quot;/test.properties&quot;,</span></span><br><span class="line"><span class="meta">    properties = &#123;&quot;timezone = GMT&quot;, &quot;port: 4242&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIntegrationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class body...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="继承和覆盖测试PropertySources"><a href="#继承和覆盖测试PropertySources" class="headerlink" title="继承和覆盖测试PropertySources"></a>继承和覆盖测试PropertySources</h6><p><code>@TestPropertySource</code>支持 boolean <code>inheritLocations</code>和<code>inheritProperties</code>属性，表示是否应继承 properties files 和超类声明的内联 properties 的资源位置。两个标志的默认 value 是<code>true</code>。这意味着 test class 继承了任何超类声明的位置和内联 properties。具体来说，test class 的位置和内联 properties 将附加到超类声明的位置和内联 properties。因此，子类可以选择扩展位置和内联 properties。请注意，后面出现的 properties 会影响(即覆盖)之前出现的同一 name 的 properties。此外，上述优先规则也适用于继承的 test property 源。</p>
<p>如果<code>@TestPropertySource</code>中的<code>inheritLocations</code>或<code>inheritProperties</code>属性设置为<code>false</code>，则分别为 test class 阴影的位置或内联 properties，并有效地替换超类定义的 configuration。</p>
<p>在下一个 example 中，<code>BaseTest</code> for <code>BaseTest</code>是仅使用<code>base.properties</code>文件作为 test property 源加载的。相反，使用<code>base.properties</code>和<code>extended.properties</code> files 作为 test property 源位置来加载<code>ApplicationContext</code> for <code>ExtendedTest</code>。以下 example 显示了如何使用<code>properties</code> files 在子类及其超类中定义 properties：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestPropertySource(&quot;base.properties&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestPropertySource(&quot;extended.properties&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下一个 example 中，<code>BaseTest</code> for <code>BaseTest</code>仅使用内联的<code>key1</code> property 加载。相反，<code>ApplicationContext</code> for <code>ExtendedTest</code>是使用内联<code>key1</code>和<code>key2</code> properties 加载的。以下 example 显示了如何使用内联 properties 在子类及其超类中定义 properties：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestPropertySource(properties = &quot;key1 = value1&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@TestPropertySource(properties = &quot;key2 = value2&quot;)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTest</span> <span class="keyword">extends</span> <span class="title">BaseTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="加载WebApplicationContext"><a href="#加载WebApplicationContext" class="headerlink" title="加载WebApplicationContext"></a>加载WebApplicationContext</h5><p>Spring 3.2 在 integration 测试中引入了的支持。要指示 TestContext framework 加载<code>WebApplicationContext</code>而不是标准<code>ApplicationContext</code>，您可以使用<code>@WebAppConfiguration</code>注释相应的 test class。</p>
<p>测试 class 上存在<code>@WebAppConfiguration</code>指示 TestContext framework(TCF)应该为 integration 测试加载<code>WebApplicationContext</code>(WAC)。在后台，TCF 确保创建<code>MockServletContext</code>并将其提供给测试的 WAC。默认情况下，<code>MockServletContext</code>的基本资源路径设置为<code>src/main/webapp</code>。这被解释为相对于 JVM 根目录的路径(通常是项目的路径)。如果您熟悉 Maven 项目中 web application 的目录结构，则您知道<code>src/main/webapp</code>是 WAR 根目录的默认位置。如果需要覆盖此默认值，则可以提供<code>@WebAppConfiguration</code> annotation 的备用路径(对于 example，<code>@WebAppConfiguration(&quot;src/test/webapp&quot;)</code>)。如果您希望从 classpath 而不是文件系统引用基本资源路径，则可以使用 Spring 的<code>classpath:</code>前缀。</p>
<p>请注意，Spring 对<code>WebApplicationContext</code> implementations 的测试支持与其对标准<code>ApplicationContext</code> implementations 的支持相同。使用<code>WebApplicationContext</code>进行测试时，可以使用<code>@ContextConfiguration</code>自由声明 XML configuration files，Groovy 脚本或<code>@Configuration</code> classes。您也可以自由使用任何其他测试注释，例如<code>@ActiveProfiles</code>，<code>@TestExecutionListeners</code>，<code>@Sql</code>，<code>@Rollback</code>等。</p>
<p>本节中的其余示例显示了的各种 configuration 选项。以下 example 显示了 TestContext framework 对_coniguration 约定的支持：</p>
<p>例 1.公约</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// defaults to &quot;file:src/main/webapp&quot;</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// detects &quot;WacTests-context.xml&quot; in the same package</span></span><br><span class="line"><span class="comment">// or static nested @Configuration classes</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WacTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用<code>@WebAppConfiguration</code>注释测试 class 而未指定资源基路径，则资源路径有效地默认为<code>file:src/main/webapp</code>。同样，如果在未指定资源<code>locations</code>，带注释的<code>classes</code>或 context <code>initializers</code>的情况下声明<code>@ContextConfiguration</code>，则 Spring 会尝试使用约定(即与<code>WacTests</code> class 或静态嵌套<code>@Configuration</code> classes 相同的包中的<code>WacTests-context.xml</code>)检测 configuration 的存在。</p>
<p>以下 example 显示了如何使用<code>@WebAppConfiguration</code>显式声明资源基本路径以及使用<code>@ContextConfiguration</code>显示 XML 资源位置：</p>
<p>Example 2.默认资源语义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file system resource</span></span><br><span class="line"><span class="meta">@WebAppConfiguration(&quot;webapp&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// classpath resource</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;/spring/test-servlet-config.xml&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WacTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意的重要一点是_path 与这两个注释的不同语义。默认情况下，<code>@WebAppConfiguration</code> resource paths 是基于文件系统的，而<code>@ContextConfiguration</code>资源位置是基于 classpath 的。</p>
<p>以下 example 显示我们可以通过指定 Spring 资源前缀来覆盖两个 annotations 的默认资源语义：</p>
<p>Example 3.显式资源语义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// classpath resource</span></span><br><span class="line"><span class="meta">@WebAppConfiguration(&quot;classpath:test-web-resources&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file system resource</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;file:src/main/webapp/WEB-INF/servlet-config.xml&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WacTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将此 example 中的 comments 与前一个 example 对比。</p>
<p>使用 Web Mocks</p>
<p>为了提供全面的 web 测试支持，Spring 3.2 引入了默认启用的<code>ServletTestExecutionListener</code>。在针对<code>WebApplicationContext</code>进行测试时，在每个测试方法之前使用 Spring Web 的<code>RequestContextHolder</code>来设置<a href="#TestExecutionListener">TestExecutionListener</a> state 默认 thread-local state，并根据使用<code>@WebAppConfiguration</code>配置的基本资源路径创建<code>MockHttpServletRequest</code>，<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>。 <code>ServletTestExecutionListener</code>还确保可以将<code>MockHttpServletResponse</code>和<code>ServletWebRequest</code>注入到测试实例中，并且一旦测试完成，它就会清除 thread-local state。</p>
<p>一旦为测试加载<code>WebApplicationContext</code>，您可能会发现需要与 web 模拟进行交互 - 例如，设置测试夹具或在调用 web component 后执行断言。以下 example 显示哪些模拟可以自动连接到您的测试实例中。请注意，<code>WebApplicationContext</code>和<code>MockServletContext</code>都在测试套件中缓存，而其他模拟由<code>ServletTestExecutionListener</code>按照测试方法进行管理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitWebConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WacTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    WebApplicationContext wac; <span class="comment">// cached</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MockServletContext servletContext; <span class="comment">// cached</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MockHttpSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MockHttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MockHttpServletResponse response;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ServletWebRequest webRequest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Context缓存"><a href="#Context缓存" class="headerlink" title="Context缓存"></a>Context缓存</h5><p>一旦 TestContext framework 为测试加载<code>ApplicationContext</code>(或<code>WebApplicationContext</code>)，该 context 就会被缓存并重用于在同一测试套件中声明相同唯一 context configuration 的所有后续测试。要了解缓存的工作原理，了解“独特”和“测试套件”的含义非常重要。</p>
<p>可以通过用于加载它的 configuration 参数的组合来唯一标识。因此，configuration 参数的唯一组合用于生成 key，高速缓存 context。 TestContext framework 使用以下 configuration 参数来 build context cache key：</p>
<ul>
<li><code>locations</code>(来自<code>@ContextConfiguration</code>)</li>
<li><code>classes</code>(来自<code>@ContextConfiguration</code>)</li>
<li><code>contextInitializerClasses</code>(来自<code>@ContextConfiguration</code>)</li>
<li><code>contextCustomizers</code>(来自<code>ContextCustomizerFactory</code>)</li>
<li><code>contextLoader</code>(来自<code>@ContextConfiguration</code>)</li>
<li><code>parent</code>(来自<code>@ContextHierarchy</code>)</li>
<li><code>activeProfiles</code>(来自<code>@ActiveProfiles</code>)</li>
<li><code>propertySourceLocations</code>(来自<code>@TestPropertySource</code>)</li>
<li><code>propertySourceProperties</code>(来自<code>@TestPropertySource</code>)</li>
<li><code>resourceBasePath</code>(来自<code>@WebAppConfiguration</code>)</li>
</ul>
<p>例如，如果<code>TestClassA</code>为<code>@ContextConfiguration</code>的<code>locations</code>(或<code>value</code>)属性指定<code>&#123;&quot;app-config.xml&quot;, &quot;test-config.xml&quot;&#125;</code>，则 TestContext framework 将相应的<code>ApplicationContext</code>和 store 加载到仅基于这些位置的 key 下的<code>static</code> context 缓存中。因此，如果<code>TestClassB</code>也为其位置定义了<code>&#123;&quot;app-config.xml&quot;, &quot;test-config.xml&quot;&#125;</code>(通过继承显式或隐式)但没有定义<code>@WebAppConfiguration</code>，不同的<code>ContextLoader</code>，不同的 active profiles，不同的 context 初始化器，不同的 test property 源或不同的 parent context，那么相同<code>ApplicationContext</code>由两个 test classes 共享。这意味着 loading application context 的设置成本仅产生一次(每个测试套件)，后续测试执行速度要快得多。</p>
<blockquote>
<p>测试套件和分叉流程</p>
</blockquote>
<p>Spring TestContext framework stores application 上下文在静态缓存中。这意味着 context 实际上存储在<code>static</code>变量中。换句话说，如果测试在单独的进程中执行，则在每次测试执行之间清除静态高速缓存，这有效地禁用了高速缓存机制。</p>
<p>要从缓存机制中受益，所有测试必须在同一个 process 或测试套件中运行。这可以通过在 IDE 中作为 group 执行所有测试来实现。类似地，当使用_bum framework(例如 Ant，Maven 或 Gradle)执行测试时，确保 build framework 不会在测试之间进行分配是很重要的。例如，如果 Maven Surefire plug-in 的<a target="_blank" rel="noopener" href="https://maven.apache.org/plugins/maven-surefire-plugin/test-mojo.html#testcontext-key-abstractions">forkMode</a>设置为<code>always</code>或<code>pertest</code>，则 TestContext framework 无法在 test classes 之间缓存 application 上下文，因此 build process 的运行速度明显更慢。</p>
<p>从 Spring Framework 4.3 开始，context 缓存的大小受限于默认的最大大小 32.每当达到最大大小时，最近最少使用(LRU)驱逐 policy 用于驱逐和关闭陈旧的上下文。您可以通过设置名为<code>spring.test.context.cache.maxSize</code>的 JVM 系统 property，从命令 line 或 build 脚本配置最大大小。或者，您可以使用<code>SpringProperties</code> API 以编程方式设置相同的 property。</p>
<p>由于在给定的测试套件中加载了大量的 application 上下文会导致套件执行不必要的 long time 执行，因此确切地知道已经加载和缓存了多少个上下文通常是有益的。要查看基础 context 缓存的统计信息，可以将<code>org.springframework.test.context.cache</code> logging 类别的 log level 设置为<code>DEBUG</code>。</p>
<p>在不太可能的情况下，测试会破坏 application context 并需要重新加载(例如，通过修改 bean 定义或 application object 的 state)，您可以使用<code>@DirtiesContext</code>注解 test class 或 test 方法(请参阅<code>@DirtiesContext</code>的讨论) <a href="#DirtiesContext注解">Spring Testing Annotations</a>)。这指示 Spring 从缓存中删除 context 并在 running 下一个测试之前重建 application context。请注意，<code>DirtiesContextBeforeModesTestExecutionListener</code>和<code>DirtiesContextTestExecutionListener</code>提供了对<code>@DirtiesContext</code> annotation 的支持，这些默认情况下已启用。</p>
<h5 id="Context层次结构"><a href="#Context层次结构" class="headerlink" title="Context层次结构"></a>Context层次结构</h5><p>在编写依赖于加载的 Spring <code>ApplicationContext</code>的 integration 测试时，通常可以对单个 context 进行测试。但是，有时候对<code>ApplicationContext</code>实例的层次结构进行测试是有益的，甚至是必要的。例如，如果你正在开发一个 Spring MVC web application，你通常会有一个由 Spring 的<code>ContextLoaderListener</code>加载的<code>WebApplicationContext</code>和一个由 Spring 的<code>DispatcherServlet</code>加载的 child <code>WebApplicationContext</code>。这会产生 parent-child context 层次结构，其中共享组件和基础结构 configuration 在根 context 中声明，并在 child context 中由 web-specific 组件使用。另一个用例可以在 Spring Batch applications 中找到，其中您经常有一个 parent context 为共享批处理基础结构提供 configuration，而 child context 用于 configuration 特定批处理 job。</p>
<p>从 Spring Framework 3.2.2 开始，您可以通过在单个 test class 或 test class 层次结构中使用<code>@ContextHierarchy</code> annotation 声明 context configuration 来编写使用 context 层次结构的 integration 测试。如果在 test class 层次结构中的多个 classes 上声明 context 层次结构，则还可以合并或覆盖 context 层次结构中特定的名为 level 的 context configuration。合并层次结构中给定 level 的 configuration 时，configuration 资源类型(即 XML configuration files 或 annotated classes)必须一致。否则，在使用不同资源类型配置的 context 层次结构中具有不同的级别是完全可以接受的。</p>
<p>本节中剩余的 JUnit 4-based 示例显示了需要使用 context 层次结构的 integration 测试的 common configuration 方案。</p>
<p>使用 context 层次结构单个测试 class</p>
<p><code>ControllerIntegrationTests</code>表示 Spring MVC web application 的典型 integration 测试场景，声明 context 层次结构包含两个级别，一个用于根<code>WebApplicationContext</code>(使用<code>TestAppConfig</code> <code>@Configuration</code> class 加载)，另一个用于调度程序 servlet <code>WebApplicationContext</code>(通过使用<code>WebConfig</code> <code>@Configuration</code> class)。自动装入测试实例的<code>WebApplicationContext</code>是 child context(即层次结构中最低的 context)的<code>WebApplicationContext</code>。以下清单显示了此 configuration 方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(classes = TestAppConfig.class),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(classes = WebConfig.class)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ControllerIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具有隐式 parent context 的 Class 层次结构</p>
<p>此 example 中的测试 classes 在 test class 层次结构中定义 context 层次结构。 <code>AbstractWebTests</code>在 Spring-powered web application 中声明了根<code>WebApplicationContext</code>的 configuration。但请注意，<code>AbstractWebTests</code>未声明<code>@ContextHierarchy</code>。因此，<code>AbstractWebTests</code>的子类可以选择参与 context 层次结构或遵循<code>@ContextConfiguration</code>的标准语义。 <code>SoapWebServiceTests</code>和<code>RestWebServiceTests</code>都扩展<code>AbstractWebTests</code>并使用<code>@ContextHierarchy</code>定义 context 层次结构。结果是加载了三个 application 上下文(每个<code>@ContextConfiguration</code>声明一个)，并且基于<code>AbstractWebTests</code>中的 configuration 加载的 application context 被设置为为具体子类加载的每个上下文的 parent context。以下清单显示了此 configuration 方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;file:src/main/webapp/WEB-INF/applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWebTests</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextHierarchy(@ContextConfiguration(&quot;/spring/soap-ws-config.xml&quot;)</span></span><br><span class="line"><span class="meta">public class SoapWebServiceTests extends AbstractWebTests &#123;&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">@ContextHierarchy(@ContextConfiguration(&quot;/spring/rest-ws-config.xml&quot;)</span></span><br><span class="line"><span class="meta">public class RestWebServiceTests extends AbstractWebTests &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>具有合并 context 层次结构 configuration 的 Class 层次结构</p>
<p>此 example 中的 classes 显示在 order 中使用命名层次结构级别来合并 context 层次结构中特定级别的 configuration。 <code>BaseTests</code>在层次结构中定义了两个级别<code>parent</code>和<code>child</code>。 <code>ExtendedTests</code>扩展<code>BaseTests</code>并指示 Spring TestContext Framework 合并<code>child</code>层次 level 的 context configuration，方法是确保<code>@ContextConfiguration</code>中<code>name</code>属性中声明的名称都是<code>child</code>。结果是加载了三个 application 上下文：一个用于<code>/app-config.xml</code>，一个用于<code>/user-config.xml</code>，一个用于<code>&#123;&quot;/user-config.xml&quot;, &quot;/order-config.xml&quot;&#125;</code>。与前面的 example 一样，从<code>/app-config.xml</code>加载的 application context 被设置为从<code>/user-config.xml</code>和<code>&#123;&quot;/user-config.xml&quot;, &quot;/order-config.xml&quot;&#125;</code>加载的上下文的 parent context。以下清单显示了此 configuration 方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(name = &quot;parent&quot;, locations = &quot;/app-config.xml&quot;),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/user-config.xml&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTests</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextHierarchy(</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/order-config.xml&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTests</span> <span class="keyword">extends</span> <span class="title">BaseTests</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>具有重写 context 层次结构 configuration 的 Class 层次结构</p>
<p>与前面的示例相比，此 example 演示了如何通过将<code>@ContextConfiguration</code>中的<code>inheritLocations</code> flag 设置为<code>false</code>来覆盖 context 层次结构中给定命名 level 的 configuration。因此，<code>ExtendedTests</code>的 application context 仅从<code>/test-user-config.xml</code>加载，并且 parent 设置为从<code>/app-config.xml</code>加载的 context。以下清单显示了此 configuration 方案：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextHierarchy(&#123;</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(name = &quot;parent&quot;, locations = &quot;/app-config.xml&quot;),</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(name = &quot;child&quot;, locations = &quot;/user-config.xml&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseTests</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextHierarchy(</span></span><br><span class="line"><span class="meta">    @ContextConfiguration(</span></span><br><span class="line"><span class="meta">        name = &quot;child&quot;,</span></span><br><span class="line"><span class="meta">        locations = &quot;/test-user-config.xml&quot;,</span></span><br><span class="line"><span class="meta">        inheritLocations = false</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendedTests</span> <span class="keyword">extends</span> <span class="title">BaseTests</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 context 层次结构中消除 context 如果在 context 配置为 context 层次结构的一部分的测试中使用<code>@DirtiesContext</code>，则可以使用<code>hierarchyMode</code> flag 来控制 context 缓存的清除方式。有关更多详细信息，请参阅<a href="#DirtiesContext注解">Spring Testing Annotations</a>中的<code>@DirtiesContext</code>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/annotation/DirtiesContext.html">@DirtiesContext</a> javadoc 的讨论。</p>
</blockquote>
<h4 id="测试fixture的依赖注入"><a href="#测试fixture的依赖注入" class="headerlink" title="测试fixture的依赖注入"></a>测试fixture的依赖注入</h4><p>当您使用<code>DependencyInjectionTestExecutionListener</code>(默认配置)时，测试实例的依赖项将从您使用<code>@ContextConfiguration</code>配置的 application context 中的 beans 注入。您可以使用 setter injection，field injection 或两者，具体取决于您选择的注释以及是否将它们放在 setter 方法或字段上。为了与 Spring 2.5 和 3.0 中引入的 annotation 支持保持一致，您可以使用 Spring 的<code>@Autowired</code> annotation 或 JSR 330 中的<code>@Inject</code> annotation。</p>
<blockquote>
<p>TestContext framework 没有检测实例化测试实例的方式。因此，对构造函数使用<code>@Autowired</code>或<code>@Inject</code>对 test classes 没有影响。</p>
</blockquote>
<p>因为<code>@Autowired</code>用于执行<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#自动化协作者">按类型自动装配</a>，如果您有多个相同类型的 bean 定义，则不能依赖此方法来处理这些特定的 beans。在这种情况下，您可以将<code>@Autowired</code>与<code>@Qualifier</code>结合使用。从 Spring 3.0 开始，您也可以选择将<code>@Inject</code>与<code>@Named</code>结合使用。或者，如果您的 test class 可以访问其<code>ApplicationContext</code>，则可以使用(for example)调用<code>applicationContext.getBean(&quot;titleRepository&quot;)</code>来执行显式查找。</p>
<p>如果您不希望将依赖项注入应用于测试实例，请不要使用<code>@Autowired</code>或<code>@Inject</code>注释字段或 setter 方法。或者，您可以通过使用<code>@TestExecutionListeners</code>显式配置 class 并从 listeners 列表中省略<code>DependencyInjectionTestExecutionListener.class</code>来完全禁用依赖项注入。</p>
<p>考虑测试<code>HibernateTitleRepository</code> class 的场景，如<a href="#集成测试的目标">目标</a>部分所述。接下来的两个 code 列表演示了在字段和 setter 方法上使用<code>@Autowired</code>。 application context configuration 在所有 sample code 列表之后显示。</p>
<blockquote>
<p>以下 code 列表中的依赖项注入行为并非特定于 JUnit 4.相同的 DI 技术可以与任何测试 framework 一起使用。</p>
</blockquote>
<p>以下示例将 calls 设置为静态断言方法，例如<code>assertNotNull()</code>，但不使用<code>Assert</code>预先调用。在这种情况下，假设该方法是通过_示例中未显示的<code>import static</code>声明正确导入的。</p>
<p>第一个 code 列表显示了一个基于 JUnit 4 的_Ilass 实现，它使用<code>@Autowired</code>进行字段注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// specifies the Spring configuration to load for this test fixture</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;repository-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateTitleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this instance will be dependency injected by type</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HibernateTitleRepository titleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Title title = titleRepository.findById(<span class="keyword">new</span> Long(<span class="number">10</span>));</span><br><span class="line">        assertNotNull(title);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，您可以将 class 配置为使用<code>@Autowired</code>进行 setter 注入，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="comment">// specifies the Spring configuration to load for this test fixture</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;repository-config.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateTitleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this instance will be dependency injected by type</span></span><br><span class="line">    <span class="keyword">private</span> HibernateTitleRepository titleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitleRepository</span><span class="params">(HibernateTitleRepository titleRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.titleRepository = titleRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Title title = titleRepository.findById(<span class="keyword">new</span> Long(<span class="number">10</span>));</span><br><span class="line">        assertNotNull(title);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 code 列表使用<code>@ContextConfiguration</code> annotation 引用的相同 XML context 文件(即<code>repository-config.xml</code>)。以下显示了此 configuration：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- this bean will be injected into the HibernateTitleRepositoryTests class --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;titleRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.repository.hibernate.HibernateTitleRepository&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sessionFactory&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- configuration elided for brevity --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果从正在其中一个 setter 方法上使用<code>@Autowired</code>的 Spring-provided test base class 进行扩展，则可能在 application context 中定义了多个受影响类型的 beans(对于 example，多个<code>DataSource</code> beans)。在这种情况下，您可以覆盖 setter 方法并使用<code>@Qualifier</code> annotation 来指示特定的目标 bean，如下所示(但请确保也委托给超类中的重写方法)：</p>
</blockquote>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Override</span><br><span class="line">    public <span class="keyword">void</span> setDataSource(@Qualifier(<span class="string">&quot;myDataSource&quot;</span>) DataSource dataSource) &#123;</span><br><span class="line">        <span class="keyword">super</span><span class="variable">.setDataSource</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>指定的限定符 value 表示特定的<code>DataSource</code> bean 到 inject，将类型匹配集缩小到特定的 bean。它的 value 与相应<code>&lt;bean&gt;</code>定义中的<code>&lt;qualifier&gt;</code>声明匹配。 bean name 用作回退限定符 value，因此您还可以有效地指向 name by name(如前所示，假设<code>myDataSource</code>是 bean <code>id</code>)。</p>
<h4 id="测试Request和Session-scopedBeans"><a href="#测试Request和Session-scopedBeans" class="headerlink" title="测试Request和Session-scopedBeans"></a>测试Request和Session-scopedBeans</h4><p>Spring 从早年就开始支持<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Request，Session，Application和WebSocketScopes">请求 - 和 session-scoped beans</a>。从 Spring 3.2 开始，您可以按照以下步骤测试 request-scoped 和 session-scoped beans：</p>
<ul>
<li>通过使用<code>@WebAppConfiguration</code>注释 test class，确保为测试加载了<code>WebApplicationContext</code>。</li>
<li>将 mock 请求或 session 注入测试实例并根据需要准备测试夹具。</li>
<li>调用从配置的<code>WebApplicationContext</code>中检索到的 web component(带依赖注入)。</li>
<li>对模拟执行断言。</li>
</ul>
<p>下一个 code 代码段显示了登录用例的 XML configuration。请注意，<code>userService</code> bean 依赖于 request-scoped <code>loginAction</code> bean。此外，<code>LoginAction</code>通过使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/24/SpringFramework官方文档翻译-核心/#Spring表达语言SpEL">SpEL 表达式</a>来实例化，该SpEL 表达式从当前 HTTP 请求中检索用户名和密码。在我们的测试中，我们希望通过 TestContext framework 管理的 mock 配置这些请求参数。以下清单显示了此用例的 configuration：</p>
<p>Example 5. Request-scoped bean configuration</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SimpleUserService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">c:loginAction-ref</span>=<span class="string">&quot;loginAction&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.LoginAction&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">c:username</span>=<span class="string">&quot;#&#123;request.getParameter(&#x27;user&#x27;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">c:password</span>=<span class="string">&quot;#&#123;request.getParameter(&#x27;pswd&#x27;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>RequestScopedBeanTests</code>中，我们将<code>UserService</code>(即被测试对象)和<code>MockHttpServletRequest</code>都注入到我们的测试实例中。在我们的<code>requestScope()</code>测试方法中，我们通过在提供的<code>MockHttpServletRequest</code>中设置请求参数来设置我们的测试夹具。当我们在<code>userService</code>上调用<code>loginUser()</code>方法时，我们可以确保用户服务可以访问当前<code>MockHttpServletRequest</code>的 request-scoped <code>loginAction</code>(也就是我们刚刚设置参数的那个)。然后，我们可以根据用户名和密码的已知输入对结果执行断言。以下清单显示了如何执行此操作：</p>
<p>Example 6. Request-scoped bean test</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestScopedBeanTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span> MockHttpServletRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestScope</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        request.setParameter(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;enigma&quot;</span>);</span><br><span class="line">        request.setParameter(<span class="string">&quot;pswd&quot;</span>, <span class="string">&quot;$pr!ng&quot;</span>);</span><br><span class="line"></span><br><span class="line">        LoginResults results = userService.loginUser();</span><br><span class="line">        <span class="comment">// assert results</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下 code 代码段类似于我们之前为 request-scoped bean 看到的代码片段。但是，这个 time，<code>userService</code> bean 依赖于 session-scoped <code>userPreferences</code> bean。请注意，<code>UserPreferences</code> bean 是使用 SpEL 表达式实例化的，该表达式从当前 HTTP session 中检索主题。在我们的测试中，我们需要在 TestContext framework 管理的 mock session 中配置主题。以下 example 显示了如何执行此操作：</p>
<p>例 7. Session-scoped bean configuration</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.SimpleUserService&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">c:userPreferences-ref</span>=<span class="string">&quot;userPreferences&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserPreferences&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">c:theme</span>=<span class="string">&quot;#&#123;session.getAttribute(&#x27;theme&#x27;)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:scoped-proxy</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>SessionScopedBeanTests</code>中，我们将<code>UserService</code>和<code>MockHttpSession</code>注入到我们的测试实例中。在我们的<code>sessionScope()</code>测试方法中，我们通过在提供的<code>MockHttpSession</code>中设置预期的<code>theme</code>属性来设置我们的测试夹具。当我们在<code>userService</code>上调用<code>processUserPreferences()</code>方法时，我们确信用户服务可以访问当前<code>MockHttpSession</code>的 session-scoped <code>userPreferences</code>，并且我们可以根据配置的主题对结果执行断言。以下 example 显示了如何执行此操作：</p>
<p>例 8. Session-scoped bean 测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionScopedBeanTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span> MockHttpSession session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionScope</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.setAttribute(<span class="string">&quot;theme&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Results results = userService.processUserPreferences();</span><br><span class="line">        <span class="comment">// assert results</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><p>在 TestContext framework 中，transactions 由<code>TransactionalTestExecutionListener</code>管理，默认情况下配置<code>TransactionalTestExecutionListener</code>，即使您没有在 test class 上显式声明<code>@TestExecutionListeners</code>。但是，要启用对 transactions 的支持，必须在<code>ApplicationContext</code>中配置<code>PlatformTransactionManager</code> bean，并加载<code>@ContextConfiguration</code>语义(稍后会提供更多详细信息)。此外，您必须在 class 或方法 level 中为测试声明 Spring 的<code>@Transactional</code> annotation。</p>
<h5 id="Test-managed事物"><a href="#Test-managed事物" class="headerlink" title="Test-managed事物"></a>Test-managed事物</h5><p>Test-managed transactions 是 transactions，通过使用<code>TransactionalTestExecutionListener</code>以编程方式管理，或者使用<code>TestTransaction</code>(稍后描述)以编程方式管理。你不应该将这样的 transactions 与 Spring-managed transactions(由<code>ApplicationContext</code>加载的 Spring 直接管理的测试)或 application-managed transactions(那些由测试调用的 application code 中以编程方式管理的那些)混淆。 Spring-managed 和 application-managed transactions 通常参与 test-managed transactions。但是，如果 Spring-managed 或 application-managed transactions 配置了除<code>REQUIRED</code>或<code>SUPPORTS</code>之外的任何传播类型，则应谨慎使用(有关详细信息，请参阅有关<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-数据访问/#Transaction传播">transaction 传播</a>的讨论)。</p>
<h5 id="启用和禁用Transactions"><a href="#启用和禁用Transactions" class="headerlink" title="启用和禁用Transactions"></a>启用和禁用Transactions</h5><p>使用<code>@Transactional</code>注释测试方法会导致测试在 transaction 中运行，默认情况下，在完成测试后会自动回滚。如果使用<code>@Transactional</code>注释了测试 class，则该 class 层次结构中的每个测试方法都在 transaction 中运行。未使用<code>@Transactional</code>(在 class 或方法 level 上)注释的测试方法在 transaction 中不是 run。此外，使用<code>@Transactional</code>注释但<code>propagation</code>类型设置为<code>NOT_SUPPORTED</code>的测试在 transaction 中不是 run。</p>
<p>请注意，<a href="#JUnit4支持Classes">AbstractTransactionalJUnit4SpringContextTests</a>和<a href="#TestNG支持Classes">AbstractTransactionalTestNGSpringContextTests</a>已预先配置为 class level 的 transactional 支持。</p>
<p>以下 example 演示了为 Hibernate-based <code>UserRepository</code>编写 integration 测试的 common 场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = TestConfig.class)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUserRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    HibernateUserRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// track initial state in test database:</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = countRowsInTable(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        User user = <span class="keyword">new</span> User(...);</span><br><span class="line">        repository.save(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Manual flush is required to avoid false positive in test</span></span><br><span class="line">        sessionFactory.getCurrentSession().flush();</span><br><span class="line">        assertNumUsers(count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">countRowsInTable</span><span class="params">(String tableName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JdbcTestUtils.countRowsInTable(<span class="keyword">this</span>.jdbcTemplate, tableName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertNumUsers</span><span class="params">(<span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;Number of rows in the [user] table.&quot;</span>, expected, countRowsInTable(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如<a href="#Transaction回滚和提交行为">Transaction 回滚和提交行为</a>中所述，在运行<code>createUser()</code>方法后无需清理数据库，因为对数据库所做的任何更改都会由<code>TransactionalTestExecutionListener</code>自动回滚。</p>
<h5 id="Transaction回滚和提交行为"><a href="#Transaction回滚和提交行为" class="headerlink" title="Transaction回滚和提交行为"></a>Transaction回滚和提交行为</h5><p>默认情况下，test transactions 将在测试完成后自动回滚;但是，transactional commit 和 rollback behavior 可以通过<code>@Commit</code>和<code>@Rollback</code>注解以声明方式配置。有关详细信息，请参阅<a href="#Annotations">annotation 支持</a>部分中的相应条目。</p>
<h5 id="编程式Transaction管理"><a href="#编程式Transaction管理" class="headerlink" title="编程式Transaction管理"></a>编程式Transaction管理</h5><p>从 Spring Framework 4.1 开始，您可以使用<code>TestTransaction</code>中的静态方法以编程方式与 test-managed transactions 进行交互。例如，您可以在测试方法中使用<code>TestTransaction</code>，在方法之前，在方法之后使用<code>TestTransaction</code>来启动或结束当前 test-managed transaction，或者为回滚或提交配置当前 test-managed transaction。只要启用<code>TransactionalTestExecutionListener</code>，就会自动提供对<code>TestTransaction</code>的支持。</p>
<p>以下 example 演示了<code>TestTransaction</code>的一些 features。有关更多详细信息，请参阅 javadoc 以获取<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestTransaction.html">TestTransaction</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = TestConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammaticTransactionManagementTests</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">        <span class="title">AbstractTransactionalJUnit4SpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transactionalTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert initial state in test database:</span></span><br><span class="line">        assertNumUsers(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        deleteFromTables(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// changes to the database will be committed!</span></span><br><span class="line">        TestTransaction.flagForCommit();</span><br><span class="line">        TestTransaction.end();</span><br><span class="line">        assertFalse(TestTransaction.isActive());</span><br><span class="line">        assertNumUsers(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        TestTransaction.start();</span><br><span class="line">        <span class="comment">// perform other actions against the database that will</span></span><br><span class="line">        <span class="comment">// be automatically rolled back after the test completes...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">assertNumUsers</span><span class="params">(<span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="string">&quot;Number of rows in the [user] table.&quot;</span>, expected, countRowsInTable(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="运行Code外的事物"><a href="#运行Code外的事物" class="headerlink" title="运行Code外的事物"></a>运行Code外的事物</h5><p>有时，您可能需要在 transactional 测试方法之前或之后执行某些 code，但在 transactional context 之外 - 为 example，在运行测试之前验证初始数据库 state 或在测试运行后验证预期的 transactional 提交行为(如果 test 配置为提交 transaction)。对于这种情况，<code>TransactionalTestExecutionListener</code>支持<code>@BeforeTransaction</code>和<code>@AfterTransaction</code> 注释。您可以使用其中一个注释在 test class 或测试接口中的任何<code>void</code> default 方法中注释任何<code>void</code>方法，并且<code>TransactionalTestExecutionListener</code>确保您的 before transaction 方法或 transaction 方法在适当的 time 运行。</p>
<blockquote>
<p>之前的任何方法(例如使用 JUnit Jupiter 的<code>@BeforeEach</code>注释的方法)和任何后续方法(例如使用 JUnit Jupiter 的<code>@AfterEach</code>注释的方法)都在 transaction 中运行。此外，对于未在 transaction 中配置为 run 的测试方法，<code>@BeforeTransaction</code>或<code>@AfterTransaction</code>注释的方法不是 run。</p>
</blockquote>
<h5 id="配置事务管理"><a href="#配置事务管理" class="headerlink" title="配置事务管理"></a>配置事务管理</h5><p><code>TransactionalTestExecutionListener</code>期望在 Spring <code>ApplicationContext</code>中定义<code>PlatformTransactionManager</code> bean 进行测试。如果在测试的<code>ApplicationContext</code>中有多个<code>PlatformTransactionManager</code>实例，则可以使用<code>@Transactional(&quot;myTxMgr&quot;)</code>或<code>@Transactional(transactionManager = &quot;myTxMgr&quot;)</code>声明限定符，或者<code>TransactionManagementConfigurer</code>可以由<code>@Configuration</code> class 实现。有关用于在测试<code>ApplicationContext</code>中查找 transaction manager 的算法的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/transaction/TestContextTransactionUtils.html#retrieveTransactionManager-org.springframework.test.context.TestContext-java.lang.String-">javadoc for TestContextTransactionUtils.retrieveTransactionManager()</a>。</p>
<h5 id="所有事物相关的Annotations的演示"><a href="#所有事物相关的Annotations的演示" class="headerlink" title="所有事物相关的Annotations的演示"></a>所有事物相关的Annotations的演示</h5><p>以下基于 JUnit 4 的 example 显示了一个虚构的 integration 测试场景，它突出显示了所有 transaction-related 注释。 example 并非用于演示最佳实践，而是用于演示如何使用这些注释。有关更多信息和 configuration 示例，请参见<a href="#Annotations">annotation 支持</a>部分。 <a href="#TransactionManagementwithsql">Transaction management for @Sql</a>包含一个额外的 example，它使用<code>@Sql</code>进行声明性 SQL 脚本执行，并使用默认的 transaction 回滚语义。以下 example 以粗体显示相关注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="meta">@Transactional(transactionManager = &quot;txMgr&quot;)</span></span><br><span class="line"><span class="meta">@Commit</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FictitiousTransactionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeTransaction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyInitialDatabaseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// logic to verify the initial state before a transaction is started</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpTestDataWithinTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// set up test data within the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">// overrides the class-level @Commit setting</span></span><br><span class="line">    <span class="meta">@Rollback</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyDatabaseWithinTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// logic which uses the test data and modifies database state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDownWithinTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute &quot;tear down&quot; logic within the transaction</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterTransaction</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">verifyFinalDatabaseState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// logic to verify the final state after transaction has rolled back</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><span id="AvoidFalse"></span></p>
<p>在测试 ORM code 时避免 false 肯定</p>
<p>当您测试操作 Hibernate session 或 JPA 持久性 context 的 state 的 application code 时，请确保在 run 该 code 的测试方法中刷新基础工作单元。未能刷新基础工作单元可能会产生 false 肯定：您的测试通过，但相同的 code 会在实时的 production 环境中抛出 exception。请注意，这适用于维护 in-memory 工作单元的任何 ORM framework。在下面的 Hibernate-based example 测试用例中，一个方法演示 false 正面，另一个方法正确公开了刷新 session 的结果：</p>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Test <span class="comment">// no expected exception!</span></span><br><span class="line">public <span class="keyword">void</span> falsePositive() &#123;</span><br><span class="line">    updateEntityInHibernateSession();</span><br><span class="line">    <span class="comment">// False positive: an exception will be thrown once the Hibernate</span></span><br><span class="line">    <span class="comment">// Session is finally flushed (i.e., in production code)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional</span><br><span class="line">@Test(expected = ...)</span><br><span class="line">public <span class="keyword">void</span> updateWithSessionFlush() &#123;</span><br><span class="line">    updateEntityInHibernateSession();</span><br><span class="line">    <span class="comment">// Manual flush is required to avoid false positive in test</span></span><br><span class="line">    sessionFactory<span class="variable">.getCurrentSession</span>()<span class="variable">.flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>以下 example 显示了 JPA 的匹配方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line">EntityManager entityManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test</span> <span class="comment">// no expected exception!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">falsePositive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateEntityInJpaPersistenceContext();</span><br><span class="line">    <span class="comment">// False positive: an exception will be thrown once the JPA</span></span><br><span class="line">    <span class="comment">// EntityManager is finally flushed (i.e., in production code)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Test(expected = ...)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateWithEntityManagerFlush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateEntityInJpaPersistenceContext();</span><br><span class="line">    <span class="comment">// Manual flush is required to avoid false positive in test</span></span><br><span class="line">    entityManager.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h4 id="执行SQL脚本"><a href="#执行SQL脚本" class="headerlink" title="执行SQL脚本"></a>执行SQL脚本</h4></blockquote>
<p>在针对关系数据库编写 integration 测试时，执行 SQL 脚本以将数据库 schema 或 insert 测试数据修改为表通常是有益的。 <code>spring-jdbc</code>模块通过在加载 Spring <code>ApplicationContext</code>时执行 SQL 脚本来支持初始化嵌入或现有数据库。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-数据访问/#嵌入式数据库支持">嵌入式数据库支持</a>和<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-数据访问/#使用嵌入式数据库测试数据访问逻辑">使用嵌入式数据库测试数据访问逻辑</a>。</p>
<p>虽然在加载<code>ApplicationContext</code>时初始化数据库进行一次测试非常有用，但有时在 integration 测试期间能够修改数据库是很重要的。以下部分说明如何在 integration 测试期间以编程方式和声明方式执行 SQL 脚本。</p>
<h5 id="以编程方式执行SQL脚本"><a href="#以编程方式执行SQL脚本" class="headerlink" title="以编程方式执行SQL脚本"></a>以编程方式执行SQL脚本</h5><p>Spring 提供了以下选项，用于在 integration 测试方法中以编程方式执行 SQL 脚本。</p>
<ul>
<li><code>org.springframework.jdbc.datasource.init.ScriptUtils</code></li>
<li><code>org.springframework.jdbc.datasource.init.ResourceDatabasePopulator</code></li>
<li><code>org.springframework.test.context.junit4.AbstractTransactionalJUnit4SpringContextTests</code></li>
<li><code>org.springframework.test.context.testng.AbstractTransactionalTestNGSpringContextTests</code></li>
</ul>
<p><code>ScriptUtils</code>提供了一组用于处理 SQL 脚本的静态实用程序方法，主要供 framework 内部使用。但是，如果您需要完全控制 SQL 脚本的解析和执行方式，<code>ScriptUtils</code>可能比后面描述的其他一些替代方案更适合您的需求。有关详细信息，请参阅中中的各个方法。</p>
<p><code>ResourceDatabasePopulator</code>提供 object-based API，用于通过使用外部资源中定义的 SQL 脚本以编程方式填充，初始化或清理数据库。 <code>ResourceDatabasePopulator</code>提供了用于配置解析和运行脚本时使用的字符编码，语句分隔符，comment 分隔符和错误处理标志的选项。每个 configuration 选项都有一个合理的默认值 value。有关默认值的详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jdbc/datasource/init/ResourceDatabasePopulator.html">javadoc</a>。要 run 在<code>ResourceDatabasePopulator</code>中配置的脚本，您可以调用<code>populate(Connection)</code>方法来执行针对<code>java.sql.Connection</code>的填充程序或<code>execute(DataSource)</code>方法来针对<code>javax.sql.DataSource</code>执行填充程序。以下 example 指定测试 schema 和测试数据的 SQL 脚本，将语句分隔符设置为<code>@@</code>，并针对<code>DataSource</code>执行脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> databaseTest &#123;</span><br><span class="line">    ResourceDatabasePopulator populator = <span class="keyword">new</span> ResourceDatabasePopulator();</span><br><span class="line">    populator.addScripts(</span><br><span class="line">            <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;test-schema.sql&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;test-data.sql&quot;</span>));</span><br><span class="line">    populator.setSeparator(<span class="string">&quot;@@&quot;</span>);</span><br><span class="line">    populator.execute(<span class="keyword">this</span>.dataSource);</span><br><span class="line">    <span class="comment">// execute code that uses the test schema and data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>ResourceDatabasePopulator</code>内部委托<code>ScriptUtils</code>进行解析和 running SQL 脚本。同样，<a href="##JUnit4支持Classes">AbstractTransactionalJUnit4SpringContextTests</a>和<a href="##TestNG支持Classes">AbstractTransactionalTestNGSpringContextTests</a>中的<code>executeSqlScript(..)</code>方法在内部使用<code>ResourceDatabasePopulator</code>到 run SQL 脚本。有关更多详细信息，请参阅 javadoc 以获取各种<code>executeSqlScript(..)</code>方法。</p>
<h5 id="以Sql注解声明性地执行SQL脚本"><a href="#以Sql注解声明性地执行SQL脚本" class="headerlink" title="以Sql注解声明性地执行SQL脚本"></a>以Sql注解声明性地执行SQL脚本</h5><p>除了前面提到的以编程方式运行 SQL 脚本的机制之外，您还可以在 Spring TestContext Framework 中以声明方式配置 SQL 脚本。具体来说，您可以在 test class 或 test 方法上声明<code>@Sql</code> annotation，以将资源_path 配置为在 integration 测试方法之前或之后应该针对给定数据库 run 的 SQL 脚本。请注意，method-level 声明覆盖 class-level 声明，并且<code>SqlScriptsTestExecutionListener</code>支持<code>@Sql</code>，默认情况下启用。</p>
<h6 id="路径资源语义"><a href="#路径资源语义" class="headerlink" title="路径资源语义"></a>路径资源语义</h6><p>每个路径都被解释为 Spring <code>Resource</code>。普通路径(对于 example，<code>&quot;schema.sql&quot;</code>)被视为 classpath 资源，该资源相对于定义 test class 的包。以斜杠开头的路径被视为绝对 classpath 资源(对于 example，<code>&quot;/org/example/schema.sql&quot;</code>)。使用指定的资源协议加载 references URL(对于 example，前缀为<code>classpath:</code>，<code>file:</code>，<code>http:</code>的路径)的路径。</p>
<p>以下 example 显示了如何在 class level 和基于 JUnit Jupiter 的 integration test class 中的方法 level 中使用<code>@Sql</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig</span></span><br><span class="line"><span class="meta">@Sql(&quot;/test-schema.sql&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatabaseTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> emptySchemaTest &#123;</span><br><span class="line">        <span class="comment">// execute code that uses the test schema without any test data</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Sql(&#123;&quot;/test-schema.sql&quot;, &quot;/test-user-data.sql&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> userTest &#123;</span><br><span class="line">        <span class="comment">// execute code that uses the test schema and test data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="默认脚本检测"><a href="#默认脚本检测" class="headerlink" title="默认脚本检测"></a>默认脚本检测</h6><p>如果未指定 SQL 脚本，则会尝试检测<code>default</code>脚本，具体取决于声明<code>@Sql</code>的位置。如果无法检测到默认值，则抛出<code>IllegalStateException</code>。</p>
<ul>
<li>Class-level 声明：如果带注释的测试 class 为<code>com.example.MyTest</code>，则相应的默认脚本为<code>classpath:com/example/MyTest.sql</code>。</li>
<li>Method-level 声明：如果带注释的测试方法名为<code>testMethod()</code>并且在 class <code>com.example.MyTest</code>中定义，则相应的默认脚本为<code>classpath:com/example/MyTest.testMethod.sql</code>。</li>
</ul>
<h6 id="声明多个Sql注解Sets"><a href="#声明多个Sql注解Sets" class="headerlink" title="声明多个Sql注解Sets"></a>声明多个Sql注解Sets</h6><p>如果需要为给定的测试 class 或测试方法配置多个 SQL 集脚本，但具有不同的语法 configuration，不同的错误处理规则或每个集的不同执行阶段，则可以声明多个<code>@Sql</code>实例。使用 Java 8，您可以使用<code>@Sql</code>作为可重复的 annotation。否则，您可以使用<code>@SqlGroup</code> annotation 作为显式容器来声明<code>@Sql</code>的多个实例。</p>
<p>以下 example 显示了如何在 Java 8 中将<code>@Sql</code>用作可重复的 annotation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;`&quot;))</span></span><br><span class="line"><span class="meta">@Sql(&quot;/test-user-data.sql&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that uses the test schema and test data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中显示的场景中，<code>test-schema.sql</code>脚本对 single-line comments 使用不同的语法。</p>
<p>以下 example 与前面的 example 相同，只是<code>@Sql</code>声明在<code>@SqlGroup</code>中组合在一起，以便与 Java 6 和 Java 7 兼容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@SqlGroup(&#123;</span></span><br><span class="line"><span class="meta">    @Sql(scripts = &quot;/test-schema.sql&quot;, config = @SqlConfig(commentPrefix = &quot;`&quot;)),</span></span><br><span class="line"><span class="meta">    @Sql(&quot;/test-user-data.sql&quot;)</span></span><br><span class="line"><span class="meta">)</span>&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that uses the test schema and test data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="脚本执行阶段"><a href="#脚本执行阶段" class="headerlink" title="脚本执行阶段"></a>脚本执行阶段</h6><p>默认情况下，SQL 脚本在相应的测试方法之前执行。但是，如果需要在测试方法之后运行一组特定的脚本(对于 example，以清理数据库 state)，则可以使用<code>@Sql</code>中的<code>executionPhase</code>属性，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Sql(</span></span><br><span class="line"><span class="meta">    scripts = &quot;create-test-data.sql&quot;,</span></span><br><span class="line"><span class="meta">    config = @SqlConfig(transactionMode = ISOLATED)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Sql(</span></span><br><span class="line"><span class="meta">    scripts = &quot;delete-test-data.sql&quot;,</span></span><br><span class="line"><span class="meta">    config = @SqlConfig(transactionMode = ISOLATED),</span></span><br><span class="line"><span class="meta">    executionPhase = AFTER_TEST_METHOD</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> userTest &#123;</span><br><span class="line">    <span class="comment">// execute code that needs the test data to be committed</span></span><br><span class="line">    <span class="comment">// to the database outside of the test&#x27;s transaction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，<code>ISOLATED</code>和<code>AFTER_TEST_METHOD</code>分别从<code>Sql.TransactionMode</code>和<code>Sql.ExecutionPhase</code>静态导入。</p>
<h6 id="使用SqlConfig注解配置脚本"><a href="#使用SqlConfig注解配置脚本" class="headerlink" title="使用SqlConfig注解配置脚本"></a>使用SqlConfig注解配置脚本</h6><p>您可以使用<code>@SqlConfig</code> annotation 配置脚本解析和错误处理。在 integration test class 上声明为 class-level annotation 时，<code>@SqlConfig</code>用作 test class 层次结构中所有 SQL 脚本的 global configuration。当使用<code>@Sql</code> annotation 的<code>config</code>属性直接声明时，<code>@SqlConfig</code>用作封闭<code>@Sql</code> annotation 中声明的 SQL 脚本的本地 configuration。 <code>@SqlConfig</code>中的每个属性都有一个隐式的默认值 value，它记录在相应属性的 javadoc 中。由于在 Java 语言规范中为 annotation 属性定义了规则，遗憾的是，不可能将<code>null</code>的 value 赋给 annotation 属性。因此，为了支持继承的 global configuration 的覆盖，<code>@SqlConfig</code>属性具有<code>&quot;&quot;</code>(对于 Strings)或<code>DEFAULT</code>(对于枚举)的显式缺省 value。这种方法允许<code>@SqlConfig</code>的局部声明通过提供除<code>&quot;&quot;</code>或<code>DEFAULT</code>之外的 value 来有选择地覆盖<code>@SqlConfig</code>的 global 声明中的各个属性。只要本地<code>@SqlConfig</code>属性不提供<code>&quot;&quot;</code>或<code>DEFAULT</code>以外的显式 value，就会继承 Global <code>@SqlConfig</code>属性。因此，显式本地配置会覆盖 global configuration。</p>
<p><code>@Sql</code>和<code>@SqlConfig</code>提供的 configuration 选项等同于<code>ScriptUtils</code>和<code>ResourceDatabasePopulator</code>支持的选项，但它们是<code>&lt;jdbc:initialize-database/&gt;</code> XML 名称空间元素提供的选项的超集。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/jdbc/Sql.html">@Sql</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html">@SqlConfig</a>中各个属性的 javadoc。</p>
<p><span id="TransactionManagementwithsql"></span></p>
<p><strong>事物管理@Sql</strong></p>
<p>默认情况下，<code>SqlScriptsTestExecutionListener</code>为使用<code>@Sql</code>配置的脚本推断出所需的 transaction 语义。具体来说，SQL 脚本是 run 而没有 transaction，在现有的 Spring-managed transaction 中(对于 example，由<code>TransactionalTestExecutionListener</code>管理的 transaction 用于使用<code>@Transactional</code>注释的测试)，或者在单独的 transaction 中，具体取决于<code>@SqlConfig</code>中<code>transactionMode</code>属性的配置 value 并且在测试的<code>ApplicationContext</code>中存在<code>PlatformTransactionManager</code>。但是，作为最低限度，测试的<code>ApplicationContext</code>中必须存在<code>javax.sql.DataSource</code>。</p>
<p>如果<code>SqlScriptsTestExecutionListener</code>用于检测<code>DataSource</code>和<code>PlatformTransactionManager</code>并推断 transaction 语义的算法不符合您的需要，则可以通过设置<code>@SqlConfig</code>的<code>dataSource</code>和<code>transactionManager</code>属性来指定显式名称。此外，您可以通过设置<code>@SqlConfig</code>的<code>transactionMode</code>属性来控制 transaction 传播行为(对于 example，脚本是否应该在隔离的 transaction 中运行)。虽然对<code>@Sql</code>的 transaction management 的所有支持选项的详尽讨论超出了本 reference 手册的范围，但<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlConfig.html">@SqlConfig</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/jdbc/SqlScriptsTestExecutionListener.html">SqlScriptsTestExecutionListener</a>的 javadoc 提供了详细信息，以下 example 显示了使用 JUnit Jupiter 和 transactional 测试的典型测试场景<code>@Sql</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(TestDatabaseConfig.class)</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransactionalSqlScriptsTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TransactionalSqlScriptsTests(DataSource dataSource) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Sql(&quot;/test-data.sql&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">usersTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// verify state in test database:</span></span><br><span class="line">        assertNumUsers(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// execute code that uses the test data...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countRowsInTable</span><span class="params">(String tableName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JdbcTestUtils.countRowsInTable(<span class="keyword">this</span>.jdbcTemplate, tableName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assertNumUsers</span><span class="params">(<span class="keyword">int</span> expected)</span> </span>&#123;</span><br><span class="line">        assertEquals(expected, countRowsInTable(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            <span class="string">&quot;Number of rows in the [user] table.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在<code>usersTest()</code>方法为 run 之后无需清理数据库，因为对数据库所做的任何更改(在测试方法内或在<code>/test-data.sql</code>脚本中)都会被<code>TransactionalTestExecutionListener</code>自动回滚(有关详细信息，请参阅<a href="#事务管理">transaction management</a>) 。</p>
<p><strong>使用@SqlMergeMode合并和重写配置</strong></p>
<p>在Spring Framework 5.2中，可以将方法级的<code>@Sql</code>声明与类级声明合并。例如，这允许您为每个测试类提供一次数据库模式或一些公共测试数据的配置，然后为每个测试方法提供附加的、特定于用例的测试数据。要启用<code>@Sql</code>合并，请使用<code>@SqlMergeMode(MERGE)</code>注释您的测试类或测试方法。要禁用特定测试方法(或特定测试子类)的合并，可以通过<code>@SqlMergeMode(OVERRIDE)</code>切换回默认模式。查阅<a href="#SqlMergeMode注解">@SqlMergeMode注解文档</a>小节以获得示例和更多细节。</p>
<h4 id="Parallel测试执行"><a href="#Parallel测试执行" class="headerlink" title="Parallel测试执行"></a>Parallel测试执行</h4><p>Spring Framework 5.0 引入了在使用 Spring TestContext Framework 时在单个 JVM 中执行 parallel 测试的基本支持。通常，这意味着大多数测试类或测试方法可以在 parallel 中执行，而无需对 test code 或 configuration 进行任何更改。</p>
<blockquote>
<p>有关如何设置 parallel 测试执行的详细信息，请参阅测试 framework，build 工具或 IDE 的文档。</p>
</blockquote>
<p>请记住，在测试套件中引入并发可能会导致意外的副作用，奇怪的运行时行为以及间歇性或看似随机失败的测试。因此，Spring 团队提供以下关于何时不在 parallel 中执行测试的一般指导原则。</p>
<p>如果测试，请不要在 parallel 中执行测试：</p>
<ul>
<li>使用 Spring 的<code>@DirtiesContext</code>支持。</li>
<li>使用 JUnit 4 的<code>@FixMethodOrder</code>支持或任何测试 framework feature，旨在确保测试方法 run 在特定的 order 中。但请注意，如果在 parallel 中执行整个测试类，则不适用。</li>
<li>更改共享服务或系统的 state，例如数据库，消息 broker，文件系统等。这适用于 in-memory 和外部系统。</li>
</ul>
<blockquote>
<p>如果 parallel 测试执行失败，并且 exception 声明当前测试的<code>ApplicationContext</code>不再是 active，则这通常意味着<code>ApplicationContext</code>已从另一个线程中的<code>ContextCache</code>中删除。</p>
</blockquote>
<p>这可能是由于使用<code>@DirtiesContext</code>或由于<code>ContextCache</code>的自动驱逐。如果<code>@DirtiesContext</code>是罪魁祸首，您需要找到一种方法来避免使用<code>@DirtiesContext</code>或从 parallel 执行中排除此类测试。如果已超出<code>ContextCache</code>的最大大小，则可以增加高速缓存的最大大小。有关详细信息，请参阅<a href="#Context缓存">context 缓存</a>上的讨论。</p>
<blockquote>
<p>Spring TestContext Framework 中的 Parallel 测试执行只有在底层<code>TestContext</code> implementation 提供复制构造函数时才有可能，如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestContext.html">TestContext</a>的 javadoc 中所述。 Spring 中使用的<code>DefaultTestContext</code>提供了这样的构造函数。但是，如果使用提供自定义<code>TestContext</code> implementation 的 third-party library，则需要验证它是否适合 parallel 测试执行。</p>
</blockquote>
<h4 id="TestContext框架支持Classes"><a href="#TestContext框架支持Classes" class="headerlink" title="TestContext框架支持Classes"></a>TestContext框架支持Classes</h4><p>本节介绍支持 Spring TestContext Framework 的各种 classes。</p>
<h5 id="SpringJUnit4Runner"><a href="#SpringJUnit4Runner" class="headerlink" title="SpringJUnit4Runner"></a>SpringJUnit4Runner</h5><p>Spring TestContext Framework 通过自定义运行器(在 JUnit 4.12 或更高版本上支持)提供与 JUnit 4 的完整 integration。通过使用<code>@RunWith(SpringJUnit4ClassRunner.class)</code>或更短的<code>@RunWith(SpringRunner.class)</code>变体注释 test classes，开发人员可以实现标准的 JUnit 4-based 单元和 integration 测试，同时获得 TestContext framework 的好处，例如支持 loading application 上下文，依赖注入测试实例，transactional 测试方法执行， 等等。如果您想将 Spring TestContext Framework 与替代跑步者(例如 JUnit 4 的<code>Parameterized</code>跑步者)或third-party跑步者(例如<code>MockitoJUnitRunner</code>)一起使用，您可以选择使用<a href="#SpringJunit4规则">Spring 支持 JUnit 规则</a>。</p>
<p>以下 code 列表显示了使用自定义 Spring <code>Runner</code>将 test class 配置为 run 的最低要求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@TestExecutionListeners(&#123;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute test logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的 example 中，<code>@TestExecutionListeners</code>配置了一个空列表，以禁用默认的 listeners，否则需要通过<code>@ContextConfiguration</code>配置<code>ApplicationContext</code>。</p>
<h5 id="SpringJunit4规则"><a href="#SpringJunit4规则" class="headerlink" title="SpringJunit4规则"></a>SpringJunit4规则</h5><p><code>org.springframework.test.context.junit4.rules</code>包提供以下 JUnit 4 规则(JUnit 4.12 或更高版本支持)：</p>
<ul>
<li><code>SpringClassRule</code></li>
<li><code>SpringMethodRule</code></li>
</ul>
<p><code>SpringClassRule</code>是一个 JUnit <code>TestRule</code>，它支持 Spring TestContext Framework 的 class-level features，而<code>SpringMethodRule</code>是一个 JUnit <code>MethodRule</code>，它支持 Spring TestContext Framework 的 instance-level 和 method-levelfeatures。</p>
<p>与<code>SpringRunner</code>相比，Spring 的 rule-based JUnit 支持具有独立于任何<code>org.junit.runner.Runner</code> implementation 的优点，因此可以与现有的替代运行程序(例如 JUnit 4 的<code>Parameterized</code>)或 third-party 运行程序(例如<code>MockitoJUnitRunner</code>)组合。</p>
<p>要支持 TestContext framework 的完整功能，必须将<code>SpringClassRule</code>与<code>SpringMethodRule</code>组合在一起。以下 example 显示了在 integration 测试中声明这些规则的正确方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Optionally specify a non-Spring Runner via @RunWith(...)</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegrationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ClassRule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SpringClassRule springClassRule = <span class="keyword">new</span> SpringClassRule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> SpringMethodRule springMethodRule = <span class="keyword">new</span> SpringMethodRule();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute test logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="JUnit4支持Classes"><a href="#JUnit4支持Classes" class="headerlink" title="JUnit4支持Classes"></a>JUnit4支持Classes</h5><p><code>org.springframework.test.context.junit4</code>包为 JUnit 4-based 测试用例提供以下支持 classes(在 JUnit 4.12 或更高版本上受支持)：</p>
<ul>
<li><code>AbstractJUnit4SpringContextTests</code></li>
<li><code>AbstractTransactionalJUnit4SpringContextTests</code></li>
</ul>
<p><code>AbstractJUnit4SpringContextTests</code>是一个抽象基础测试 class，它将 Spring TestContext Framework 与 JUnit 4 环境中的显式<code>ApplicationContext</code>测试支持集成在一起。扩展<code>AbstractJUnit4SpringContextTests</code>时，可以访问<code>protected</code> <code>applicationContext</code>实例变量，可用于执行显式 bean 查找或测试 context 的 state 作为整体。</p>
<p><code>AbstractTransactionalJUnit4SpringContextTests</code>是<code>AbstractJUnit4SpringContextTests</code>的抽象 transactional 扩展，为 JDBC 访问添加了一些便利功能。这个 class 期望在<code>ApplicationContext</code>中定义<code>javax.sql.DataSource</code> bean 和<code>PlatformTransactionManager</code> bean。当您扩展<code>AbstractTransactionalJUnit4SpringContextTests</code>时，您可以访问<code>protected</code> <code>jdbcTemplate</code>实例变量，您可以使用该变量来运行 SQL statements 来查询数据库。您可以在 running database-related application code 之前和之后使用此类查询来确认数据库 state，并且 Spring 确保此类查询在与 application code 相同的 transaction 范围内运行。与 ORM 工具结合使用时，请务必避免使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-tx-false-positives">误报</a>。如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#integration-testing-support-jdbc">JDBC 测试支持</a>中所述，<code>AbstractTransactionalJUnit4SpringContextTests</code>还提供了方便的方法，通过使用前面提到的<code>jdbcTemplate</code>来委托<code>JdbcTestUtils</code>中的方法。此外，<code>AbstractTransactionalJUnit4SpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法，用于针对配置的<code>DataSource</code>运行 SQL 脚本。</p>
<blockquote>
<p>这些 classes 是扩展的便利。如果您不希望将 test classes 绑定到 Spring-specific class 层次结构，则可以使用<code>@RunWith(SpringRunner.class)</code>或<a href="#SpringJunit4规则">Spring 的 JUnit 规则</a>配置自己的自定义测试 classes。</p>
</blockquote>
<h5 id="JUnitJupiter的SpringExtension"><a href="#JUnitJupiter的SpringExtension" class="headerlink" title="JUnitJupiter的SpringExtension"></a>JUnitJupiter的SpringExtension</h5><p>Spring TestContext Framework 使用 JUnit 5 中引入的 JUnit Jupiter 测试 framework 提供完整的 integration。通过使用<code>@ExtendWith(SpringExtension.class)</code>注释 test classes，您可以实现标准的 JUnit Jupiter-based 单元和 integration 测试，同时获得 TestContext framework 的好处，例如支持 loading application 上下文，依赖注入测试实例，transactional 测试方法执行等。</p>
<p>此外，由于 JUnit Jupiter 中的丰富扩展 API，Spring 可以在 Spring 支持 JUnit 4 和 TestNG 的 feature 集之上提供以下 features：</p>
<ul>
<li>测试构造函数，测试方法和测试生命周期回调方法的依赖注入。有关详细信息，请参阅<a href="#SpringExtension的依赖注入">SpringExtension 的依赖注入</a>。</li>
<li>基于 SpEL 表达式，环境变量，系统 properties 等对<a target="_blank" rel="noopener" href="http://junit.org/junit5/docs/current/user-guide/#extensions-conditions">条件测试执行</a>的强大支持。有关更多详细信息和示例，请参阅<a href="#SpringJUnitJupiterTestingAnnotations">Spring JUnit Jupiter Testing Annotations</a>中<code>@EnabledIf</code>和<code>@DisabledIf</code>的文档。</li>
<li>自定义组合的注释，它们组合了来自 Spring 和 JUnit Jupiter 的 annotations。有关详细信息，请参阅<a href="#Meta-Annotation支持测试">Meta-Annotation 支持测试</a>中的<code>@TransactionalDevTestConfig</code>和<code>@TransactionalIntegrationTest</code>示例。</li>
</ul>
<p>以下 code 列表显示了如何配置 test class 以将<code>SpringExtension</code>与<code>@ContextConfiguration</code>结合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instructs JUnit Jupiter to extend the test with Spring support.</span></span><br><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="comment">// Instructs Spring to load an ApplicationContext from TestConfig.class</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = TestConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute test logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于您也可以在 JUnit 5 中使用 annotations 作为 meta-annotations，Spring 可以提供<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>组合注释来简化测试<code>ApplicationContext</code>和 JUnit Jupiter 的 configuration。</p>
<p>以下 example 使用<code>@SpringJUnitConfig</code>来减少前一个 example 中使用的 configuration 数量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instructs Spring to register the SpringExtension with JUnit</span></span><br><span class="line"><span class="comment">// Jupiter and load an ApplicationContext from TestConfig.class</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(TestConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute test logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，以下 example 使用<code>@SpringJUnitWebConfig</code>创建<code>WebApplicationContext</code>以与 JUnit Jupiter 一起使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instructs Spring to register the SpringExtension with JUnit</span></span><br><span class="line"><span class="comment">// Jupiter and load a WebApplicationContext from TestWebConfig.class</span></span><br><span class="line"><span class="meta">@SpringJUnitWebConfig(TestWebConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleWebTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// execute test logic...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关详细信息，请参阅<a href="#SpringJUnitJupiterTestingAnnotations">Spring JUnit Jupiter Testing Annotations</a>中<code>@SpringJUnitConfig</code>和<code>@SpringJUnitWebConfig</code>的文档。</p>
<h5 id="SpringExtension的依赖注入"><a href="#SpringExtension的依赖注入" class="headerlink" title="SpringExtension的依赖注入"></a>SpringExtension的依赖注入</h5><p><code>SpringExtension</code>从 JUnit Jupiter 实现<a target="_blank" rel="noopener" href="http://junit.org/junit5/docs/current/user-guide/#extensions-parameter-resolution">ParameterResolver</a>扩展 API，它允许 Spring 为测试构造函数，测试方法和测试生命周期回调方法提供依赖注入。</p>
<p>具体来说，<code>SpringExtension</code>可以将测试的<code>ApplicationContext</code>中的依赖项注入到使用<code>@BeforeAll</code>，<code>@AfterAll</code>，<code>@BeforeEach</code>，<code>@AfterEach</code>，<code>@Test</code>，<code>@RepeatedTest</code>，<code>@ParameterizedTest</code>等注释的测试构造函数和方法中。</p>
<h6 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h6><p>如果 JUnit Jupiter 测试 class 的构造函数中的参数类型为<code>ApplicationContext</code>(或 sub-type)或带注释或带有<code>@Autowired</code>，<code>@Qualifier</code>或<code>@Value</code>的 meta-annotated，则 Spring 会使用测试中的相应 bean 为该特定参数注入 value <code>ApplicationContext</code>。如果所有参数都应由 Spring 提供，您还可以使用<code>@Autowired</code>直接注释测试构造函数。</p>
<blockquote>
<p>如果 test class 的构造函数本身用<code>@Autowired</code>注释，则 Spring 承担解析构造函数中所有参数的责任。因此，JUnit Jupiter 中没有注册的其他<code>ParameterResolver</code>可以解析此类构造函数的参数。</p>
</blockquote>
<p>在下面的示例中，Spring 将从<code>TestConfig.class</code>加载的<code>ApplicationContext</code>中的<code>OrderService</code> bean 注入<code>OrderServiceIntegrationTests</code>构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(TestConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderServiceIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    OrderServiceIntegrationTests(OrderService orderService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.orderService = orderService.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tests that use the injected OrderService</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，此 feature 允许测试依赖项为<code>final</code>，因此不可变。</p>
<h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>如果 JUnit Jupiter 测试方法或测试生命周期回调方法中的参数类型为<code>ApplicationContext</code>(或 sub-type)或带注释或 meta-annotated 带有<code>@Autowired</code>，<code>@Qualifier</code>或<code>@Value</code>，则 Spring 会使用相应的 bean 从该特定参数中注入 value 考试的<code>ApplicationContext</code>。</p>
<p>在下面的示例中，Spring 将从<code>TestConfig.class</code>加载的<code>ApplicationContext</code>中的<code>OrderService</code>注入到<code>deleteOrder()</code>测试方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(TestConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderServiceIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteOrder</span><span class="params">(<span class="meta">@Autowired</span> OrderService orderService)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// use orderService from the test&#x27;s ApplicationContext</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 JUnit Jupiter 中<code>ParameterResolver</code>支持的健壮性，您还可以将多个依赖项注入单个方法，不仅来自 Spring，还来自 JUnit Jupiter 本身或其他 third-party extensions。</p>
<p>以下 example 显示了如何同时将 Spring 和 JUnit Jupiter inject 依赖项同时包含在<code>placeOrderRepeatedly()</code>测试方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(TestConfig.class)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderServiceIntegrationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RepeatedTest(10)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">placeOrderRepeatedly</span><span class="params">(RepetitionInfo repetitionInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Autowired</span> OrderService orderService)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use orderService from the test&#x27;s ApplicationContext</span></span><br><span class="line">        <span class="comment">// and repetitionInfo from JUnit Jupiter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，使用 JUnit Jupiter 中的<code>@RepeatedTest</code>可以让测试方法获得对<code>RepetitionInfo</code>的访问权限。</p>
<h5 id="TestNG支持Classes"><a href="#TestNG支持Classes" class="headerlink" title="TestNG支持Classes"></a>TestNG支持Classes</h5><p><code>org.springframework.test.context.testng</code>包为基于 TestNG 的测试用例提供以下支持 classes：</p>
<ul>
<li><code>AbstractTestNGSpringContextTests</code></li>
<li><code>AbstractTransactionalTestNGSpringContextTests</code></li>
</ul>
<p><code>AbstractTestNGSpringContextTests</code>是一个抽象基础测试 class，它将 Spring TestContext Framework 与 TestNG 环境中的显式<code>ApplicationContext</code>测试支持集成在一起。扩展<code>AbstractTestNGSpringContextTests</code>时，可以访问<code>protected</code> <code>applicationContext</code>实例变量，可用于执行显式 bean 查找或测试 context 的 state 作为整体。</p>
<p><code>AbstractTransactionalTestNGSpringContextTests</code>是<code>AbstractTestNGSpringContextTests</code>的抽象 transactional 扩展，为 JDBC 访问添加了一些便利功能。这个 class 期望在<code>ApplicationContext</code>中定义<code>javax.sql.DataSource</code> bean 和<code>PlatformTransactionManager</code> bean。扩展<code>AbstractTransactionalTestNGSpringContextTests</code>时，可以访问可用于执行 SQL statements 以查询数据库的<code>protected</code> <code>jdbcTemplate</code>实例变量。您可以在 running database-related application code 之前和之后使用此类查询来确认数据库 state，并且 Spring 确保此类查询在与 application code 相同的 transaction 范围内运行。与 ORM 工具结合使用时，请务必避免使用<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-tx-false-positives">误报</a>。如<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#integration-testing-support-jdbc">JDBC 测试支持</a>中所述，<code>AbstractTransactionalTestNGSpringContextTests</code>还提供了方便的方法，通过使用前面提到的<code>jdbcTemplate</code>来委托<code>JdbcTestUtils</code>中的方法。此外，<code>AbstractTransactionalTestNGSpringContextTests</code>提供了一个<code>executeSqlScript(..)</code>方法，用于针对配置的<code>DataSource</code>运行 SQL 脚本。</p>
<blockquote>
<p>这些 classes 是扩展的便利。如果您不希望将 test classes 绑定到 Spring-specific class 层次结构，则可以使用<code>@ContextConfiguration</code>，<code>@TestExecutionListeners</code>等配置自己的自定义测试 classes，并使用<code>TestContextManager</code>手动检测 test class。有关如何检测测试 class 的示例，请参阅<code>AbstractTestNGSpringContextTests</code>的 source code。</p>
</blockquote>
<h3 id="SpringMVC测试框架"><a href="#SpringMVC测试框架" class="headerlink" title="SpringMVC测试框架"></a>SpringMVC测试框架</h3><p>Spring MVC Test framework 为使用 fluent API 测试 Spring MVC code 提供了第一个 class 支持，您可以将其与 JUnit，TestNG 或任何其他测试 framework 一起使用。它建立在<code>spring-test</code>模块的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/mock/web/package-summary.html">Servlet API mock objects</a>上，因此不使用 running Servlet 容器。它使用<code>DispatcherServlet</code>提供完整的 Spring MVC 运行时行为，并且除了独立模式之外，还支持使用 TestContext framework 加载实际的 Spring configuration，在独立模式下，您可以手动实例化控制器并在 time 时测试它们。</p>
<p>Spring MVC Test 还为测试使用<code>RestTemplate</code>的 code 提供 client-side 支持。 Client-side tests mock 服务器响应，也不使用 running 服务器。</p>
<blockquote>
<p>Spring Boot 提供了一个选项来编写包含 running 服务器的完整的 end-to-end integration 测试。如果这是您的目标，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot reference 页面</a>。有关 out-of-container 和 end-to-end integration 测试之间差异的更多信息，请参阅<a href="#Out-of-Container和End-to-End集成测试之间的差异">Out-of-Container 和 End-to-End Integration 测试之间的差异</a>。</p>
</blockquote>
<h4 id="Server-Side测试"><a href="#Server-Side测试" class="headerlink" title="Server-Side测试"></a>Server-Side测试</h4><p>您可以使用 JUnit 或 TestNG 为 Spring MVC 控制器编写普通单元测试。为此，实例化控制器，使用模拟或存根依赖项对其进行注入，并调用其方法(根据需要传递<code>MockHttpServletRequest</code>，<code>MockHttpServletResponse</code>和其他)。但是，在编写这样的单元测试时，仍有许多未经测试：例如，请求映射，数据绑定，类型转换，验证等等。此外，还可以调用其他控制器方法(如<code>@InitBinder</code>，<code>@ModelAttribute</code>和<code>@ExceptionHandler</code>)作为请求处理生命周期的一部分。</p>
<p>Spring MVC Test 的目标是通过执行请求并通过实际<code>DispatcherServlet</code>生成响应来提供测试控制器的有效方法。</p>
<p>Spring MVC Test 建立在<code>spring-test</code>模块中熟悉的<a href="#ServletAPI">“mock”实现 Servlet API</a>上。这允许执行请求并生成响应，而无需在 Servlet 容器中运行 running。在大多数情况下，一切都应该像在运行时那样使用一些值得注意的 exceptions，如<a href="#Out-of-Container和End-to-End集成测试之间的差异">Out-of-Container 和 End-to-End Integration 测试之间的差异</a>中所述。以下 JUnit Jupiter-based example 使用 Spring MVC Test：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitWebConfig(locations = &quot;test-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">(WebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getAccount</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc.perform(get(<span class="string">&quot;/accounts/1&quot;</span>)</span><br><span class="line">                .accept(MediaType.parseMediaType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>)))</span><br><span class="line">            .andExpect(status().isOk())</span><br><span class="line">            .andExpect(content().contentType(<span class="string">&quot;application/json&quot;</span>))</span><br><span class="line">            .andExpect(jsonPath(<span class="string">&quot;$.name&quot;</span>).value(<span class="string">&quot;Lee&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述测试依赖于 TestContext framework 的<code>WebApplicationContext</code>支持，以从与 test class 相同的包中的 XML configuration 文件加载 Spring configuration，但也支持 Java-based 和 Groovy-based configuration。看到这些<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples/context">sample 测试</a>。</p>
<p><code>MockMvc</code>实例用于对<code>/accounts/1</code>执行<code>GET</code>请求，并验证生成的响应是否为状态 200，content type 是<code>application/json</code>，并且响应正文具有名为<code>name</code>且带有 value <code>Lee</code>的 JSON property。 Jayway <a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath">JsonPath 项目</a>支持<code>jsonPath</code>语法。验证执行请求结果的许多其他选项将在本文档的后面部分讨论。</p>
<h5 id="静态进口"><a href="#静态进口" class="headerlink" title="静态进口"></a>静态进口</h5><p>来自<a href="#Server-Side测试">前一节</a>的 example 中的 fluent API 需要一些静态导入，例如<code>MockMvcRequestBuilders.*</code>，<code>MockMvcResultMatchers.*</code>和<code>MockMvcBuilders.*</code>。查找这些 classes 的简单方法是搜索 match <code>MockMvc*</code>的类型。如果您使用 Eclipse 或 Eclipse-based Spring 工具套件，请确保在 Java→编辑器→内容辅助→收藏夹下的 Eclipse 首选项中将它们添加为“最喜欢的静态成员”。这样做可以在 typing 静态方法 name 的第一个字符后使用内容辅助。其他 IDE(例如 IntelliJ)可能不需要任何其他 configuration。检查静态成员的 code 完成支持。</p>
<h5 id="设置选择"><a href="#设置选择" class="headerlink" title="设置选择"></a>设置选择</h5><p>您有两个主要选项来创建<code>MockMvc</code>的实例。第一种是通过 TestContext framework 加载 Spring MVC configuration，它加载 Spring configuration 并将<code>WebApplicationContext</code>注入测试以用于 build <code>MockMvc</code>实例。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;my-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.wac).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个选项是手动创建一个控制器实例，而不是 loading Spring configuration。相反，将自动创建与 MVC JavaConfig 或 MVC 名称空间大致相当的基本默认 configuration。您可以在一定程度上自定义它。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mockMvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> AccountController()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你应该使用哪种设置选项？</p>
<p><code>webAppContextSetup</code>加载您实际的 Spring MVC configuration，从而产生更完整的 integration 测试。由于 TestContext framework 缓存了加载的 Spring configuration，因此即使您在测试套件中引入了更多测试，它也有助于保持测试快速运行。此外，您可以通过 Spring configuration 将 mock 服务注入控制器，以继续专注于测试 web 层。以下 example 使用 Mockito 声明 mock 服务：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mockito.Mockito&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;mock&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;org.example.AccountService&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，您可以将 mock 服务注入测试以设置和验证您的期望，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebAppConfiguration</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;test-servlet-context.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一方面，<code>standaloneSetup</code>更接近单元测试。它在 time 测试一个控制器。您可以使用 mock 依赖项手动 inject 控制器，它不涉及 loading Spring configuration。这些测试更侧重于样式，并且更容易看到正在测试哪个控制器，是否需要任何特定的 Spring MVC configuration 才能工作，等等。 <code>standaloneSetup</code>也是编写 ad-hoc 测试以验证特定行为或调试问题的一种非常方便的方法。</p>
<p>与大多数“整合与单元测试”辩论一样，没有正确或错误的答案。但是，使用<code>standaloneSetup</code>确实意味着需要在 order 中进行额外的<code>webAppContextSetup</code>测试以验证您的 Spring MVC configuration。或者，您可以使用<code>webAppContextSetup</code>编写所有测试，在 order 中始终针对您的实际 Spring MVC configuration 进行测试。</p>
<h5 id="设置Features"><a href="#设置Features" class="headerlink" title="设置Features"></a>设置Features</h5><p>无论您使用哪个 MockMvc 构建器，所有<code>MockMvcBuilder</code> implementations 都提供了一些 common 和非常有用的 features。对于 example，您可以为所有请求声明<code>Accept</code>标头，并期望在所有响应中状态为 200 以及<code>Content-Type</code>标头，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of MockMvcBuilders.standaloneSetup</span></span><br><span class="line"></span><br><span class="line">MockMvc mockMvc = standaloneSetup(<span class="keyword">new</span> MusicController())</span><br><span class="line">        .defaultRequest(get(<span class="string">&quot;/&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">        .alwaysExpect(status().isOk())</span><br><span class="line">        .alwaysExpect(content().contentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>))</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>另外，third-party frameworks(和 applications)可以 pre-package 设置指令，例如<code>MockMvcConfigurer</code>中的指令。 Spring Framework 有一个这样的 built-in implementation，它有助于跨请求保存和 re-use HTTP session。您可以按如下方式使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static import of SharedHttpSessionConfigurer.sharedHttpSession</span></span><br><span class="line"></span><br><span class="line">MockMvc mockMvc = MockMvcBuilders.standaloneSetup(<span class="keyword">new</span> TestController())</span><br><span class="line">        .apply(sharedHttpSession())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use mockMvc to perform requests...</span></span><br></pre></td></tr></table></figure>
<p>有关<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/web/servlet/setup/ConfigurableMockMvcBuilder.html">ConfigurableMockMvcBuilder</a>的 javadoc，请参阅所有 MockMvc 构建器 features 的列表，或使用 IDE 浏览可用选项。</p>
<h5 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h5><p>您可以执行使用任何 HTTP 方法的请求，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/hotels/&#123;id&#125;&quot;</span>, <span class="number">42</span>).accept(MediaType.APPLICATION_JSON));</span><br></pre></td></tr></table></figure>
<p>您还可以执行内部使用<code>MockMultipartHttpServletRequest</code>的文件上载请求，以便不会实际解析 multipart 请求。相反，您必须将其设置为类似于以下 example：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(multipart(<span class="string">&quot;/doc&quot;</span>).file(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;ABC&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>您可以在 URI 模板样式中指定查询参数，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/hotels?thing=&#123;thing&#125;&quot;</span>, <span class="string">&quot;somewhere&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>您还可以添加表示查询或表单参数的 Servlet 请求参数，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/hotels&quot;</span>).param(<span class="string">&quot;thing&quot;</span>, <span class="string">&quot;somewhere&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果 application code 依赖于 Servlet 请求参数，并且没有显式检查查询 string(最常见的情况)，那么使用哪个选项并不重要。但请记住，对 URI 模板提供的查询参数进行解码，而通过<code>param(…)</code>方法提供的请求参数预计已经被解码。</p>
<p>在大多数情况下，最好将 context 路径和 Servlet 路径保留在请求 URI 之外。如果必须使用完整请求 URI 进行测试，请确保相应地设置<code>contextPath</code>和<code>servletPath</code>以使请求映射有效，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/app/main/hotels/&#123;id&#125;&quot;</span>).contextPath(<span class="string">&quot;/app&quot;</span>).servletPath(<span class="string">&quot;/main&quot;</span>))</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，对每个执行的请求设置<code>contextPath</code>和<code>servletPath</code>将是麻烦的。相反，您可以设置默认请求 properties，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mockMvc = standaloneSetup(<span class="keyword">new</span> AccountController())</span><br><span class="line">            .defaultRequest(get(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">            .contextPath(<span class="string">&quot;/app&quot;</span>).servletPath(<span class="string">&quot;/main&quot;</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON)).build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>前面的 properties 会影响通过<code>MockMvc</code>实例执行的每个请求。如果在给定请求上也指定了相同的 property，它将覆盖默认的 value。这就是默认请求中的 HTTP 方法和 URI 无关紧要的原因，因为必须在每个请求中指定它们。</p>
<h5 id="定义期望"><a href="#定义期望" class="headerlink" title="定义期望"></a>定义期望</h5><p>您可以在执行请求后通过附加一个或多个<code>.andExpect(..)</code> _call 来定义期望，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/accounts/1&quot;</span>)).andExpect(status().isOk());</span><br></pre></td></tr></table></figure>
<p><code>MockMvcResultMatchers.*</code>提供了许多期望，其中一些期望与更详细的期望进一步嵌套。</p>
<p>期望分为两大类。第一类断言验证响应的 properties(例如，响应状态，headers 和内容)。这些是断言最重要的结果。</p>
<p>第二类断言超出了回应范围。这些断言允许您检查 Spring MVC 特定方面，例如处理请求的控制器方法，是否引发和处理 exception，model 的内容是什么，选择了哪个视图，添加了哪些 flash 属性等等。它们还允许您检查 Servlet 特定方面，例如 request 和 session 属性。</p>
<p>以下测试断言 binding 或验证失败：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>))</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andExpect(model().attributeHasErrors(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>很多时候，在编写测试时，转储执行的请求的结果很有用。您可以按如下方式执行此操作，其中<code>print()</code>是来自<code>MockMvcResultHandlers</code>的静态 import：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>))</span><br><span class="line">    .andDo(print())</span><br><span class="line">    .andExpect(status().isOk())</span><br><span class="line">    .andExpect(model().attributeHasErrors(<span class="string">&quot;person&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>由于 long 因为请求处理不会导致未处理的 exception，<code>print()</code>方法会将所有可用的结果数据打印到<code>System.out</code>。 Spring Framework 4.2 引入了<code>log()</code>方法和<code>print()</code>方法的另外两个变体，一个接受<code>OutputStream</code>，另一个接受<code>Writer</code>。对于 example，调用<code>print(System.err)</code>将结果数据打印到<code>System.err</code>，而调用<code>print(myWriter)</code>则将结果数据打印到自定义 writer。如果要记录结果数据而不是打印结果数据，可以调用<code>log()</code>方法，该方法将结果数据记录为<code>org.springframework.test.web.servlet.result</code> logging 类别下的单个<code>DEBUG</code>消息。</p>
<p>在某些情况下，您可能希望直接访问结果并验证无法验证的内容。这可以通过在所有其他期望之后附加<code>.andReturn()</code>来实现，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MvcResult mvcResult = mockMvc.perform(post(<span class="string">&quot;/persons&quot;</span>)).andExpect(status().isOk()).andReturn();</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>如果所有测试重复相同的期望，则可以在 building <code>MockMvc</code>实例时设置 common 期望值，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">standaloneSetup(<span class="keyword">new</span> SimpleController())</span><br><span class="line">    .alwaysExpect(status().isOk())</span><br><span class="line">    .alwaysExpect(content().contentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>))</span><br><span class="line">    .build()</span><br></pre></td></tr></table></figure>
<p>请注意，如果没有 creating 单独的<code>MockMvc</code>实例，则始终会应用 common 期望值并且无法覆盖。</p>
<p>当 JSON 响应内容包含使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，您可以使用 JsonPath 表达式验证生成的链接，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/people&quot;</span>).accept(MediaType.APPLICATION_JSON))</span><br><span class="line">    .andExpect(jsonPath(<span class="string">&quot;$.links[?(@.rel == &#x27;self&#x27;)].href&quot;</span>).value(<span class="string">&quot;http://localhost:8080/people&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>当 XML 响应内容包含使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-hateoas">Spring HATEOAS</a>创建的超媒体链接时，您可以使用 XPath 表达式验证生成的链接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; ns = Collections.singletonMap(<span class="string">&quot;ns&quot;</span>, <span class="string">&quot;http://www.w3.org/2005/Atom&quot;</span>);</span><br><span class="line">mockMvc.perform(get(<span class="string">&quot;/handle&quot;</span>).accept(MediaType.APPLICATION_XML))</span><br><span class="line">    .andExpect(xpath(<span class="string">&quot;/person/ns:link[@rel=&#x27;self&#x27;]/@href&quot;</span>, ns).string(<span class="string">&quot;http://localhost:8080/people&quot;</span>));</span><br></pre></td></tr></table></figure>
<h5 id="过滤器注册"><a href="#过滤器注册" class="headerlink" title="过滤器注册"></a>过滤器注册</h5><p>设置<code>MockMvc</code>实例时，可以注册一个或多个 Servlet <code>Filter</code>实例，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc = standaloneSetup(<span class="keyword">new</span> PersonController()).addFilters(<span class="keyword">new</span> CharacterEncodingFilter()).build();</span><br></pre></td></tr></table></figure>
<p>已注册的过滤器通过<code>spring-test</code>从<code>spring-test</code>调用，最后一个过滤器委托给<code>DispatcherServlet</code>。</p>
<h5 id="Out-of-Container和End-to-End集成测试之间的差异"><a href="#Out-of-Container和End-to-End集成测试之间的差异" class="headerlink" title="Out-of-Container和End-to-End集成测试之间的差异"></a>Out-of-Container和End-to-End集成测试之间的差异</h5><p>如前所述 Spring MVC Test 构建在<code>spring-test</code>模块的 Servlet API mock objects 之上，并且不使用 running Servlet 容器。因此，与使用实际 client 和 server running 的完整 end-to-end integration 测试相比，存在一些重要差异。</p>
<p>考虑这一点的最简单方法是从空白<code>MockHttpServletRequest</code>开始。无论你添加什么是请求变成什么。令你惊讶的是，默认情况下没有 context 路径;没有<code>jsessionid</code> cookie;没有转发，错误或异步调度;因此，没有实际的 JSP 渲染。相反，“转发”和“重定向”的 URL 保存在<code>MockHttpServletResponse</code>中，并且可以满足期望。</p>
<p>这意味着，如果使用 JSP，则可以验证请求转发到的 JSP 页面，但不呈现 HTML。换句话说，不调用 JSP。但请注意，所有其他不依赖转发的呈现技术(如 Thymeleaf 和 Freemarker)都会按预期将 HTML 呈现给响应主体。通过<code>@ResponseBody</code>方法呈现 JSON，XML 和其他格式也是如此。</p>
<p>或者，您可以考虑 Spring Boot 与<code>@WebIntegrationTest</code>的完整 end-to-end integration 测试支持。见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html#boot-features-testing-spring-boot-applications">Spring Boot Reference Guide</a>。</p>
<p>每种方法都有利弊。 Spring MVC Test 中提供的选项在从经典单元测试到完整整合测试的规模上是不同的停止。确切地说，Spring MVC Test 中的所有选项都属于经典单元测试类别，但它们更接近它。例如，您可以通过将模拟服务注入控制器来隔离 web 层，在这种情况下，您只通过<code>DispatcherServlet</code>测试 web 层，但使用实际的 Spring configuration，因为您可以独立于上面的层测试数据访问层。此外，您可以使用 stand-alone 设置，在 time 时关注一个控制器并手动提供使其工作所需的 configuration。</p>
<p>使用 Spring MVC Test 时的另一个重要区别是，从概念上讲，这样的测试是 server-side，所以你可以检查使用了什么处理程序，是否使用 HandlerExceptionResolver 处理 exception，model 的内容是什么，binding 错误是什么等细节。这意味着编写期望更容易，因为服务器不是黑盒子，就像通过实际的 HTTP client 测试它一样。这通常是经典单元测试的一个优点：它更容易编写，推理和调试，但不能取代完整整合测试的需要。在同一时间，重要的是不要忽视响应是最重要的检查事实。简而言之，即使在同一个项目中，也存在多种样式和测试策略的空间。</p>
<h5 id="进一步Server-Side测试实例"><a href="#进一步Server-Side测试实例" class="headerlink" title="进一步Server-Side测试实例"></a>进一步Server-Side测试实例</h5><p>framework 自己的测试包括<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/servlet/samples">许多 sample 测试</a>旨在展示如何使用 Spring MVC Test。您可以浏览这些示例以获取更多想法。此外，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-mvc-showcase">spring-mvc-showcase</a>项目具有基于 Spring MVC 测试的完整测试覆盖率。</p>
<h4 id="HtmlUnit集成"><a href="#HtmlUnit集成" class="headerlink" title="HtmlUnit集成"></a>HtmlUnit集成</h4><p>Spring 在<a href="#Server-Side测试">MockMvc</a>和<a target="_blank" rel="noopener" href="http://htmlunit.sourceforge.net/">HtmlUnit</a>之间提供 integration。这简化了使用 HTML-based 视图时执行 end-to-end 测试的过程。这个 integration 让你：</p>
<ul>
<li>使用<a target="_blank" rel="noopener" href="http://htmlunit.sourceforge.net/">HtmlUnit</a>，<a target="_blank" rel="noopener" href="http://seleniumhq.org/projects/webdriver/">webdriver</a>和<a target="_blank" rel="noopener" href="http://www.gebish.org/manual/current/#spock-junit-testng">创业板</a>等工具轻松测试 HTML 页面，而无需部署到 Servlet 容器。</li>
<li>在页面中测试 JavaScript。</li>
<li>(可选)使用 mock 服务进行测试以加快测试速度。</li>
<li>在 in-container end-to-end 测试和 out-of-container integration 测试之间共享逻辑。</li>
</ul>
<blockquote>
<p>MockMvc 使用不依赖于 Servlet 容器的模板技术(对于 example，Thymeleaf，FreeMarker 等)，但它不适用于 JSP，因为它们依赖于 Servlet 容器。</p>
</blockquote>
<h5 id="为什么HtmlUnit集成？"><a href="#为什么HtmlUnit集成？" class="headerlink" title="为什么HtmlUnit集成？"></a>为什么HtmlUnit集成？</h5><p>想到的最明显的问题是“为什么我需要这个？”通过探索一个非常基本的 sample application 可以找到答案。假设您有 Spring MVC web application，它支持<code>Message</code> object 上的 CRUD 操作。 application 还支持对所有消息进行分页。你会怎么做测试呢？</p>
<p>使用 Spring MVC Test，我们可以轻松测试是否能够创建<code>Message</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MockHttpServletRequestBuilder createMessage = post(<span class="string">&quot;/messages/&quot;</span>)</span><br><span class="line">        .param(<span class="string">&quot;summary&quot;</span>, <span class="string">&quot;Spring Rocks&quot;</span>)</span><br><span class="line">        .param(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;In case you didn&#x27;t know, Spring Rocks!&quot;</span>);</span><br><span class="line"></span><br><span class="line">mockMvc.perform(createMessage)</span><br><span class="line">        .andExpect(status().is3xxRedirection())</span><br><span class="line">        .andExpect(redirectedUrl(<span class="string">&quot;/messages/123&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>如果我们想测试允许我们创建消息的表单视图，该怎么办？对于 example，假设我们的表单看起来像以下代码段：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;messageForm&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/messages/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pull-right&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/messages/&quot;</span>&gt;</span>Messages<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;summary&quot;</span>&gt;</span>Summary<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;required&quot;</span> <span class="attr">id</span>=<span class="string">&quot;summary&quot;</span> <span class="attr">name</span>=<span class="string">&quot;summary&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;text&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-actions&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Create&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们如何确保我们的表单产生正确的请求以创建新消息？天真的尝试可能类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(get(<span class="string">&quot;/messages/form&quot;</span>))</span><br><span class="line">        .andExpect(xpath(<span class="string">&quot;//input[@name=&#x27;summary&#x27;]&quot;</span>).exists())</span><br><span class="line">        .andExpect(xpath(<span class="string">&quot;//textarea[@name=&#x27;text&#x27;]&quot;</span>).exists());</span><br></pre></td></tr></table></figure>
<p>该测试有一些明显的缺点。如果我们更新控制器以使用参数<code>message</code>而不是<code>text</code>，我们的表单测试将继续通过，即使 HTML 表单与控制器不同步。要解决这个问题，我们可以结合两个测试，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String summaryParamName = <span class="string">&quot;summary&quot;</span>;</span><br><span class="line">String textParamName = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">mockMvc.perform(get(<span class="string">&quot;/messages/form&quot;</span>))</span><br><span class="line">        .andExpect(xpath(<span class="string">&quot;//input[@name=&#x27;&quot;</span> + summaryParamName + <span class="string">&quot;&#x27;]&quot;</span>).exists())</span><br><span class="line">        .andExpect(xpath(<span class="string">&quot;//textarea[@name=&#x27;&quot;</span> + textParamName + <span class="string">&quot;&#x27;]&quot;</span>).exists());</span><br><span class="line"></span><br><span class="line">MockHttpServletRequestBuilder createMessage = post(<span class="string">&quot;/messages/&quot;</span>)</span><br><span class="line">        .param(summaryParamName, <span class="string">&quot;Spring Rocks&quot;</span>)</span><br><span class="line">        .param(textParamName, <span class="string">&quot;In case you didn&#x27;t know, Spring Rocks!&quot;</span>);</span><br><span class="line"></span><br><span class="line">mockMvc.perform(createMessage)</span><br><span class="line">        .andExpect(status().is3xxRedirection())</span><br><span class="line">        .andExpect(redirectedUrl(<span class="string">&quot;/messages/123&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这样可以降低我们的测试错误传递的风险，但仍然存在一些问题：</p>
<ul>
<li>如果我们的页面上有多个表单怎么办？不可否认，我们可以更新我们的 XPath 表达式，但是由于我们考虑了更多因素，它们变得更加复杂：字段是否是正确的类型？字段是否已启用？等等。</li>
<li>另一个问题是我们正在做我们期望的工作。我们必须首先验证视图，然后我们使用我们刚刚验证的相同参数提交视图。理想情况下，这可以一次完成。</li>
<li>最后，我们仍然无法解释一些事情。例如，如果表单具有我们希望测试的 JavaScript 验证，该怎么办？</li>
</ul>
<p>总体问题是测试 web 页面不涉及单个交互。相反，它是用户如何与 web 页面交互以及 web 页面如何与其他资源交互的组合。对于 example，表单视图的结果用作用户输入创建消息的输入。此外，我们的表单视图可能会使用影响页面行为的其他资源，例如 JavaScript 验证。</p>
<h6 id="Integration测试救援？"><a href="#Integration测试救援？" class="headerlink" title="Integration测试救援？"></a>Integration测试救援？</h6><p>要解决前面提到的问题，我们可以执行 end-to-end integration 测试，但这有一些缺点。考虑测试让我们浏览消息的视图。我们可能需要以下测试：</p>
<ul>
<li>我们的页面是否向用户显示通知，指示消息为空时没有结果可用？</li>
<li>我们的页面是否正确显示单个消息？</li>
<li>我们的页面是否正确支持分页？</li>
</ul>
<p>要设置这些测试，我们需要确保我们的数据库包含正确的消息。这导致了许多额外的挑战：</p>
<ul>
<li>确保数据库中存在正确的消息可能很繁琐。 (考虑外国 key constraints.)</li>
<li>测试可能会变慢，因为每个测试都需要确保数据库处于正确的 state 状态。</li>
<li>由于我们的数据库需要在特定的 state 中，因此我们无法在 parallel 中运行测试。</li>
<li>对诸如 auto-generatedid，时间戳等项目执行断言可能很困难。</li>
</ul>
<p>这些挑战并不意味着我们应该完全放弃 end-to-end 整合测试。相反，我们可以通过重构我们的详细测试来减少 end-to-end 整合测试的数量，以便使用 mock 服务，这些服务运行速度更快，更可靠，没有副作用。然后，我们可以实现少量 true end-to-end integration 测试，以验证简单的工作流程，以确保一切正常工作。</p>
<h6 id="输入HtmlUnit集成"><a href="#输入HtmlUnit集成" class="headerlink" title="输入HtmlUnit集成"></a>输入HtmlUnit集成</h6><p>那么我们如何才能在测试页面交互之间取得平衡，并在测试套件中保持良好的性能？答案是：“通过将 MockMvc 与 HtmlUnit 集成。”</p>
<h6 id="HtmlUnit集成选项"><a href="#HtmlUnit集成选项" class="headerlink" title="HtmlUnit集成选项"></a>HtmlUnit集成选项</h6><p>当您想要将 MockMvc 与 HtmlUnit 集成时，您有许多选项：</p>
<ul>
<li><a href="#MockMvc和HtmlUnit">MockMvc 和 HtmlUnit</a>：如果要使用原始 HtmlUnit libraries，请使用此选项。</li>
<li><a href="#MockMvc和WebDriver">MockMvc 和 WebDriver</a>：使用此选项可以简化 integration 和 end-to-end 测试之间的开发和重用 code。</li>
<li><a href="#MockMvc和Geb">MockMvc 和 Geb</a>：如果要使用 Groovy 进行测试，简化开发并在 integration 和 end-to-end testing 之间重用 code，请使用此选项。</li>
</ul>
<h5 id="MockMvc和HtmlUnit"><a href="#MockMvc和HtmlUnit" class="headerlink" title="MockMvc和HtmlUnit"></a>MockMvc和HtmlUnit</h5><p>本节介绍如何集成 MockMvc 和 HtmlUnit。如果要使用原始 HtmlUnit libraries，请使用此选项。</p>
<h6 id="MockMvc和HtmlUnit设置"><a href="#MockMvc和HtmlUnit设置" class="headerlink" title="MockMvc和HtmlUnit设置"></a>MockMvc和HtmlUnit设置</h6><p>首先，确保您已在<code>net.sourceforge.htmlunit:htmlunit</code>中包含测试依赖项。为了使用 HtmlUnit 和 Apache HttpComponents 4.5，你需要使用 HtmlUnit 2.18 或更高版本。</p>
<p>我们可以使用<code>MockMvcWebClientBuilder</code>轻松创建一个与 MockMvc 集成的 HtmlUnit <code>WebClient</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">WebClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    webClient = MockMvcWebClientBuilder</span><br><span class="line">            .webAppContextSetup(context)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是使用<code>MockMvcWebClientBuilder</code>的简单示例。有关高级用法，请参阅<a href="#高级MockMvcWebClientBuilder">高级 MockMvcWebClientBuilder</a>。</p>
</blockquote>
<p>这确保了 references <code>localhost</code>作为服务器的任何 URL 都定向到我们的<code>MockMvc</code>实例，而无需真正的 HTTP 连接。正常情况下，使用网络连接请求任何其他 URL。这让我们可以轻松测试 CDN 的使用。</p>
<h6 id="MockMvc和HtmlUnit用法"><a href="#MockMvc和HtmlUnit用法" class="headerlink" title="MockMvc和HtmlUnit用法"></a>MockMvc和HtmlUnit用法</h6><p>现在我们可以像往常一样使用 HtmlUnit，但不需要将 application 部署到 Servlet 容器。对于 example，我们可以请求视图创建包含以下内容的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HtmlPage createMsgFormPage = webClient.getPage(<span class="string">&quot;http://localhost/messages/form&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认的 context 路径是<code>&quot;&quot;</code>。或者，我们可以指定 context 路径，如<a href="#高级MockMvcWebClientBuilder">高级 MockMvcWebClientBuilder</a>中所述。</p>
</blockquote>
<p>一旦我们对<code>HtmlPage</code>进行了 reference，我们就可以填写表单并提交它以创建一条消息，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HtmlForm form = createMsgFormPage.getHtmlElementById(<span class="string">&quot;messageForm&quot;</span>);</span><br><span class="line">HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById(<span class="string">&quot;summary&quot;</span>);</span><br><span class="line">summaryInput.setValueAttribute(<span class="string">&quot;Spring Rocks&quot;</span>);</span><br><span class="line">HtmlTextArea textInput = createMsgFormPage.getHtmlElementById(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">textInput.setText(<span class="string">&quot;In case you didn&#x27;t know, Spring Rocks!&quot;</span>);</span><br><span class="line">HtmlSubmitInput submit = form.getOneHtmlElementByAttribute(<span class="string">&quot;input&quot;</span>, <span class="string">&quot;type&quot;</span>, <span class="string">&quot;submit&quot;</span>);</span><br><span class="line">HtmlPage newMessagePage = submit.click();</span><br></pre></td></tr></table></figure>
<p>最后，我们可以验证是否已成功创建新消息。以下断言使用<a target="_blank" rel="noopener" href="https://joel-costigliola.github.io/assertj/">AssertJ</a> library：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assertThat(newMessagePage.getUrl().toString()).endsWith(<span class="string">&quot;/messages/123&quot;</span>);</span><br><span class="line">String id = newMessagePage.getHtmlElementById(<span class="string">&quot;id&quot;</span>).getTextContent();</span><br><span class="line">assertThat(id).isEqualTo(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">String summary = newMessagePage.getHtmlElementById(<span class="string">&quot;summary&quot;</span>).getTextContent();</span><br><span class="line">assertThat(summary).isEqualTo(<span class="string">&quot;Spring Rocks&quot;</span>);</span><br><span class="line">String text = newMessagePage.getHtmlElementById(<span class="string">&quot;text&quot;</span>).getTextContent();</span><br><span class="line">assertThat(text).isEqualTo(<span class="string">&quot;In case you didn&#x27;t know, Spring Rocks!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>前面的 code 以多种方式改进了我们的<a href="#为什么HtmlUnit集成?">MockMvc 测试</a>。首先，我们不再需要显式验证我们的表单，然后创建一个看起来像表单的请求。相反，我们请求表单，填写表单并提交表单，从而显着减少开销。</p>
<p>另一个重要因素是<a target="_blank" rel="noopener" href="http://htmlunit.sourceforge.net/javascript.html">HtmlUnit 使用 Mozilla Rhino 引擎</a>来评估 JavaScript。这意味着我们还可以在页面中测试 JavaScript 的行为。</p>
<p>有关使用 HtmlUnit 的其他信息，请参阅<a target="_blank" rel="noopener" href="http://htmlunit.sourceforge.net/gettingStarted.html">HtmlUnit 文档</a>。</p>
<h6 id="高级MockMvcWebClientBuilder"><a href="#高级MockMvcWebClientBuilder" class="headerlink" title="高级MockMvcWebClientBuilder"></a>高级MockMvcWebClientBuilder</h6><p>在到目前为止的示例中，我们以最简单的方式使用<code>MockMvcWebClientBuilder</code>，通过基于 Spring TestContext Framework 为我们加载的<code>WebApplicationContext</code>构建<code>WebClient</code>。在以下 example 中重复此方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">WebClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    webClient = MockMvcWebClientBuilder</span><br><span class="line">            .webAppContextSetup(context)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以指定其他 configuration 选项，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WebClient webClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    webClient = MockMvcWebClientBuilder</span><br><span class="line">        <span class="comment">// demonstrates applying a MockMvcConfigurer (Spring Security)</span></span><br><span class="line">        .webAppContextSetup(context, springSecurity())</span><br><span class="line">        <span class="comment">// for illustration only - defaults to &quot;&quot;</span></span><br><span class="line">        .contextPath(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">// By default MockMvc is used for localhost only;</span></span><br><span class="line">        <span class="comment">// the following will use MockMvc for example.com and example.org as well</span></span><br><span class="line">        .useMockMvcForHosts(<span class="string">&quot;example.com&quot;</span>,<span class="string">&quot;example.org&quot;</span>)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为替代方案，我们可以通过单独配置<code>MockMvc</code>实例并将其提供给<code>MockMvcWebClientBuilder</code>来执行完全相同的设置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MockMvc mockMvc = MockMvcBuilders</span><br><span class="line">        .webAppContextSetup(context)</span><br><span class="line">        .apply(springSecurity())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">webClient = MockMvcWebClientBuilder</span><br><span class="line">        .mockMvcSetup(mockMvc)</span><br><span class="line">        <span class="comment">// for illustration only - defaults to &quot;&quot;</span></span><br><span class="line">        .contextPath(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">// By default MockMvc is used for localhost only;</span></span><br><span class="line">        <span class="comment">// the following will use MockMvc for example.com and example.org as well</span></span><br><span class="line">        .useMockMvcForHosts(<span class="string">&quot;example.com&quot;</span>,<span class="string">&quot;example.org&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>这更加冗长，但是，通过使用<code>MockMvc</code>实例构建<code>WebClient</code>，我们可以轻而易举地获得 MockMvc 的全部功能。</p>
<blockquote>
<p>有关创建<code>MockMvc</code>实例的其他信息，请参阅<a href="#设置选择">设置选择</a>。</p>
</blockquote>
<h5 id="MockMvc和WebDriver"><a href="#MockMvc和WebDriver" class="headerlink" title="MockMvc和WebDriver"></a>MockMvc和WebDriver</h5><p>在前面的部分中，我们已经了解了如何将 MockMvc 与原始 HtmlUnit API 结合使用。在本节中，我们使用 Selenium <a target="_blank" rel="noopener" href="http://docs.seleniumhq.org/projects/webdriver/">webdriver</a>中的其他抽象来使事情变得更加容易。</p>
<h6 id="为什么选择WebDriver和MockMvc"><a href="#为什么选择WebDriver和MockMvc" class="headerlink" title="为什么选择WebDriver和MockMvc?"></a>为什么选择WebDriver和MockMvc?</h6><p>我们已经可以使用 HtmlUnit 和 MockMvc，那么我们为什么要使用 WebDriver 呢？ Selenium WebDriver 提供了一个非常优雅的 API，可以让我们轻松地组织我们的 code。为了更好地展示它的工作原理，我们将在本节中探讨一个 example。</p>
<blockquote>
<p>尽管是<a target="_blank" rel="noopener" href="http://docs.seleniumhq.org/">Selenium</a>的一部分，但 WebDriver 并不需要 Selenium Server 来运行您的测试。</p>
</blockquote>
<p>假设我们需要确保正确创建消息。测试涉及查找 HTML 表单输入元素，填写它们以及进行各种断言。</p>
<p>这种方法导致许多单独的测试，因为我们也想测试错误条件。例如，如果我们只填写表单的一部分，我们希望确保收到错误。如果我们填写整个表格，则应在之后显示新创建的消息。</p>
<p>如果其中一个字段被命名为“summary”，我们可能会在我们的测试中有多个类似于以下重复的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HtmlTextInput summaryInput = currentPage.getHtmlElementById(<span class="string">&quot;summary&quot;</span>);</span><br><span class="line">summaryInput.setValueAttribute(summary);</span><br></pre></td></tr></table></figure>
<p>那么如果我们将<code>id</code>更改为<code>smmry</code>会发生什么？这样做会迫使我们更新所有测试以包含此更改。这违反了 DRY 原则，因此我们理想情况下应将此 code 提取到自己的方法中，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HtmlPage <span class="title">createMessage</span><span class="params">(HtmlPage currentPage, String summary, String text)</span> </span>&#123;</span><br><span class="line">    setSummary(currentPage, summary);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSummary</span><span class="params">(HtmlPage currentPage, String summary)</span> </span>&#123;</span><br><span class="line">    HtmlTextInput summaryInput = currentPage.getHtmlElementById(<span class="string">&quot;summary&quot;</span>);</span><br><span class="line">    summaryInput.setValueAttribute(summary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做可确保我们在更改 UI 时不必更新所有测试。</p>
<p>我们甚至可以进一步将这个逻辑放在一个<code>Object</code>中，代表我们当前所在的<code>HtmlPage</code>，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateMessagePage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HtmlPage currentPage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HtmlTextInput summaryInput;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> HtmlSubmitInput submit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateMessagePage</span><span class="params">(HtmlPage currentPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentPage = currentPage;</span><br><span class="line">        <span class="keyword">this</span>.summaryInput = currentPage.getHtmlElementById(<span class="string">&quot;summary&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.submit = currentPage.getHtmlElementById(<span class="string">&quot;submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMessage</span><span class="params">(String summary, String text)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        setSummary(summary);</span><br><span class="line"></span><br><span class="line">        HtmlPage result = submit.click();</span><br><span class="line">        <span class="keyword">boolean</span> error = CreateMessagePage.at(result);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) (error ? <span class="keyword">new</span> CreateMessagePage(result) : <span class="keyword">new</span> ViewMessagePage(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSummary</span><span class="params">(String summary)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        summaryInput.setValueAttribute(summary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">at</span><span class="params">(HtmlPage page)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Create Message&quot;</span>.equals(page.getTitleText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以前，这个 pattern 被称为<a target="_blank" rel="noopener" href="https://github.com/SeleniumHQ/selenium/wiki/PageObjects">Page Object Pattern</a>。虽然我们当然可以使用 HtmlUnit 执行此操作，但 WebDriver 提供了一些我们在以下部分中探讨的工具，以使此 pattern 更容易实现。</p>
<h6 id="MockMvc和WebDriver设置"><a href="#MockMvc和WebDriver设置" class="headerlink" title="MockMvc和WebDriver设置"></a>MockMvc和WebDriver设置</h6><p>要将 Selenium WebDriver 与 Spring MVC Test framework 一起使用，请确保您的项目包含对<code>org.seleniumhq.selenium:selenium-htmlunit-driver</code>的测试依赖项。</p>
<p>我们可以使用<code>MockMvcHtmlUnitDriverBuilder</code>轻松创建与 MockMvc 集成的 Selenium WebDriver，如以下 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">    WebDriver driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver = MockMvcHtmlUnitDriverBuilder</span><br><span class="line">                .webAppContextSetup(context)</span><br><span class="line">                .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是使用<code>MockMvcHtmlUnitDriverBuilder</code>的简单示例。有关更高级的用法，请参阅<a href="#高级MockMvcHtmlUnitDriverBuilder">高级 MockMvcHtmlUnitDriverBuilder</a>。</p>
</blockquote>
<p>前面的 example 确保将_re 作为服务器的任何 URL 定向到我们的<code>MockMvc</code>实例，而无需真正的 HTTP 连接。正常情况下，使用网络连接请求任何其他 URL。这让我们可以轻松测试 CDN 的使用。</p>
<h6 id="MockMvc和WebDriver用法"><a href="#MockMvc和WebDriver用法" class="headerlink" title="MockMvc和WebDriver用法"></a>MockMvc和WebDriver用法</h6><p>现在我们可以像往常一样使用 WebDriver，但不需要将 application 部署到 Servlet 容器。对于 example，我们可以请求视图创建包含以下内容的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateMessagePage page = CreateMessagePage.to(driver);</span><br></pre></td></tr></table></figure>
<p>然后我们可以填写表单并提交它以创建消息，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewMessagePage viewMessagePage =</span><br><span class="line">        page.createMessage(ViewMessagePage.class, expectedSummary, expectedText);</span><br></pre></td></tr></table></figure>
<p>这通过利用 Page Object Pattern 改进了<a href="#MockMvc和HtmlUnit用法">HtmlUnit 测试</a>的设计。正如我们在<a href="#为什么选择WebDriver和MockMvc?">为什么选择 WebDriver 和 MockMvc？</a>中提到的，我们可以使用 Page Object Pattern 和 HtmlUnit，但使用 WebDriver 会更容易。考虑以下<code>CreateMessagePage</code> implementation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateMessagePage</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractPage</span> </span>&#123; (<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    (<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> WebElement summary;</span><br><span class="line">    <span class="keyword">private</span> WebElement text;</span><br><span class="line"></span><br><span class="line">    (<span class="number">3</span>)</span><br><span class="line">    <span class="meta">@FindBy(css = &quot;input[type=submit]&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> WebElement submit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreateMessagePage</span><span class="params">(WebDriver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(driver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMessage</span><span class="params">(Class&lt;T&gt; resultPage, String summary, String details)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.summary.sendKeys(summary);</span><br><span class="line">        <span class="keyword">this</span>.text.sendKeys(details);</span><br><span class="line">        <span class="keyword">this</span>.submit.click();</span><br><span class="line">        <span class="keyword">return</span> PageFactory.initElements(driver, resultPage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CreateMessagePage <span class="title">to</span><span class="params">(WebDriver driver)</span> </span>&#123;</span><br><span class="line">        driver.get(<span class="string">&quot;http://localhost:9990/mail/messages/form&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> PageFactory.initElements(driver, CreateMessagePage.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td><code>CreateMessagePage</code>扩展<code>AbstractPage</code>。我们不会详细介绍<code>AbstractPage</code>的细节，但总的来说，它包含了我们所有页面的 common 功能。例如，如果我们的 application 具有导航栏，global 错误消息和其他 features，我们可以将此逻辑放在共享位置。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>我们有一个成员变量，用于我们感兴趣的 HTML 页面的每个部分。这些是<code>WebElement</code>类型。 WebDriver 的<a target="_blank" rel="noopener" href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory">PageFactory</a>允许我们通过自动解析每个<code>WebElement</code>从<code>CreateMessagePage</code>的 HtmlUnit version 中删除大量 code。 <a target="_blank" rel="noopener" href="https://seleniumhq.github.io/selenium/docs/api/java/org/openqa/selenium/support/PageFactory.html#initElements-org.openqa.selenium.WebDriver-java.lang.Class-">PageFactory#initElements(WebDriver,Class)</a>方法通过使用字段 name 自动解析每个<code>WebElement</code>，并通过 HTML 页面中元素的<code>id</code>或<code>name</code>查找它。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>我们可以使用<a target="_blank" rel="noopener" href="https://github.com/SeleniumHQ/selenium/wiki/PageFactory#making-the-example-work-using-annotations">@FindBy annotation</a>来覆盖默认的查找行为。我们的 example 显示了如何使用<code>@FindBy</code> annotation 查找带有<code>css</code>选择器的提交按钮(<strong>输入[2083]</strong>)。</td>
</tr>
</tbody>
</table>
</div>
<p>最后，我们可以验证是否已成功创建新消息。以下断言使用<a target="_blank" rel="noopener" href="https://joel-costigliola.github.io/assertj/">AssertJ</a>断言 library：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage);</span><br><span class="line">assertThat(viewMessagePage.getSuccess()).isEqualTo(<span class="string">&quot;Successfully created a new message&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以看到我们的<code>ViewMessagePage</code>允许我们与自定义域 model 进行交互。对于 example，它公开了一个返回<code>Message</code> object 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Message <span class="title">getMessage</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    Message message = <span class="keyword">new</span> Message();</span><br><span class="line">    message.setId(getId());</span><br><span class="line">    message.setCreated(getCreated());</span><br><span class="line">    message.setSummary(getSummary());</span><br><span class="line">    message.setText(getText());</span><br><span class="line">    <span class="keyword">return</span> message;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以在断言中使用富域 objects。</p>
<p>最后，我们不要忘记在测试完成时关闭<code>WebDriver</code>实例，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@After</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        driver.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关使用 WebDriver 的其他信息，请参阅 Selenium <a target="_blank" rel="noopener" href="https://github.com/SeleniumHQ/selenium/wiki/Getting-Started">WebDriver 文档</a>。</p>
<h6 id="高级MockMvcHtmlUnitDriverBuilder"><a href="#高级MockMvcHtmlUnitDriverBuilder" class="headerlink" title="高级MockMvcHtmlUnitDriverBuilder"></a>高级MockMvcHtmlUnitDriverBuilder</h6><p>在到目前为止的示例中，我们以最简单的方式使用<code>MockMvcHtmlUnitDriverBuilder</code>，通过基于 Spring TestContext Framework 为我们加载的<code>WebApplicationContext</code>构建<code>WebDriver</code>。这里重复这种方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">WebApplicationContext context;</span><br><span class="line"></span><br><span class="line">WebDriver driver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    driver = MockMvcHtmlUnitDriverBuilder</span><br><span class="line">            .webAppContextSetup(context)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以指定其他 configuration 选项，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WebDriver driver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        driver = MockMvcHtmlUnitDriverBuilder</span><br><span class="line">                <span class="comment">// demonstrates applying a MockMvcConfigurer (Spring Security)</span></span><br><span class="line">                .webAppContextSetup(context, springSecurity())</span><br><span class="line">                <span class="comment">// for illustration only - defaults to &quot;&quot;</span></span><br><span class="line">                .contextPath(<span class="string">&quot;&quot;</span>)</span><br><span class="line">                <span class="comment">// By default MockMvc is used for localhost only;</span></span><br><span class="line">                <span class="comment">// the following will use MockMvc for example.com and example.org as well</span></span><br><span class="line">                .useMockMvcForHosts(<span class="string">&quot;example.com&quot;</span>,<span class="string">&quot;example.org&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为替代方案，我们可以通过单独配置<code>MockMvc</code>实例并将其提供给<code>MockMvcHtmlUnitDriverBuilder</code>来执行完全相同的设置，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MockMvc mockMvc = MockMvcBuilders</span><br><span class="line">        .webAppContextSetup(context)</span><br><span class="line">        .apply(springSecurity())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">driver = MockMvcHtmlUnitDriverBuilder</span><br><span class="line">        .mockMvcSetup(mockMvc)</span><br><span class="line">        <span class="comment">// for illustration only - defaults to &quot;&quot;</span></span><br><span class="line">        .contextPath(<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="comment">// By default MockMvc is used for localhost only;</span></span><br><span class="line">        <span class="comment">// the following will use MockMvc for example.com and example.org as well</span></span><br><span class="line">        .useMockMvcForHosts(<span class="string">&quot;example.com&quot;</span>,<span class="string">&quot;example.org&quot;</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure>
<p>这更加冗长，但是，通过使用<code>MockMvc</code>实例构建<code>WebDriver</code>，我们可以轻而易举地获得 MockMvc 的全部功能。</p>
<blockquote>
<p>有关创建<code>MockMvc</code>实例的其他信息，请参阅<a href="#设置选择">设置选择</a>。</p>
</blockquote>
<h5 id="MockMvc和Geb"><a href="#MockMvc和Geb" class="headerlink" title="MockMvc和Geb"></a>MockMvc和Geb</h5><p>在上一节中，我们了解了如何将 MockMvc 与 WebDriver 一起使用。在本节中，我们使用<a target="_blank" rel="noopener" href="http://www.gebish.org/">创业板</a>使我们的测试甚至 Groovy-er。</p>
<h6 id="为什么选择Geb和MockMvc？"><a href="#为什么选择Geb和MockMvc？" class="headerlink" title="为什么选择Geb和MockMvc？"></a>为什么选择Geb和MockMvc？</h6><p>Geb 由 WebDriver 支持，因此它提供了许多我们从 WebDriver 获得的<a href="#为什么选择WebDriver和MockMvc?">同样的好处</a>。但是，通过为我们处理一些样板 code，Geb 使事情变得更加容易。</p>
<h6 id="MockMvc和Geb设置"><a href="#MockMvc和Geb设置" class="headerlink" title="MockMvc和Geb设置"></a>MockMvc和Geb设置</h6><p>我们可以使用使用 MockMvc 的 Selenium WebDriver 轻松初始化 Geb <code>Browser</code>，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    browser.driver = MockMvcHtmlUnitDriverBuilder</span><br><span class="line">        .webAppContextSetup(context)</span><br><span class="line">        .build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是使用<code>MockMvcHtmlUnitDriverBuilder</code>的简单示例。有关更高级的用法，请参阅<a href="#高级MockMvcHtmlUnitDriverBuilder">高级 MockMvcHtmlUnitDriverBuilder</a>。</p>
</blockquote>
<p>这可确保任何引用<code>localhost</code>作为服务器的 URL 都定向到我们的<code>MockMvc</code>实例，而无需真正的 HTTP 连接。正常使用网络连接请求任何其他 URL。这让我们可以轻松测试 CDN 的使用。</p>
<h6 id="MockMvc和Geb用法"><a href="#MockMvc和Geb用法" class="headerlink" title="MockMvc和Geb用法"></a>MockMvc和Geb用法</h6><p>现在我们可以像往常一样使用 Geb，但不需要将 application 部署到 Servlet 容器。对于 example，我们可以请求视图创建包含以下内容的消息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to CreateMessagePage</span><br></pre></td></tr></table></figure>
<p>然后我们可以填写表单并提交它以创建消息，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">when:</span><br><span class="line">form.summary = expectedSummary</span><br><span class="line">form.text = expectedMessage</span><br><span class="line">submit.click(ViewMessagePage)</span><br></pre></td></tr></table></figure>
<p>任何未识别的方法 calls 或 property 访问或未找到的 references 将被转发到当前页面 object。这删除了直接使用 WebDriver 时我们需要的许多样板 code。</p>
<p>与直接使用 WebDriver 一样，这通过使用 Page Object Pattern 改进了<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#spring-mvc-test-server-htmlunit-mah-usage">HtmlUnit 测试</a>的设计。如前所述，我们可以使用 Page Object Pattern 和 HtmlUnit 以及 WebDriver，但使用 Geb 更容易。考虑我们新的 Groovy-based <code>CreateMessagePage</code> implementation：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateMessagePage</span> <span class="keyword">extends</span> <span class="title">Page</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> url = <span class="string">&#x27;messages/form&#x27;</span></span><br><span class="line">    <span class="keyword">static</span> at = &#123; <span class="keyword">assert</span> title == <span class="string">&#x27;Messages : Create&#x27;</span>; <span class="keyword">true</span> &#125;</span><br><span class="line">    <span class="keyword">static</span> content =  &#123;</span><br><span class="line">        submit &#123; $(<span class="string">&#x27;input[type=submit]&#x27;</span>) &#125;</span><br><span class="line">        form &#123; $(<span class="string">&#x27;form&#x27;</span>) &#125;</span><br><span class="line">        errors(required:<span class="keyword">false</span>) &#123; $(<span class="string">&#x27;label.error, .alert-error&#x27;</span>)?.text() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的<code>CreateMessagePage</code>扩展<code>Page</code>。我们不会详细介绍<code>Page</code>的细节，但总的来说，它包含了我们所有页面的 common 功能。我们定义了一个可以在其中找到此页面的 URL。这让我们可以导航到页面，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to CreateMessagePage</span><br></pre></td></tr></table></figure>
<p>我们还有一个<code>at</code>闭包，用于确定我们是否在指定页面。如果我们在正确的页面上，它应该_ret。这就是为什么我们可以断言我们在正确的页面上，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then:</span><br><span class="line">at CreateMessagePage</span><br><span class="line">errors.contains(&#39;This field is required.&#39;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们在闭包中使用断言，以便在错误的页面中我们可以确定出错的地方。</p>
</blockquote>
<p>接下来，我们创建一个<code>content</code>闭包，指定页面中所有感兴趣的区域。我们可以使用<a target="_blank" rel="noopener" href="http://www.gebish.org/manual/current/#the-jquery-ish-navigator-api">jQuery-ish Navigator API</a>来选择我们感兴趣的内容。</p>
<p>最后，我们可以验证是否已成功创建新消息，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">then:</span><br><span class="line">at ViewMessagePage</span><br><span class="line">success &#x3D;&#x3D; &#39;Successfully created a new message&#39;</span><br><span class="line">id</span><br><span class="line">date</span><br><span class="line">summary &#x3D;&#x3D; expectedSummary</span><br><span class="line">message &#x3D;&#x3D; expectedMessage</span><br></pre></td></tr></table></figure>
<p>有关如何充分利用 Geb 的更多详细信息，请参阅<a target="_blank" rel="noopener" href="http://www.gebish.org/manual/current/">The Geb</a>用户手册。</p>
<h4 id="客户端REST测试"><a href="#客户端REST测试" class="headerlink" title="客户端REST测试"></a>客户端REST测试</h4><p>您可以使用 client-side 测试来测试内部使用<code>RestTemplate</code>的 code。 idea 用于声明预期的请求并提供“存根”响应，以便您可以专注于单独测试 code(即，无需运行服务器)。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();</span><br><span class="line">mockServer.expect(requestTo(<span class="string">&quot;/greeting&quot;</span>)).andRespond(withSuccess());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test code that uses the above RestTemplate ...</span></span><br><span class="line"></span><br><span class="line">mockServer.verify();</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，<code>MockRestServiceServer</code>(client-side REST 测试的中央 class)使用自定义<code>ClientHttpRequestFactory</code>配置<code>RestTemplate</code>，该自定义<code>ClientHttpRequestFactory</code>根据预期断言实际请求并返回“存根”响应。在这种情况下，我们期望<code>/greeting</code>的请求并且想要返回带有<code>text/plain</code>内容的 200 响应。我们可以根据需要定义其他预期请求和存根响应。当我们定义期望的请求和存根响应时，<code>RestTemplate</code>可以像往常一样在 client-side code 中使用。在测试结束时，<code>mockServer.verify()</code>可用于验证是否已满足所有期望。</p>
<p>默认情况下，请求在声明期望的 order 中。您可以在 building 服务器时设置<code>ignoreExpectOrder</code>选项，在这种情况下，检查所有期望(在 order 中)以查找给定请求的 match。这意味着允许请求进入任何 order。以下 example 使用<code>ignoreExpectOrder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(<span class="keyword">true</span>).build();</span><br></pre></td></tr></table></figure>
<p>即使默认情况下无序请求，每个请求也只允许执行一次。 <code>expect</code>方法提供了一个重载变量，它接受一个指定计数范围的<code>ExpectedCount</code>参数(对于 example，<code>once</code>，<code>manyTimes</code>，<code>max</code>，<code>min</code>，<code>between</code>等)。以下 example 使用<code>times</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line"></span><br><span class="line">MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build();</span><br><span class="line">mockServer.expect(times(<span class="number">2</span>), requestTo(<span class="string">&quot;/something&quot;</span>)).andRespond(withSuccess());</span><br><span class="line">mockServer.expect(times(<span class="number">3</span>), requestTo(<span class="string">&quot;/somewhere&quot;</span>)).andRespond(withSuccess());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">mockServer.verify();</span><br></pre></td></tr></table></figure>
<p>请注意，如果未设置<code>ignoreExpectOrder</code>(默认值)，并且因此请求在 order 声明中，则该 order 仅适用于任何预期请求中的第一个。对于 example，如果预期“/something”两次，然后是“/somewhere”三次，那么在请求“/somewhere”之前应该有“/something”的请求，但是，除了后续的“/something”和“/somewhere”之外“，请求可以在任何时间到来。</p>
<p>作为上述所有选项的替代方案，client-side 测试支持还提供<code>ClientHttpRequestFactory</code> implementation，您可以将其配置为<code>RestTemplate</code>以将其绑定到<code>MockMvc</code>实例。这允许使用实际 server-side 逻辑处理请求但不运行服务器。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(<span class="keyword">this</span>.wac).build();</span><br><span class="line"><span class="keyword">this</span>.restTemplate = <span class="keyword">new</span> RestTemplate(<span class="keyword">new</span> MockMvcClientHttpRequestFactory(mockMvc));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test code that uses the above RestTemplate ...</span></span><br></pre></td></tr></table></figure>
<h5 id="静态进口-1"><a href="#静态进口-1" class="headerlink" title="静态进口"></a>静态进口</h5><p>与 server-side 测试一样，client-side 测试的 fluent API 需要一些静态导入。通过搜索<code>MockRest*</code>很容易找到。 Eclipse 用户应该在 Java→编辑器→内容辅助→收藏夹下的 Eclipse 首选项中添加<code>MockRestRequestMatchers.*</code>和<code>MockRestResponseCreators.*</code>作为“最喜欢的静态成员”。这允许在 typing 静态方法 name 的第一个字符后使用内容辅助。其他 IDE(例如 IntelliJ)可能不需要任何额外的 configuration。检查静态成员对 code 完成的支持。</p>
<h5 id="客户端REST测试的更多示例"><a href="#客户端REST测试的更多示例" class="headerlink" title="客户端REST测试的更多示例"></a>客户端REST测试的更多示例</h5><p>Spring MVC Test 自己的测试包括<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/tree/master/spring-test/src/test/java/org/springframework/test/web/client/samples">example 测试</a> client-side REST 测试。</p>
<h3 id="WebTestClient"><a href="#WebTestClient" class="headerlink" title="WebTestClient"></a>WebTestClient</h3><p><code>WebTestClient</code>是一个围绕<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#WebClient">Web 客户端</a>的瘦 shell，用它来执行请求并公开一个专用的，流畅的 API 来验证响应。 <code>WebTestClient</code>使用<a href="#SpringWebReactive">mock 请求和响应</a>绑定到 WebFlux application，或者它可以通过 HTTP 连接测试任何 web 服务器。</p>
<blockquote>
<p>Kotlin 用户：请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-语言支持/#入门">这个部分</a>与使用<code>WebTestClient</code>相关。</p>
</blockquote>
<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>要创建<code>WebTestClient</code>，您必须选择多个服务器设置选项之一。实际上，您要么将 WebFlux application 配置为绑定，要么使用 URL 连接到运行服务器。</p>
<h5 id="绑定到控制器"><a href="#绑定到控制器" class="headerlink" title="绑定到控制器"></a>绑定到控制器</h5><p>以下 example 显示了如何创建服务器设置以在 time 测试一个<code>@Controller</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = WebTestClient.bindToController(<span class="keyword">new</span> TestController()).build();</span><br></pre></td></tr></table></figure>
<p>前面的 example 加载<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#WebFlux配置">WebFlux Java configuration</a>并注册给定的控制器。通过使用 mock 请求和响应 objects，在没有 HTTP 服务器的情况下测试生成的 WebFlux application。构建器上有更多方法可以自定义默认的 WebFlux Java configuration。</p>
<h5 id="绑定到RouterFunction"><a href="#绑定到RouterFunction" class="headerlink" title="绑定到RouterFunction"></a>绑定到RouterFunction</h5><p>以下 example 显示了如何从<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#功能性Endpoints">RouterFunction</a>设置服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RouterFunction&lt;?&gt; route = ...</span><br><span class="line">    client = WebTestClient.bindToRouterFunction(route).build();</span><br></pre></td></tr></table></figure>
<p>在内部，configuration 传递给<code>RouterFunctions.toWebHandler</code>。通过使用 mock 请求和响应 objects，在没有 HTTP 服务器的情况下测试生成的 WebFlux application。</p>
<h5 id="绑定到ApplicationContext"><a href="#绑定到ApplicationContext" class="headerlink" title="绑定到ApplicationContext"></a>绑定到ApplicationContext</h5><p>以下 example 显示了如何从 application 的 Spring configuration 或其某个子集设置服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line">    <span class="meta">@ContextConfiguration(classes = WebConfig.class)</span> (<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationContext context; (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WebTestClient client;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Before</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            client = WebTestClient.bindToApplicationContext(context).build(); (<span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>指定要加载的 configuration</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>Inject the configuration</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>创建<code>WebTestClient</code></td>
</tr>
</tbody>
</table>
</div>
<p>在内部，configuration 被传递给<code>WebHttpHandlerBuilder</code>以设置请求处理链。有关详细信息，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#WebHandlerAPI">WebHandler API</a>。通过使用 mock 请求和响应 objects，在没有 HTTP 服务器的情况下测试生成的 WebFlux application。</p>
<h5 id="绑定到服务器"><a href="#绑定到服务器" class="headerlink" title="绑定到服务器"></a>绑定到服务器</h5><p>以下服务器设置选项允许您连接到运行服务器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client = WebTestClient.bindToServer().baseUrl(<span class="string">&quot;http://localhost:8080&quot;</span>).build();</span><br></pre></td></tr></table></figure>
<h5 id="ClientBuilder"><a href="#ClientBuilder" class="headerlink" title="ClientBuilder"></a>ClientBuilder</h5><p>除了前面描述的服务器设置选项之外，您还可以配置 client 选项，包括基本 URL，默认 headers，client 过滤器等。这些选项在<code>bindToServer</code>之后随时可用。对于所有其他人，您需要使用<code>configureClient()</code>从服务器转换到 client configuration，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client = WebTestClient.bindToController(<span class="keyword">new</span> TestController())</span><br><span class="line">            .configureClient()</span><br><span class="line">            .baseUrl(<span class="string">&quot;/test&quot;</span>)</span><br><span class="line">            .build();</span><br></pre></td></tr></table></figure>
<h4 id="写测试"><a href="#写测试" class="headerlink" title="写测试"></a>写测试</h4><p><code>WebTestClient</code>提供与<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#WebClient">Web 客户端</a>相同的 API，直到使用<code>exchange()</code>执行请求为止。 <code>exchange()</code>之后的内容是用于验证响应的链式 API 工作流程。</p>
<p>通常，您首先声明响应状态和 headers，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons/1&quot;</span>)</span><br><span class="line">            .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectHeader().contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">            <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>然后指定如何解码和使用响应正文：</p>
<ul>
<li><code>expectBody(Class&lt;T&gt;)</code>：解码为单个 object。</li>
<li><code>expectBodyList(Class&lt;T&gt;)</code>：将 objects 解码并收集到<code>List&lt;T&gt;</code>。</li>
<li><code>expectBody()</code>：为<a href="#JSON内容">JSON 内容</a>或空体解码为<code>byte[]</code>。</li>
</ul>
<p>然后你可以使用 built-in 断言为身体。以下 example 显示了一种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBodyList(Person.class).hasSize(<span class="number">3</span>).contains(person);</span><br></pre></td></tr></table></figure>
<p>您还可以超越 built-in 断言并创建自己的断言，如下面的示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons/1&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(Person.class)</span><br><span class="line">            .consumeWith(result -&gt; &#123;</span><br><span class="line">                <span class="comment">// custom assertions (e.g. AssertJ)...</span></span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>您也可以退出工作流程并获得结果，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EntityExchangeResult&lt;Person&gt; result = client.get().uri(<span class="string">&quot;/persons/1&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody(Person.class)</span><br><span class="line">            .returnResult();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当您需要使用泛型解码为目标类型时，请查找接受<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/ParameterizedTypeReference.html">ParameterizedTypeReference</a>而不是<code>Class&lt;T&gt;</code>的重载方法。</p>
</blockquote>
<h5 id="没有内容"><a href="#没有内容" class="headerlink" title="没有内容"></a>没有内容</h5><p>如果响应没有内容(或者您不关心它)，请使用<code>Void.class</code>，这可确保释放资源。以下 example 显示了如何执行此操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons/123&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isNotFound()</span><br><span class="line">            .expectBody(Void.class);</span><br></pre></td></tr></table></figure>
<p>或者，如果要断言没有响应内容，可以使用类似于以下内容的 code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.post().uri(<span class="string">&quot;/persons&quot;</span>)</span><br><span class="line">            .body(personMono, Person.class)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isCreated()</span><br><span class="line">            .expectBody().isEmpty();</span><br></pre></td></tr></table></figure>
<h5 id="JSON内容"><a href="#JSON内容" class="headerlink" title="JSON内容"></a>JSON内容</h5><p>使用<code>expectBody()</code>时，响应将作为<code>byte[]</code>使用。这对原始内容断言很有用。对于 example，您可以使用<a target="_blank" rel="noopener" href="http://jsonassert.skyscreamer.org/">JSONAssert</a>来验证 JSON 内容，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons/1&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody()</span><br><span class="line">            .json(<span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;Jane\&quot;&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>您还可以使用<a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath">JSONPath</a>表达式，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">client.get().uri(<span class="string">&quot;/persons&quot;</span>)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .expectBody()</span><br><span class="line">            .jsonPath(<span class="string">&quot;$[0].name&quot;</span>).isEqualTo(<span class="string">&quot;Jane&quot;</span>)</span><br><span class="line">            .jsonPath(<span class="string">&quot;$[1].name&quot;</span>).isEqualTo(<span class="string">&quot;Jason&quot;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Streaming响应"><a href="#Streaming响应" class="headerlink" title="Streaming响应"></a>Streaming响应</h5><p>要测试无限流(对于 example，<code>&quot;text/event-stream&quot;</code>或<code>&quot;application/stream+json&quot;</code>)，您需要在响应状态和标头断言之后立即退出链式 API(使用<code>returnResult</code>)，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FluxExchangeResult&lt;MyEvent&gt; result = client.get().uri(<span class="string">&quot;/events&quot;</span>)</span><br><span class="line">            .accept(TEXT_EVENT_STREAM)</span><br><span class="line">            .exchange()</span><br><span class="line">            .expectStatus().isOk()</span><br><span class="line">            .returnResult(MyEvent.class);</span><br></pre></td></tr></table></figure>
<p>现在你可以使用<code>Flux&lt;T&gt;</code>，断言解码后的 objects，然后在满足测试目标时取消。我们建议使用<code>reactor-test</code>模块中的<code>StepVerifier</code>来执行此操作，如下面的 example 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Event&gt; eventFux = result.getResponseBody();</span><br><span class="line"></span><br><span class="line">    StepVerifier.create(eventFlux)</span><br><span class="line">            .expectNext(person)</span><br><span class="line">            .expectNextCount(<span class="number">4</span>)</span><br><span class="line">            .consumeNextWith(p -&gt; ...)</span><br><span class="line">            .thenCancel()</span><br><span class="line">            .verify();</span><br></pre></td></tr></table></figure>
<h5 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h5><p>当涉及 building 请求时，<code>WebTestClient</code>提供与<code>WebClient</code>相同的 API，implementation 主要是一个简单的 pass-through。有关如何使用正文准备请求的示例，请参阅<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/25/SpringFramework官方文档翻译-Web-on-Reactive-Stack/#请求体">WebClient 文档</a>，包括提交表单数据，Multipart 请求等。</p>
<h3 id="PetClinic例子"><a href="#PetClinic例子" class="headerlink" title="PetClinic例子"></a>PetClinic例子</h3><p>在<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-petclinic">GitHub 上</a>上可用的 PetClinic application 显示了 JUnit 4 环境中 Spring TestContext Framework 的几个 features。大多数测试功能都包含在<code>AbstractClinicTests</code>中，其中部分列表如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="comment">// import ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClinicTests</span> <span class="keyword">extends</span> <span class="title">AbstractTransactionalJUnit4SpringContextTests</span> </span>&#123; (<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> (<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">protected</span> Clinic clinic;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;Vet&gt; vets = <span class="keyword">this</span>.clinic.getVets();</span><br><span class="line">        assertEquals(<span class="string">&quot;JDBC query must show the same number of vets&quot;</span>,</span><br><span class="line">            <span class="keyword">super</span>.countRowsInTable(<span class="string">&quot;VETS&quot;</span>), vets.size()); (<span class="number">4</span>)</span><br><span class="line">        Vet v1 = EntityUtils.getById(vets, Vet.class, <span class="number">2</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Leary&quot;</span>, v1.getLastName());</span><br><span class="line">        assertEquals(<span class="number">1</span>, v1.getNrOfSpecialties());</span><br><span class="line">        assertEquals(<span class="string">&quot;radiology&quot;</span>, (v1.getSpecialties().get(<span class="number">0</span>)).getName());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从默认位置加载 application context：<code>AbstractClinicTests-context.xml</code>。</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>这个测试用例扩展了<code>AbstractTransactionalJUnit4SpringContextTests</code> class，它继承了依赖注入的 configuration(通过<code>DependencyInjectionTestExecutionListener</code>)和 transactional 行为(通过<code>TransactionalTestExecutionListener</code>)。</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td><code>clinic</code>实例变量(正在测试的 application object)由依赖注入通过<code>@Autowired</code>语义设置。</td>
</tr>
<tr>
<td><strong>4</strong></td>
<td><code>getVets()</code>方法显示了如何使用继承的<code>countRowsInTable()</code>方法轻松验证给定 table 中的行数，从而验证正在测试的 application code 的正确行为。这允许更强的测试并减少对精确测试数据的依赖性。例如，您可以在数据库中添加其他行而不会破坏测试。</td>
</tr>
</tbody>
</table>
</div>
<p>与使用数据库的许多 integration 测试一样，<code>AbstractClinicTests</code>中的大多数测试依赖于测试用例 run 之前数据库中已存在的最小数据量。或者，您可以在测试用例的测试夹具设置中填充数据库(同样，在与测试相同的 transaction 中)。</p>
<p>PetClinic application 支持三种数据访问技术：JDBC，Hibernate 和 JPA。通过在没有任何特定资源位置的情况下声明<code>@ContextConfiguration</code>，<code>AbstractClinicTests</code> class 从默认位置<code>AbstractClinicTests-context.xml</code>加载了 application context，它声明 common <code>DataSource</code>。子类指定必须声明<code>PlatformTransactionManager</code>的其他 context 位置和<code>Clinic</code>的具体 implementation。</p>
<p>例如，PetClinic 测试的 Hibernate implementation 包含以下 implementation。对于此 example，<code>HibernateClinicTests</code>不包含 code 的 line。我们只需声明<code>@ContextConfiguration</code>，测试继承自<code>AbstractClinicTests</code>。因为声明<code>@ContextConfiguration</code>没有任何特定的资源位置，Spring TestContext Framework 从<code>AbstractClinicTests-context.xml</code>中定义的所有 beans(即继承的位置)和<code>HibernateClinicTests-context.xml</code>加载 application context，可能覆盖<code>AbstractClinicTests-context.xml</code>中定义的 beans。以下清单显示了<code>HibernateClinicTests</code> class 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span> (<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateClinicTests</span> <span class="keyword">extends</span> <span class="title">AbstractClinicTests</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1</strong></td>
<td>从<code>AbstractClinicTests-context.xml</code>和<code>HibernateClinicTests-context.xml</code>加载 application context。</td>
</tr>
</tbody>
</table>
</div>
<p>在 large-scale application 中，Spring configuration 通常分为多个 files。因此，configuration 位置通常在 common base class 中为所有 application-specific integration 测试指定。这样的 base class 也可以添加有用的实例变量(自然地由依赖注入填充)，例如在使用 Hibernate 的 application 的情况下<code>SessionFactory</code>。</p>
<p>您应尽可能在 integration 测试中使用与部署环境中完全相同的 Spring configuration files。一个可能的差异点涉及数据库连接池和 transaction 基础结构。如果要部署到 full-blown application 服务器，则可能使用其连接池(可通过 JNDI 获得)和 JTA implementation。因此，在 production 中，您可以使用<code>JndiObjectFactoryBean</code>或<code>&lt;jee:jndi-lookup&gt;</code>作为<code>DataSource</code>和<code>JtaTransactionManager</code>。 JNDI 和 JTA 在 out-of-container integration 测试中不可用，因此您应该使用 Commons _DBCP <code>BasicDataSource</code>和<code>DataSourceTransactionManager</code>或<code>HibernateTransactionManager</code>这样的组合。您可以将此变体行为分解为单个 XML 文件，可以选择 application 服务器和与所有其他 configuration 分离的“本地”configuration，这在 test 和 production 环境之间不会有所不同。此外，我们建议您使用 properties files 进行连接设置。有关 example，请参阅 PetClinic application。</p>
<h2 id="更多资源"><a href="#更多资源" class="headerlink" title="更多资源"></a>更多资源</h2><p>有关测试的更多信息，请参阅以下资源：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.junit.org/">JUnit</a>：“A programmer-oriented 测试 framework for Java”。由 Spring Framework 在其测试套件中使用。</li>
<li><a target="_blank" rel="noopener" href="http://testng.org/">TestNG</a>：受 JUnit 启发的测试 framework，增加了对 annotations，测试组，data-driven 测试，分布式测试和其他 features 的支持。</li>
<li><a target="_blank" rel="noopener" href="https://joel-costigliola.github.io/assertj/">AssertJ</a>：“Fluent 断言为 Java”，包括对 Java 8 lambdas，流和其他 features 的支持。</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Mock_Object">Mock Objects</a>：维基百科中的文章。</li>
<li><a target="_blank" rel="noopener" href="http://www.mockobjects.com/">MockObjects.com</a>：Web 网站致力于 mock objects，这是一种在 test-driven 开发中改进 code 设计的技术。</li>
<li><a target="_blank" rel="noopener" href="http://mockito.org/">Mockito</a>：Java mock library 基于<a target="_blank" rel="noopener" href="http://xunitpatterns.com/Test Spy.html">Test Spy</a> pattern。</li>
<li><a target="_blank" rel="noopener" href="http://www.easymock.org/">EasyMock</a>：Java library“通过使用 Java 的代理机制动态生成它们，为接口提供 Mock Objects(以及通过 class 扩展提交 objects)。”由 Spring Framework 在其测试套件中使用。</li>
<li><a target="_blank" rel="noopener" href="http://www.jmock.org/">JMock</a>：Library 支持使用 mock objects 开发 Java code test-driven。</li>
<li><a target="_blank" rel="noopener" href="http://dbunit.sourceforge.net/">DbUnit</a>：针对 database-driven 项目的 JUnit 扩展(也可用于 Ant 和 Maven)，除其他外，将数据库置于测试运行之间的已知 state 中。</li>
<li><a target="_blank" rel="noopener" href="http://grinder.sourceforge.net/">磨床</a>：Java 负载测试 framework。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringFramework/" rel="tag"># SpringFramework</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%A6%82%E8%BF%B0/" rel="prev" title="SpringFramework官方文档翻译-概述">
      <i class="fa fa-chevron-left"></i> SpringFramework官方文档翻译-概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/" rel="next" title="SpringFramework官方文档翻译-数据访问">
      SpringFramework官方文档翻译-数据访问 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">1.</span> <span class="nav-text">测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-number">1.1.</span> <span class="nav-text">单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MockObjects"><span class="nav-number">1.1.1.</span> <span class="nav-text">MockObjects</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JNDI"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">JNDI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ServletAPI"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">ServletAPI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringWebReactive"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">SpringWebReactive</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%94%AF%E6%8C%81Classes"><span class="nav-number">1.1.2.</span> <span class="nav-text">单元测试支持Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E6%B5%8B%E8%AF%95%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">一般测试实用程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringMVC%E6%B5%8B%E8%AF%95%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">SpringMVC测试实用程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.</span> <span class="nav-text">集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="nav-number">1.2.2.</span> <span class="nav-text">集成测试的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%92%8C%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">上下文管理和缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95fixture%E5%AE%9E%E4%BE%8B%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">测试fixture实例的依赖注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TransactionManagement"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">TransactionManagement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E6%94%AF%E6%8C%81%E7%B1%BB"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">集成测试的支持类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E6%B5%8B%E8%AF%95%E6%94%AF%E6%8C%81"><span class="nav-number">1.2.3.</span> <span class="nav-text">JDBC测试支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Annotations"><span class="nav-number">1.2.4.</span> <span class="nav-text">Annotations</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringTestingAnnotations"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">SpringTestingAnnotations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BootstrapWith%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.1.</span> <span class="nav-text">BootstrapWith注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ContextConfiguration%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.2.</span> <span class="nav-text">ContextConfiguration注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#WebAppConfiguration%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.3.</span> <span class="nav-text">WebAppConfiguration注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ContextHierarchy%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.4.</span> <span class="nav-text">ContextHierarchy注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ActiveProfiles%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.5.</span> <span class="nav-text">ActiveProfiles注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestPropertySource%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.6.</span> <span class="nav-text">TestPropertySource注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DirtiesContext%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.7.</span> <span class="nav-text">DirtiesContext注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestExecutionListeners%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.8.</span> <span class="nav-text">TestExecutionListeners注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Commit%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.9.</span> <span class="nav-text">Commit注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Rollback%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.10.</span> <span class="nav-text">Rollback注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BeforeTransaction%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.11.</span> <span class="nav-text">BeforeTransaction注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AfterTransaction%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.12.</span> <span class="nav-text">AfterTransaction注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sql%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.13.</span> <span class="nav-text">Sql注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SqlConfig%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.14.</span> <span class="nav-text">SqlConfig注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SqlGroup%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.1.15.</span> <span class="nav-text">SqlGroup注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">标准注解支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringJUnit4%E6%B5%8B%E8%AF%95%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">SpringJUnit4测试注解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#IfProfileValue%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.3.1.</span> <span class="nav-text">IfProfileValue注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ProfileValueSourceConfiguration%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.3.2.</span> <span class="nav-text">ProfileValueSourceConfiguration注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Timed%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.3.3.</span> <span class="nav-text">Timed注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Repeat%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.3.4.</span> <span class="nav-text">Repeat注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringJUnitJupiterTestingAnnotations"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">SpringJUnitJupiterTestingAnnotations</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringJUnitConfig%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.4.1.</span> <span class="nav-text">SpringJUnitConfig注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringJUnitWebConfig%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.4.2.</span> <span class="nav-text">SpringJUnitWebConfig注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EnabledIf%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.4.3.</span> <span class="nav-text">EnabledIf注解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DisabledIf%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.2.4.4.4.</span> <span class="nav-text">DisabledIf注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Meta-Annotation%E6%94%AF%E6%8C%81%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.4.5.</span> <span class="nav-text">Meta-Annotation支持测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringTestContext%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.5.</span> <span class="nav-text">SpringTestContext框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Key%E6%8A%BD%E8%B1%A1"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">Key抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#TestContext"><span class="nav-number">1.2.5.1.1.</span> <span class="nav-text">TestContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestContextManager"><span class="nav-number">1.2.5.1.2.</span> <span class="nav-text">TestContextManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestExecutionListener"><span class="nav-number">1.2.5.1.3.</span> <span class="nav-text">TestExecutionListener</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Context%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">1.2.5.1.4.</span> <span class="nav-text">Context加载器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%AF%BCTestContextFramework"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">引导TestContextFramework</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TestExecutionListener%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">TestExecutionListener配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E5%86%8CTestExecutionListener%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.3.1.</span> <span class="nav-text">注册TestExecutionListener实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%91%E7%8E%B0%E9%BB%98%E8%AE%A4%E7%9A%84TestExecutionListener%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.3.2.</span> <span class="nav-text">自动发现默认的TestExecutionListener实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OrderingTestExecutionListener%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.3.3.</span> <span class="nav-text">OrderingTestExecutionListener实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6TestExecutionListener%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.3.4.</span> <span class="nav-text">合并TestExecutionListener实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Context%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">Context管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8XML%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AEContext"><span class="nav-number">1.2.5.4.1.</span> <span class="nav-text">使用XML资源配置Context</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Groovy%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AEContext"><span class="nav-number">1.2.5.4.2.</span> <span class="nav-text">使用Groovy脚本配置Context</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Annotated%E7%B1%BB%E9%85%8D%E7%BD%AEContext"><span class="nav-number">1.2.5.4.3.</span> <span class="nav-text">使用Annotated类配置Context</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B7%E5%90%88XML-Groovy%E8%84%9A%E6%9C%AC%E5%92%8C%E5%B8%A6%E6%B3%A8%E8%A7%A3%E7%9A%84Classes"><span class="nav-number">1.2.5.4.4.</span> <span class="nav-text">混合XML,Groovy脚本和带注解的Classes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Context%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E9%85%8D%E7%BD%AEContext"><span class="nav-number">1.2.5.4.5.</span> <span class="nav-text">使用Context初始化器配置Context</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Context%E9%85%8D%E7%BD%AE%E7%BB%A7%E6%89%BF"><span class="nav-number">1.2.5.4.6.</span> <span class="nav-text">Context配置继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E9%85%8D%E7%BD%AE"><span class="nav-number">1.2.5.4.7.</span> <span class="nav-text">使用环境配置文件进行上下文配置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B5%8B%E8%AF%95Property%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AEContext"><span class="nav-number">1.2.5.4.8.</span> <span class="nav-text">使用测试Property资源配置Context</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E6%B5%8B%E8%AF%95%E5%B1%9E%E6%80%A7%E6%9D%A5%E6%BA%90"><span class="nav-number">1.2.5.4.8.1.</span> <span class="nav-text">声明测试属性来源</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4Properties%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B"><span class="nav-number">1.2.5.4.8.2.</span> <span class="nav-text">默认Properties文件检测</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BC%98%E5%85%88"><span class="nav-number">1.2.5.4.8.3.</span> <span class="nav-text">优先</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95PropertySources"><span class="nav-number">1.2.5.4.8.4.</span> <span class="nav-text">继承和覆盖测试PropertySources</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDWebApplicationContext"><span class="nav-number">1.2.5.4.9.</span> <span class="nav-text">加载WebApplicationContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Context%E7%BC%93%E5%AD%98"><span class="nav-number">1.2.5.4.10.</span> <span class="nav-text">Context缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Context%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.5.4.11.</span> <span class="nav-text">Context层次结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95fixture%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">测试fixture的依赖注入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95Request%E5%92%8CSession-scopedBeans"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">测试Request和Session-scopedBeans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">事务管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Test-managed%E4%BA%8B%E7%89%A9"><span class="nav-number">1.2.5.7.1.</span> <span class="nav-text">Test-managed事物</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E5%92%8C%E7%A6%81%E7%94%A8Transactions"><span class="nav-number">1.2.5.7.2.</span> <span class="nav-text">启用和禁用Transactions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Transaction%E5%9B%9E%E6%BB%9A%E5%92%8C%E6%8F%90%E4%BA%A4%E8%A1%8C%E4%B8%BA"><span class="nav-number">1.2.5.7.3.</span> <span class="nav-text">Transaction回滚和提交行为</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8FTransaction%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.5.7.4.</span> <span class="nav-text">编程式Transaction管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E8%A1%8CCode%E5%A4%96%E7%9A%84%E4%BA%8B%E7%89%A9"><span class="nav-number">1.2.5.7.5.</span> <span class="nav-text">运行Code外的事物</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.5.7.6.</span> <span class="nav-text">配置事务管理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%80%E6%9C%89%E4%BA%8B%E7%89%A9%E7%9B%B8%E5%85%B3%E7%9A%84Annotations%E7%9A%84%E6%BC%94%E7%A4%BA"><span class="nav-number">1.2.5.7.7.</span> <span class="nav-text">所有事物相关的Annotations的演示</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8CSQL%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">执行SQL脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%89%A7%E8%A1%8CSQL%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.5.8.1.</span> <span class="nav-text">以编程方式执行SQL脚本</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A5Sql%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E%E6%80%A7%E5%9C%B0%E6%89%A7%E8%A1%8CSQL%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.5.8.2.</span> <span class="nav-text">以Sql注解声明性地执行SQL脚本</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E8%B5%84%E6%BA%90%E8%AF%AD%E4%B9%89"><span class="nav-number">1.2.5.8.2.1.</span> <span class="nav-text">路径资源语义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E8%84%9A%E6%9C%AC%E6%A3%80%E6%B5%8B"><span class="nav-number">1.2.5.8.2.2.</span> <span class="nav-text">默认脚本检测</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%A4%9A%E4%B8%AASql%E6%B3%A8%E8%A7%A3Sets"><span class="nav-number">1.2.5.8.2.3.</span> <span class="nav-text">声明多个Sql注解Sets</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="nav-number">1.2.5.8.2.4.</span> <span class="nav-text">脚本执行阶段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8SqlConfig%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE%E8%84%9A%E6%9C%AC"><span class="nav-number">1.2.5.8.2.5.</span> <span class="nav-text">使用SqlConfig注解配置脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel%E6%B5%8B%E8%AF%95%E6%89%A7%E8%A1%8C"><span class="nav-number">1.2.5.9.</span> <span class="nav-text">Parallel测试执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TestContext%E6%A1%86%E6%9E%B6%E6%94%AF%E6%8C%81Classes"><span class="nav-number">1.2.5.10.</span> <span class="nav-text">TestContext框架支持Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringJUnit4Runner"><span class="nav-number">1.2.5.10.1.</span> <span class="nav-text">SpringJUnit4Runner</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringJunit4%E8%A7%84%E5%88%99"><span class="nav-number">1.2.5.10.2.</span> <span class="nav-text">SpringJunit4规则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JUnit4%E6%94%AF%E6%8C%81Classes"><span class="nav-number">1.2.5.10.3.</span> <span class="nav-text">JUnit4支持Classes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JUnitJupiter%E7%9A%84SpringExtension"><span class="nav-number">1.2.5.10.4.</span> <span class="nav-text">JUnitJupiter的SpringExtension</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringExtension%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.5.10.5.</span> <span class="nav-text">SpringExtension的依赖注入</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.5.10.5.1.</span> <span class="nav-text">构造函数注入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5"><span class="nav-number">1.2.5.10.5.2.</span> <span class="nav-text">方法注入</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TestNG%E6%94%AF%E6%8C%81Classes"><span class="nav-number">1.2.5.10.6.</span> <span class="nav-text">TestNG支持Classes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.6.</span> <span class="nav-text">SpringMVC测试框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Server-Side%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">Server-Side测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%BF%9B%E5%8F%A3"><span class="nav-number">1.2.6.1.1.</span> <span class="nav-text">静态进口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E9%80%89%E6%8B%A9"><span class="nav-number">1.2.6.1.2.</span> <span class="nav-text">设置选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AEFeatures"><span class="nav-number">1.2.6.1.3.</span> <span class="nav-text">设置Features</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82"><span class="nav-number">1.2.6.1.4.</span> <span class="nav-text">执行请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9C%9F%E6%9C%9B"><span class="nav-number">1.2.6.1.5.</span> <span class="nav-text">定义期望</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%B3%A8%E5%86%8C"><span class="nav-number">1.2.6.1.6.</span> <span class="nav-text">过滤器注册</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Out-of-Container%E5%92%8CEnd-to-End%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="nav-number">1.2.6.1.7.</span> <span class="nav-text">Out-of-Container和End-to-End集成测试之间的差异</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5Server-Side%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.2.6.1.8.</span> <span class="nav-text">进一步Server-Side测试实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HtmlUnit%E9%9B%86%E6%88%90"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">HtmlUnit集成</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88HtmlUnit%E9%9B%86%E6%88%90%EF%BC%9F"><span class="nav-number">1.2.6.2.1.</span> <span class="nav-text">为什么HtmlUnit集成？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Integration%E6%B5%8B%E8%AF%95%E6%95%91%E6%8F%B4%EF%BC%9F"><span class="nav-number">1.2.6.2.1.1.</span> <span class="nav-text">Integration测试救援？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BE%93%E5%85%A5HtmlUnit%E9%9B%86%E6%88%90"><span class="nav-number">1.2.6.2.1.2.</span> <span class="nav-text">输入HtmlUnit集成</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HtmlUnit%E9%9B%86%E6%88%90%E9%80%89%E9%A1%B9"><span class="nav-number">1.2.6.2.1.3.</span> <span class="nav-text">HtmlUnit集成选项</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MockMvc%E5%92%8CHtmlUnit"><span class="nav-number">1.2.6.2.2.</span> <span class="nav-text">MockMvc和HtmlUnit</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CHtmlUnit%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.6.2.2.1.</span> <span class="nav-text">MockMvc和HtmlUnit设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CHtmlUnit%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.6.2.2.2.</span> <span class="nav-text">MockMvc和HtmlUnit用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7MockMvcWebClientBuilder"><span class="nav-number">1.2.6.2.2.3.</span> <span class="nav-text">高级MockMvcWebClientBuilder</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MockMvc%E5%92%8CWebDriver"><span class="nav-number">1.2.6.2.3.</span> <span class="nav-text">MockMvc和WebDriver</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9WebDriver%E5%92%8CMockMvc"><span class="nav-number">1.2.6.2.3.1.</span> <span class="nav-text">为什么选择WebDriver和MockMvc?</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CWebDriver%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.6.2.3.2.</span> <span class="nav-text">MockMvc和WebDriver设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CWebDriver%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.6.2.3.3.</span> <span class="nav-text">MockMvc和WebDriver用法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7MockMvcHtmlUnitDriverBuilder"><span class="nav-number">1.2.6.2.3.4.</span> <span class="nav-text">高级MockMvcHtmlUnitDriverBuilder</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MockMvc%E5%92%8CGeb"><span class="nav-number">1.2.6.2.4.</span> <span class="nav-text">MockMvc和Geb</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Geb%E5%92%8CMockMvc%EF%BC%9F"><span class="nav-number">1.2.6.2.4.1.</span> <span class="nav-text">为什么选择Geb和MockMvc？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CGeb%E8%AE%BE%E7%BD%AE"><span class="nav-number">1.2.6.2.4.2.</span> <span class="nav-text">MockMvc和Geb设置</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MockMvc%E5%92%8CGeb%E7%94%A8%E6%B3%95"><span class="nav-number">1.2.6.2.4.3.</span> <span class="nav-text">MockMvc和Geb用法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFREST%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">客户端REST测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%BF%9B%E5%8F%A3-1"><span class="nav-number">1.2.6.3.1.</span> <span class="nav-text">静态进口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AFREST%E6%B5%8B%E8%AF%95%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.6.3.2.</span> <span class="nav-text">客户端REST测试的更多示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebTestClient"><span class="nav-number">1.2.7.</span> <span class="nav-text">WebTestClient</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E7%AB%8B"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">建立</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.2.7.1.1.</span> <span class="nav-text">绑定到控制器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0RouterFunction"><span class="nav-number">1.2.7.1.2.</span> <span class="nav-text">绑定到RouterFunction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0ApplicationContext"><span class="nav-number">1.2.7.1.3.</span> <span class="nav-text">绑定到ApplicationContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.2.7.1.4.</span> <span class="nav-text">绑定到服务器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ClientBuilder"><span class="nav-number">1.2.7.1.5.</span> <span class="nav-text">ClientBuilder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%B5%8B%E8%AF%95"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">写测试</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B2%A1%E6%9C%89%E5%86%85%E5%AE%B9"><span class="nav-number">1.2.7.2.1.</span> <span class="nav-text">没有内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JSON%E5%86%85%E5%AE%B9"><span class="nav-number">1.2.7.2.2.</span> <span class="nav-text">JSON内容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Streaming%E5%93%8D%E5%BA%94"><span class="nav-number">1.2.7.2.3.</span> <span class="nav-text">Streaming响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%AD%A3%E6%96%87"><span class="nav-number">1.2.7.2.4.</span> <span class="nav-text">请求正文</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PetClinic%E4%BE%8B%E5%AD%90"><span class="nav-number">1.2.8.</span> <span class="nav-text">PetClinic例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90"><span class="nav-number">1.3.</span> <span class="nav-text">更多资源</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/25/SpringFramework%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E6%B5%8B%E8%AF%95/";
    this.page.identifier = "2020/08/25/SpringFramework官方文档翻译-测试/";
    this.page.title = "SpringFramework官方文档翻译-测试";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
