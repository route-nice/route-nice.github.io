<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Spring Boot Features 本节详细介绍Spring引导。在这里，您可以了解您可能想要使用和自定义的关键特性。如果您还没有这样做，那么您可能需要阅读入门和使用，使您有了良好的基础知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot官方文档翻译-SpringBoot功能">
<meta property="og:url" content="http://yoursite.com/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/index.html">
<meta property="og:site_name" content="Route-nice">
<meta property="og:description" content="Spring Boot Features 本节详细介绍Spring引导。在这里，您可以了解您可能想要使用和自定义的关键特性。如果您还没有这样做，那么您可能需要阅读入门和使用，使您有了良好的基础知识。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-08-31T03:40:42.000Z">
<meta property="article:modified_time" content="2020-09-18T03:36:10.026Z">
<meta property="article:author" content="Route-nice">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>SpringBoot官方文档翻译-SpringBoot功能 | Route-nice</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8b3aabf954a120e5a2920d31f3600013";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Route-nice</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Route-nice">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Route-nice">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SpringBoot官方文档翻译-SpringBoot功能
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-31 11:40:42" itemprop="dateCreated datePublished" datetime="2020-08-31T11:40:42+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-18 11:36:10" itemprop="dateModified" datetime="2020-09-18T11:36:10+08:00">2020-09-18</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringIO/" itemprop="url" rel="index"><span itemprop="name">SpringIO</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2020/08/31/SpringBoot官方文档翻译-SpringBoot功能/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><strong>Spring Boot Features</strong></p>
<p>本节详细介绍Spring引导。在这里，您可以了解您可能想要使用和自定义的关键特性。如果您还没有这样做，那么您可能需要阅读<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8Starter/">入门</a>和<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8SpringBoot/">使用</a>，使您有了良好的基础知识。</p>
<a id="more"></a>
<h1 id="Spring应用程序"><a href="#Spring应用程序" class="headerlink" title="Spring应用程序"></a>Spring应用程序</h1><p><code>SpringApplication</code>类提供了一种方便的方法来引导从<code>main()</code>方法启动的 Spring 应用程序。在许多情况下，您可以委派给静态<code>SpringApplication.run</code>方法，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当您的应用程序启动时，您应该看到类似于以下输出的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.   ____          _            __ _ _</span><br><span class="line"> /\\ / ___<span class="string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="string">( ( )\___ | &#x27;</span>_ | <span class="string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  <span class="string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="string"> =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="string"> :: Spring Boot ::   v2.1.1.RELEASE</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)</span></span><br><span class="line"><span class="string">2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.ser[emailprotected]6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span></span><br><span class="line"><span class="string">2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span></span><br><span class="line"><span class="string">2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，显示<code>INFO</code>级别日志记录消息，包括一些相关的启动详细信息，例如启动该应用程序的用户。如果您需要<code>INFO</code>以外的其他日志级别，则可以按照<a href="#日志级别">第 26.4 节“日志级别”</a>中的说明进行设置，</p>
<h2 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h2><p>如果您的应用程序无法启动，则已注册的<code>FailureAnalyzers</code>有机会提供专用的错误消息和解决该问题的具体措施。例如，如果您在端口<code>8080</code>上启动 Web 应用程序，并且该端口已在使用中，则应该看到类似于以下消息的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already <span class="keyword">in</span> use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that<span class="string">&#x27;s listening on port 8080 or configure this application to listen on another port.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>Spring Boot 提供了众多的<code>FailureAnalyzer</code>实现，您可以<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#创建自己的FailureAnalyzer">添加自己的</a>。</p>
</blockquote>
<p>如果没有故障分析器能够处理该异常，您仍然可以显示完整情况报告，以更好地了解出了什么问题。为此，您需要<code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code> <a href="#外部化配置">启用调试属性</a>或<a href="#日志级别">启用调试日志记录</a>。</p>
<p>例如，如果您使用<code>java -jar</code>运行应用程序，则可以启用<code>debug</code>属性，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span><br></pre></td></tr></table></figure>
<h2 id="自定义banner"><a href="#自定义banner" class="headerlink" title="自定义banner"></a>自定义banner</h2><p>可以通过将<code>banner.txt</code>文件添加到 Classpath 或将<code>spring.banner.location</code>属性设置为此类文件的位置来更改启动时打印的 banner。如果文件的编码不是 UTF-8，则可以设置<code>spring.banner.charset</code>。除了文本文件之外，您还可以将<code>banner.gif</code>，<code>banner.jpg</code>或<code>banner.png</code>图像文件添加到 Classpath 或设置<code>spring.banner.image.location</code>属性。图像将转换为 ASCII 艺术作品并打印在任何文本 banner 上方。</p>
<p>在<code>banner.txt</code>文件中，您可以使用以下任何占位符：</p>
<p><strong>表 23.1 标语变量</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Variable</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$&#123;application.version&#125;</code></td>
<td><code>MANIFEST.MF</code>中声明的应用程序的版本号。例如，<code>Implementation-Version: 1.0</code>被打印为<code>1.0</code>。</td>
</tr>
<tr>
<td><code>$&#123;application.formatted-version&#125;</code></td>
<td>您的应用程序的版本号，以<code>MANIFEST.MF</code>声明，并设置为显示格式(用方括号括起来并以<code>v</code>作为前缀)。例如<code>(v1.0)</code>。</td>
</tr>
<tr>
<td><code>$&#123;spring-boot.version&#125;</code></td>
<td>您正在使用的 Spring Boot 版本。例如<code>2.1.1.RELEASE</code>。</td>
</tr>
<tr>
<td><code>$&#123;spring-boot.formatted-version&#125;</code></td>
<td>您正在使用的 Spring Boot 版本，已格式化以用于显示(用方括号括起来，并以<code>v</code>作为前缀)。例如<code>(v2.1.1.RELEASE)</code>。</td>
</tr>
<tr>
<td><code>$&#123;Ansi.NAME&#125;</code>(或<code>$&#123;AnsiColor.NAME&#125;</code>，<code>$&#123;AnsiBackground.NAME&#125;</code>，<code>$&#123;AnsiStyle.NAME&#125;</code>)</td>
<td>其中<code>NAME</code>是 ANSI 转义代码的名称。有关详情，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java">AnsiPropertySource</a>。</td>
</tr>
<tr>
<td><code>$&#123;application.title&#125;</code></td>
<td><code>MANIFEST.MF</code>中声明的应用程序标题。例如<code>Implementation-Title: MyApp</code>被打印为<code>MyApp</code>。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Tip</p>
<p>如果要以编程方式生成 banner，则可以使用<code>SpringApplication.setBanner(…)</code>方法。使用<code>org.springframework.boot.Banner</code>接口并实现自己的<code>printBanner()</code>方法。</p>
</blockquote>
<p>您还可以使用<code>spring.main.banner-mode</code>属性来确定 banner 是否必须打印在<code>System.out</code>(<code>console</code>)上，发送到配置的 Logger(<code>log</code>)或根本不打印(<code>off</code>)。</p>
<p>打印的 banner 以以下名称注册为单例 bean：<code>springBootBanner</code>。</p>
<h2 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h2><p>如果您不喜欢默认的<code>SpringApplication</code>，则可以创建一个本地实例并对其进行自定义。例如，要关闭 banner，您可以编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SpringApplication app = <span class="keyword">new</span> SpringApplication(MySpringConfiguration.class);</span><br><span class="line">    app.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">    app.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>传递给<code>SpringApplication</code>的构造函数参数是 Spring bean 的配置源。在大多数情况下，这些是对<code>@Configuration</code>类的引用，但它们也可以是对 XML 配置或应扫描的程序包的引用。</p>
</blockquote>
<p>也可以通过使用<code>application.properties</code>文件来配置<code>SpringApplication</code>。有关详细信息，请参见<em> <a href="#外部化配置">第 24 章，外部化配置</a> </em>。</p>
<p>有关配置选项的完整列表，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/SpringApplication.html">SpringApplication Javadoc</a>。</p>
<h2 id="流式构建器API"><a href="#流式构建器API" class="headerlink" title="流式构建器API"></a>流式构建器API</h2><p>如果您需要构建<code>ApplicationContext</code>层次结构(具有父/子关系的多个上下文)，或者您更喜欢使用“Fluent 的”构建器 API，则可以使用<code>SpringApplicationBuilder</code>。</p>
<p><code>SpringApplicationBuilder</code>使您可以将多个方法调用链接在一起，并包括<code>parent</code>和<code>child</code>方法，这些方法使您可以创建层次结构，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">        .sources(Parent.class)</span><br><span class="line">        .child(Application.class)</span><br><span class="line">        .bannerMode(Banner.Mode.OFF)</span><br><span class="line">        .run(args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>创建<code>ApplicationContext</code>层次结构时有一些限制。例如，Web 组件 <strong>必须</strong> 包含在子上下文中，并且相同的<code>Environment</code>用于父上下文和子上下文。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/builder/SpringApplicationBuilder.html">SpringApplicationBuilder Javadoc</a>。</p>
</blockquote>
<h2 id="应用程序可用性"><a href="#应用程序可用性" class="headerlink" title="应用程序可用性"></a>应用程序可用性</h2><p>当部署在平台上时，应用程序可以使用<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">Kubernetes探针</a>等基础设施向平台提供关于其可用性的信息。Spring引导包括对常用的“活跃”和“准备就绪”可用状态的开箱即用支持。如果您正在使用Spring Boot的“actuator”支持，那么这些状态将作为运行状况端点组公开。</p>
<p>此外，您还可以通过将<code>ApplicationAvailability</code>接口注入您自己的bean来获得可用性状态。</p>
<h3 id="Liveness状态"><a href="#Liveness状态" class="headerlink" title="Liveness状态"></a>Liveness状态</h3><p>应用程序的“活动”状态告诉它的内部状态是否允许它正确地工作，或者如果它当前失败了，它自己恢复。中断的“活动”状态意味着应用程序处于无法恢复的状态，基础设施应该重新启动应用程序。</p>
<blockquote>
<p>通常，“活动”状态不应该基于外部检查，比如运行<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-health">状况检查</a>。如果是这样，失败的外部系统(数据库、Web API、外部缓存)将触发大规模重启和跨平台的级联故障。</p>
</blockquote>
<p>Spring引导应用程序的内部状态主要由Spring <code>ApplicationContext</code>表示。如果应用程序上下文已经成功启动，Spring Boot将假定应用程序处于有效状态。一旦上下文被刷新，应用程序就被认为是活动的，请参阅<a href="#应用程序事件和侦听器">Spring Boot应用程序生命周期和相关应用程序事件</a>。</p>
<h3 id="Readiness状态"><a href="#Readiness状态" class="headerlink" title="Readiness状态"></a>Readiness状态</h3><p>应用程序的“准备就绪”状态告诉应用程序是否准备好处理流量。失败的“准备就绪”状态告诉平台现在不应该将流量路由到应用程序。这通常发生在启动时，当<code>CommandLineRunner</code>和<code>ApplicationRunner</code>组件正在处理，或在任何时候，如果应用程序认为它处理额外的流量太忙。</p>
<p>一旦调用了应用程序和命令行运行器，就认为应用程序已经准备好了，请参阅Spring Boot<a href="#应用程序事件和侦听器">应用程序生命周期和相关应用程序事件</a>。</p>
<blockquote>
<p>期望在启动期间运行的任务应该由<code>CommandLineRunner</code>和<code>ApplicationRunner</code>组件执行，而不是使用Spring组件生命周期回调，如<code>@PostConstruct</code>。</p>
</blockquote>
<h3 id="管理应用程序可用状态"><a href="#管理应用程序可用状态" class="headerlink" title="管理应用程序可用状态"></a>管理应用程序可用状态</h3><p>通过注入<code>ApplicationAvailability</code>接口并在其上调用方法，应用程序组件可以在任何时候检索当前的可用性状态。更常见的情况是，应用程序希望侦听状态更新或更新应用程序的状态。</p>
<p>例如，我们可以导出应用程序的“准备就绪”状态到一个文件，以便Kubernetes的“exec探针”可以查看这个文件:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadinessStateExporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChange</span><span class="params">(AvailabilityChangeEvent&lt;ReadinessState&gt; event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (event.getState()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACCEPTING_TRAFFIC:</span><br><span class="line">            <span class="comment">// create file /tmp/healthy</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFUSING_TRAFFIC:</span><br><span class="line">            <span class="comment">// remove file /tmp/healthy</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以更新应用程序的状态，当应用程序中断，无法恢复:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalCacheVerifier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LocalCacheVerifier</span><span class="params">(ApplicationEventPublisher eventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eventPublisher = eventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkLocalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (CacheCompletelyBrokenException ex) &#123;</span><br><span class="line">            AvailabilityChangeEvent.publish(<span class="keyword">this</span>.eventPublisher, ex, LivenessState.BROKEN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Boot为执行器运行状况端点的“活动”和“准备就绪”提供了<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot-Actuator%E5%8F%AF%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD/#Kubernetes探头">Kubernetes HTTP探针</a>。在专门的部分中，您可以获得关于在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot-Actuator%E5%8F%AF%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD/#Kubernetes">Kubernetes上部署Spring引导应用程序</a>的更多指导。</p>
<h2 id="应用程序事件和侦听器"><a href="#应用程序事件和侦听器" class="headerlink" title="应用程序事件和侦听器"></a>应用程序事件和侦听器</h2><p>除了通常的 Spring Framework 事件(例如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html">ContextRefreshedEvent</a>)之外，<code>SpringApplication</code>还发送一些其他应用程序事件。</p>
<blockquote>
<p>Note</p>
<p>有些事件实际上是在创建<code>ApplicationContext</code>之前触发的，因此您不能将这些事件注册为<code>@Bean</code>。您可以使用<code>SpringApplication.addListeners(…)</code>方法或<code>SpringApplicationBuilder.listeners(…)</code>方法注册它们。</p>
</blockquote>
<p>如果希望这些监听器自动注册，而不管创建应用程序的方式如何，都可以将<code>META-INF/spring.factories</code>文件添加到项目中，并使用<code>org.springframework.context.ApplicationListener</code>键引用您的监听器，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">com.example.project.MyListener</span></span><br></pre></td></tr></table></figure>
<p>应用程序事件在您的应用程序运行时按以下顺序发送：</p>
<ol>
<li><code>ApplicationStartingEvent</code>在运行开始时但在进行任何处理之前(侦听器和初始化器的注册除外)发送。</li>
<li><code>ApplicationEnvironmentPreparedEvent</code>在上下文中使用的环境已知但在创建上下文之前发送。</li>
<li>当准备好<code>ApplicationContext</code>并且调用了<code>ApplicationContextInitializedEvent</code>，但在加载任何bean定义之前发送<code>applicationcontextinitialalizer</code>。</li>
<li><code>ApplicationPreparedEvent</code>是在刷新启动之前但加载bean定义之后发送的。</li>
<li><code>ApplicationStartedEvent</code>是在刷新上下文之后，在调用任何应用程序和命令行运行器之前发送的。</li>
<li>然后用<code>AvailabilityChangeEvent</code>发送一个`LivenessState.CORRECT,表示应用程序是活动的。</li>
<li>在调用任何应用程序和<code>command-line runners</code>之后发送一个<code>ApplicationReadyEvent</code>。</li>
<li>然后，<code>AvailabilityChangeEvent</code>发送一个<code>ReadinessState.ACCEPTING_TRAFFIC</code>，表示应用程序已准备好为请求提供服务。</li>
<li>如果启动时出现异常，则发送<code>ApplicationFailedEvent</code>。</li>
</ol>
<p>上面的列表只包含绑定到<code>SpringApplication</code>的<code>SpringApplicationEvents</code>。除此之外，以下事件也在<code>ApplicationPreparedEvent</code>之后和<code>ApplicationStartedEvent</code>之前发布:</p>
<ul>
<li><code>WebServerInitializedEvent</code>在WebServer准备好之后发送。<code>ServletWebServerInitializedEvent</code>和<code>ReactiveWebServerInitializedEvent</code>分别是servlet和反应变量。</li>
<li>当刷新<code>ApplicationContext</code>时发送<code>ContextRefreshedEvent</code>。</li>
</ul>
<blockquote>
<p>您通常不需要使用应用程序事件，但是很容易知道它们的存在。在内部，Spring Boot 使用事件来处理各种任务。</p>
</blockquote>
<p>应用程序事件是通过使用 Spring Framework 的事件发布机制发送的。此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。结果，如果您的应用程序使用<code>SpringApplication</code>实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。</p>
<p>为了使您的侦听器能够区分其上下文的事件和后代上下文的事件，它应请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现<code>ApplicationContextAware</code>来注入上下文，或者如果侦听器是 bean，则可以通过使用<code>@Autowired</code>来注入上下文。</p>
<h2 id="Web环境"><a href="#Web环境" class="headerlink" title="Web环境"></a>Web环境</h2><p><code>SpringApplication</code>尝试代表您创建正确的<code>ApplicationContext</code>类型。确定<code>WebApplicationType</code>的算法非常简单：</p>
<ul>
<li>如果存在 Spring MVC，则使用<code>AnnotationConfigServletWebServerApplicationContext</code></li>
<li>如果不存在Spring MVC且存在Spring WebFlux，则使用<code>AnnotationConfigReactiveWebServerApplicationContext</code></li>
<li>否则，使用<code>AnnotationConfigApplicationContext</code></li>
</ul>
<p>这意味着，如果您在同一应用程序中使用 Spring MVC 和 Spring WebFlux 的新<code>WebClient</code>，则默认使用 Spring MVC。您可以通过调用<code>setWebApplicationType(WebApplicationType)</code>轻松覆盖它。</p>
<p>也可以完全控制通过调用<code>setApplicationContextClass(…)</code>所使用的<code>ApplicationContext</code>类型。</p>
<blockquote>
<p>Tip</p>
<p>在 JUnit 测试中使用<code>SpringApplication</code>时，通常希望调用<code>setWebApplicationType(WebApplicationType.NONE)</code>。</p>
</blockquote>
<h2 id="访问应用程序参数"><a href="#访问应用程序参数" class="headerlink" title="访问应用程序参数"></a>访问应用程序参数</h2><p>如果您需要访问传递给<code>SpringApplication.run(…)</code>的应用程序参数，则可以注入<code>org.springframework.boot.ApplicationArguments</code> bean。 <code>ApplicationArguments</code>接口提供对原始<code>String[]</code>参数以及已解析的<code>option</code>和<code>non-option</code>参数的访问，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ApplicationArguments args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> debug = args.containsOption(<span class="string">&quot;debug&quot;</span>);</span><br><span class="line">        List&lt;String&gt; files = args.getNonOptionArgs();</span><br><span class="line">        <span class="comment">// if run with &quot;--debug logfile.txt&quot; debug=true, files=[&quot;logfile.txt&quot;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip</p>
<p>Spring Boot 还向 Spring <code>Environment</code>注册了一个<code>CommandLinePropertySource</code>。这样，您还可以使用<code>@Value</code>注解注入单个应用程序参数。</p>
</blockquote>
<h2 id="使用ApplicationRunner或CommandLineRunner"><a href="#使用ApplicationRunner或CommandLineRunner" class="headerlink" title="使用ApplicationRunner或CommandLineRunner"></a>使用ApplicationRunner或CommandLineRunner</h2><p>如果在<code>SpringApplication</code>启动后需要运行一些特定的代码，则可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。两个接口以相同的方式工作，并提供一个<code>run</code>方法，该方法在<code>SpringApplication.run(…)</code>完成之前被调用。</p>
<p><code>CommandLineRunner</code>接口以简单的字符串数组提供对应用程序参数的访问，而<code>ApplicationRunner</code>使用前面讨论的<code>ApplicationArguments</code>接口。以下示例显示使用<code>run</code>方法的<code>CommandLineRunner</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do something...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了几个必须按特定顺序调用的<code>CommandLineRunner</code>或<code>ApplicationRunner</code> bean，则可以另外实现<code>org.springframework.core.Ordered</code>接口或使用<code>org.springframework.core.annotation.Order</code>注解。</p>
<h2 id="应用退出"><a href="#应用退出" class="headerlink" title="应用退出"></a>应用退出</h2><p>每个<code>SpringApplication</code>向 JVM 注册一个关闭钩子，以确保<code>ApplicationContext</code>在退出时正常关闭。可以使用所有标准的 Spring 生命周期回调(例如<code>DisposableBean</code>接口或<code>@PreDestroy</code>注解)。</p>
<p>另外，如果 bean 希望在调用<code>SpringApplication.exit()</code>时返回特定的退出代码，则可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口。然后可以将此退出代码传递给<code>System.exit()</code>，以将其作为状态代码返回，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExitCodeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExitCodeGenerator <span class="title">exitCodeGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> () -&gt; <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.exit(SpringApplication</span><br><span class="line">                .exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，<code>ExitCodeGenerator</code>接口可能会通过异常实现。遇到此类异常时，Spring Boot 将返回已实现的<code>getExitCode()</code>方法提供的退出代码。</p>
<h2 id="管理员功能"><a href="#管理员功能" class="headerlink" title="管理员功能"></a>管理员功能</h2><p>通过指定<code>spring.application.admin.enabled</code>属性，可以为应用程序启用与 Management 员相关的功能。这将在平台<code>MBeanServer</code>上公开<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java">SpringApplicationAdminMXBean</a>。您可以使用此功能来远程 Management Spring Boot 应用程序。对于任何服务包装器实现，此功能也可能很有用。</p>
<blockquote>
<p>Tip</p>
<p>如果您想知道应用程序在哪个 HTTP 端口上运行，请使用<code>local.server.port</code>键获取属性。</p>
<p>Warning</p>
<p>启用此功能时要小心，因为 MBean 公开了一种关闭应用程序的方法。</p>
</blockquote>
<h1 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h1><p>Spring Boot 使您可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。您可以使用属性文件，YAML 文件，环境变量和命令行参数来外部化配置。属性值可以使用<code>@Value</code>注解直接注入到您的 bean 中，可以通过 Spring 的<code>Environment</code>抽象访问，也可以是<a href="#类型安全的配置属性">绑定到结构化对象</a>到<code>@ConfigurationProperties</code>。</p>
<p>Spring Boot 使用一个非常特殊的<code>PropertySource</code>顺序，该顺序被设计为允许明智地覆盖值。按以下顺序考虑属性：</p>
<ul>
<li>您的主目录上的<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用SpringBoot/#全局设置">Devtools 全局设置属性</a>(在 devtools 处于 Active 状态时为<code>~/.spring-boot-devtools.properties</code>)。</li>
<li>测试中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html">@TestPropertySource</a>。</li>
<li>测试中的<code>properties</code>属性。在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html">@SpringBootTest</a>和<a href="#自动配置的测试">测试 Comments 以测试应用程序的特定部分</a>上可用。</li>
<li>命令行参数。</li>
<li><code>SPRING_APPLICATION_JSON</code>中的属性(嵌入在环境变量或系统属性中的内联 JSON)。</li>
<li><code>ServletConfig</code>个初始化参数。</li>
<li><code>ServletContext</code>个初始化参数。</li>
<li>来自<code>java:comp/env</code>的 JNDI 属性。</li>
<li>Java 系统属性(<code>System.getProperties()</code>)。</li>
<li>os 环境变量。</li>
<li>仅在<code>random.*</code>中具有属性的<code>RandomValuePropertySource</code>。</li>
<li><a href="#特定于配置文件的属性">特定于配置文件的应用程序属性</a>在打包的 jar 之外(<code>application-&#123;profile&#125;.properties</code>和 YAML 变体)。</li>
<li><a href="#特定于配置文件的属性">特定于配置文件的应用程序属性</a>包装在 jar 中(<code>application-&#123;profile&#125;.properties</code>和 YAML 变体)。</li>
<li>打包的 jar 之外的应用程序属性(<code>application.properties</code>和 YAML 变体)。</li>
<li>打包在 jar 中的应用程序属性(<code>application.properties</code>和 YAML 变体)。</li>
<li><code>@Configuration</code>个类上的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html">@PropertySource</a>条注解。</li>
<li>默认属性(通过设置<code>SpringApplication.setDefaultProperties</code>指定)。</li>
</ul>
<p>为了提供一个具体的示例，假设您开发一个使用<code>name</code>属性的<code>@Component</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在您的应用程序 Classpath 上(例如，在 jar 内)，您可以拥有一个<code>application.properties</code>文件，该文件为<code>name</code>提供了合理的默认属性值。在新环境中运行时，可以在 jar 外部提供<code>application.properties</code>文件，该文件将覆盖<code>name</code>。对于一次性测试，可以使用特定的命令行开关(例如<code>java -jar app.jar --name=&quot;Spring&quot;</code>)启动。</p>
<blockquote>
<p>Tip</p>
<p><code>SPRING_APPLICATION_JSON</code>属性可以在命令行中提供环境变量。例如，您可以在UNIX shell中使用以下行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> SPRING_APPLICATION_JSON=<span class="string">&#x27;&#123;&quot;acme&quot;:&#123;&quot;name&quot;:&quot;test&quot;&#125;&#125;&#x27;</span> java -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，您在 Spring<code>Environment</code>中以<code>acme.name=test</code>结尾。您还可以在 System 属性中以<code>spring.application.json</code>的形式提供 JSON，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Dspring.application.json=<span class="string">&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27;</span> -jar myapp.jar</span></span><br></pre></td></tr></table></figure>
<p>您还可以使用命令行参数来提供 JSON，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --spring.application.json=<span class="string">&#x27;&#123;&quot;name&quot;:&quot;test&quot;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<p>您还可以将 JSON 作为 JNDI 变量提供，如下所示：<code>java:comp/env/spring.application.json</code>。</p>
</blockquote>
<h2 id="配置随机值"><a href="#配置随机值" class="headerlink" title="配置随机值"></a>配置随机值</h2><p><code>RandomValuePropertySource</code>可用于注入随机值(例如，Importing 到机密或测试用例中)。它可以产生整数，longs，uuid 或字符串，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my.secret=$&#123;random.value&#125;</span><br><span class="line">my.number=$&#123;random.int&#125;</span><br><span class="line">my.bignumber=$&#123;random.long&#125;</span><br><span class="line">my.uuid=$&#123;random.uuid&#125;</span><br><span class="line">my.number.less.than.ten=$&#123;random.int(10)&#125;</span><br><span class="line">my.number.in.range=$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure>
<p><code>random.int*</code>语法为<code>OPEN value (,max) CLOSE</code>，其中<code>OPEN,CLOSE</code>是任何字符，而<code>value,max</code>是整数。如果提供<code>max</code>，则<code>value</code>是最小值，而<code>max</code>是最大值(不包括)。</p>
<h2 id="访问命令行属性"><a href="#访问命令行属性" class="headerlink" title="访问命令行属性"></a>访问命令行属性</h2><p>默认情况下，<code>SpringApplication</code>将任何命令行选项参数(即以<code>--</code>开头的参数，例如<code>--server.port=9000</code>)转换为<code>property</code>并将其添加到 Spring <code>Environment</code>。如前所述，命令行属性始终优先于其他属性源。</p>
<p>如果您不想将命令行属性添加到<code>Environment</code>，则可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>禁用它们。</p>
<h2 id="应用程序属性文件"><a href="#应用程序属性文件" class="headerlink" title="应用程序属性文件"></a>应用程序属性文件</h2><p><code>SpringApplication</code>从以下位置的<code>application.properties</code>文件中加载属性，并将它们添加到 Spring <code>Environment</code>中：</p>
<ul>
<li>当前目录的<code>/config</code>子目录</li>
<li>当前目录</li>
<li>Classpath<code>/config</code>包</li>
<li>Classpath 根</li>
</ul>
<p>该列表按优先级排序(在列表较高位置定义的属性会覆盖在较低位置定义的属性)。</p>
<blockquote>
<p>Note</p>
<p>您也可以<a href="#使用YAML代替属性">使用 YAML(‘.yml’)文件</a>替代“ .properties”。</p>
</blockquote>
<p>如果您不喜欢<code>application.properties</code>作为配置文件名，则可以通过指定<code>spring.config.name</code>环境属性来切换到另一个文件名。您还可以使用<code>spring.config.location</code>环境属性(这是目录位置或文件路径的逗号分隔列表)来引用显式位置。下面的示例演示如何指定其他文件名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></td></tr></table></figure>
<p>下面的示例演示如何指定两个位置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.properties</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Warning</p>
<p><code>spring.config.name</code>和<code>spring.config.location</code>很早就用于确定必须加载哪些文件，因此必须将它们定义为环境属性(通常是 OS 环境变量，系统属性或命令行参数)。</p>
</blockquote>
<p>如果<code>spring.config.location</code>包含目录(而不是文件)，则它们应以<code>/</code>结尾(并且在运行时，应在加载之前附加从<code>spring.config.name</code>生成的名称，包括特定于配置文件的文件名)。 <code>spring.config.location</code>中指定的文件按原样使用，不支持特定于配置文件的变体，并且被任何特定于配置文件的属性覆盖。</p>
<p>配置位置以相反的顺序搜索。默认情况下，配置的位置是<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索顺序如下：</p>
<ul>
<li><code>file:./config/</code></li>
<li><code>file:./</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ul>
<p>使用<code>spring.config.location</code>配置自定义配置位置后，它们将替换默认位置。例如，如果将<code>spring.config.location</code>配置为值<code>classpath:/custom-config/,file:./custom-config/</code>，则搜索顺序如下：</p>
<ul>
<li><code>file:./custom-config/</code></li>
<li><code>classpath:custom-config/</code></li>
</ul>
<p>或者，当使用<code>spring.config.additional-location</code>配置自定义配置位置时，除默认位置外还使用它们。在默认位置之前搜索其他位置。例如，如果配置了<code>classpath:/custom-config/,file:./custom-config/</code>的其他位置，则搜索顺序如下：</p>
<ul>
<li><code>file:./custom-config/</code></li>
<li><code>classpath:custom-config/</code></li>
<li><code>file:./config/</code></li>
<li><code>file:./</code></li>
<li><code>classpath:/config/</code></li>
<li><code>classpath:/</code></li>
</ul>
<p>通过此搜索顺序，您可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。您可以在默认位置之一的<code>application.properties</code>(或使用<code>spring.config.name</code>选择的其他任何基本名称)中为应用程序提供默认值。然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。</p>
<p>Note</p>
<p>如果使用环境变量而不是系统属性，则大多数操作系统都不允许使用句点分隔的键名，但可以使用下划线代替(例如，<code>SPRING_CONFIG_NAME</code>代替<code>spring.config.name</code>)。</p>
<blockquote>
<p>Note</p>
<p>如果您的应用程序在容器中运行，则可以使用 JNDI 属性(在<code>java:comp/env</code>中)或 servlet 上下文初始化参数来代替环境变量或系统属性，也可以使用它们。</p>
</blockquote>
<h2 id="特定于配置文件的属性"><a href="#特定于配置文件的属性" class="headerlink" title="特定于配置文件的属性"></a>特定于配置文件的属性</h2><p>除了<code>application.properties</code>个文件之外，还可以使用以下命名约定来定义特定于配置文件的属性：<code>application-&#123;profile&#125;.properties</code>。 <code>Environment</code>具有一组默认配置文件(默认情况下为<code>[default]</code>)，如果未设置任何 Active 配置文件，则使用这些配置文件。换句话说，如果未显式激活任何配置文件，则将加载<code>application-default.properties</code>中的属性。</p>
<p>特定于配置文件的属性是从与标准<code>application.properties</code>相同的位置加载的，特定于配置文件的文件总是会覆盖非特定文件，无论特定于配置文件的文件是在打包 jar 的内部还是外部。</p>
<p>如果指定了多个配置文件，则采用后赢策略。例如，由<code>spring.profiles.active</code>属性指定的配置文件将添加到通过<code>SpringApplication</code> API 配置的配置文件之后，因此具有优先权。</p>
<blockquote>
<p>Note</p>
<p>如果您在<code>spring.config.location</code>中指定了任何文件，则不会考虑这些文件的特定于配置文件的变体。如果您还想使用特定于配置文件的属性，请使用<code>spring.config.location</code>中的目录。</p>
</blockquote>
<h2 id="属性中的占位符"><a href="#属性中的占位符" class="headerlink" title="属性中的占位符"></a>属性中的占位符</h2><p><code>application.properties</code>中的值在使用时会通过现有的<code>Environment</code>进行过滤，因此您可以参考以前定义的值(例如，从“系统”属性中)。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a Spring Boot application</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip</p>
<p>您还可以使用此技术来创建现有 Spring Boot 属性的“简短”变体。有关详细信息，请参见<em> <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#使用&quot;简短&quot;命令行参数">“使用’短’命令行参数”</a> </em>操作方法。</p>
</blockquote>
<h2 id="加密属性"><a href="#加密属性" class="headerlink" title="加密属性"></a>加密属性</h2><p>Spring Boot 不提供对加密属性值的任何内置支持，但是，它确实提供了修改 Spring <code>Environment</code>中包含的值所必需的钩子点。 <code>EnvironmentPostProcessor</code>界面允许您在应用程序启动之前操纵<code>Environment</code>。有关详情，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#在启动环境或ApplicationContext之前对其进行自定义">“在启动前自定义环境或 ApplicationContext”</a>。</p>
<p>如果您正在寻找一种安全的方式来存储凭据和密码，则<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-vault/">Spring Cloud Vault</a>项目提供了对将外部化配置存储在<a target="_blank" rel="noopener" href="https://www.vaultproject.io/">HashiCorp Vault</a>中的支持。</p>
<h2 id="使用YAML代替属性"><a href="#使用YAML代替属性" class="headerlink" title="使用YAML代替属性"></a>使用YAML代替属性</h2><p><a target="_blank" rel="noopener" href="http://yaml.org/">YAML</a>是 JSON 的超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在 Classpath 上具有<a target="_blank" rel="noopener" href="http://www.snakeyaml.org/">SnakeYAML</a>库，<code>SpringApplication</code>类就会自动支持 YAML 作为属性的替代方法。</p>
<blockquote>
<p>Note</p>
<p>如果您使用“Starter”，则<code>spring-boot-starter</code>自动提供 SnakeYAML。</p>
</blockquote>
<h3 id="加载YAML"><a href="#加载YAML" class="headerlink" title="加载YAML"></a>加载YAML</h3><p>Spring Framework 提供了两个方便的类，可用于加载 YAML 文档。 <code>YamlPropertiesFactoryBean</code>将 YAML 加载为<code>Properties</code>，而<code>YamlMapFactoryBean</code>将 YAML 加载为<code>Map</code>。</p>
<p>例如，考虑以下 YAML 文档：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environments:</span></span><br><span class="line">    <span class="attr">dev:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://dev.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Developer</span> <span class="string">Setup</span></span><br><span class="line">    <span class="attr">prod:</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">http://another.example.com</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">My</span> <span class="string">Cool</span> <span class="string">App</span></span><br></pre></td></tr></table></figure>
<p>前面的示例将转换为以下属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">environments.dev.url</span>=<span class="string">http://dev.example.com</span></span><br><span class="line"><span class="meta">environments.dev.name</span>=<span class="string">Developer Setup</span></span><br><span class="line"><span class="meta">environments.prod.url</span>=<span class="string">http://another.example.com</span></span><br><span class="line"><span class="meta">environments.prod.name</span>=<span class="string">My Cool App</span></span><br></pre></td></tr></table></figure>
<p>YAML 列表表示为带有<code>[index]</code>解引用器的属性键。例如，考虑以下 YAML：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">servers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev.example.com</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>
<p>前面的示例将转换为以下属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">my.servers[0]</span>=<span class="string">dev.example.com</span></span><br><span class="line"><span class="meta">my.servers[1]</span>=<span class="string">another.example.com</span></span><br></pre></td></tr></table></figure>
<p>要使用 Spring Boot 的<code>Binder</code>Util(即<code>@ConfigurationProperties</code>所做的)绑定到类似的属性，您需要在<code>java.util.List</code>(或<code>Set</code>)类型的目标 bean 中具有一个属性，并且需要提供 setter 或使用 a 初始化它。可变值。例如，以下示例绑定到前面显示的属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;my&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; servers = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.servers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在Spring环境中将YAML公开为属性"><a href="#在Spring环境中将YAML公开为属性" class="headerlink" title="在Spring环境中将YAML公开为属性"></a>在Spring环境中将YAML公开为属性</h3><p><code>YamlPropertySourceLoader</code>类可用于在 Spring <code>Environment</code>中将 YAML 公开为<code>PropertySource</code>。这样做使您可以将<code>@Value</code>注解与占位符语法一起使用以访问 YAML 属性。</p>
<h3 id="多配置文件YAML文档"><a href="#多配置文件YAML文档" class="headerlink" title="多配置文件YAML文档"></a>多配置文件YAML文档</h3><p>您可以使用<code>spring.profiles</code>键在一个文件中指定多个特定于配置文件的 YAML 文档，以指示何时应用该文档，如以下示例所示：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">development</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">profiles:</span> <span class="string">production</span> <span class="string">&amp;</span> <span class="string">eu-central</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.120</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果<code>development</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>127.0.0.1</code>。同样，如果<code>production</code>和<code>eu-central</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>192.168.1.120</code>。如果<code>development</code>，<code>production</code>和<code>eu-central</code>配置文件未启用，则该属性的值为<code>192.168.1.100</code>。</p>
<blockquote>
<p>Note</p>
<p>因此<code>spring.profiles</code>可以包含一个简单的配置文件名称(例如<code>production</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production &amp; (eu-central | eu-west)</code>。查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">reference guide</a>以获取更多详细信息。</p>
</blockquote>
<p>如果在启动应用程序上下文时未明确激活任何 Active，则会激活默认配置文件。因此，在以下 YAML 中，我们为<code>spring.security.user.password</code>设置了一个值，该值仅在“默认”配置文件中可用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure>
<p>而在以下示例中，始终设置密码是因为该密码未附加到任何配置文件，并且必须根据需要在所有其他配置文件中将其显式重置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">weak</span></span><br></pre></td></tr></table></figure>
<p>Spring配置文件可以被<code>spring.profile</code>元素通过使用<code>!</code>字符被随意否定。如果为单个文档同时指定了否定配置文件和非否定配置文件，则必须至少匹配一个非否定配置文件，并且不能匹配任何否定配置文件。</p>
<h3 id="YAML缺点"><a href="#YAML缺点" class="headerlink" title="YAML缺点"></a>YAML缺点</h3><p>无法使用<code>@PropertySource</code>注解加载YAML文件。因此，在需要以这种方式加载值的情况下，需要使用属性文件。</p>
<h2 id="类型安全的配置属性"><a href="#类型安全的配置属性" class="headerlink" title="类型安全的配置属性"></a>类型安全的配置属性</h2><p>使用<code>@Value(&quot;$&#123;property&#125;&quot;)</code>注解注入配置属性有时会很麻烦，尤其是当您使用多个属性或数据本质上是分层的时。 Spring Boot 提供了一种使用属性的替代方法，该方法使强类型的Bean可以管理和验证应用程序的配置。</p>
<blockquote>
<p>参考<a href="#ConfigurationProperties注解与Value注解">@ConfigurationProperties与@Value</a>的不同</p>
</blockquote>
<h3 id="JavaBean属性绑定"><a href="#JavaBean属性绑定" class="headerlink" title="JavaBean属性绑定"></a>JavaBean属性绑定</h3><p>可以绑定声明标准JavaBean属性的bean，如下面的例子所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnabled</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteAddress</span><span class="params">(InetAddress remoteAddress)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">getSecurity</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; roles = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.singleton(<span class="string">&quot;USER&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoles</span><span class="params">(List&lt;String&gt; roles)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的 POJO 定义了以下属性：</p>
<ul>
<li><code>acme.enabled</code>，默认值为<code>false</code>。</li>
<li><code>acme.remote-address</code>，其类型可以从<code>String</code>强制转换。</li>
<li><code>acme.security.username</code>，带有嵌套的“安全”对象，其名称由属性名称确定。特别是，返回类型在那里根本不使用，可能是<code>SecurityProperties</code>。</li>
<li><code>acme.security.password</code> .</li>
<li><code>acme.security.roles</code>，集合为<code>String</code>。</li>
</ul>
<blockquote>
<p>Note</p>
<p>映射到Spring Boot中可用的<code>@ConfigurationProperties</code>类的属性(通过属性文件、YAML文件、环境变量等配置)是公共API，但类本身的访问器(getter /setter)并不打算直接使用。</p>
<p>Note</p>
<p>这种安排依赖于默认的空构造函数，getter和setter通常是强制的，因为绑定是通过标准的Java bean属性描述符进行的，就像Spring MVC中一样。在下列情况下，可省略setter:</p>
<ul>
<li>映射，只要它们被初始化，就需要一个getter，但不一定是setter，因为它们可以被绑定器改变。</li>
<li>可以通过索引(通常使用YAML)或使用逗号分隔的值(属性)访问集合和数组。在后一种情况下，setter是必需的。我们建议始终为此类类型添加setter。如果初始化一个集合，请确保它不是不可变的(如前面的示例所示)。</li>
<li>如果初始化了嵌套的POJO属性(如前面示例中的<code>Security</code>字段)，则不需要setter。如果希望绑定器使用其默认构造函数动态创建实例，则需要一个setter。</li>
</ul>
<p>有些人使用Project Lombok自动添加getter和setter。请确保Lombok不会为这样的类型生成任何特定的构造函数，因为容器会自动使用它来实例化对象。</p>
<p>最后，只考虑标准Java Bean属性，不支持绑定静态属性。</p>
</blockquote>
<h3 id="构造器绑定"><a href="#构造器绑定" class="headerlink" title="构造器绑定"></a>构造器绑定</h3><p>上一节中的例子可以用不可变的方式重写，如下面的例子所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConstructorBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.bind.DefaultValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcmeProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, Security security)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        <span class="keyword">this</span>.security = security;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InetAddress <span class="title">getRemoteAddress</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Security <span class="title">getSecurity</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; roles;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Security</span><span class="params">(String username, String password,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@DefaultValue(&quot;USER&quot;)</span> List&lt;String&gt; roles)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">this</span>.roles = roles;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRoles</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个设置中，<code>@ConstructorBinding</code>注解用于指示应该使用构造函数绑定。这意味着绑定器将期望找到具有您希望绑定的参数的构造器。</p>
<p><code>@ConstructorBinding</code>类的嵌套成员(如上面示例中的Security)也将通过它们的构造函数绑定。</p>
<p>可以使用<code>@DefaultValue</code>指定默认值，并且将应用相同的转换服务将字符串值强制转换为缺失属性的目标类型。默认情况下，如果没有属性绑定到安全性，则<code>AcmeProperties</code>实例将包含用于安全性的<code>null</code>。如果你希望你返回一个非空的安全实例，即使没有属性绑定到它，你可以使用一个空的<code>@DefaultValue</code>注解这样做:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConstructorBinding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.bind.DefaultValue;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ConstructorBinding</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcmeProperties</span><span class="params">(<span class="keyword">boolean</span> enabled, InetAddress remoteAddress, <span class="meta">@DefaultValue</span> Security security)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        <span class="keyword">this</span>.remoteAddress = remoteAddress;</span><br><span class="line">        <span class="keyword">this</span>.security = security;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>要使用构造函数绑定，必须使用<code>@EnableConfigurationProperties</code>或配置属性扫描启用该类。不能使用构造函数绑定由常规Spring机制创建的bean(例如<code>@Component</code> bean、通过<code>@Bean</code>方法创建的bean或使用<code>@Import</code>加载的bean)</p>
<p>Tips</p>
<p>如果您的类有多个构造函数，您也可以在应该绑定的构造函数上直接使用<code>@ConstructorBinding</code>。</p>
<p>Note</p>
<p><code>java.util.Optional</code>和<code>@ConfigurationProperties</code>一块使用是不推荐使用，因为它主要用于作为返回类型。因此，它并不非常适合配置属性注入。为了与其他类型的属性保持一致，如果您声明了一个<code>Optional</code>属性，但它没有值，那么将绑定<code>null</code>而不是空<code>Optional</code>属性。</p>
</blockquote>
<h3 id="开启ConfigurationProperties-annotated注解类型"><a href="#开启ConfigurationProperties-annotated注解类型" class="headerlink" title="开启ConfigurationProperties-annotated注解类型"></a>开启ConfigurationProperties-annotated注解类型</h3><p>Spring引导提供了绑定<code>@ConfigurationProperties</code>类型并将其注册为bean的基础设施。您可以逐个类启用配置属性，也可以启用配置属性扫描，其工作方式类似于组件扫描。</p>
<p>有时候，用<code>@ConfigurationProperties</code>注解的类可能不适合扫描，例如，如果您正在开发自己的自动配置，或者希望有条件地启用它们。在这些情况下，使用<code>@EnableConfigurationProperties</code>注解指定要处理的类型列表。这可以在任何<code>@Configuration</code>类上完成，如下面的例子所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要使用配置属性扫描，请在应用程序中添加<code>@ConfigurationPropertiesScan</code>注解。通常，它被添加到用<code>@SpringBootApplication</code>注解的主应用程序类中，但是它可以添加到任何<code>@Configuration</code>类中。默认情况下，扫描将从声明注解的类的包中进行。如果您想要定义特定的包来扫描，您可以这样做，如下面的例子所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ConfigurationPropertiesScan(&#123; &quot;com.example.app&quot;, &quot;org.acme.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>当<code>@ConfigurationProperties</code> bean注册使用配置属性扫描或通过<code>@EnableConfigurationProperties</code> bean有一个惯用名称:<code>&lt;prefix&gt;-&lt;fqn&gt;</code>, <code>&lt;prefix&gt;</code>是环境关键<code>@ConfigurationProperties</code>注解中指定的前缀和<code>&lt; fqn &gt;</code>是完全限定的bean的名称。如果注解不提供任何前缀，则只使用bean的完全限定名。</p>
<p>上面示例中的bean名是<code>acme-com.example.AcmeProperties</code>。</p>
</blockquote>
<p>我们建议<code>@ConfigurationProperties</code>只处理环境，特别地，不要从上下文注入其他bean。对于特殊情况，可以使用setter注入或框架提供的任何<code>*Aware</code>接口(例如，如果需要访问环境，可以使用<code>EnvironmentAware</code>)。如果您仍然希望使用构造函数注入其他bean，则配置属性bean必须使用<code>@Component</code>进行注解，并使用基于javabean的属性绑定。</p>
<h3 id="使用ConfigurationProperties-annotated注解类型"><a href="#使用ConfigurationProperties-annotated注解类型" class="headerlink" title="使用ConfigurationProperties-annotated注解类型"></a>使用ConfigurationProperties-annotated注解类型</h3><p>这种配置风格在<code>SpringApplication</code>的外部YAML配置中工作得特别好，如下面的示例所示:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line">    <span class="attr">remote-address:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">security:</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">        <span class="attr">roles:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">USER</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">ADMIN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># additional configuration as required</span></span><br></pre></td></tr></table></figure>
<p>要使用<code>@ConfigurationProperties</code> bean，您可以使用与任何其他bean相同的方式注入它们，如下面的例子所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AcmeProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(AcmeProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server(<span class="keyword">this</span>.properties.getRemoteAddress());</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>使用<code>@ConfigurationProperties</code>还可以让您生成元数据文件，IDEs可以使用这些元数据文件为您自己的键提供自动完成功能。详见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E9%99%84%E5%BD%95/#配置元数据">附录</a>。</p>
</blockquote>
<h3 id="第三方配置"><a href="#第三方配置" class="headerlink" title="第三方配置"></a>第三方配置</h3><p>除了使用<code>@ConfigurationProperties</code>注解类，您还可以在公共<code>@Bean</code>方法上使用它。当您要将属性绑定到控件之外的第三方组件时，这样做特别有用。</p>
<p>要通过<code>Environment</code>属性配置 bean，请将<code>@ConfigurationProperties</code>添加到其 bean 注册中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;another&quot;)</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnotherComponent <span class="title">anotherComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>another</code>前缀定义的任何属性都以类似于前面<code>AcmeProperties</code>示例的方式 Map 到该<code>AnotherComponent</code> bean。</p>
<h3 id="宽松绑定"><a href="#宽松绑定" class="headerlink" title="宽松绑定"></a>宽松绑定</h3><p>Spring Boot 使用一些宽松的规则将<code>Environment</code>属性绑定到<code>@ConfigurationProperties</code> bean，因此<code>Environment</code>属性名称和 bean 属性名称之间不需要完全匹配。有用的常见示例包括破折号分隔的环境属性(例如<code>context-path</code>绑定到<code>contextPath</code>)和大写的环境属性(例如<code>PORT</code>绑定到<code>port</code>)。</p>
<p>例如，考虑以下<code>@ConfigurationProperties</code>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;acme.my-project.person&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnerProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，可以全部使用以下属性名称：</p>
<p><strong>表 24.1. Relaxed绑定</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>acme.my-project.person.first-name</code></td>
<td>Kebab 情况，建议在<code>.properties</code>和<code>.yml</code>文件中使用。</td>
</tr>
<tr>
<td><code>acme.myProject.person.firstName</code></td>
<td>标准驼峰式语法。</td>
</tr>
<tr>
<td><code>acme.my_project.person.first_name</code></td>
<td>下划线表示法，是在<code>.properties</code>和<code>.yml</code>文件中使用的另一种格式。</td>
</tr>
<tr>
<td><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code></td>
<td>大写格式，使用系统环境变量时建议使用。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Note</p>
<p>注解*的<code>prefix</code>值必须为 kebab(小写并由<code>-</code>分隔，例如<code>acme.my-project.person</code>)。</p>
</blockquote>
<p><strong>表 24.2. 每个资源来源的宽松绑定规则</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Property Source</th>
<th>Simple</th>
<th>List</th>
</tr>
</thead>
<tbody>
<tr>
<td>Properties Files</td>
<td>骆驼案，烤肉串案或下划线</td>
<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法</td>
</tr>
<tr>
<td>YAML Files</td>
<td>骆驼案，烤肉串案或下划线</td>
<td>标准 YAML 列表语法或逗号分隔的值</td>
</tr>
<tr>
<td>Environment Variables</td>
<td>以下划线作为定界符的大写格式。 <code>_</code>不应在属性名称中使用</td>
<td>带有下划线的数字值，例如<code>MY_ACME_1_OTHER = my.acme[1].other</code></td>
</tr>
<tr>
<td>System properties</td>
<td>骆驼案，烤肉串案或下划线</td>
<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>Tip</p>
<p>我们建议，如果可能的话，属性以小写的 kebab 格式存储，例如<code>my.property-name=acme</code>。</p>
</blockquote>
<p><strong>Binding Maps</strong></p>
<p>绑定到<code>Map</code>属性时，如果<code>key</code>包含小写字母数字字符或<code>-</code>以外的任何内容，则需要使用方括号表示法，以便保留原始值。如果键没有被<code>[]</code>包围，则所有非字母数字或<code>-</code>的字符都将被删除。例如，考虑将以下属性绑定到<code>Map</code>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="string">&quot;[/key1]&quot;</span><span class="string">:</span> <span class="string">value1</span></span><br><span class="line">    <span class="string">&quot;[/key2]&quot;</span><span class="string">:</span> <span class="string">value2</span></span><br><span class="line">    <span class="string">/key3:</span> <span class="string">value3</span></span><br></pre></td></tr></table></figure>
<p>上面的属性将绑定到<code>Map</code>，其中<code>/key1</code>，<code>/key2</code>和<code>key3</code>作为 Map 中的键。</p>
<p><strong>从环境变量绑定</strong></p>
<p>大多数操作系统对可用于环境变量的名称实施严格的规则。例如，Linux shell变量只能包含字母(a到z或a到z)、数字(0到9)或下划线字符(_)。按照惯例，Unix shell变量的名称也是大写的。</p>
<p>Spring Boot的宽松绑定规则被尽可能地设计为与这些命名限制兼容。</p>
<p>要将规范形式的属性名转换为环境变量名，可以遵循以下规则:</p>
<ul>
<li><p>将点(.)替换为下划线(_)。</p>
</li>
<li><p>删除所有破折号(-)。</p>
</li>
<li><p>转换为大写。</p>
</li>
</ul>
<p>例如，配置属性<code>spring.main.log-startup-info</code>是一个名为<code>SPRING_MAIN_LOGSTARTUPINFO</code>的环境变量。</p>
<blockquote>
<p>Note</p>
<p>下划线不能用于替换属性名称中的破折号。如果您尝试在上面的示例中使用<code>SPRING_MAIN_LOG_STARTUP_INFO</code>，则不会绑定任何值。</p>
</blockquote>
<p>在绑定到对象列表时，也可以使用环境变量。要绑定到列表，元素号应该在变量名中用下划线包围。</p>
<p>例如，配置属性<code>my.acme[0].other</code>。other将使用名为<code>MY_ACME_0_OTHER</code>的环境变量。</p>
<h3 id="合并复杂类型"><a href="#合并复杂类型" class="headerlink" title="合并复杂类型"></a>合并复杂类型</h3><p>如果在多个位置配置了列表，则通过替换整个列表来进行覆盖。</p>
<p>例如，假设一个<code>MyPojo</code>对象的<code>name</code>和<code>description</code>属性默认为<code>null</code>。以下示例公开了<code>AcmeProperties</code>中的<code>MyPojo</code>个对象的列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MyPojo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;MyPojo&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>
<p>如果<code>dev</code>配置文件无效，则<code>AcmeProperties.list</code>包含一个<code>MyPojo</code>条目，如先前所定义。但是，如果启用了<code>dev</code>配置文件，则<code>list</code> <em>仍然</em>仅包含一个条目(名称为<code>my another name</code>和描述为<code>null</code>)。此配置<em>不会</em>将第二个<code>MyPojo</code>实例添加到列表中，并且不会合并项目。</p>
<p>在多个配置文件中指定<code>List</code>时，将使用优先级最高的(并且只有该优先级)。考虑以下示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">another</span> <span class="string">name</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">another</span> <span class="string">description</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my</span> <span class="string">another</span> <span class="string">name</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果<code>dev</code>配置文件处于 Active 状态，则<code>AcmeProperties.list</code>包含<em> one </em> <code>MyPojo</code>条目(名称为<code>my another name</code>且描述为<code>null</code>)。对于 YAML，可以使用逗号分隔的列表和 YAML 列表来完全覆盖列表的内容。</p>
<p>对于<code>Map</code>属性，您可以绑定从多个来源获取的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。以下示例从<code>AcmeProperties</code>公开<code>Map&lt;String, MyPojo&gt;</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;acme&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, MyPojo&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, MyPojo&gt; <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="attr">key1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">my</span> <span class="string">name</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">my</span> <span class="string">description</span> <span class="number">1</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">acme:</span></span><br><span class="line">  <span class="attr">map:</span></span><br><span class="line">    <span class="attr">key1:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dev</span> <span class="string">name</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">key2:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">dev</span> <span class="string">name</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">dev</span> <span class="string">description</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果<code>dev</code>配置文件未激活，则<code>AcmeProperties.map</code>包含一个键为<code>key1</code>的条目(名称为<code>my name 1</code>和描述为<code>my description 1</code>)。但是，如果启用了<code>dev</code>配置文件，则<code>map</code>包含两个条目，其中包含键<code>key1</code>(名称为<code>dev name 1</code>和<code>my description 1</code>的描述)和<code>key2</code>(名称为<code>dev name 2</code>和<code>dev description 2</code>的描述)。</p>
<blockquote>
<p>Note</p>
<p>前述合并规则不仅适用于 YAML 文件，而且适用于所有属性源中的属性。</p>
</blockquote>
<h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>当 Spring Boot 绑定到<code>@ConfigurationProperties</code> bean 时，它尝试将外部应用程序属性强制为正确的类型。如果需要自定义类型转换，则可以提供<code>ConversionService</code> bean(使用名为<code>conversionService</code>的 bean)或自定义属性编辑器(通过<code>CustomEditorConfigurer</code> bean)或自定义<code>Converters</code>(将 bean 定义标注为<code>@ConfigurationPropertiesBinding</code>)。</p>
<blockquote>
<p>Note</p>
<p>由于在应用程序生命周期中非常早就请求了此 bean，因此请确保限制您的<code>ConversionService</code>使用的依赖项。通常，您需要的任何依赖项可能在创建时未完全初始化。如果配置键强制不需要自定义<code>ConversionService</code>，而只依赖于具有<code>@ConfigurationPropertiesBinding</code>限定的自定义转换器，则可能要重命名。</p>
</blockquote>
<h4 id="Convertingdurations"><a href="#Convertingdurations" class="headerlink" title="Convertingdurations"></a>Convertingdurations</h4><p>Spring Boot 为表达持续时间提供了专门的支持。如果公开<code>java.time.Duration</code>属性，则应用程序属性中的以下格式可用：</p>
<ul>
<li>常规<code>long</code>表示形式(使用毫秒作为默认单位，除非已指定<code>@DurationUnit</code>)</li>
<li>标准 ISO-8601 格式<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence-">由 java.util.Duration 使用</a></li>
<li>值和单位相结合的更易读的格式(例如<code>10s</code>表示 10 秒)</li>
</ul>
<p>考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.system&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppSystemProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DurationUnit(ChronoUnit.SECONDS)</span></span><br><span class="line">    <span class="keyword">private</span> Duration sessionTimeout = Duration.ofSeconds(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Duration readTimeout = Duration.ofMillis(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Duration <span class="title">getSessionTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSessionTimeout</span><span class="params">(Duration sessionTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sessionTimeout = sessionTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Duration <span class="title">getReadTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.readTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadTimeout</span><span class="params">(Duration readTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readTimeout = readTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要指定 30 秒的会话超时，<code>30</code>，<code>PT30S</code>和<code>30s</code>都是等效的。可以采用以下任何形式指定 500ms 的读取超时：<code>500</code>，<code>PT0.5S</code>和<code>500ms</code>。</p>
<p>您也可以使用任何受支持的单位。这些是：</p>
<ul>
<li><code>ns</code>纳秒</li>
<li><code>us</code>微秒</li>
<li><code>ms</code>毫秒</li>
<li><code>s</code>秒</li>
<li><code>m</code>分钟</li>
<li><code>h</code>小时</li>
<li><code>d</code>天</li>
</ul>
<p>默认单位是毫秒，可以使用<code>@DurationUnit</code>覆盖，如上面的示例所示。</p>
<blockquote>
<p>Tip</p>
<p>如果要从仅使用<code>Long</code>表示持续时间的先前版本进行升级，请确保在切换到<code>Duration</code>的时间不是毫秒的情况下(使用<code>@DurationUnit</code>)定义单位。这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
<h4 id="转换数据大小"><a href="#转换数据大小" class="headerlink" title="转换数据大小"></a>转换数据大小</h4><p>Spring Framework 的<code>DataSize</code>值类型允许以字节表示大小。如果公开<code>DataSize</code>属性，则应用程序属性中的以下格式可用：</p>
<ul>
<li>常规的<code>long</code>表示形式(除非已指定<code>@DataSizeUnit</code>，否则使用字节作为默认单位)</li>
<li>值和单位耦合在一起的更具可读性的格式(例如<code>10MB</code>表示 10 兆字节)</li>
</ul>
<p>考虑以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;app.io&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppIoProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class="line">    <span class="keyword">private</span> DataSize bufferSize = DataSize.ofMegabytes(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSize sizeThreshold = DataSize.ofBytes(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSize <span class="title">getBufferSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBufferSize</span><span class="params">(DataSize bufferSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bufferSize = bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSize <span class="title">getSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sizeThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSizeThreshold</span><span class="params">(DataSize sizeThreshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sizeThreshold = sizeThreshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要指定 10 MB 的缓冲区大小，<code>10</code>和<code>10MB</code>是等效的。可以将 256 个字节的大小阈值指定为<code>256</code>或<code>256B</code>。</p>
<p>您也可以使用任何受支持的单位。这些是：</p>
<ul>
<li><code>B</code>个字节</li>
<li><code>KB</code>千字节</li>
<li><code>MB</code>代表兆字节</li>
<li><code>GB</code>代表千兆字节</li>
<li><code>TB</code>代表兆兆字节</li>
</ul>
<p>默认单位是字节，可以使用<code>@DataSizeUnit</code>覆盖，如上面的示例所示。</p>
<blockquote>
<p>Tip</p>
<p>如果要从仅使用<code>Long</code>表示大小的先前版本进行升级，请确保在切换到<code>DataSize</code>的旁边不是字节的情况下定义单位(使用<code>@DataSizeUnit</code>)。这样做可以提供透明的升级路径，同时支持更丰富的格式。</p>
</blockquote>
<h3 id="ConfigurationProperties注解验证"><a href="#ConfigurationProperties注解验证" class="headerlink" title="ConfigurationProperties注解验证"></a>ConfigurationProperties注解验证</h3><p>每当使用 Spring 的<code>@Validated</code>注解 进行注解时，Spring Boot 就会尝试验证<code>@ConfigurationProperties</code>类。您可以在配置类上直接使用 JSR-303 <code>javax.validation</code>约束注解。为此，请确保在 Classpath 上有兼容的 JSR-303 实现，然后将约束注解添加到字段中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;acme&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip</p>
<p>您还可以通过使用<code>@Validated</code>Comments 创建配置属性的<code>@Bean</code>方法来触发验证。</p>
</blockquote>
<p>尽管嵌套属性在绑定时也会被验证，但是最好将关联的字段注解为<code>@Valid</code>。这样可以确保即使没有嵌套属性也可以触发验证。以下示例基于前面的<code>AcmeProperties</code>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix=&quot;acme&quot;)</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Security security = <span class="keyword">new</span> Security();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">public</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... getters and setters</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以通过创建名为<code>configurationPropertiesValidator</code>的 bean 定义来添加自定义 Spring <code>Validator</code>。 <code>@Bean</code>方法应声明为<code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，并且将<code>@Bean</code>方法声明为静态方法可以使 Bean 得以创建而不必实例化<code>@Configuration</code>类。这样做可以避免因早期实例化而引起的任何问题。有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-property-validation">属性验证 samples</a>显示了如何进行设置。</p>
<blockquote>
<p>Tip</p>
<p><code>spring-boot-actuator</code>模块包含一个公开所有<code>@ConfigurationProperties</code> bean 的端点。将您的 Web 浏览器指向<code>/actuator/configprops</code>或使用等效的 JMX 端点。有关详细信息，请参见“ <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-SpringBoot-Actuator可用于生产的功能/#Endpoints">生产就绪功能</a>”部分。</p>
</blockquote>
<h3 id="ConfigurationProperties注解与Value注解"><a href="#ConfigurationProperties注解与Value注解" class="headerlink" title="ConfigurationProperties注解与Value注解"></a>ConfigurationProperties注解与Value注解</h3><p><code>@Value</code>注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。下表总结了<code>@ConfigurationProperties</code>和<code>@Value</code>支持的功能：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>@ConfigurationProperties</code></th>
<th><code>@Value</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#轻松绑定">Relaxed binding</a></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#配置元数据">Meta-data support</a></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>SpEL</code>评估</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
</div>
<p>如果您为自己的组件定义了一组配置键，我们建议您将它们组合在以<code>@ConfigurationProperties</code>注解的 POJO 中。您还应该意识到，由于<code>@Value</code>不支持宽松的绑定，因此如果您需要使用环境变量来提供值，则它不是很好的选择。</p>
<p>最后，尽管您可以在<code>@Value</code>中编写<code>SpEL</code>表达式，但不会从<a href="#应用程序属性文件">应用程序属性文件</a>处理此类表达式。</p>
<h1 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h1><p>Spring Profiles 提供了一种隔离应用程序配置的各部分并使之仅在某些环境中可用的方法。可以用<code>@Profile</code>标记任何<code>@Component</code>或<code>@Configuration</code>以限制其什么时候被加载，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile(&quot;production&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductionConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>spring.profiles.active</code> <code>Environment</code>属性来指定哪些配置文件处于 Active 状态。您可以通过本章前面介绍的任何方式指定属性。例如，您可以将其包含在<code>application.properties</code>中，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev,hsqldb</span><br></pre></td></tr></table></figure>
<p>您还可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。</p>
<h2 id="添加Active配置文件"><a href="#添加Active配置文件" class="headerlink" title="添加Active配置文件"></a>添加Active配置文件</h2><p><code>spring.profiles.active</code>属性遵循与其他属性相同的排序规则：最高<code>PropertySource</code>获胜。这意味着您可以在<code>application.properties</code>中指定 Active 配置文件，然后使用命令行开关“替换”它们。</p>
<p>有时，将特定于配置文件的属性“添加”到 Active 配置文件而不是替换它们很有用。 <code>spring.profiles.include</code>属性可用于无条件添加 Active 配置文件。 <code>SpringApplication</code>入口点还具有 Java API，用于设置其他配置文件(即，在<code>spring.profiles.active</code>属性激活的配置文件之上)。请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/SpringApplication.html">SpringApplication</a>中的<code>setAdditionalProfiles()</code>方法。</p>
<p>例如，当使用开关<code>--spring.profiles.active=prod</code>运行具有以下属性的应用程序时，还将激活<code>proddb</code>和<code>prodmq</code>配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">my.property:</span> <span class="string">fromyamlfile</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring.profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">spring.profiles.include:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">proddb</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">prodmq</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>请记住，可以在 <code>YAML</code> 文档中定义<code>spring.profiles</code>属性，以确定何时将该特定文档包括在配置中。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#根据环境更改配置">“根据环境更改配置”</a>。</p>
</blockquote>
<h2 id="以编程方式设置配置文件"><a href="#以编程方式设置配置文件" class="headerlink" title="以编程方式设置配置文件"></a>以编程方式设置配置文件</h2><p>您可以在应用程序运行之前通过调用<code>SpringApplication.setAdditionalProfiles(…)</code>以编程方式设置 Active 配置文件。也可以使用 Spring 的<code>ConfigurableEnvironment</code>界面激活配置文件。</p>
<h2 id="特定于配置文件的配置文件"><a href="#特定于配置文件的配置文件" class="headerlink" title="特定于配置文件的配置文件"></a>特定于配置文件的配置文件</h2><p><code>application.properties</code>(或<code>application.yml</code>)和通过<code>@ConfigurationProperties</code>引用的文件的特定于配置文件的变体都被视为文件并已加载。有关详细信息，请参见“ <a href="#特定于配置文件的属性">“特定于配置文件的属性”</a>”。</p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>Spring引导对所有内部日志使用<a target="_blank" rel="noopener" href="https://commons.apache.org/logging">Commons Logging</a>，但保留底层日志实现。为<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html">Java Util 记录</a>，<a target="_blank" rel="noopener" href="https://logging.apache.org/log4j/2.x/">Log4J2</a>和<a target="_blank" rel="noopener" href="http://logback.qos.ch/">Logback</a>提供了默认配置。在每种情况下，Logger 都已预先配置为使用控制台输出，同时还提供可选文件输出。</p>
<p>默认情况下，如果使用“启动器”，则使用 Logback 进行日志记录。还包括适当的 Logback 路由，以确保使用 Java Util Logging，Commons Logging，Log4J 或 SLF4J 的从属库均能正常工作。</p>
<blockquote>
<p>Tip</p>
<p>有许多可用于 Java 的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且 Spring Boot 默认值可以正常工作。</p>
</blockquote>
<h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>Spring Boot 的默认日志输出类似于以下示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#x27;dispatcherServlet&#x27; to [/]</span><br><span class="line">2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#x27;hiddenHttpMethodFilter&#x27; to: [/*]</span><br></pre></td></tr></table></figure>
<p>输出以下项目：</p>
<ul>
<li>日期和时间：毫秒精度，易于排序。</li>
<li>日志级别：<code>ERROR</code>，<code>WARN</code>，<code>INFO</code>，<code>DEBUG</code>或<code>TRACE</code>。</li>
<li>Process ID.</li>
<li><code>---</code>分隔符用于区分实际日志消息的开始。</li>
<li>线程名称：用方括号括起来(对于控制台输出可能会被截断)。</li>
<li>Logger 名称：这通常是源类名称(通常缩写)。</li>
<li>日志消息。</li>
</ul>
<blockquote>
<p>Note</p>
<p>Logback 没有<code>FATAL</code>级别。它 Map 到<code>ERROR</code>。</p>
</blockquote>
<h2 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h2><p>缺省日志配置在写入消息时将消息回显到控制台。默认情况下，将记录<code>ERROR</code>级，<code>WARN</code>级和<code>INFO</code>级消息。您还可以通过使用<code>--debug</code>标志启动应用程序来启用“调试”模式。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -jar myapp.jar --debug</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>您也可以在<code>application.properties</code>中指定<code>debug=true</code>。</p>
</blockquote>
<p>启用调试模式后，将配置一些核心 Logger(嵌入式容器，Hibernate 和 Spring Boot)以输出更多信息。启用调试模式不会<em>不</em>将您的应用程序配置为记录所有具有<code>DEBUG</code>级的消息。</p>
<p>另外，您可以通过使用<code>--trace</code>标志(或<code>application.properties</code>中的<code>trace=true</code>)启动应用程序来启用“跟踪”模式。这样做可以为某些核心 Logger(嵌入式容器，Hibernate 模式生成以及整个 Spring 产品组合)启用跟踪记录。</p>
<h3 id="颜色编码的输出"><a href="#颜色编码的输出" class="headerlink" title="颜色编码的输出"></a>颜色编码的输出</h3><p>如果您的终端支持 ANSI，则使用彩色输出来提高可读性。您可以将<code>spring.output.ansi.enabled</code>设置为<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html">supported value</a>以覆盖自动检测。</p>
<p>通过使用<code>%clr</code>转换字来配置颜色编码。转换器以最简单的形式根据对数级别为输出着色，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">clr(%5p)</span></span><br></pre></td></tr></table></figure>
<p>下表描述了日志级别到颜色的 Map：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Level</th>
<th>Color</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FATAL</code></td>
<td>Red</td>
</tr>
<tr>
<td><code>ERROR</code></td>
<td>Red</td>
</tr>
<tr>
<td><code>WARN</code></td>
<td>Yellow</td>
</tr>
<tr>
<td><code>INFO</code></td>
<td>Green</td>
</tr>
<tr>
<td><code>DEBUG</code></td>
<td>Green</td>
</tr>
<tr>
<td><code>TRACE</code></td>
<td>Green</td>
</tr>
</tbody>
</table>
</div>
<p>另外，您可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如，要使文本变黄，请使用以下设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;yellow&#125;</span></span><br></pre></td></tr></table></figure>
<p>支持以下颜色和样式：</p>
<ul>
<li><code>blue</code></li>
<li><code>cyan</code></li>
<li><code>faint</code></li>
<li><code>green</code></li>
<li><code>magenta</code></li>
<li><code>red</code></li>
<li><code>yellow</code></li>
</ul>
<h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>默认情况下，Spring Boot 仅记录到控制台，不写日志文件。如果除了控制台输出外还想写入日志文件，则需要设置<code>logging.file</code>或<code>logging.path</code>属性(例如，在<code>application.properties</code>中)。</p>
<p>下表显示了如何一起使用<code>logging.*</code>属性：</p>
<p><strong>表 26.1 记录属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>logging.file</code></th>
<th><code>logging.path</code></th>
<th>Example</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>(none)</em></td>
<td><em>(none)</em></td>
<td></td>
<td>仅控制台记录。</td>
</tr>
<tr>
<td>Specific file</td>
<td><em>(none)</em></td>
<td><code>my.log</code></td>
<td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。</td>
</tr>
<tr>
<td><em>(none)</em></td>
<td>Specific directory</td>
<td><code>/var/log</code></td>
<td>将<code>spring.log</code>写入指定的目录。名称可以是确切的位置，也可以相对于当前目录。</td>
</tr>
</tbody>
</table>
</div>
<p>日志文件达到 10 MB 时会旋转，并且与控制台输出一样，默认记录<code>ERROR</code> -level，<code>WARN</code> -level 和<code>INFO</code> -level 消息。大小限制可以使用<code>logging.file.max-size</code>属性更改。除非已设置<code>logging.file.max-history</code>属性，否则以前旋转的文件将无限期存档。</p>
<blockquote>
<p>Note</p>
<p>日志记录系统在应用程序生命周期的早期进行了初始化。因此，在通过<code>@PropertySource</code>注解加载的属性文件中找不到日志记录属性。</p>
<p>Tip</p>
<p>日志记录属性与实际的日志记录基础结构无关。结果，Spring Boot 不会管理特定的配置密钥(例如 Log 的<code>logback.configurationFile</code>)。</p>
</blockquote>
<h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>所有支持的日志记录系统都可以使用<code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code>在 Spring <code>Environment</code>(例如，在<code>application.properties</code>)中设置 Logger 级别，其中<code>level</code>是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL 或 OFF 之一。可以使用<code>logging.level.root</code>来配置<code>root</code>Logger。</p>
<p>以下示例显示了<code>application.properties</code>中的潜在日志记录设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.root</span>=<span class="string">WARN</span></span><br><span class="line"><span class="meta">logging.level.org.springframework.web</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">logging.level.org.hibernate</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure>
<h2 id="日志组"><a href="#日志组" class="headerlink" title="日志组"></a>日志组</h2><p>能够将相关 Logger 组合在一起通常很有用，以便可以同时配置它们。例如，您可能通常会更改与 Tomcat 相关的所有 Logger 的日志记录级别，但是您不容易记住顶级软件包。</p>
<p>为了解决这个问题，Spring Boot 允许您在 Spring <code>Environment</code>中定义日志记录组。例如，这是通过将“ tomcat”组添加到<code>application.properties</code>来定义它的方法：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.group.tomcat</span>=<span class="string">org.apache.catalina, org.apache.coyote, org.apache.tomcat</span></span><br></pre></td></tr></table></figure>
<p>定义后，您可以使用一行更改该组中所有 Logger 的级别：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.tomcat</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure>
<p>Spring Boot 包含以下 sched 义的日志记录组，它们可以直接使用：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Name</th>
<th>Loggers</th>
</tr>
</thead>
<tbody>
<tr>
<td>web</td>
<td><code>org.springframework.core.codec</code> , <code>org.springframework.http</code> , <code>org.springframework.web</code></td>
</tr>
<tr>
<td>sql</td>
<td><code>org.springframework.jdbc.core</code> , <code>org.hibernate.SQL</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h2><p>可以通过在 Classpath 中包括适当的库来激活各种日志记录系统，并可以通过在 Classpath 的根目录中或在以下 Spring <code>Environment</code>属性：<code>logging.config</code>指定的位置中提供适当的配置文件来进一步自定义各种日志记录系统。</p>
<p>您可以通过使用<code>org.springframework.boot.logging.LoggingSystem</code> system 属性来强制 Spring Boot 使用特定的日志记录系统。该值应该是<code>LoggingSystem</code>实现的完全限定的类名。您还可以使用<code>none</code>值完全禁用 Spring Boot 的日志记录配置。</p>
<blockquote>
<p>Note</p>
<p>由于日志记录是在创建<code>ApplicationContext</code>之前**初始化的，因此无法从 Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。</p>
</blockquote>
<p>根据您的日志系统，将加载以下文件：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Logging System</th>
<th>Customization</th>
</tr>
</thead>
<tbody>
<tr>
<td>Logback</td>
<td><code>logback-spring.xml</code>，<code>logback-spring.groovy</code>，<code>logback.xml</code>或<code>logback.groovy</code></td>
</tr>
<tr>
<td>Log4j2</td>
<td><code>log4j2-spring.xml</code>或<code>log4j2.xml</code></td>
</tr>
<tr>
<td>JDK(Java Util 日志记录)</td>
<td><code>logging.properties</code></td>
</tr>
</tbody>
</table>
</div>
<p>Note</p>
<p>如果可能，我们建议您将<code>-spring</code>变体用于日志记录配置(例如<code>logback-spring.xml</code>而不是<code>logback.xml</code>)。如果使用标准配置位置，Spring 将无法完全控制日志初始化。</p>
<p>Warning</p>
<p>从“可执行 jar”运行时，Java Util Logging 存在一些已知的类加载问题，这些问题会引起问题。我们建议您尽可能从“可执行 jar”运行时避免使用它。</p>
<p>为了帮助进行自定义，如下表所述，一些其他属性从 Spring <code>Environment</code>转移到 System 属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Spring Environment</th>
<th>System Property</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>logging.exception-conversion-word</code></td>
<td><code>LOG_EXCEPTION_CONVERSION_WORD</code></td>
<td>记录异常时使用的转换字。</td>
</tr>
<tr>
<td><code>logging.file</code></td>
<td><code>LOG_FILE</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.file.max-size</code></td>
<td><code>LOG_FILE_MAX_SIZE</code></td>
<td>最大日志文件大小(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>logging.file.max-history</code></td>
<td><code>LOG_FILE_MAX_HISTORY</code></td>
<td>要保留的最大归档日志文件数(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>logging.path</code></td>
<td><code>LOG_PATH</code></td>
<td>如果定义，它将在默认日志配置中使用。</td>
</tr>
<tr>
<td><code>logging.pattern.console</code></td>
<td><code>CONSOLE_LOG_PATTERN</code></td>
<td>在控制台上使用的日志模式(stdout)。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>logging.pattern.dateformat</code></td>
<td><code>LOG_DATEFORMAT_PATTERN</code></td>
<td>记录日期格式的附加模式。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>logging.pattern.file</code></td>
<td><code>FILE_LOG_PATTERN</code></td>
<td>文件中使用的日志模式(如果启用了<code>LOG_FILE</code>)。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>logging.pattern.level</code></td>
<td><code>LOG_LEVEL_PATTERN</code></td>
<td>渲染日志级别时使用的格式(默认为<code>%5p</code>)。 (仅默认登录设置支持.)</td>
</tr>
<tr>
<td><code>PID</code></td>
<td><code>PID</code></td>
<td>当前进程 ID(如果可能，并且尚未将其定义为 OS 环境变量时发现)。</td>
</tr>
</tbody>
</table>
</div>
<p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见<code>spring-boot.jar</code>中的默认配置：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml">Logback</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml">Log4j 2</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties">Java Util 日志记录</a></li>
</ul>
<p>Tip</p>
<p>如果要在日志记录属性中使用占位符，则应使用<a href="#属性中的占位符">Spring Boot 的语法</a>而不是基础框架的语法。值得注意的是，如果使用 Logback，则应使用<code>:</code>作为属性名称与其默认值之间的分隔符，而不应使用<code>:-</code>。</p>
<p>Tip</p>
<p>您可以通过仅覆盖<code>LOG_LEVEL_PATTERN</code>(或使用 Logback 覆盖<code>logging.pattern.level</code>)将 MDC 和其他临时内容添加到日志行。例如，如果使用<code>logging.pattern.level=user:%X&#123;user&#125; %5p</code>，则默认日志格式包含“ user”的 MDC 条目(如果存在)，如以下示例所示。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2015-09-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class="line">Handling authenticated request</span><br></pre></td></tr></table></figure>
<h2 id="Logback扩展"><a href="#Logback扩展" class="headerlink" title="Logback扩展"></a>Logback扩展</h2><p>Spring Boot 包含许多 Logback 扩展，可以帮助进行高级配置。您可以在<code>logback-spring.xml</code>配置文件中使用这些 extensions。</p>
<blockquote>
<p>Note</p>
<p>由于标准<code>logback.xml</code>配置文件加载时间过早，因此无法在其中使用 extensions。您需要使用<code>logback-spring.xml</code>或定义<code>logging.config</code>属性。</p>
<p>Warning</p>
<p>这些扩展不能与 Logback 的<a target="_blank" rel="noopener" href="http://logback.qos.ch/manual/configuration.html#autoScan">configuration scanning</a>一起使用。如果尝试这样做，则对配置文件进行更改将导致类似于以下记录之一的错误记录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR <span class="keyword">in</span> [emailprotected]:71 - no applicable action <span class="keyword">for</span> [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class="line">ERROR <span class="keyword">in</span> [emailprotected]:71 - no applicable action <span class="keyword">for</span> [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="特定于配置文件的配置"><a href="#特定于配置文件的配置" class="headerlink" title="特定于配置文件的配置"></a>特定于配置文件的配置</h3><p><code>&lt;springProfile&gt;</code>标签可让您根据有效的 Spring 配置文件有选择地包括或排除配置部分。 <code>&lt;configuration&gt;</code>元素中任何位置都支持概要文件部分。使用<code>name</code>属性指定哪个配置文件接受配置。 <code>&lt;springProfile&gt;</code>标记可以包含一个简单的配置文件名称(例如<code>staging</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production &amp; (eu-central | eu-west)</code>。查看<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java">reference guide</a>以获取更多详细信息。以下 Lists 显示了三个 samples 概要文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev | staging&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;dev&quot; or &quot;staging&quot; profiles are active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;!production&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the &quot;production&quot; profile is not active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="环境属性"><a href="#环境属性" class="headerlink" title="环境属性"></a>环境属性</h3><p><code>&lt;springProperty&gt;</code>标签可让您公开 Spring <code>Environment</code>中的属性，以供在 Logback 中使用。如果要从 Logback 配置中访问<code>application.properties</code>文件中的值，则这样做很有用。该标记的工作方式类似于 Logback 的标准<code>&lt;property&gt;</code>标记。但是，不是指定直接的<code>value</code>，而是指定属性的<code>source</code>(来自<code>Environment</code>)。如果需要将属性存储在<code>local</code>范围以外的其他位置，则可以使用<code>scope</code>属性。如果需要回退值(如果未在<code>Environment</code>中设置该属性)，则可以使用<code>defaultValue</code>属性。以下示例显示如何公开用于 Logback 的属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProperty</span> <span class="attr">scope</span>=<span class="string">&quot;context&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fluentHost&quot;</span> <span class="attr">source</span>=<span class="string">&quot;myapp.fluentd.host&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">defaultValue</span>=<span class="string">&quot;localhost&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FLUENT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.more.appenders.DataFluentAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">remoteHost</span>&gt;</span>$&#123;fluentHost&#125;<span class="tag">&lt;/<span class="name">remoteHost</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p><code>source</code>必须在烤肉串情况下指定(例如<code>my.property-name</code>)。但是，可以使用宽松规则将属性添加到<code>Environment</code>。</p>
</blockquote>
<h1 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h1><p>Spring Boot支持本地化消息，这样您的应用程序就可以满足不同语言偏好的用户。默认情况下，Spring Boot在类路径的根查找是否存在消息资源束。</p>
<blockquote>
<p>Note</p>
<p>当配置的资源包的默认属性文件可用时(默认<code>message.properties</code>)，自动配置就会应用。如果资源包只包含特定于语言的属性文件，则需要添加缺省值。如果没有找到匹配任何配置的基本名称的属性文件，那么就不会有自动配置的<code>MessageSource</code>。</p>
</blockquote>
<p>资源包的基本名称以及其他几个属性可以使用spring配置。消息名称空间，如下面的示例所示:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.messages.basename</span>=<span class="string">messages,config.i18n.messages</span></span><br><span class="line"><span class="meta">spring.messages.fallback-to-system-locale</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p><code>spring.messages.basename</code>支持以逗号分隔的位置列表，可以是包限定符，也可以是从类路径根解析出来的资源。</p>
<p>关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.3.3.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/context/MessageSourceProperties.java">MessageSourceProperties</a>。</p>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>Spring Boot 提供了与三个 JSON Map 库的集成：</p>
<ul>
<li>Gson</li>
<li>Jackson</li>
<li>JSON-B</li>
</ul>
<p>Jackson 是首选的默认库。</p>
<h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><p>提供了 Jackson 的自动配置功能，并且 Jackson 是<code>spring-boot-starter-json</code>的一部分。当 Jackson 放在 Classpath 上时，会自动配置<code>ObjectMapper</code> bean。为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#自定义JacksonObjectMapper">定制 ObjectMapper 的配置</a>提供了几个配置属性。</p>
<h2 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h2><p>提供了 Gson 的自动配置。当 Gson 在 Classpath 上时，会自动配置<code>Gson</code> bean。提供了几个<code>spring.gson.*</code>配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个<code>GsonBuilderCustomizer</code> bean。</p>
<h2 id="JSON-B"><a href="#JSON-B" class="headerlink" title="JSON-B"></a>JSON-B</h2><p>提供了 JSON-B 的自动配置。当 JSON-B API 和实现位于 Classpath 上时，将自动配置<code>Jsonb</code> bean。首选的 JSON-B 实现是提供依赖 Management 的 Apache Johnzon。</p>
<h1 id="开发Web应用程序"><a href="#开发Web应用程序" class="headerlink" title="开发Web应用程序"></a>开发Web应用程序</h1><p>Spring Boot 非常适合 Web 应用程序开发。您可以使用嵌入式 Tomcat，Jetty，Undertow 或 Netty 创建独立的 HTTP 服务器。大多数 Web 应用程序都使用<code>spring-boot-starter-web</code>模块来快速启动和运行。您还可以选择使用<code>spring-boot-starter-webflux</code>模块来构建响应式 Web 应用程序。</p>
<p>如果尚未开发 Spring Boot Web 应用程序，则可以遵循“ Hello World！”。 <em> <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用Starter/#开发您的第一个SpringBoot应用程序">Getting started</a></em>部分中的示例。</p>
<h2 id="SpringWebMVC框架"><a href="#SpringWebMVC框架" class="headerlink" title="SpringWebMVC框架"></a>SpringWebMVC框架</h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc">Spring Web MVC 框架</a>(通常简称为“ Spring MVC”)是一个丰富的“模型视图控制器” Web 框架。 Spring MVC 使您可以创建特殊的<code>@Controller</code>或<code>@RestController</code> bean 来处理传入的 HTTP 请求。控制器中的方法通过使用<code>@RequestMapping</code>注解Map 到 HTTP。</p>
<p>以下代码显示了提供 JSON 数据的典型<code>@RestController</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;/customers&quot;, method=RequestMethod.GET)</span></span><br><span class="line">    <span class="function">List&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value=&quot;/&#123;user&#125;&quot;, method=RequestMethod.DELETE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring MVC 是核心 Spring Framework 的一部分，有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc">reference documentation</a>。 <a target="_blank" rel="noopener" href="https://spring.io/guides">spring.io/guides</a>提供了一些涵盖 Spring MVC 的指南。</p>
<h3 id="SpringMVC自动配置"><a href="#SpringMVC自动配置" class="headerlink" title="SpringMVC自动配置"></a>SpringMVC自动配置</h3><p>Spring Boot 为 Spring MVC 提供了自动配置，可与大多数应用程序完美配合。</p>
<p>自动配置在 Spring 的默认值之上添加了以下功能：</p>
<ul>
<li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>bean。</li>
<li>支持提供静态资源，包括对 WebJars 的支持(覆盖<a href="#静态内容">本文档后面</a>。</li>
<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> bean。</li>
<li>支持<code>HttpMessageConverters</code>(包含<a href="#HttpMessageConverters">本文档后面</a>。</li>
<li>自动注册<code>MessageCodesResolver</code>(已发现<a href="#MessageCodesResolver">本文档后面</a>。</li>
<li>静态<code>index.html</code>支持。</li>
<li>自定义<code>Favicon</code>支持(包含<a href="#自定义图标">本文档后面</a>。</li>
<li>自动使用<code>ConfigurableWebBindingInitializer</code> bean(包含<a href="#ConfigurableWebBindingInitializer">本文档后面</a>。</li>
</ul>
<p>如果您想保留 Spring Boot MVC 功能，并且想要添加其他<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc">MVC configuration</a>(拦截器，格式化程序，视图控制器和其他功能)，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebMvcConfigurer</code>，但是没有 <code>@EnableWebMvc</code>。如果希望提供<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例，则可以声明<code>WebMvcRegistrationsAdapter</code>实例以提供此类组件。</p>
<p>如果要完全控制 Spring MVC，则可以添加自己的<code>@Configuration</code>并以<code>@EnableWebMvc</code>Comments。</p>
<h3 id="HttpMessageConverters"><a href="#HttpMessageConverters" class="headerlink" title="HttpMessageConverters"></a>HttpMessageConverters</h3><p>Spring MVC 使用<code>HttpMessageConverter</code>接口转换 HTTP 请求和响应。开箱即用中包含明智的默认设置。例如，可以将对象自动转换为 JSON(通过使用 Jackson 库)或 XML(通过使用 Jackson XML 扩展(如果可用)或通过使用 JAXB(如果 Jackson XML 扩展不可用))。默认情况下，字符串以<code>UTF-8</code>编码。</p>
<p>如果需要添加或定制转换器，则可以使用 Spring Boot 的<code>HttpMessageConverters</code>类，如以下 Lists 所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpMessageConverters <span class="title">customConverters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpMessageConverter&lt;?&gt; additional = ...</span><br><span class="line">        HttpMessageConverter&lt;?&gt; another = ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpMessageConverters(additional, another);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上下文中存在的任何<code>HttpMessageConverter</code> bean 都将添加到转换器列表中。您也可以用相同的方法覆盖默认转换器。</p>
<h3 id="自定义JSON序列化器和反序列化器"><a href="#自定义JSON序列化器和反序列化器" class="headerlink" title="自定义JSON序列化器和反序列化器"></a>自定义JSON序列化器和反序列化器</h3><p>如果使用 Jackson 来序列化和反序列化 JSON 数据，则可能要编写自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化器通常是<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers">通过模块在 Jackson 注册</a>，但是 Spring Boot 提供了<code>@JsonComponent</code>Comments，这使得直接注册 Spring Bean 更加容易。</p>
<p>您可以直接在<code>JsonSerializer</code>或<code>JsonDeserializer</code>实现中使用<code>@JsonComponent</code>Comments。您还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.*;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.jackson.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonComponent</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">SomeObject</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ApplicationContext</code>中的所有<code>@JsonComponent</code> bean 都会自动向 Jackson 进行注册。因为<code>@JsonComponent</code>是用<code>@Component</code>进行元 Comments 的，所以通常的组件扫描规则适用。</p>
<p>Spring Boot 还提供了<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java">JsonObjectSerializer</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java">JsonObjectDeserializer</a>Base Class，这些 Base Class 在序列化对象时为标准 Jackson 版本提供了有用的替代方法。有关详细信息，请参见 Javadoc 中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html">JsonObjectSerializer</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html">JsonObjectDeserializer</a>。</p>
<h3 id="MessageCodesResolver"><a href="#MessageCodesResolver" class="headerlink" title="MessageCodesResolver"></a>MessageCodesResolver</h3><p>Spring MVC 有一种生成错误代码的策略，该错误代码用于从绑定错误<code>MessageCodesResolver</code>渲染错误消息。如果设置<code>spring.mvc.message-codes-resolver.format</code>属性<code>PREFIX_ERROR_CODE</code>或<code>POSTFIX_ERROR_CODE</code>，Spring Boot 会为您创建一个(请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html">DefaultMessageCodesResolver.Format</a>中的枚举)。</p>
<h3 id="静态内容"><a href="#静态内容" class="headerlink" title="静态内容"></a>静态内容</h3><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录或<code>ServletContext</code>的根目录中提供静态内容。它使用 Spring MVC 中的<code>ResourceHttpRequestHandler</code>，因此您可以通过添加自己的<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。</p>
<p>在独立的 Web 应用程序中，还启用了容器中的默认 servlet，并将其用作后备，如果 Spring 决定不处理<code>ServletContext</code>的根，则从<code>ServletContext</code>的根开始提供内容。在大多数情况下，这不会发生(除非您修改默认的 MVC 配置)，因为 Spring 始终可以通过<code>DispatcherServlet</code>处理请求。</p>
<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以使用<code>spring.mvc.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
<p>您还可以使用<code>spring.resources.static-locations</code>属性来自定义静态资源位置(用目录位置列表替换默认值)。根 Servlet 上下文路径<code>&quot;/&quot;</code>也会自动添加为位置。</p>
<p>除了前面提到的“标准”静态资源位置以外，还对<a target="_blank" rel="noopener" href="https://www.webjars.org/">Webjars content</a>进行了特殊处理。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。</p>
<p>Tip</p>
<p>如果您的应用程序打包为 jar，则不要使用<code>src/main/webapp</code>目录。尽管此目录是一个通用标准，但它仅在 war 打包中有效，并且在生成 jar 时，大多数构建工具都将其忽略。</p>
<p>Spring Boot 还支持 Spring MVC 提供的高级资源处理功能，允许使用案例，例如缓存清除静态资源或对 Webjars 使用版本无关的 URL。</p>
<p>要对 Webjar 使用版本无关的 URL，请添加<code>webjars-locator-core</code>依赖项。然后声明您的 Webjar。以 jQuery 为例，在<code>&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;</code>中添加<code>&quot;/webjars/jquery/jquery.min.js&quot;</code>结果。其中<code>x.y.z</code>是 Webjar 版本。</p>
<p>Note</p>
<p>如果使用 JBoss，则需要声明<code>webjars-locator-jboss-vfs</code>依赖性而不是<code>webjars-locator-core</code>。否则，所有 Webjar 都解析为<code>404</code>。</p>
<p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，从而有效地在 URL 中添加了内容哈希，例如<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>得益于为 Thymeleaf 和 FreeMarker 自动配置的<code>ResourceUrlEncodingFilter</code>，在运行时将资源链接重写为模板。使用 JSP 时，您应该手动声明此过滤器。当前不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，并可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html">ResourceUrlProvider</a>。</p>
<p>例如，当使用 JavaScript 模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以组合的原因。 “固定”策略在 URL 中添加静态版本字符串，而不会更改文件名，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.resources.chain.strategy.content.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.paths</span>=<span class="string">/js/lib/</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.version</span>=<span class="string">v12</span></span><br></pre></td></tr></table></figure>
<p>通过这种配置，位于<code>&quot;/js/lib/&quot;</code>下的 JavaScript 模块使用固定的版本控制策略(<code>&quot;/v12/js/lib/mymodule.js&quot;</code>)，而其他资源仍使用内容版本(<code>&lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&gt;</code>)。</p>
<p>有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java">ResourceProperties</a>。</p>
<p>Tip</p>
<p>此功能已在专用的<a target="_blank" rel="noopener" href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">blog post</a>和 Spring Framework 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">reference documentation</a>中进行了详细描述。</p>
<h3 id="欢迎页面"><a href="#欢迎页面" class="headerlink" title="欢迎页面"></a>欢迎页面</h3><p>Spring Boot 支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找<code>index.html</code>文件。如果未找到，则它将寻找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。</p>
<h3 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h3><p>Spring Boot 在配置的静态内容位置和 Classpath 的根目录(按此 Sequences)中查找<code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。</p>
<h3 id="路径匹配和内容协商"><a href="#路径匹配和内容协商" class="headerlink" title="路径匹配和内容协商"></a>路径匹配和内容协商</h3><p>Spring MVC 可以通过查看请求路径并将其匹配到应用程序中定义的 Map(例如 Controller 方法上的<code>@GetMapping</code>Comments)，将传入的 HTTP 请求 Map 到处理程序。</p>
<p>Spring Boot 默认选择禁用后缀模式匹配，这意味着诸如<code>&quot;GET /projects/spring-boot.json&quot;</code>之类的请求将不会与<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>Map 相匹配。这被视为<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match">Spring MVC 应用程序的最佳实践</a>。过去，此功能主要用于未发送正确的“ Accept”请求 Headers 的 HTTP Client 端。我们需要确保将正确的 Content Type 发送给 Client 端。如今，内容协商已变得更加可靠。</p>
<p>还有其他处理 HTTP Client 端的方法，这些方法不能始终发送正确的“ Accept”请求 Headers。除了使用后缀匹配，我们还可以使用查询参数来确保将<code>&quot;GET /projects/spring-boot?format=json&quot;</code>之类的请求 Map 到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can change the parameter name, which is &quot;format&quot; by default:</span></span><br><span class="line"><span class="comment"># spring.mvc.contentnegotiation.parameter-name=myparam</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can also register additional file extensions/media types with:</span></span><br><span class="line"><span class="meta">spring.mvc.contentnegotiation.media-types.markdown</span>=<span class="string">text/markdown</span></span><br></pre></td></tr></table></figure>
<p>如果您了解了注意事项，但仍希望您的应用程序使用后缀模式匹配，则需要以下配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class="line">spring.mvc.pathmatch.use-suffix-pattern=true</span><br></pre></td></tr></table></figure>
<p>另外，与其打开所有后缀模式，不如只支持注册的后缀模式，这是更安全的：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mvc.contentnegotiation.favor-path-extension</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.mvc.pathmatch.use-registered-suffix-pattern</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You can also register additional file extensions/media types with:</span></span><br><span class="line"><span class="comment"># spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</span></span><br></pre></td></tr></table></figure>
<h3 id="ConfigurableWebBindingInitializer"><a href="#ConfigurableWebBindingInitializer" class="headerlink" title="ConfigurableWebBindingInitializer"></a>ConfigurableWebBindingInitializer</h3><p>Spring MVC 使用<code>WebBindingInitializer</code>来为特定请求初始化<code>WebDataBinder</code>。如果创建自己的<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot 会自动将 Spring MVC 配置为使用它。</p>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>除了 REST Web 服务之外，您还可以使用 Spring MVC 来提供动态 HTML 内容。 Spring MVC 支持各种模板技术，包括 Thymeleaf，FreeMarker 和 JSP。同样，许多其他模板引擎包括他们自己的 Spring MVC 集成。</p>
<p>Spring Boot 包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://freemarker.apache.org/docs/">FreeMarker</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></li>
<li><a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a target="_blank" rel="noopener" href="https://mustache.github.io/">Mustache</a></li>
</ul>
<p>Tip</p>
<p>如果可能，应避免使用 JSP。与嵌入式 servlet 容器一起使用时，有多个<a href="#JSP限制">known limitations</a>。</p>
<p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。</p>
<p>Tip</p>
<p>根据您运行应用程序的方式，IntelliJ IDEA 对 Classpath 的排序方式不同。与使用 Maven 或 Gradle 或从打包的 jar 运行应用程序时，从 IDE 的 Main 方法运行应用程序的 Sequences 会有所不同。这可能会导致 Spring Boot 无法在 Classpath 上找到模板。如果遇到此问题，则可以在 IDE 中重新排序 Classpath，以首先放置模块的类和资源。另外，您可以配置模板前缀以搜索 Classpath 上的每个<code>templates</code>目录，如下所示：<code>classpath*:/templates/</code>。</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>默认情况下，Spring Boot 提供了一个<code>/error</code>Map，可以明智地处理所有错误，并且已在 servlet 容器中注册为“全局”错误页面。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，存在一个“ whitelabel”错误视图，该视图以 HTML 格式渲染相同的数据(要对其进行自定义，请添加解析为<code>error</code>的<code>View</code>)。要完全替换默认行为，可以实现<code>ErrorController</code>并注册该类型的 Bean 定义，或添加<code>ErrorAttributes</code>类型的 Bean 以使用现有机制但替换其内容。</p>
<p>Tip</p>
<p><code>BasicErrorController</code>可用作自定义<code>ErrorController</code>的 Base Class。如果要为新的 Content Type 添加处理程序(默认是专门处理<code>text/html</code>并为其他所有内容提供后备功能)，则此功能特别有用。为此，扩展<code>BasicErrorController</code>，添加具有<code>produces</code>属性的<code>@RequestMapping</code>的公共方法，并创建新类型的 bean。</p>
<p>您还可以定义带有<code>@ControllerAdvice</code>Comments 的类，以自定义 JSON 文档以针对特定的控制器和/或异常类型返回，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackageClasses = AcmeController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcmeControllerAdvice</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(YourException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) &#123;</span><br><span class="line">        HttpStatus status = getStatus(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="keyword">new</span> CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> HttpStatus <span class="title">getStatus</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Integer statusCode = (Integer) request.getAttribute(<span class="string">&quot;javax.servlet.error.status_code&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (statusCode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> HttpStatus.valueOf(statusCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果在与<code>AcmeController</code>相同的程序包中定义的控制器抛出<code>YourException</code>，则使用<code>CustomErrorType</code> POJO 的 JSON 表示代替<code>ErrorAttributes</code>表示。</p>
<h4 id="自定义错误页面"><a href="#自定义错误页面" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板来构建。文件名应为确切的状态代码或系列掩码。</p>
<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src&#x2F;</span><br><span class="line"> +- main&#x2F;</span><br><span class="line">     +- java&#x2F;</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources&#x2F;</span><br><span class="line">         +- public&#x2F;</span><br><span class="line">             +- error&#x2F;</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要使用 FreeMarker 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.ftl</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<p>对于更复杂的 Map，还可以添加实现<code>ErrorViewResolver</code>接口的 bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorViewResolver</span> <span class="keyword">implements</span> <span class="title">ErrorViewResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveErrorView</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">            HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Use the request or status to optionally return a ModelAndView</span></span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用常规的 Spring MVC 功能，例如<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers">@ExceptionHandler methods</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice">@ControllerAdvice</a>。 <code>ErrorController</code>然后接收任何未处理的异常。</p>
<h4 id="MapSpringMVC之外的错误页面"><a href="#MapSpringMVC之外的错误页面" class="headerlink" title="MapSpringMVC之外的错误页面"></a>MapSpringMVC之外的错误页面</h4><p>对于不使用 Spring MVC 的应用程序，可以使用<code>ErrorPageRegistrar</code>接口直接注册<code>ErrorPages</code>。此抽象直接与基础嵌入式 servlet 容器一起使用，即使您没有 Spring MVC <code>DispatcherServlet</code>，也可以使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ErrorPageRegistrar <span class="title">errorPageRegistrar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyErrorPageRegistrar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyErrorPageRegistrar</span> <span class="keyword">implements</span> <span class="title">ErrorPageRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerErrorPages</span><span class="params">(ErrorPageRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.BAD_REQUEST, <span class="string">&quot;/400&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>如果您注册的<code>ErrorPage</code>的路径最终由<code>Filter</code>处理(这在某些非 Spring Web 框架(如 Jersey 和 Wicket)中很常见)，则必须将<code>Filter</code>明确注册为<code>ERROR</code>调度程序，如图所示。下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">myFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FilterRegistrationBean registration = <span class="keyword">new</span> FilterRegistrationBean();</span><br><span class="line">    registration.setFilter(<span class="keyword">new</span> MyFilter());</span><br><span class="line">    ...</span><br><span class="line">    registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class="line">    <span class="keyword">return</span> registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，默认的<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。</p>
<p>注意：Spring Boot 部署到 servlet 容器时，将使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0 和更高版本在成功完成 servlet 的服务方法后提交响应。您应该通过将<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>设置为<code>false</code>来禁用此行为。</p>
<h3 id="SpringHATEOAS"><a href="#SpringHATEOAS" class="headerlink" title="SpringHATEOAS"></a>SpringHATEOAS</h3><p>如果您开发使用超媒体的 RESTful API，Spring Boot 将为 Spring HATEOAS 提供自动配置，该配置可与大多数应用程序很好地配合使用。自动配置取代了使用<code>@EnableHypermediaSupport</code>的需要，并注册了许多 Bean 以简化基于超媒体的应用程序的构建，包括<code>LinkDiscoverers</code>(用于 Client 端支持)和<code>ObjectMapper</code>，这些<code>ObjectMapper</code>被配置为将响应正确地编组为所需的表示形式。 <code>ObjectMapper</code>是通过设置各种<code>spring.jackson.*</code>属性来定制的，或者通过设置<code>Jackson2ObjectMapperBuilder</code> bean 来定制(如果存在)。</p>
<p>您可以使用<code>@EnableHypermediaSupport</code>来控制 Spring HATEOAS 的配置。请注意，这样做会禁用前面介绍的<code>ObjectMapper</code>自定义。</p>
<h3 id="CORS支持"><a href="#CORS支持" class="headerlink" title="CORS支持"></a>CORS支持</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">跨域资源共享</a>(CORS)是由<a target="_blank" rel="noopener" href="https://caniuse.com/#feat=cors">most browsers</a>实现的<a target="_blank" rel="noopener" href="https://www.w3.org/TR/cors/">W3C specification</a>，可让您灵活地指定授权哪种类型的跨域请求，而不是使用一些安全性和功能不强的方法(例如 IFRAME 或 JSONP)。</p>
<p>从 4.2 版本开始，Spring MVC <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#cors">supports CORS</a>。在 Spring Boot 应用程序中使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration">控制器方法 CORS 配置</a>和<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html">@CrossOrigin</a>注解不需要任何特定的配置。可以通过使用自定义的<code>addCorsMappings(CorsRegistry)</code>方法注册<code>WebMvcConfigurer</code> bean 来定义<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#global-cors-configuration">全局 CORS 配置</a>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebMvcConfigurer <span class="title">corsConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebMvcConfigurer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">                registry.addMapping(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringWebFlux框架"><a href="#SpringWebFlux框架" class="headerlink" title="SpringWebFlux框架"></a>SpringWebFlux框架</h2><p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步和非阻塞的，并通过<a target="_blank" rel="noopener" href="https://projectreactor.io/">反应堆项目</a>实现<a target="_blank" rel="noopener" href="http://www.reactive-streams.org/">Reactive Streams</a>规范。</p>
<p>Spring WebFlux 有两种形式：功能性的和基于 Comments 的。基于 Comments 的模型非常类似于 Spring MVC 模型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;user&#125;/customers&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flux&lt;Customer&gt; <span class="title">getUserCustomers</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;user&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;User&gt; <span class="title">deleteUser</span><span class="params">(<span class="meta">@PathVariable</span> Long user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能变体“ WebFlux.fn”将路由配置与请求的实际处理分开，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">monoRouterFunction</span><span class="params">(UserHandler userHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> route(GET(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class="line">                .andRoute(GET(<span class="string">&quot;/&#123;user&#125;/customers&quot;</span>).and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class="line">                .andRoute(DELETE(<span class="string">&quot;/&#123;user&#125;&quot;</span>).and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">getUserCustomers</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">deleteUser</span><span class="params">(ServerRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WebFlux 是 Spring Framework 的一部分，其<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn">reference documentation</a>中提供了详细信息。</p>
<p>Tip</p>
<p>您可以根据需要定义尽可能多的<code>RouterFunction</code> bean，以对 Router 的定义进行模块化。如果需要应用优先级，可以 Order Bean。</p>
<p>首先，将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。</p>
<p>Note</p>
<p>在应用程序中同时添加<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致 Spring Boot 自动配置 Spring MVC，而不是 WebFlux。之所以选择这种行为，是因为许多 Spring 开发人员将<code>spring-boot-starter-webflux</code>添加到他们的 Spring MVC 应用程序中以使用 Reactive<code>WebClient</code>。您仍然可以通过将选定的应用程序类型设置为<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>来强制执行选择。</p>
<h3 id="SpringWebFlux自动配置"><a href="#SpringWebFlux自动配置" class="headerlink" title="SpringWebFlux自动配置"></a>SpringWebFlux自动配置</h3><p>Spring Boot 为 Spring WebFlux 提供了自动配置，可与大多数应用程序完美配合。</p>
<p>自动配置在 Spring 的默认值之上添加了以下功能：</p>
<ul>
<li>为<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例(说明<a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器">本文档后面</a>配置编解码器。</li>
<li>支持服务静态资源，包括对 WebJars 的支持(描述为<a href="#静态内容">本文档后面</a>。</li>
</ul>
<p>如果您想保留 Spring Boot WebFlux 功能，并且想要添加其他<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#web-reactive">WebFlux configuration</a>，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebFluxConfigurer</code>，但 <strong>没有</strong> <code>@EnableWebFlux</code>。</p>
<p>如果要完全控制 Spring WebFlux，则可以添加带有<code>@EnableWebFlux</code>Comments 的自己的<code>@Configuration</code>。</p>
<h3 id="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"><a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器" class="headerlink" title="带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器"></a>带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</h3><p>Spring WebFlux 使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换 HTTP 请求和响应。通过查看 Classpath 中可用的库，将它们配置为<code>CodecConfigurer</code>以具有合理的默认值。</p>
<p>Spring Boot 通过使用<code>CodecCustomizer</code>实例应用进一步的自定义。例如，将<code>spring.jackson.*</code>个配置密钥应用于 Jackson 编解码器。</p>
<p>如果需要添加或自定义编解码器，则可以创建自定义<code>CodecCustomizer</code>组件，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CodecCustomizer <span class="title">myCodecCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> codecConfigurer -&gt; &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您还可以使用<a href="#自定义JSON序列化器和反序列化器">Boot 的自定义 JSON 序列化器和反序列化器</a>。</p>
<h3 id="静态内容-1"><a href="#静态内容-1" class="headerlink" title="静态内容"></a>静态内容</h3><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录中提供静态内容。它使用 Spring WebFlux 中的<code>ResourceWebHandler</code>，以便您可以通过添加自己的<code>WebFluxConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。</p>
<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以通过设置<code>spring.webflux.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.webflux.static-path-pattern</span>=<span class="string">/resources/**</span></span><br></pre></td></tr></table></figure>
<p>您还可以使用<code>spring.resources.static-locations</code>自定义静态资源位置。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果启动时您的任何位置都存在<code>index.html</code>，则它是应用程序的主页。</p>
<p>除了前面列出的“标准”静态资源位置之外，<a target="_blank" rel="noopener" href="https://www.webjars.org/">Webjars content</a>也是一种特殊情况。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。</p>
<p>Tip</p>
<p>Spring WebFlux 应用程序不严格依赖 Servlet API，因此不能将它们部署为 war 文件，也不使用<code>src/main/webapp</code>目录。</p>
<h3 id="模板引擎-1"><a href="#模板引擎-1" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>除了 REST Web 服务之外，您还可以使用 Spring WebFlux 来提供动态 HTML 内容。 Spring WebFlux 支持多种模板技术，包括 Thymeleaf，FreeMarker 和 Mustache。</p>
<p>Spring Boot 包括对以下模板引擎的自动配置支持：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://freemarker.apache.org/docs/">FreeMarker</a></li>
<li><a target="_blank" rel="noopener" href="http://www.thymeleaf.org/">Thymeleaf</a></li>
<li><a target="_blank" rel="noopener" href="https://mustache.github.io/">Mustache</a></li>
</ul>
<p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。</p>
<h3 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h3><p>Spring Boot 提供了一个<code>WebExceptionHandler</code>，可以明智地处理所有错误。它在处理 Sequences 中的位置紧靠 WebFlux 提供的处理程序之前，该处理程序被认为是最后一个。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，有一个“ whitelabel”错误处理程序，以 HTML 格式渲染相同的数据。您还可以提供自己的 HTML 模板来显示错误(请参见<a href="#自定义错误页面">next section</a>。</p>
<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，您可以添加<code>ErrorAttributes</code>类型的 bean。</p>
<p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的 bean 定义。由于<code>WebExceptionHandler</code>的级别很低，因此 Spring Boot 还提供了一个方便的<code>AbstractErrorWebExceptionHandler</code>，让您以 WebFlux 功能方式处理错误，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomErrorWebExceptionHandler</span> <span class="keyword">extends</span> <span class="title">AbstractErrorWebExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define constructor here</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RouterFunction&lt;ServerResponse&gt; <span class="title">getRoutingFunction</span><span class="params">(ErrorAttributes errorAttributes)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RouterFunctions</span><br><span class="line">                .route(aPredicate, aHandler)</span><br><span class="line">                .andRoute(anotherPredicate, anotherHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获得更完整的图片，您还可以直接继承<code>DefaultErrorWebExceptionHandler</code>并重写特定方法。</p>
<h4 id="自定义错误页面-1"><a href="#自定义错误页面-1" class="headerlink" title="自定义错误页面"></a>自定义错误页面</h4><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板构建。文件名应为确切的状态代码或系列掩码。</p>
<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- public/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 404.html</span><br><span class="line">             +- &lt;other public assets&gt;</span><br></pre></td></tr></table></figure>
<p>要使用 Mustache 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src/</span><br><span class="line"> +- main/</span><br><span class="line">     +- java/</span><br><span class="line">     |   + &lt;source code&gt;</span><br><span class="line">     +- resources/</span><br><span class="line">         +- templates/</span><br><span class="line">             +- error/</span><br><span class="line">             |   +- 5xx.mustache</span><br><span class="line">             +- &lt;other templates&gt;</span><br></pre></td></tr></table></figure>
<h3 id="网页过滤器"><a href="#网页过滤器" class="headerlink" title="网页过滤器"></a>网页过滤器</h3><p>Spring WebFlux 提供了一个<code>WebFilter</code>接口，可以实现该接口来过滤 HTTP 请求-响应交换。在应用程序上下文中找到的<code>WebFilter</code> bean 将自动用于过滤每次交换。</p>
<p>在过滤器 Sequences 很重要的地方，它们可以实现<code>Ordered</code>或用<code>@Order</code>Comments。 Spring Boot 自动配置可能会为您配置 Web 过滤器。这样做时，将使用下表中显示的 Sequences：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Web Filter</th>
<th>Order</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>MetricsWebFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td><code>WebFilterChainProxy</code>(Spring Security 性)</td>
<td><code>-100</code></td>
</tr>
<tr>
<td><code>HttpTraceWebFilter</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="JAX-RS和Jersey"><a href="#JAX-RS和Jersey" class="headerlink" title="JAX-RS和Jersey"></a>JAX-RS和Jersey</h2><p>如果您更喜欢 REST 端点的 JAX-RS 编程模型，则可以使用可用的实现之一来代替 Spring MVC。 <a target="_blank" rel="noopener" href="https://jersey.github.io/">Jersey</a>和<a target="_blank" rel="noopener" href="https://cxf.apache.org/">Apache CXF</a>开箱即用。 CXF 要求您在应用程序上下文中将其<code>Servlet</code>或<code>Filter</code>注册为<code>@Bean</code>。Jersey(Jersey)有一些本机 Spring 支持，因此我们在 Spring Boot 中还与启动程序一起为其提供了自动配置支持。</p>
<p>要开始使用 Jersey，请将<code>spring-boot-starter-jersey</code>作为依赖项，然后需要一个<code>ResourceConfig</code>类型的<code>@Bean</code>，在其中注册所有端点，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JerseyConfig</span> <span class="keyword">extends</span> <span class="title">ResourceConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JerseyConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register(Endpoint.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Warning</p>
<p>Jersey 对扫描可执行归档文件的支持非常有限。例如，在运行可执行的 war 文件时，它无法扫描在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-部署SpringBoot应用程序/#安装SpringBoot应用程序">完全可执行的 jar 文件</a>或<code>WEB-INF/classes</code>中找到的程序包中的端点。为避免此限制，不应使用<code>packages</code>方法，并且应使用<code>register</code>方法分别注册端点，如前面的示例所示。</p>
<p>对于更高级的定制，您还可以注册实现<code>ResourceConfigCustomizer</code>的任意数量的 bean。</p>
<p>所有注册的端点都应为<code>@Components</code>，并带有 HTTP 资源 Comments(<code>@GET</code>和其他 Comments)，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Path(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Endpoint</code>是 Spring <code>@Component</code>，其生命周期由 Spring Management，因此您可以使用<code>@Autowired</code>注解注入依赖项，并使用<code>@Value</code>注解注入外部配置。默认情况下，Jersey servlet 已注册并 Map 到<code>/*</code>。您可以通过将<code>@ApplicationPath</code>添加到<code>ResourceConfig</code>来更改 Map。</p>
<p>默认情况下，Jersey 在名为<code>jerseyServletRegistration</code>的<code>ServletRegistrationBean</code>类型的<code>@Bean</code>中设置为 Servlet。默认情况下，该 Servlet 延迟初始化，但是您可以通过设置<code>spring.jersey.servlet.load-on-startup</code>来自定义该行为。您可以通过使用相同的名称创建自己的一个来禁用或覆盖该 bean。您还可以通过设置<code>spring.jersey.type=filter</code>(在这种情况下，要替换或覆盖的<code>@Bean</code>是<code>jerseyFilterRegistration</code>)来使用过滤器而不是 Servlet。过滤器具有<code>@Order</code>，您可以使用<code>spring.jersey.filter.order</code>进行设置。可以使用<code>spring.jersey.init.*</code>指定属性 Map，从而为 servlet 和过滤器注册都赋予 init 参数。</p>
<p>有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-jersey">Jersey sample</a>，以便您可以了解如何进行设置。</p>
<h2 id="嵌入式Servlet容器支持"><a href="#嵌入式Servlet容器支持" class="headerlink" title="嵌入式Servlet容器支持"></a>嵌入式Servlet容器支持</h2><p>Spring Boot 包含对嵌入式<a target="_blank" rel="noopener" href="https://tomcat.apache.org/">Tomcat</a>，<a target="_blank" rel="noopener" href="https://www.eclipse.org/jetty/">Jetty</a>和<a target="_blank" rel="noopener" href="http://undertow.io/">Undertow</a>服务器的支持。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口<code>8080</code>上侦听 HTTP 请求。</p>
<p>Warning</p>
<p>如果选择在<a target="_blank" rel="noopener" href="https://www.centos.org/">CentOS</a>上使用 Tomcat，请注意，默认情况下，将使用一个临时目录来存储编译的 JSP，文件上载等等。您的应用程序运行时，此目录可能被<code>tmpwatch</code>删除，从而导致失败。为避免这种情况，您可能需要自定义<code>tmpwatch</code>配置，以使<code>tomcat.*</code>目录不会被删除，或配置<code>server.tomcat.basedir</code>，以使嵌入式 Tomcat 使用其他位置。</p>
<h3 id="Servlet-过滤器和侦听器"><a href="#Servlet-过滤器和侦听器" class="headerlink" title="Servlet,过滤器和侦听器"></a>Servlet,过滤器和侦听器</h3><p>使用嵌入式 Servlet 容器时，可以通过使用 Spring bean 或扫描 Servlet 组件来注册 Servlet 规范中的 Servlet，过滤器和所有侦听器(例如<code>HttpSessionListener</code>)。</p>
<h4 id="将Servlet-过滤器和侦听器注册为SpringBean"><a href="#将Servlet-过滤器和侦听器注册为SpringBean" class="headerlink" title="将Servlet,过滤器和侦听器注册为SpringBean"></a>将Servlet,过滤器和侦听器注册为SpringBean</h4><p>任何作为 Spring bean 的<code>Servlet</code>，<code>Filter</code>或 servlet <code>*Listener</code>实例都向嵌入式容器注册。如果要在配置过程中引用<code>application.properties</code>中的值，这可能特别方便。</p>
<p>默认情况下，如果上下文仅包含单个 Servlet，则将其 Map 到<code>/</code>。对于多个 servlet bean，bean 名称用作路径前缀。过滤器 Map 到<code>/*</code>。</p>
<p>如果基于约定的 Map 不够灵活，则可以使用<code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类进行完全控制。</p>
<p>Spring Boot 附带了许多可能定义 Filter bean 的自动配置。以下是过滤器及其各自 Sequences 的一些示例(较低的 Sequences 值表示较高的优先级)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Servlet Filter</th>
<th>Order</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>OrderedCharacterEncodingFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE</code></td>
</tr>
<tr>
<td><code>WebMvcMetricsFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td><code>ErrorPageFilter</code></td>
<td><code>Ordered.HIGHEST_PRECEDENCE + 1</code></td>
</tr>
<tr>
<td><code>HttpTraceFilter</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE - 10</code></td>
</tr>
</tbody>
</table>
</div>
<p>通常可以使无序滤 bean 处于无序状态。</p>
<p>如果需要特定的 Sequences，则应避免配置一个在<code>Ordered.HIGHEST_PRECEDENCE</code>读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。如果 Servlet 过滤器包装了请求，则应以小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>的 Sequences 对其进行配置。</p>
<h3 id="Servlet上下文初始化"><a href="#Servlet上下文初始化" class="headerlink" title="Servlet上下文初始化"></a>Servlet上下文初始化</h3><p>嵌入式 Servlet 容器不会直接执行 Servlet 3.0 <code>javax.servlet.ServletContainerInitializer</code>接口或 Spring 的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意设计的决定，目的是减少旨在在 War 中运行的第三方库可能破坏 Spring Boot 应用程序的风险。</p>
<p>如果需要在 Spring Boot 应用程序中执行 servlet 上下文初始化，则应该注册一个实现<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的 bean。单个<code>onStartup</code>方法提供对<code>ServletContext</code>的访问，并且在必要时可以轻松地用作现有<code>WebApplicationInitializer</code>的适配器。</p>
<h4 id="扫描Servlet-过滤器和侦听器"><a href="#扫描Servlet-过滤器和侦听器" class="headerlink" title="扫描Servlet,过滤器和侦听器"></a>扫描Servlet,过滤器和侦听器</h4><p>使用嵌入式容器时，可以通过使用<code>@ServletComponentScan</code>来启用自动注册带有<code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>Comments 的类。</p>
<p>Tip</p>
<p><code>@ServletComponentScan</code>在独立容器中无效，而是使用该容器的内置发现机制。</p>
<h3 id="ServletWebServerApplicationContext"><a href="#ServletWebServerApplicationContext" class="headerlink" title="ServletWebServerApplicationContext"></a>ServletWebServerApplicationContext</h3><p>在后台，Spring Boot 使用另一种类型的<code>ApplicationContext</code>来支持嵌入式 servlet 容器。 <code>ServletWebServerApplicationContext</code>是<code>WebApplicationContext</code>的一种特殊类型，它通过搜索单个<code>ServletWebServerFactory</code> bean 来进行自我引导。通常<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code>已被自动配置。</p>
<p>Note</p>
<p>通常，您不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表您创建了相应的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>。</p>
<h3 id="自定义嵌入式Servlet容器"><a href="#自定义嵌入式Servlet容器" class="headerlink" title="自定义嵌入式Servlet容器"></a>自定义嵌入式Servlet容器</h3><p>可以使用 Spring <code>Environment</code>属性来配置常见的 servlet 容器设置。通常，您将在<code>application.properties</code>文件中定义属性。</p>
<p>常用服务器设置包括：</p>
<ul>
<li>网络设置：侦听传入 HTTP 请求的端口(<code>server.port</code>)，绑定到<code>server.address</code>的接口地址，等等。</li>
<li>会话设置：会话是否持久(<code>server.servlet.session.persistence</code>)，会话超时(<code>server.servlet.session.timeout</code>)，会话数据的位置(<code>server.servlet.session.store-dir</code>)和会话 cookie 配置(<code>server.servlet.session.cookie.*</code>)。</li>
<li>错误 Management：错误页面的位置(<code>server.error.path</code>)，依此类推。</li>
<li><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#配置SSL">SSL</a></li>
<li><a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#启用HTTP响应压缩">HTTP compression</a></li>
</ul>
<p>Spring Boot 尝试尽可能多地公开通用设置，但这并不总是可能的。在这种情况下，专用名称空间提供服务器特定的自定义项(请参见<code>server.tomcat</code>和<code>server.undertow</code>)。例如，<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#配置访问日志">access logs</a>可以配置有嵌入式 Servlet 容器的特定功能。</p>
<p>Tip</p>
<p>有关完整列表，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java">ServerProperties</a>类。</p>
<h4 id="程序定制"><a href="#程序定制" class="headerlink" title="程序定制"></a>程序定制</h4><p>如果需要以编程方式配置嵌入式 servlet 容器，则可以注册一个实现<code>WebServerFactoryCustomizer</code>接口的 Spring bean。 <code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code>的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationBean</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory server)</span> </span>&#123;</span><br><span class="line">        server.setPort(<span class="number">9000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是<code>ConfigurableServletWebServerFactory</code>的专用变体，分别具有针对 Tomcat，Jetty 和 Undertow 的其他自定义设置方法。</p>
<h4 id="直接自定义ConfigurableServletWebServerFactory"><a href="#直接自定义ConfigurableServletWebServerFactory" class="headerlink" title="直接自定义ConfigurableServletWebServerFactory"></a>直接自定义ConfigurableServletWebServerFactory</h4><p>如果上述定制技术太有限，则可以自己注册<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">    factory.setPort(<span class="number">9000</span>);</span><br><span class="line">    factory.setSessionTimeout(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    factory.addErrorPages(<span class="keyword">new</span> ErrorPage(HttpStatus.NOT_FOUND, <span class="string">&quot;/notfound.html&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供了许多配置选项的设置器。如果您需要做一些更奇特的操作，还提供了几种受保护的方法“钩子”。有关详情，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">源代码文档</a>。</p>
<h3 id="JSP限制"><a href="#JSP限制" class="headerlink" title="JSP限制"></a>JSP限制</h3><p>当运行使用嵌入式 servlet 容器(并打包为可执行归档文件)的 Spring Boot 应用程序时，JSP 支持存在一些限制。</p>
<ul>
<li>对于 Jetty 和 Tomcat，如果使用 War 包装，它应该可以工作。与<code>java -jar</code>一起启动时，可执行的 War 将起作用，并且也可部署到任何标准容器中。使用可执行 jar 时，不支持 JSP。</li>
<li>Undertow 不支持 JSP。</li>
<li>创建自定义<code>error.jsp</code>页面不会覆盖<a href="#错误处理">error handling</a>的默认视图。应该改用<a href="#自定义错误页面">自定义错误页面</a>。</li>
</ul>
<p>有一个<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp">JSP sample</a>，以便您可以了解如何进行设置。</p>
<h2 id="嵌入式反应式服务器支持"><a href="#嵌入式反应式服务器支持" class="headerlink" title="嵌入式反应式服务器支持"></a>嵌入式反应式服务器支持</h2><p>Spring Boot 包含对以下嵌入式反应式 Web 服务器的支持：Reactor Netty，Tomcat，Jetty 和 Undertow。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口 8080 上侦听 HTTP 请求。</p>
<h2 id="Reactive服务器资源配置"><a href="#Reactive服务器资源配置" class="headerlink" title="Reactive服务器资源配置"></a>Reactive服务器资源配置</h2><p>当自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean，这些 bean 将为服务器实例提供 HTTP 资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。</p>
<p>默认情况下，在以下情况下，这些资源还将与 Reactor Netty 和 Jetty Client 端共享，以实现最佳性能：</p>
<ul>
<li>服务器和 Client 端使用相同的技术</li>
<li>Client 端实例是使用 Spring Boot 自动配置的<code>WebClient.Builder</code> bean 构建的</li>
</ul>
<p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。</p>
<p>您可以在<a href="#安装SpringBoot应用程序">WebClient 运行时部分</a>中了解有关 Client 端资源配置的更多信息。</p>
<h1 id="平滑关闭"><a href="#平滑关闭" class="headerlink" title="平滑关闭"></a>平滑关闭</h1><p>所有4个嵌入式web服务器(Jetty、Reactor Netty、Tomcat和Undertow)以及响应式和基于servlet的web应用程序都支持优雅的关机。它是关闭应用程序上下文的一部分，在停止<code>SmartLifecycle</code> bean的最初阶段执行。此停止处理使用了一个超时，该超时提供了一个宽限期，在此期间允许现有请求完成，但不允许新请求。不允许新请求的确切方式取决于所使用的web服务器。Jetty、Reactor Netty和Tomcat将停止在网络层接受请求。Undertow将接受请求，但立即响应一个服务不可用(503)响应。</p>
<blockquote>
<p>使用Tomcat优雅地关机需要Tomcat 9.0.33或更高版本。</p>
</blockquote>
<p>要启用优雅的关机，请配置服务器。关机属性，如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.shutdown</span>=<span class="string">graceful</span></span><br></pre></td></tr></table></figure>
<p>要配置超时时间，请配置spring.lifecycle。每关闭阶段超时属性，如下例所示:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.lifecycle.timeout-per-shutdown-phase</span>=<span class="string">20s</span></span><br></pre></td></tr></table></figure>
<h1 id="RSocket"><a href="#RSocket" class="headerlink" title="RSocket"></a>RSocket</h1><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><p>如果<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security/">Spring Security</a>在 Classpath 上，则默认情况下将保护 Web 应用程序的安全。 Spring Boot 依靠 Spring Security 的内容协商策略来确定使用<code>httpBasic</code>还是<code>formLogin</code>。要将方法级安全性添加到 Web 应用程序，您还可以使用所需的设置添加<code>@EnableGlobalMethodSecurity</code>。其他信息可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.1.2.RELEASE/reference/htmlsingle#jc-method">Spring Security 参考指南</a>中找到。</p>
<p>默认的<code>UserDetailsService</code>有一个用户。用户名为<code>user</code>，密码为随机密码，并在应用程序启动时以 INFO 级别显示，如下例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>如果您微调日志记录配置，请确保将<code>org.springframework.boot.autoconfigure.security</code>类别设置为记录<code>INFO</code>级消息。否则，不会打印默认密码。</p>
<p>您可以通过提供<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来更改用户名和密码。</p>
<p>默认情况下，您在 Web 应用程序中获得的基本功能是：</p>
<ul>
<li>具有内存存储的<code>UserDetailsService</code>(或 WebFlux 应用程序为<code>ReactiveUserDetailsService</code>)bean 和具有生成的密码的单个用户(有关用户的属性，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html">SecurityProperties.User</a>)。</li>
<li>整个应用程序的基于表单的登录或 HTTP 基本安全性(取决于 Content-Type)(如果 Actuator 位于 Classpath 上，则包括 Actuator 端点)。</li>
<li><code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</li>
</ul>
<p>您可以通过添加一个 Bean 来提供另一个<code>AuthenticationEventPublisher</code>。</p>
<h2 id="MVC安全性"><a href="#MVC安全性" class="headerlink" title="MVC安全性"></a>MVC安全性</h2><p>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebSecurityConfigurerAdapter</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。</p>
<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>类型的 Bean。 <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/">Spring Bootsample</a>中有几个安全的应用程序，可帮助您开始使用常见的用例。</p>
<p>通过添加自定义<code>WebSecurityConfigurerAdapter</code>可以覆盖访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>RequestMatcher</code>。 <code>PathRequest</code>可用于为常用位置的资源创建<code>RequestMatcher</code>。</p>
<h2 id="WebFlux安全性"><a href="#WebFlux安全性" class="headerlink" title="WebFlux安全性"></a>WebFlux安全性</h2><p>与 Spring MVC 应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护 WebFlux 应用程序。默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebFilterChainProxy</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。</p>
<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>ReactiveUserDetailsService</code>或<code>ReactiveAuthenticationManager</code>类型的 Bean。</p>
<p>可以通过添加自定义<code>SecurityWebFilterChain</code>来配置访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>ServerWebExchangeMatcher</code>。</p>
<p><code>PathRequest</code>可用于为常用位置的资源创建<code>ServerWebExchangeMatcher</code>。</p>
<p>例如，您可以通过添加以下内容来自定义安全配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecurityWebFilterChain <span class="title">springSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> http</span><br><span class="line">        .authorizeExchange()</span><br><span class="line">            .matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class="line">            .pathMatchers(<span class="string">&quot;/foo&quot;</span>, <span class="string">&quot;/bar&quot;</span>)</span><br><span class="line">                .authenticated().and()</span><br><span class="line">            .formLogin().and()</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p><a target="_blank" rel="noopener" href="https://oauth.net/2/">OAuth2</a>是 Spring 支持的广泛使用的授权框架。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>如果您的 Classpath 上有<code>spring-security-oauth2-client</code>，则可以利用一些自动配置功能来轻松设置 OAuth2/Open ID Connect Client 端。此配置使用<code>OAuth2ClientProperties</code>下的属性。相同的属性适用于 servlet 和反应式应用程序。</p>
<p>您可以使用<code>spring.security.oauth2.client</code>前缀注册多个 OAuth2 Client 端和提供者，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-name</span>=<span class="string">Client for user scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.scope</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.redirect-uri-template</span>=<span class="string">http://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-1.authorization-grant-type</span>=<span class="string">authorization_code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-name</span>=<span class="string">Client for email scope</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.provider</span>=<span class="string">my-oauth-provider</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.scope</span>=<span class="string">email</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.redirect-uri-template</span>=<span class="string">http://my-redirect-uri.com</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.client-authentication-method</span>=<span class="string">basic</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client-2.authorization-grant-type</span>=<span class="string">authorization_code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri</span>=<span class="string">http://my-auth-server/oauth/authorize</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.token-uri</span>=<span class="string">http://my-auth-server/oauth/token</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri</span>=<span class="string">http://my-auth-server/userinfo</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method</span>=<span class="string">header</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri</span>=<span class="string">http://my-auth-server/token_keys</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute</span>=<span class="string">name</span></span><br></pre></td></tr></table></figure>
<p>对于支持<a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect 发现</a>的 OpenID Connect 提供程序，可以进一步简化配置。提供者需要配置一个<code>issuer-uri</code>，这是它声明为其发布者标识符的 URI。例如，如果提供的<code>issuer-uri</code>是“ <a target="_blank" rel="noopener" href="https://example.com”，则将对“">https://example.com”，则将对“</a> <a target="_blank" rel="noopener" href="https://example.com/.well-known/openid-configuration”设置`OpenID">https://example.com/.well-known/openid-configuration”设置`OpenID</a> Provider Configuration Request<code>。结果预期为</code>OpenID Provider Configuration Response<code>。以下示例显示了如何使用</code>issuer-uri`配置 OpenID Connect 提供程序：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.provider.oidc-provider.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，Spring Security 的<code>OAuth2LoginAuthenticationFilter</code>只处理与<code>/login/oauth2/code/*</code>匹配的 URL。如果要定制<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该定制模式。例如，对于 servlet 应用程序，您可以添加自己的<code>WebSecurityConfigurerAdapter</code>，其类似于以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OAuth2LoginSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">            .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">                .and()</span><br><span class="line">            .oauth2Login()</span><br><span class="line">                .redirectionEndpoint()</span><br><span class="line">                    .baseUri(<span class="string">&quot;/custom-callback&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="通用提供商的OAuth2Client端注册"><a href="#通用提供商的OAuth2Client端注册" class="headerlink" title="通用提供商的OAuth2Client端注册"></a>通用提供商的OAuth2Client端注册</h4><p>对于常见的 OAuth2 和 OpenID 提供程序，包括 Google，Github，Facebook 和 Okta，我们提供了一组提供程序默认值(分别为<code>google</code>，<code>github</code>，<code>facebook</code>和<code>okta</code>)。</p>
<p>如果不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为您需要为其推断默认值的属性。另外，如果用于 Client 端注册的密钥与默认支持的提供程序匹配，则 Spring Boot 也会进行推断。</p>
<p>换句话说，以下示例中的两种配置都使用 Google 提供程序：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.client-secret</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.my-client.provider</span>=<span class="string">google</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-id</span>=<span class="string">abcd</span></span><br><span class="line"><span class="meta">spring.security.oauth2.client.registration.google.client-secret</span>=<span class="string">password</span></span><br></pre></td></tr></table></figure>
<h3 id="资源服务器"><a href="#资源服务器" class="headerlink" title="资源服务器"></a>资源服务器</h3><p>如果您的 Classpath 上有<code>spring-security-oauth2-resource-server</code>，则只要指定了 JWK Set URI 或 OIDC Issuer URI，Spring Boot 就可以设置 OAuth2 资源服务器，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.jwk-set-uri</span>=<span class="string">https://example.com/oauth2/default/v1/keys</span></span><br><span class="line"><span class="meta">spring.security.oauth2.resourceserver.jwt.issuer-uri</span>=<span class="string">https://dev-123456.oktapreview.com/oauth2/default/</span></span><br></pre></td></tr></table></figure>
<p>相同的属性适用于 servlet 和反应式应用程序。</p>
<p>另外，您可以为 Servlet 应用程序定义自己的<code>JwtDecoder</code> bean 或为 Reactive 应用程序定义<code>ReactiveJwtDecoder</code>。</p>
<h3 id="授权服务器"><a href="#授权服务器" class="headerlink" title="授权服务器"></a>授权服务器</h3><p>当前，Spring Security 不提供对实现 OAuth 2.0 授权服务器的支持。但是，此功能可从<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-security-oauth/">Spring Security OAuth</a>项目获得，最终将被 Spring Security 完全取代。在此之前，您可以使用<code>spring-security-oauth2-autoconfigure</code>模块轻松设置 OAuth 2.0 授权服务器；有关说明，请参见其<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security-oauth2-boot">documentation</a>。</p>
<h2 id="Actuator安全性"><a href="#Actuator安全性" class="headerlink" title="Actuator安全性"></a>Actuator安全性</h2><p>为了安全起见，默认禁用除<code>/health</code>和<code>/info</code>以外的所有 Actuator。 <code>management.endpoints.web.exposure.include</code>属性可用于启用 Actuator。</p>
<p>如果 Spring Security 位于 Classpath 上，并且不存在其他 WebSecurityConfigurerAdapter，则通过 Spring Boot 自动配置来保护<code>/health</code>和<code>/info</code>以外的所有 Actuator。如果您定义一个自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot 自动配置将退出，您将完全控制 Actuator 访问规则。</p>
<p>Note</p>
<p>在设置<code>management.endpoints.web.exposure.include</code>之前，请确保裸露的 Actuator 不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如 Spring Security 之类的东西进行保护。</p>
<h3 id="跨站点请求伪造保护"><a href="#跨站点请求伪造保护" class="headerlink" title="跨站点请求伪造保护"></a>跨站点请求伪造保护</h3><p>由于 Spring Boot 依赖于 Spring Security 的默认值，因此默认情况下 CSRF 保护是打开的。这意味着在使用默认安全性配置时，需要<code>POST</code>的 Actuator 端点(关机和 Logger 端点)，<code>PUT</code>或<code>DELETE</code>将收到 403 禁止错误。</p>
<p>Note</p>
<p>我们建议仅在创建非浏览器 Client 端使用的服务时完全禁用 CSRF 保护。</p>
<p>有关 CSRF 保护的其他信息可以在<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-security/site/docs/5.1.2.RELEASE/reference/htmlsingle#csrf">Spring Security 参考指南</a>中找到。</p>
<h1 id="使用SQL数据库"><a href="#使用SQL数据库" class="headerlink" title="使用SQL数据库"></a>使用SQL数据库</h1><p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-framework/">Spring Framework</a>为使用 SQL 数据库提供了广泛的支持，从使用<code>JdbcTemplate</code>的直接 JDBC 访问到完整的“对象关系 Map”技术(例如 Hibernate)。 <a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data/">Spring Data</a>提供了更高级别的功能：直接从接口创建<code>Repository</code>实现，并使用约定从您的方法名称生成查询。</p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>Java 的<code>javax.sql.DataSource</code>接口提供了使用数据库连接的标准方法。传统上，“数据源”使用<code>URL</code>以及一些凭据来构建数据库连接。</p>
<p>Tip</p>
<p>有关更高级的示例，请参见<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#配置自定义数据源">“操作方法”部分</a>，通常可以完全控制 DataSource 的配置。</p>
<h3 id="嵌入式数据库支持"><a href="#嵌入式数据库支持" class="headerlink" title="嵌入式数据库支持"></a>嵌入式数据库支持</h3><p>通过使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。</p>
<p>Tip</p>
<p>“操作方法”部分包括<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#初始化数据库">关于如何初始化数据库的部分</a>。</p>
<p>Spring Boot 可以自动配置嵌入式<a target="_blank" rel="noopener" href="http://www.h2database.com/">H2</a>，<a target="_blank" rel="noopener" href="http://hsqldb.org/">HSQL</a>和<a target="_blank" rel="noopener" href="https://db.apache.org/derby/">Derby</a>数据库。您无需提供任何连接 URL。您只需要包含要使用的嵌入式数据库的构建依赖项即可。</p>
<p>Note</p>
<p>如果在测试中使用此功能，则可能会注意到，整个测试套件将重用同一数据库，而不管您使用的应用程序上下文的数量如何。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将<code>spring.datasource.generate-unique-name</code>设置为<code>true</code>。</p>
<p>例如，典型的 POM 依赖关系如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>您需要依赖<code>spring-jdbc</code>才能自动配置嵌入式数据库。在此示例中，它通过<code>spring-boot-starter-data-jpa</code>暂时拉入。</p>
<p>Tip</p>
<p>如果出于某种原因确实为嵌入式数据库配置了连接 URL，请确保确保禁用了数据库的自动关闭功能。如果使用 H2，则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>。如果使用 HSQLDB，则应确保不使用<code>shutdown=true</code>。通过禁用数据库的自动关闭功能，Spring Boot 可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以执行该操作。</p>
<h3 id="连接到生产数据库"><a href="#连接到生产数据库" class="headerlink" title="连接到生产数据库"></a>连接到生产数据库</h3><p>生产数据库连接也可以使用池<code>DataSource</code>进行自动配置。 Spring Boot 使用以下算法来选择特定的实现：</p>
<ul>
<li>我们更喜欢<a target="_blank" rel="noopener" href="https://github.com/brettwooldridge/HikariCP">HikariCP</a>的性能和并发性。如果 HikariCP 可用，我们总是选择它。</li>
<li>否则，如果 Tomcat 池<code>DataSource</code>可用，我们将使用它。</li>
<li>如果 HikariCP 和 Tomcat 池数据源都不可用，并且<a target="_blank" rel="noopener" href="https://commons.apache.org/proper/commons-dbcp/">Commons DBCP2</a>可用，我们将使用它。</li>
</ul>
<p>如果使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>“启动器”，则会自动获得<code>HikariCP</code>的依赖项。</p>
<p>Note</p>
<p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性来指定要使用的连接池。如果您在 Tomcat 容器中运行应用程序，这一点尤其重要，因为默认情况下提供<code>tomcat-jdbc</code>。</p>
<p>Tip</p>
<p>其他连接池始终可以手动配置。如果定义自己的<code>DataSource</code> bean，则不会进行自动配置。</p>
<p>数据源配置由<code>spring.datasource.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost/test</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">dbuser</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">dbpass</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>您至少应通过设置<code>spring.datasource.url</code>属性来指定 URL。否则，Spring Boot 会尝试自动配置嵌入式数据库。</p>
<p>Tip</p>
<p>您通常不需要指定<code>driver-class-name</code>，因为 Spring Boot 可以从<code>url</code>推导大多数数据库。</p>
<p>Note</p>
<p>对于要创建的池<code>DataSource</code>，我们需要能够验证一个有效的<code>Driver</code>类是否可用，因此我们在进行任何操作之前都要进行检查。换句话说，如果设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，则该类必须是可加载的。</p>
<p>有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java">DataSourceProperties</a>。这些是与实际实现无关的标准选项。也可以使用它们各自的前缀(<code>spring.datasource.hikari.*</code>，<code>spring.datasource.tomcat.*</code>和<code>spring.datasource.dbcp2.*</code>)微调实现特定的设置。有关更多详细信息，请参考所用连接池实现的文档。</p>
<p>例如，如果您使用<a target="_blank" rel="noopener" href="https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes">Tomcat 连接池</a>，则可以自定义许多其他设置，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Number of ms to wait before throwing an exception if no connection is available.</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.max-wait</span>=<span class="string">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maximum number of active connections that can be allocated from this pool at the same time.</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.max-active</span>=<span class="string">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Validate the connection before borrowing it from the pool.</span></span><br><span class="line"><span class="meta">spring.datasource.tomcat.test-on-borrow</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<h3 id="连接到JNDI数据源"><a href="#连接到JNDI数据源" class="headerlink" title="连接到JNDI数据源"></a>连接到JNDI数据源</h3><p>如果您将 Spring Boot 应用程序部署到 Application Server，则可能需要使用 Application Server 的内置功能来配置和 Management DataSource，并使用 JNDI 对其进行访问。</p>
<p><code>spring.datasource.jndi-name</code>属性可以替代<code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性，以从特定的 JNDI 位置访问<code>DataSource</code>。例如，<code>application.properties</code>中的以下部分显示了如何访问 JBoss AS 定义的<code>DataSource</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.jndi-name</span>=<span class="string">java:jboss/datasources/customers</span></span><br></pre></td></tr></table></figure>
<h2 id="使用JdbcTemplate"><a href="#使用JdbcTemplate" class="headerlink" title="使用JdbcTemplate"></a>使用JdbcTemplate</h2><p>Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们<code>@Autowire</code>放入自己的 bean 中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以使用<code>spring.jdbc.template.*</code>属性来自定义模板的某些属性，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jdbc.template.max-rows</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p><code>NamedParameterJdbcTemplate</code>在后台重复使用相同的<code>JdbcTemplate</code>实例。如果定义了多个<code>JdbcTemplate</code>并且不存在主要候选对象，则不会自动配置<code>NamedParameterJdbcTemplate</code>。</p>
<h2 id="JPA和SpringDataJPA"><a href="#JPA和SpringDataJPA" class="headerlink" title="JPA和SpringDataJPA"></a>JPA和SpringDataJPA</h2><p>Java Persistence API 是一种标准技术，可让您将对象“Map”到关系数据库。 <code>spring-boot-starter-data-jpa</code> POM 提供了一种快速的 Starter 方法。它提供以下关键依赖性：</p>
<ul>
<li>Hibernate：最流行的 JPA 实现之一。</li>
<li>Spring Data JPA：使基于 JPA 的存储库的实现变得容易。</li>
<li>Spring ORM：Spring Framework 提供的核心 ORM 支持。</li>
</ul>
<p>Tip</p>
<p>在这里，我们不会过多讨论 JPA 或<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data/">Spring Data</a>的细节。您可以按照<a target="_blank" rel="noopener" href="https://spring.io/">spring.io</a>中的<a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-jpa/">“使用 JPA 访问数据”</a>指南进行操作，并阅读<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-jpa/">Spring Data JPA</a>和<a target="_blank" rel="noopener" href="https://hibernate.org/orm/documentation/">Hibernate</a>参考文档。</p>
<h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><p>传统上，JPA“实体”类是在<code>persistence.xml</code>文件中指定的。对于 Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的软件包)下的所有软件包。</p>
<p>任何带有<code>@Entity</code>，<code>@Embeddable</code>或<code>@MappedSuperclass</code>Comments 的类。典型的实体类类似于以下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... additional members, often include @OneToMany mappings</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">City</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// no-args constructor required by JPA spec</span></span><br><span class="line">        <span class="comment">// this one is protected since it shouldn&#x27;t be used directly</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(String name, String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... etc</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>您可以使用<code>@EntityScan</code>Comments 来自定义实体扫描位置。请参阅“ <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/将Entity注解定义与Spring配置分开">第 84.4 节“将@Entity 定义与 Spring 配置分开”</a>”方法。</p>
<h3 id="SpringDataJPA存储库"><a href="#SpringDataJPA存储库" class="headerlink" title="SpringDataJPA存储库"></a>SpringDataJPA存储库</h3><p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-jpa/">Spring Data JPA</a>存储库是您可以定义以访问数据的接口。 JPA 查询是根据您的方法名称自动创建的。例如，一个<code>CityRepository</code>接口可能声明<code>findAllByState(String state)</code>方法来查找给定 State 的所有城市。</p>
<p>对于更复杂的查询，您可以使用 Spring Data 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html">Query</a>Comments 对方法进行 Comments。</p>
<p>Spring Data 存储库通常从<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html">Repository</a>或<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html">CrudRepository</a>接口扩展。如果使用自动配置，则会从包含主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的主配置类)的包中搜索存储库。</p>
<p>以下示例显示了典型的 Spring Data 存储库接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data JPA 存储库支持三种不同的引导模式：默认，延迟和延迟。要启用延迟引导或延迟引导，请将<code>spring.data.jpa.repositories.bootstrap-mode</code>分别设置为<code>deferred</code>或<code>lazy</code>。当使用延迟或延迟启动时，自动配置的<code>EntityManagerFactoryBuilder</code>将使用上下文的异步任务 Actuator(如果有)作为引导 Actuator。</p>
<p>Tip</p>
<p>我们几乎没有刮过 Spring Data JPA 的表面。有关完整的详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">Spring Data JPA 参考文档</a>。</p>
<h3 id="创建和删除JPA数据库"><a href="#创建和删除JPA数据库" class="headerlink" title="创建和删除JPA数据库"></a>创建和删除JPA数据库</h3><p>默认情况下，如果您使用嵌入式数据库(H2，HSQL 或 Derby)，则仅“ <em>*”自动创建 JPA 数据库。您可以使用`spring.jpa.</em><code>属性来显式配置 JPA 设置。例如，要创建和删除表，可以将以下行添加到</code>application.properties`：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">create-drop</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>Hibernate 自己的内部属性名称是<code>hibernate.hbm2ddl.auto</code>(如果您记得更好的话)。您可以使用<code>spring.jpa.properties.*</code>来设置它以及其他 Hibernate 本机属性(将前缀添加到实体 Management 器之前，前缀会被删除)。下面的行显示了为 Hibernate 设置 JPA 属性的示例：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jpa.properties.hibernate.globally_quoted_identifiers</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>
<p>前面示例中的行将<code>hibernate.globally_quoted_identifiers</code>属性的值<code>true</code>传递给 Hibernate 实体 Management 器。</p>
<p>默认情况下，DDL 执行(或验证)被推迟到<code>ApplicationContext</code>开始。还有一个<code>spring.jpa.generate-ddl</code>标志，但是如果 Hibernate 自动配置处于 Active 状态，则不使用它，因为<code>ddl-auto</code>设置更细粒度。</p>
<h3 id="在视图中打开EntityManager"><a href="#在视图中打开EntityManager" class="headerlink" title="在视图中打开EntityManager"></a>在视图中打开EntityManager</h3><p>如果您正在运行 Web 应用程序，则默认情况下，Spring Boot 注册<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html">OpenEntityManagerInViewInterceptor</a>以应用“在视图中打开 EntityManager”模式，以允许在 Web 视图中进行延迟加载。如果您不希望出现这种情况，则应在<code>application.properties</code>中将<code>spring.jpa.open-in-view</code>设置为<code>false</code>。</p>
<h2 id="SpringDataJDBC"><a href="#SpringDataJDBC" class="headerlink" title="SpringDataJDBC"></a>SpringDataJDBC</h2><p>Spring Data 包括对 JDBC 的存储库支持，并将自动为<code>CrudRepository</code>上的方法生成 SQL。对于更高级的查询，提供了<code>@Query</code>Comments。</p>
<p>当必要的依赖项位于 Classpath 上时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。只需依赖<code>spring-boot-starter-data-jdbc</code>即可将它们添加到您的项目中。如有必要，您可以通过向应用程序中添加<code>@EnableJdbcRepositories</code>注解或<code>JdbcConfiguration</code>子类来控制 Spring Data JDBC 的配置。</p>
<p>Tip</p>
<p>有关 Spring Data JDBC 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-jdbc/">reference documentation</a>。</p>
<h2 id="使用H2的Web-控制台"><a href="#使用H2的Web-控制台" class="headerlink" title="使用H2的Web 控制台"></a>使用H2的Web 控制台</h2><p><a target="_blank" rel="noopener" href="http://www.h2database.com/">H2 database</a>提供了<a target="_blank" rel="noopener" href="http://www.h2database.com/html/quickstart.html#h2_console">browser-based console</a>，Spring Boot 可以为您自动配置<a target="_blank" rel="noopener" href="http://www.h2database.com/html/quickstart.html#jooq-in-7-steps-step3">browser-based console</a>。满足以下条件时，将自动配置控制台：</p>
<ul>
<li>您正在开发基于 servlet 的 Web 应用程序。</li>
<li><code>com.h2database:h2</code>在 Classpath 上。</li>
<li>您正在使用<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用SpringBoot/#开发者工具">Spring Boot 的开发人员工具</a>。</li>
</ul>
<p>Tip</p>
<p>如果您不使用 Spring Boot 的开发人员工具，但仍想使用 H2 的控制台，则可以将<code>spring.h2.console.enabled</code>属性配置为<code>true</code>。</p>
<p>Note</p>
<p>H2 控制台仅在开发期间使用，因此您应确保在 Producing 不要将<code>spring.h2.console.enabled</code>设置为<code>true</code>。</p>
<h3 id="更改H2控制台的路径"><a href="#更改H2控制台的路径" class="headerlink" title="更改H2控制台的路径"></a>更改H2控制台的路径</h3><p>默认情况下，控制台位于<code>/h2-console</code>。您可以使用<code>spring.h2.console.path</code>属性来自定义控制台的路径。</p>
<h2 id="使用jOOQ"><a href="#使用jOOQ" class="headerlink" title="使用jOOQ"></a>使用jOOQ</h2><p>面向 Java 对象的查询(<a target="_blank" rel="noopener" href="http://www.jooq.org/">jOOQ</a>)是<a target="_blank" rel="noopener" href="http://www.datageekery.com/">Data Geekery</a>的流行产品，它可以从数据库中生成 Java 代码，并允许您通过其流畅的 API 构建类型安全的 SQL 查询。商业版和开源版都可以与 Spring Boot 一起使用。</p>
<h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>为了使用 jOOQ 类型安全查询，您需要从数据库架构中生成 Java 类。您可以按照<a target="_blank" rel="noopener" href="https://www.jooq.org/doc/3.11.7/manual-single-page/#+5+">jOOQ 用户手册</a>中的说明进行操作。如果您使用<code>jooq-codegen-maven</code>插件，并且还使用<code>spring-boot-starter-parent</code>“父 POM”，则可以安全地忽略该插件的<code>&lt;version&gt;</code>标签。您还可以使用 Spring Boot 定义的版本变量(例如<code>h2.version</code>)来声明插件的数据库依赖关系。以下 Lists 显示了一个示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;h2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">driver</span>&gt;</span>org.h2.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:h2:~/yourdatabase<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用DSLContext"><a href="#使用DSLContext" class="headerlink" title="使用DSLContext"></a>使用DSLContext</h3><p>jOOQ 提供的流畅的 API 是通过<code>org.jooq.DSLContext</code>接口启动的。 Spring Boot 将<code>DSLContext</code>自动配置为 Spring Bean，并将其连接到应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以<code>@Autowire</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JooqExample</span> <span class="keyword">implements</span> <span class="title">CommandLineRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DSLContext create;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JooqExample</span><span class="params">(DSLContext dslContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.create = dslContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>jOOQ 手册倾向于使用名为<code>create</code>的变量来保存<code>DSLContext</code>。</p>
<p>然后，您可以使用<code>DSLContext</code>构造查询，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GregorianCalendar&gt; <span class="title">authorsBornAfter1980</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.create.selectFrom(AUTHOR)</span><br><span class="line">        .where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class="keyword">new</span> GregorianCalendar(<span class="number">1980</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">        .fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jOOQSQL方言"><a href="#jOOQSQL方言" class="headerlink" title="jOOQSQL方言"></a>jOOQSQL方言</h3><p>除非已配置<code>spring.jooq.sql-dialect</code>属性，否则 Spring Boot 会确定要用于数据源的 SQL 方言。如果 Spring Boot 无法检测到方言，则使用<code>DEFAULT</code>。</p>
<p>Note</p>
<p>Spring Boot 只能自动配置开源版本的 jOOQ 支持的方言。</p>
<h3 id="自定义jOOQ"><a href="#自定义jOOQ" class="headerlink" title="自定义jOOQ"></a>自定义jOOQ</h3><p>通过定义自己的<code>@Bean</code>定义(可以在创建 jOOQ <code>Configuration</code>时使用)可以实现更高级的自定义。您可以为以下 jOOQ 类型定义 bean：</p>
<ul>
<li><code>ConnectionProvider</code></li>
<li><code>ExecutorProvider</code></li>
<li><code>TransactionProvider</code></li>
<li><code>RecordMapperProvider</code></li>
<li><code>RecordUnmapperProvider</code></li>
<li><code>RecordListenerProvider</code></li>
<li><code>ExecuteListenerProvider</code></li>
<li><code>VisitListenerProvider</code></li>
<li><code>TransactionListenerProvider</code></li>
</ul>
<p>如果要完全控制 jOOQ 配置，也可以创建自己的<code>org.jooq.Configuration</code> <code>@Bean</code>。</p>
<h1 id="使用NoSQL技术"><a href="#使用NoSQL技术" class="headerlink" title="使用NoSQL技术"></a>使用NoSQL技术</h1><p>Spring Data 提供了其他项目，可帮助您访问各种 NoSQL 技术，包括：<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-mongodb/">MongoDB</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-neo4j/">Neo4J</a>，<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-elasticsearch/">Elasticsearch</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-solr/">Solr</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-redis/">Redis</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-gemfire/">Gemfire</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-cassandra/">Cassandra</a>，<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-couchbase/">Couchbase</a>和<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-ldap/">LDAP</a>。 Spring Boot 为 Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase 和 LDAP 提供自动配置。您可以使用其他项目，但是必须自己配置它们。请参考<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data">projects.spring.io/spring-data</a>的相应参考文档。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><a target="_blank" rel="noopener" href="http://redis.io/">Redis</a>是缓存，消息代理和功能丰富的键值存储。 Spring Boot 为<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>和<a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis/">Jedis</a>Client 端库提供了基本的自动配置，以及<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-redis">Spring Data Redis</a>提供的对它们的抽象。</p>
<p>有一个<code>spring-boot-starter-data-redis</code>“启动程序”，以方便的方式收集依赖项。默认情况下，它使用<a target="_blank" rel="noopener" href="https://github.com/lettuce-io/lettuce-core/">Lettuce</a>。该启动程序可以处理传统应用程序和响应式应用程序。</p>
<blockquote>
<p>Tip</p>
<p>我们还提供<code>spring-boot-starter-data-redis-reactive</code>“Starter”，以与其他具有 Reactive 支持的 Store 保持一致。</p>
</blockquote>
<h3 id="连接到Redis"><a href="#连接到Redis" class="headerlink" title="连接到Redis"></a>连接到Redis</h3><p>您可以像注入其他任何 Spring Bean 一样注入自动配置的<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>实例。默认情况下，该实例尝试连接到<code>localhost:6379</code>的 Redis 服务器。下面的 Lists 显示了这种 Bean 的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(StringRedisTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>您还可以注册任意数量的实现<code>LettuceClientConfigurationBuilderCustomizer</code>的 bean，以进行更高级的自定义。如果您使用 Jedis，则<code>JedisClientConfigurationBuilderCustomizer</code>也可用。</p>
<p>如果添加自己的任何自动配置类型的<code>@Bean</code>，它将替换默认值(除非<code>RedisTemplate</code>，但排除基于 Bean 名称<code>redisTemplate</code>而不是其类型，则除外)。默认情况下，如果<code>commons-pool2</code>在 Classpath 上，则将得到一个池化连接工厂。</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p><a target="_blank" rel="noopener" href="https://www.mongodb.com/">MongoDB</a>是一个开源 NoSQL 文档数据库，它使用类似 JSON 的架构而不是传统的基于表的关系数据。 Spring Boot 为使用 MongoDB 提供了许多便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code>“启动器”。</p>
<h3 id="连接到MongoDB数据库"><a href="#连接到MongoDB数据库" class="headerlink" title="连接到MongoDB数据库"></a>连接到MongoDB数据库</h3><p>要访问 Mongo 数据库，您可以注入自动配置的<code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，该实例尝试连接到<code>mongodb://localhost/test</code>的 MongoDB 服务器。以下示例显示如何连接到 MongoDB 数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class="line"><span class="keyword">import</span> com.mongodb.DB;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoDbFactory mongo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoDbFactory mongo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mongo = mongo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DB db = mongo.getDb();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以设置<code>spring.data.mongodb.uri</code>属性来更改 URL 并配置其他设置，例如<em> replica set </em>，如以下示例所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.uri=mongodb://user:[emailprotected]:12345,mongo2.example.com:23456/test</span><br></pre></td></tr></table></figure>
<p>另外，只要您使用 Mongo 2.x，就可以指定<code>host</code>/<code>port</code>。例如，您可以在<code>application.properties</code>中声明以下设置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.mongodb.host</span>=<span class="string">mongoserver</span></span><br><span class="line"><span class="meta">spring.data.mongodb.port</span>=<span class="string">27017</span></span><br></pre></td></tr></table></figure>
<p>如果您定义了自己的<code>MongoClient</code>，它将用于自动配置合适的<code>MongoDbFactory</code>。 <code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code>均受支持。</p>
<p>Note</p>
<p>如果使用 Mongo 3.0 Java 驱动程序，则不支持<code>spring.data.mongodb.host</code>和<code>spring.data.mongodb.port</code>。在这种情况下，应使用<code>spring.data.mongodb.uri</code>提供所有配置。</p>
<p>Tip</p>
<p>如果未指定<code>spring.data.mongodb.port</code>，则使用默认值<code>27017</code>。您可以从前面显示的示例中删除此行。</p>
<p>Tip</p>
<p>如果您不使用 Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code> bean 而不是<code>MongoDbFactory</code>。如果要完全控制构建 MongoDB 连接的方式，则还可以声明自己的<code>MongoDbFactory</code>或<code>MongoClient</code> bean。</p>
<p>Note</p>
<p>如果使用 Reactive 驱动程序，则 SSL 需要 Netty。如果 Netty 可用并且尚未自定义要使用的工厂，则自动配置会自动配置该工厂。</p>
<h3 id="MongoTemplate"><a href="#MongoTemplate" class="headerlink" title="MongoTemplate"></a>MongoTemplate</h3><p><a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-mongodb/">Spring Data MongoDB</a>提供的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html">MongoTemplate</a>类的设计与 Spring 的<code>JdbcTemplate</code>非常相似。与<code>JdbcTemplate</code>一样，Spring Boot 为您自动配置一个 Bean 来注入模板，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(MongoTemplate mongoTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mongoTemplate = mongoTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关完整的详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html">MongoOperations Javadoc</a>。</p>
<h3 id="SpringDataMongoDB存储库"><a href="#SpringDataMongoDB存储库" class="headerlink" title="SpringDataMongoDB存储库"></a>SpringDataMongoDB存储库</h3><p>Spring Data 包括对 MongoDB 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动构造查询。</p>
<p>实际上，Spring Data JPA 和 Spring Data MongoDB 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Mongo 数据类而不是 JPA <code>@Entity</code>，它的工作方式相同，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Repository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Page&lt;City&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">City <span class="title">findByNameAndStateAllIgnoringCase</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>您可以使用<code>@EntityScan</code>Comments 来自定义文档扫描位置。</p>
<p>Tip</p>
<p>有关 Spring Data MongoDB 的完整详细信息，包括其丰富的对象 Map 技术，请参阅其<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-mongodb/">reference documentation</a>。</p>
<h3 id="嵌入式Mongo"><a href="#嵌入式Mongo" class="headerlink" title="嵌入式Mongo"></a>嵌入式Mongo</h3><p>Spring Boot 为<a target="_blank" rel="noopener" href="https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo">Embedded Mongo</a>提供自动配置。要在您的 Spring Boot 应用程序中使用它，请在<code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>上添加一个依赖项。</p>
<p>可以通过设置<code>spring.data.mongodb.port</code>属性来配置 Mongo 侦听的端口。要使用随机分配的空闲端口，请使用 0 值。由<code>MongoAutoConfiguration</code>创建的<code>MongoClient</code>自动配置为使用随机分配的端口。</p>
<p>Note</p>
<p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口(而不是 27017)。</p>
<p>如果 Classpath 上有 SLF4J，则 Mongo 产生的输出将自动路由到名为<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>的 Logger。</p>
<p>您可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean 来控制 Mongo 实例的配置和日志记录路由。</p>
<h2 id="Neo4j"><a href="#Neo4j" class="headerlink" title="Neo4j"></a>Neo4j</h2><p><a target="_blank" rel="noopener" href="http://neo4j.com/">Neo4j</a>是一个开源 NoSQL 图形数据库，它使用通过一级关系连接的节点的丰富数据模型，比传统的 RDBMS 方法更适合于连接的大数据。 Spring Boot 为 Neo4j 的使用提供了许多便利，包括<code>spring-boot-starter-data-neo4j</code>“ Starter”。</p>
<h3 id="连接到Neo4j数据库"><a href="#连接到Neo4j数据库" class="headerlink" title="连接到Neo4j数据库"></a>连接到Neo4j数据库</h3><p>要访问 Neo4j 服务器，您可以注入自动配置的<code>org.neo4j.ogm.session.Session</code>。默认情况下，该实例尝试使用 Bolt 协议连接到<code>localhost:7687</code>处的 Neo4j 服务器。以下示例显示如何注入 Neo4j <code>Session</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Session session;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(Session session)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.session = session;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以通过设置<code>spring.data.neo4j.*</code>属性来配置要使用的 uri 和凭据，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.neo4j.uri</span>=<span class="string">bolt://my-server:7687</span></span><br><span class="line"><span class="meta">spring.data.neo4j.username</span>=<span class="string">neo4j</span></span><br><span class="line"><span class="meta">spring.data.neo4j.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>您可以通过添加<code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>来完全控制会话的创建。另外，添加类型为<code>SessionFactory</code>的<code>@Bean</code>会禁用自动配置，并提供完全控制权。</p>
<h3 id="使用嵌入式模式"><a href="#使用嵌入式模式" class="headerlink" title="使用嵌入式模式"></a>使用嵌入式模式</h3><p>如果您将<code>org.neo4j:neo4j-ogm-embedded-driver</code>添加到应用程序的依赖项中，则 Spring Boot 将自动配置 Neo4j 的进程内嵌入式实例，该实例在应用程序关闭时不会保留任何数据。</p>
<p>Note</p>
<p>由于嵌入式 Neo4j OGM 驱动程序本身不提供 Neo4j 内核，因此您必须自己声明<code>org.neo4j:neo4j</code>作为依赖项。有关兼容版本的列表，请参考<a target="_blank" rel="noopener" href="https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started">Neo4j OGM 文档</a>。</p>
<p>当 Classpath 上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置<code>spring.data.neo4j.embedded.enabled=false</code>显式禁用嵌入式模式。</p>
<p>如上所述，如果嵌入式驱动程序和 Neo4j 内核位于 Classpath 中，则<a href="#自动配置的数据Neo4j测试">数据 Neo4j 测试</a>自动使用嵌入式 Neo4j 实例。</p>
<p>Note</p>
<p>您可以通过在配置中提供数据库文件的路径来启用嵌入式模式的持久性。 <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</p>
<h3 id="Neo4jSession"><a href="#Neo4jSession" class="headerlink" title="Neo4jSession"></a>Neo4jSession</h3><p>默认情况下，如果您正在运行 Web 应用程序，则会话将绑定到线程以进行请求的整个处理(即，它使用“在视图中打开会话”模式)。如果您不希望出现这种情况，请将以下行添加到您的<code>application.properties</code>文件中：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.neo4j.open-in-view</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<h3 id="SpringDataNeo4j存储库"><a href="#SpringDataNeo4j存储库" class="headerlink" title="SpringDataNeo4j存储库"></a>SpringDataNeo4j存储库</h3><p>Spring Data 包括对 Neo4j 的存储库支持。</p>
<p>Spring Data Neo4j 与许多其他 Spring Data 模块一样，与 Spring Data JPA 共享公共基础结构。您可以使用前面的 JPA 示例，并将<code>City</code>定义为 Neo4j OGM <code>@NodeEntity</code>而不是 JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapp.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.neo4j.repository.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CityRepository</span> <span class="keyword">extends</span> <span class="title">Neo4jRepository</span>&lt;<span class="title">City</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Optional&lt;City&gt; <span class="title">findOneByNameAndState</span><span class="params">(String name, String state)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>spring-boot-starter-data-neo4j</code>“启动器”启用存储库支持以及事务 Management。您可以通过分别在<code>@Configuration</code> -bean 上使用<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>来定制位置以查找存储库和实体。</p>
<p>Tip</p>
<p>有关 Spring Data Neo4j 的完整详细信息，包括其对象 Map 技术，请参阅<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-neo4j/">reference documentation</a>。</p>
<h2 id="Gemfire"><a href="#Gemfire" class="headerlink" title="Gemfire"></a>Gemfire</h2><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-gemfire">Spring Data Gemfire</a>提供了方便使用 Spring 的便捷工具，用于访问<a target="_blank" rel="noopener" href="https://pivotal.io/big-data/pivotal-gemfire#details">Pivotal Gemfire</a>数据 Management 平台。有一个<code>spring-boot-starter-data-gemfire</code>“启动器”，用于以方便的方式收集依赖项。 Gemfire 当前没有自动配置支持，但是您可以使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java">单个 Comments：@EnableGemfireRepositories</a>启用 Spring Data Repositories。</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p><a target="_blank" rel="noopener" href="https://lucene.apache.org/solr/">Apache Solr</a>是搜索引擎。 Spring Boot 为 Solr 5 Client 端库提供了基本的自动配置，并由<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-solr">Spring Data Solr</a>提供了对它的抽象。有一个<code>spring-boot-starter-data-solr</code>“启动程序”，用于以方便的方式收集依赖项。</p>
<h3 id="连接到Solr"><a href="#连接到Solr" class="headerlink" title="连接到Solr"></a>连接到Solr</h3><p>您可以像注入其他任何 Spring bean 一样注入自动配置的<code>SolrClient</code>实例。默认情况下，该实例尝试连接到<code>localhost:8983/solr</code>处的服务器。下面的示例显示如何注入 Solr bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SolrClient solr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(SolrClient solr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.solr = solr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己的<code>SolrClient</code>类型的<code>@Bean</code>，它将替换默认值。</p>
<h3 id="SpringDataSolr存储库"><a href="#SpringDataSolr存储库" class="headerlink" title="SpringDataSolr存储库"></a>SpringDataSolr存储库</h3><p>Spring Data 包括对 Apache Solr 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为\构造查询。</p>
<p>实际上，Spring Data JPA 和 Spring Data Solr 共享相同的通用基础结构。您可以从以前的 JPA 示例开始，并假设<code>City</code>现在是<code>@SolrDocument</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。</p>
<p>Tip</p>
<p>有关 Spring Data Solr 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-data-solr/">reference documentation</a>。</p>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><a target="_blank" rel="noopener" href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>是开源，分布式，RESTful 搜索和分析引擎。 Spring Boot 为 Elasticsearch 提供了基本的自动配置。</p>
<p>Spring Boot 支持多个 HTTP Client 端：</p>
<ul>
<li>官方 Java“低级”和“高级” REST Client 端</li>
<li><a target="_blank" rel="noopener" href="https://github.com/searchbox-io/Jest">Jest</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-elasticsearch">Spring Data Elasticsearch</a>仍在使用传输 Client 端，您可以从<code>spring-boot-starter-data-elasticsearch</code>“ Starter”开始使用。</p>
<h3 id="通过-RESTClient端连接到Elasticsearch"><a href="#通过-RESTClient端连接到Elasticsearch" class="headerlink" title="通过 RESTClient端连接到Elasticsearch"></a>通过 RESTClient端连接到Elasticsearch</h3><p>Elasticsearch 附带了<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html">两个不同的 REST Client 端</a>，可用于查询集群：“低级”Client 端和“高级”Client 端。</p>
<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖关系，Spring Boot 将自动配置并注册一个<code>RestClient</code> bean，默认情况下它针对<code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>的配置方式，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.rest.uris</span>=<span class="string">http://search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.elasticsearch.rest.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的实现<code>RestClientBuilderCustomizer</code>的 bean，以进行更高级的自定义。要完全控制注册，请定义一个<code>RestClient</code> bean。</p>
<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>依赖性，则 Spring Boot 将自动配置<code>RestHighLevelClient</code>，该_包装任何现有的<code>RestClient</code> bean，并重新使用其 HTTP 配置。</p>
<h3 id="使用Jest连接到Elasticsearch"><a href="#使用Jest连接到Elasticsearch" class="headerlink" title="使用Jest连接到Elasticsearch"></a>使用Jest连接到Elasticsearch</h3><p>如果您在 Classpath 上有<code>Jest</code>，则可以注入自动配置的<code>JestClient</code>，默认情况下以<code>localhost:9200</code>为目标。您可以进一步调整 Client 端的配置方式，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.elasticsearch.jest.uris</span>=<span class="string">http://search.example.com:9200</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.read-timeout</span>=<span class="string">10000</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.username</span>=<span class="string">user</span></span><br><span class="line"><span class="meta">spring.elasticsearch.jest.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的实现<code>HttpClientConfigBuilderCustomizer</code>的 bean，以进行更高级的自定义。以下示例调整其他 HTTP 设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpSettingsCustomizer</span> <span class="keyword">implements</span> <span class="title">HttpClientConfigBuilderCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(HttpClientConfig.Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.maxTotalConnection(<span class="number">100</span>).defaultMaxTotalConnectionPerRoute(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要完全控制注册，请定义一个<code>JestClient</code> bean。</p>
<h3 id="使用Spring数据连接到Elasticsearch"><a href="#使用Spring数据连接到Elasticsearch" class="headerlink" title="使用Spring数据连接到Elasticsearch"></a>使用Spring数据连接到Elasticsearch</h3><p>要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code>属性设置为逗号分隔的<code>host:port</code>列表来指定地址。有了此配置后，就可以像其他任何 Spring bean 一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.cluster-nodes=localhost:<span class="number">9300</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ElasticsearchTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(ElasticsearchTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。</p>
<h3 id="SpringDataElasticsearch存储库"><a href="#SpringDataElasticsearch存储库" class="headerlink" title="SpringDataElasticsearch存储库"></a>SpringDataElasticsearch存储库</h3><p>Spring Data 包括对 Elasticsearch 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为您构造查询。</p>
<p>实际上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Elasticsearch <code>@Document</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。</p>
<p>Tip</p>
<p>有关 Spring Data Elasticsearch 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/elasticsearch/docs/">reference documentation</a>。</p>
<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p><a target="_blank" rel="noopener" href="https://cassandra.apache.org/">Cassandra</a>是一个开放源代码的分布式数据库 Management 系统，旨在处理许多商品服务器上的大量数据。 Spring Boot 为 Cassandra 提供自动配置，并由<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-cassandra">Spring Data Cassandra</a>提供最高级的抽象。有一个<code>spring-boot-starter-data-cassandra</code>“启动程序”，用于以方便的方式收集依赖项。</p>
<h3 id="连接到Cassandra"><a href="#连接到Cassandra" class="headerlink" title="连接到Cassandra"></a>连接到Cassandra</h3><p>您可以像使用其他任何 Spring Bean 一样注入自动配置的<code>CassandraTemplate</code>或 Cassandra <code>Session</code>实例。 <code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和<code>contact-points</code>属性，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.data.cassandra.keyspace-name</span>=<span class="string">mykeyspace</span></span><br><span class="line"><span class="meta">spring.data.cassandra.contact-points</span>=<span class="string">cassandrahost1,cassandrahost2</span></span><br></pre></td></tr></table></figure>
<p>您还可以注册任意数量的实现<code>ClusterBuilderCustomizer</code>的 bean，以进行更高级的自定义。</p>
<p>以下代码 Lists 显示了如何注入 Cassandra bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CassandraTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CassandraTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果添加自己的<code>CassandraTemplate</code>类型的<code>@Bean</code>，它将替换默认值。</p>
<h3 id="SpringDataCassandra存储库"><a href="#SpringDataCassandra存储库" class="headerlink" title="SpringDataCassandra存储库"></a>SpringDataCassandra存储库</h3><p>Spring Data 包括对 Cassandra 的基本存储库支持。当前，这比前面讨论的 JPA 存储库受到更多限制，并且需要使用<code>@Query</code>Comments finder 方法。</p>
<p>Tip</p>
<p>有关 Spring Data Cassandra 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/cassandra/docs/">reference documentation</a>。</p>
<h2 id="Couchbase"><a href="#Couchbase" class="headerlink" title="Couchbase"></a>Couchbase</h2><p><a target="_blank" rel="noopener" href="https://www.couchbase.com/">Couchbase</a>是开放源代码，分布式，多模型的 NoSQL 面向文档的数据库，已针对交互式应用程序进行了优化。 Spring Boot 为 Couchbase 提供自动配置，并由<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-couchbase">Spring Data Couchbase</a>提供最高级的抽象。有<code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code>个“启动程序”，以方便的方式收集依赖项。</p>
<h3 id="连接到Couchbase"><a href="#连接到Couchbase" class="headerlink" title="连接到Couchbase"></a>连接到Couchbase</h3><p>您可以通过添加 Couchbase SDK 和一些配置来获得<code>Bucket</code>和<code>Cluster</code>。 <code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.bootstrap-hosts</span>=<span class="string">my-host-1,192.168.1.123</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.name</span>=<span class="string">my-bucket</span></span><br><span class="line"><span class="meta">spring.couchbase.bucket.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>您至少需要提供*引导主机，在这种情况下，存储区名称为<code>default</code>，密码为空字符串。另外，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>来控制整个配置。</p>
<p>还可以自定义某些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改了用于打开新的<code>Bucket</code>的超时并启用了 SSL 支持：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.couchbase.env.timeouts.connect</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store</span>=<span class="string">/location/of/keystore.jks</span></span><br><span class="line"><span class="meta">spring.couchbase.env.ssl.key-store-password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>查看<code>spring.couchbase.env.*</code>属性以获取更多详细信息。</p>
<h3 id="SpringDataCouchbase存储库"><a href="#SpringDataCouchbase存储库" class="headerlink" title="SpringDataCouchbase存储库"></a>SpringDataCouchbase存储库</h3><p>Spring Data 包括对 Couchbase 的存储库支持。有关 Spring Data Couchbase 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/">reference documentation</a>。</p>
<p>您可以像使用任何其他 Spring Bean 一样注入自动配置的<code>CouchbaseTemplate</code>实例，前提是<em> default </em> <code>CouchbaseConfigurer</code>可用(如前所述，启用 Couchbase 支持时会发生这种情况)。</p>
<p>以下示例显示了如何注入 Couchbase bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CouchbaseTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(CouchbaseTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以在自己的配置中定义一些 Bean，以覆盖自动配置提供的那些：</p>
<ul>
<li>名称为<code>couchbaseTemplate</code>的<code>CouchbaseTemplate</code> <code>@Bean</code>。</li>
<li>名为<code>couchbaseIndexManager</code>的<code>IndexManager</code> <code>@Bean</code>。</li>
<li>名称为<code>couchbaseCustomConversions</code>的<code>CustomConversions</code> <code>@Bean</code>。</li>
</ul>
<p>为了避免在您自己的配置中对这些名称进行硬编码，您可以重复使用 Spring Data Couchbase 提供的<code>BeanNames</code>。例如，您可以自定义要使用的转换器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomConversions <span class="title">myCustomConversions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomConversions(...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>如果您想完全绕过 Spring Data Couchbase 的自动配置，请提供自己的<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>实现。</p>
<h2 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">LDAP</a>(轻型目录访问协议)是一种开放的，与供应商无关的行业标准应用程序协议，用于通过 IP 网络访问和维护分布式目录信息服务。 Spring Boot 为任何兼容的 LDAP 服务器提供自动配置，并从<a target="_blank" rel="noopener" href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>支持嵌入式内存 LDAP 服务器。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-data-ldap">Spring Data LDAP</a>提供 LDAP 抽象。有一个<code>spring-boot-starter-data-ldap</code>“启动程序”，以方便的方式收集依赖项。</p>
<h3 id="连接到LDAP服务器"><a href="#连接到LDAP服务器" class="headerlink" title="连接到LDAP服务器"></a>连接到LDAP服务器</h3><p>要连接到 LDAP 服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>“ Starter”或<code>spring-ldap-core</code>的依赖关系，然后在 application.properties 中声明服务器的 URL，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.urls</span>=<span class="string">ldap://myserver:1235</span></span><br><span class="line"><span class="meta">spring.ldap.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.ldap.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>如果需要自定义连接设置，则可以使用<code>spring.ldap.base</code>和<code>spring.ldap.base-environment</code>属性。</p>
<p><code>LdapContextSource</code>是根据这些设置自动配置的。如果您需要对其进行自定义(例如使用<code>PooledContextSource</code>)，则仍可以注入自动配置的<code>LdapContextSource</code>。确保将自定义的<code>ContextSource</code>标记为<code>@Primary</code>，以便自动配置的<code>LdapTemplate</code>使用它。</p>
<h3 id="SpringDataLDAP存储库"><a href="#SpringDataLDAP存储库" class="headerlink" title="SpringDataLDAP存储库"></a>SpringDataLDAP存储库</h3><p>Spring Data 包括对 LDAP 的存储库支持。有关 Spring Data LDAP 的完整详细信息，请参阅<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/">reference documentation</a>。</p>
<p>您还可以像使用其他任何 Spring Bean 一样注入自动配置的<code>LdapTemplate</code>实例，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LdapTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(LdapTemplate template)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.template = template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="嵌入式内存LDAP服务器"><a href="#嵌入式内存LDAP服务器" class="headerlink" title="嵌入式内存LDAP服务器"></a>嵌入式内存LDAP服务器</h3><p>出于测试目的，Spring Boot 支持从<a target="_blank" rel="noopener" href="https://www.ldap.com/unboundid-ldap-sdk-for-java">UnboundID</a>自动配置内存中的 LDAP 服务器。要配置服务器，请将依赖项添加到<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn</span>=<span class="string">dc=spring,dc=io</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>可以定义多个 base-dn 值，但是，由于可分辨的名称通常包含逗号，因此必须使用正确的符号来定义它们。</p>
<p>在 yaml 文件中，您可以使用 yaml 列表符号：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn</span>:<span class="string"></span></span><br><span class="line"><span class="meta">-</span> <span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="meta">-</span> <span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure>
<p>在属性文件中，必须将索引包括在属性名称中：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.ldap.embedded.base-dn[0]</span>=<span class="string">dc=spring,dc=io</span></span><br><span class="line"><span class="meta">spring.ldap.embedded.base-dn[1]</span>=<span class="string">dc=pivotal,dc=io</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，服务器在随机端口上启动并触发常规 LDAP 支持。无需指定<code>spring.ldap.urls</code>属性。</p>
<p>如果您的 Classpath 上有一个<code>schema.ldif</code>文件，它将用于初始化服务器。如果要从其他资源加载初始化脚本，则也可以使用<code>spring.ldap.embedded.ldif</code>属性。</p>
<p>默认情况下，使用标准架构来验证<code>LDIF</code>个文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您具有自定义属性，则可以使用<code>spring.ldap.embedded.validation.schema</code>定义您的自定义属性类型或对象类。</p>
<h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><p><a target="_blank" rel="noopener" href="https://www.influxdata.com/">InfluxDB</a>是开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。</p>
<h3 id="连接到nfluxDB"><a href="#连接到nfluxDB" class="headerlink" title="连接到nfluxDB"></a>连接到nfluxDB</h3><p>只要<code>influxdb-java</code>Client 端位于 Classpath 上并且设置了数据库的 URL，Spring Boot 就会自动配置<code>InfluxDB</code>实例，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.influx.url</span>=<span class="string">http://172.0.0.1:8086</span></span><br></pre></td></tr></table></figure>
<p>如果与 InfluxDB 的连接需要用户和密码，则可以相应地设置<code>spring.influx.user</code>和<code>spring.influx.password</code>属性。</p>
<p>InfluxDB 依赖 OkHttp。如果需要在后台调整 http Client 端<code>InfluxDB</code>的使用，则可以注册<code>InfluxDbOkHttpClientBuilderProvider</code> bean。</p>
<h1 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h1><p>Spring 框架提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code>Comments 启用了缓存支持，Spring Boot 就会自动配置缓存基础结构。</p>
<p>Note</p>
<p>查看 Spring 框架参考的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#cache">relevant section</a>以获得更多详细信息。</p>
<p>简而言之，将缓存添加到服务的操作就像将相关 Comments 添加到其方法一样容易，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(&quot;piDecimals&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">computePiDecimal</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本示例说明了在可能耗资巨大的操作上使用缓存的方法。在调用<code>computePiDecimal</code>之前，抽象将在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。</p>
<blockquote>
<p>Warning</p>
<p>您还可以透明地使用标准 JSR-107(JCache)注解(例如<code>@CacheResult</code>)。但是，我们强烈建议您不要混合使用 Spring Cache 和 JCache 注解。</p>
<p>如果您不添加任何特定的缓存库，Spring Boot 会自动配置一个使用内存中并发 Map 的<a href="#Simple">simple provider</a>。需要缓存时(例如上例中的<code>piDecimals</code>)，此提供程序将为您创建它。实际上，不建议将简单提供程序用于生产用途，但是它对于 Starter 并确保您了解功能非常有用。确定要使用的缓存提供程序后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。</p>
<p>Tip</p>
<p>也可以透明地从缓存中<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#cache-annotations-put">update</a>或<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#cache-annotations-evict">evict</a>数据。</p>
</blockquote>
<h2 id="支持的缓存提供程序"><a href="#支持的缓存提供程序" class="headerlink" title="支持的缓存提供程序"></a>支持的缓存提供程序</h2><p>缓存抽象不提供实际的存储，而是依赖于<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现的抽象。</p>
<p>如果尚未定义类型<code>CacheManager</code>或名为<code>cacheResolver</code>的<code>CacheResolver</code>(请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html">CachingConfigurer</a>)，则 Spring Boot 尝试检测以下提供程序(按指示的 Sequences)：</p>
<ul>
<li><a href="#Generic">Generic</a></li>
<li><a href="#JCache (JSR-107">JCache (JSR-107)</a>)(EhCache 3，Hazelcast，Infinispan 等)</li>
<li><a href="#EhCache2.x">EhCache 2.x</a></li>
<li><a href="#Hazelcast">Hazelcast</a></li>
<li><a href="#Infinispan">Infinispan</a></li>
<li><a href="#Couchbase">Couchbase</a></li>
<li><a href="#Redis">Redis</a></li>
<li><a href="#Caffeine">Caffeine</a></li>
<li><a href="#Simple">Simple</a></li>
</ul>
<p>Tip</p>
<p>也可以通过设置<code>spring.cache.type</code>属性来“强制”特定的缓存提供程序。如果需要在某些环境(例如测试)中<a href="#None">完全禁用缓存</a>，请使用此属性。</p>
<p>Tip</p>
<p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本的缓存依赖项。启动器带来<code>spring-context-support</code>。如果手动添加依赖项，则必须包含<code>spring-context-support</code>才能使用 JCache，EhCache 2.x 或 Guava 支持。</p>
<p>如果<code>CacheManager</code>是由 Spring Boot 自动配置的，则可以通过公开实现<code>CacheManagerCustomizer</code>接口的 bean，在完全初始化之前进一步调整其配置。下面的示例设置一个标志，指示应该将空值向下传递到基础 Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheManagerCustomizer&lt;ConcurrentMapCacheManager&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConcurrentMapCacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">            cacheManager.setAllowNullValues(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>在前面的示例中，应使用自动配置的<code>ConcurrentMapCacheManager</code>。如果不是这种情况(您提供了自己的配置，或者自动配置了其他缓存提供程序)，则根本不会调用定制程序。您可以根据需要拥有任意数量的定制程序，也可以使用<code>@Order</code>或<code>Ordered</code>对其进行排序。</p>
<h3 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h3><p>如果上下文至少定义了一个<code>org.springframework.cache.Cache</code> bean，则使用通用缓存。创建一个<code>CacheManager</code>包装该类型的所有 bean。</p>
<h3 id="JCache-JSR-107"><a href="#JCache-JSR-107" class="headerlink" title="JCache(JSR-107)"></a>JCache(JSR-107)</h3><p><a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=107">JCache</a>通过 Classpath 上存在<code>javax.cache.spi.CachingProvider</code>进行引导(即，Classpath 上存在符合 JSR-107 的缓存库)，并且<code>JCacheCacheManager</code>由<code>spring-boot-starter-cache</code>“启动程序”提供。提供了各种兼容的库，Spring Boot 为 Ehcache 3，Hazelcast 和 Infinispan 提供了依赖 Management。也可以添加任何其他兼容的库。</p>
<p>可能会出现多个提供者，在这种情况下，必须明确指定提供者。即使 JSR-107 标准没有强制采用标准化的方式来定义配置文件的位置，Spring Boot 也会尽其所能以设置具有实现细节的缓存，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Only necessary if more than one provider is present</span></span><br><span class="line"><span class="meta">spring.cache.jcache.provider</span>=<span class="string">com.acme.MyCachingProvider</span></span><br><span class="line"><span class="meta">spring.cache.jcache.config</span>=<span class="string">classpath:acme.xml</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>当缓存库同时提供本机实现和 JSR-107 支持时，Spring Boot 会首选 JSR-107 支持，因此，如果您切换到其他 JSR-107 实现，则可以使用相同的功能。</p>
<p>Tip</p>
<p>Spring Boot 具有<a href="#Hazelcast">对 Hazelcast 的常规支持</a>。如果有一个<code>HazelcastInstance</code>可用，则除非指定<code>spring.cache.jcache.config</code>属性，否则它也会自动为<code>CacheManager</code>重用。</p>
<p>自定义基础<code>javax.cache.cacheManager</code>的方法有两种：</p>
<ul>
<li>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code> bean，则将其用于自定义它们。</li>
<li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 与<code>CacheManager</code>的引用一起调用以进行完全自定义。</li>
</ul>
<p>Tip</p>
<p>如果定义了一个标准的<code>javax.cache.CacheManager</code> bean，它将自动包装在抽象期望的<code>org.springframework.cache.CacheManager</code>实现中。不再对其应用定制。</p>
<h3 id="EhCache2-x"><a href="#EhCache2-x" class="headerlink" title="EhCache2.x"></a>EhCache2.x</h3><p>如果可以在 Classpath 的根目录下找到名为<code>ehcache.xml</code>的文件，则使用<a target="_blank" rel="noopener" href="http://www.ehcache.org/">EhCache</a>2.x。如果找到 EhCache 2.x，则使用<code>spring-boot-starter-cache</code>“启动程序”提供的<code>EhCacheCacheManager</code>来引导缓存 Management 器。也可以提供备用配置文件，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.ehcache.config</span>=<span class="string">classpath:config/another-config.xml</span></span><br></pre></td></tr></table></figure>
<h3 id="Hazelcast缓存"><a href="#Hazelcast缓存" class="headerlink" title="Hazelcast缓存"></a>Hazelcast缓存</h3><p>Spring Boot 具有<a href="#Hazelcast">对 Hazelcast 的常规支持</a>。如果已自动配置<code>HazelcastInstance</code>，则会自动将其包装在<code>CacheManager</code>中。</p>
<h3 id="Infinispan"><a href="#Infinispan" class="headerlink" title="Infinispan"></a>Infinispan</h3><p><a target="_blank" rel="noopener" href="http://infinispan.org/">Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.infinispan.config</span>=<span class="string">infinispan.xml</span></span><br></pre></td></tr></table></figure>
<p>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>ConfigurationBuilder</code> bean，则用于自定义缓存。</p>
<p>Note</p>
<p>Spring Boot 对 Infinispan 的支持仅限于嵌入式模式，并且非常基础。如果您需要更多选择，则应该使用官方的 Infinispan Spring Boot 启动程序。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/infinispan/infinispan-spring-boot">Infinispan’s documentation</a>。</p>
<h3 id="Couchbase-1"><a href="#Couchbase-1" class="headerlink" title="Couchbase"></a>Couchbase</h3><p>如果<a target="_blank" rel="noopener" href="https://www.couchbase.com/">Couchbase</a> Java Client 端和<code>couchbase-spring-cache</code>实现可用且 Couchbase 为<a target="_blank" rel="noopener" href="https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-couchbase">configured</a>，则将自动配置<code>CouchbaseCacheManager</code>。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在自动配置的<code>Bucket</code>上运行。您还可以*使用定制程序在另一个<code>Bucket</code>上创建其他缓存。假设您在“主” <code>Bucket</code>上需要两个缓存(<code>cache1</code>和<code>cache2</code>)，在(另一个)<code>Bucket</code>上需要一个缓存(<code>cache3</code>)的自定义时间为 2 秒。您可以通过配置创建前两个缓存，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br></pre></td></tr></table></figure>
<p>然后，您可以定义一个<code>@Configuration</code>类来配置额外的<code>Bucket</code>和<code>cache3</code>缓存，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouchbaseCacheConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cluster cluster;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CouchbaseCacheConfiguration</span><span class="params">(Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cluster = cluster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bucket <span class="title">anotherBucket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cluster.openBucket(<span class="string">&quot;another&quot;</span>, <span class="string">&quot;secret&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManagerCustomizer&lt;CouchbaseCacheManager&gt; <span class="title">cacheManagerCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c -&gt; &#123;</span><br><span class="line">            c.prepareCache(<span class="string">&quot;cache3&quot;</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class="line">                    .withExpiration(<span class="number">2</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此示例配置重复使用通过自动配置创建的<code>Cluster</code>。</p>
<h3 id="Redis-1"><a href="#Redis-1" class="headerlink" title="Redis"></a>Redis</h3><p>如果<a target="_blank" rel="noopener" href="http://redis.io/">Redis</a>可用并已配置，则将自动配置<code>RedisCacheManager</code>。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存，并且可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值。例如，以下配置创建了“生存时间”为 10 分钟的<code>cache1</code>和<code>cache2</code>缓存：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.redis.time-to-live</span>=<span class="string">600000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>默认情况下，添加密钥前缀，以便如果两个单独的缓存使用相同的密钥，则 Redis 不会有重叠的密钥，并且不能返回无效值。如果您创建自己的<code>RedisCacheManager</code>，强烈建议您启用此设置。</p>
<p>Tip</p>
<p>您可以添加自己的<code>RedisCacheConfiguration</code> <code>@Bean</code>，从而完全控制配置。如果您要自定义序列化策略，这将很有用。</p>
</blockquote>
<h3 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h3><p><a target="_blank" rel="noopener" href="https://github.com/ben-manes/caffeine">Caffeine</a>是对 Guava 缓存的 Java 8 重写，取代了对 Guava 的支持。如果存在 Caffeine，则会自动配置<code>CaffeineCacheManager</code>(由<code>spring-boot-starter-cache</code>“Starter”提供)。缓存可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建，并且可以通过以下方式之一自定义(按指示的 Sequences)：</p>
<ul>
<li><code>spring.cache.caffeine.spec</code>定义的缓存规范</li>
<li>定义了一个<code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean</li>
<li>定义了一个<code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</li>
</ul>
<p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为 500，并且<em>生存时间</em>为 10 分钟</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br><span class="line"><span class="meta">spring.cache.caffeine.spec</span>=<span class="string">maximumSize=500,expireAfterAccess=600s</span></span><br></pre></td></tr></table></figure>
<p>如果定义了<code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean，它将自动与<code>CaffeineCacheManager</code>关联。由于<code>CacheLoader</code>将与由缓存 Management 器 Management 的<em> all </em>缓存相关联，因此必须将其定义为<code>CacheLoader&lt;Object, Object&gt;</code>。自动配置将忽略任何其他通用类型。</p>
<h3 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h3><p>如果找不到其他提供者，则配置使用<code>ConcurrentHashMap</code>作为缓存存储区的简单实现。如果您的应用程序中不存在任何缓存库，则这是默认设置。默认情况下，将根据需要创建缓存，但是您可以通过设置<code>cache-names</code>属性来限制可用缓存的列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，则按如下所示设置<code>cache-names</code>属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.cache-names</span>=<span class="string">cache1,cache2</span></span><br></pre></td></tr></table></figure>
<p>如果这样做，并且您的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但不会在启动时失败。这类似于使用未声明的缓存时“实际”缓存提供程序的行为。</p>
<h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>当您的配置中包含<code>@EnableCaching</code>时，也需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制将缓存类型设置为<code>none</code>以使用无操作实现，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cache.type</span>=<span class="string">none</span></span><br></pre></td></tr></table></figure>
<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>Spring 框架为与消息传递系统集成提供了广泛的支持，从简化使用<code>JmsTemplate</code>的 JMS API 的使用到完整的异步接收消息的基础结构。 Spring AMQP 为高级消息队列协议提供了类似的功能集。 Spring Boot 还为<code>RabbitTemplate</code>和 RabbitMQ 提供了自动配置选项。 Spring WebSocket 本身就包含对 STOMP 消息的支持，而 Spring Boot 通过启动程序和少量的自动配置对此提供了支持。 Spring Boot 还支持 Apache Kafka。</p>
<h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p><code>javax.jms.ConnectionFactory</code>接口提供了创建<code>javax.jms.Connection</code>与 JMS 代理进行交互的标准方法。尽管 Spring 需要<code>ConnectionFactory</code>才能与 JMS 一起使用，但是您通常不需要自己直接使用它，而是可以依靠更高级别的消息抽象。 (有关详细信息，请参见 Spring Framework 参考文档的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#jms">relevant section</a>。)Spring Boot 还自动配置必要的基础结构来发送和接收消息。</p>
<h3 id="ActiveMQ支持"><a href="#ActiveMQ支持" class="headerlink" title="ActiveMQ支持"></a>ActiveMQ支持</h3><p>当<a target="_blank" rel="noopener" href="http://activemq.apache.org/">ActiveMQ</a>在 Classpath 上可用时，Spring Boot 也可以配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(前提是未通过配置指定代理 URL)。</p>
<p>Note</p>
<p>如果使用<code>spring-boot-starter-activemq</code>，则将提供连接或嵌入 ActiveMQ 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。</p>
<p>ActiveMQ 配置由<code>spring.activemq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.broker-url</span>=<span class="string">tcp://192.168.1.210:9876</span></span><br><span class="line"><span class="meta">spring.activemq.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.activemq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>
<p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.activemq.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.activemq.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip</p>
<p>有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java">ActiveMQProperties</a>。您还可以注册任意数量的实现<code>ActiveMQConnectionFactoryCustomizer</code>的 bean，以进行更高级的自定义。</p>
</blockquote>
<p>默认情况下，ActiveMQ 将创建一个目的地(如果目的地尚不存在)，以便根据其提供的名称来解析目的地。</p>
<h3 id="Artemis支持"><a href="#Artemis支持" class="headerlink" title="Artemis支持"></a>Artemis支持</h3><p>当 Spring Boot 检测到<a target="_blank" rel="noopener" href="http://activemq.apache.org/artemis/">Artemis</a>在 Classpath 中可用时，它可以自动配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(除非已明确设置 mode 属性)。支持的模式为<code>embedded</code>(以明确要求使用嵌入式代理，并且如果代理在 Classpath 上不可用，则会发生错误)和<code>native</code>(使用<code>netty</code>传输协议连接到代理)。配置后者后，Spring Boot 将使用默认设置配置一个<code>ConnectionFactory</code>，该<code>ConnectionFactory</code>连接到在本地计算机上运行的代理。</p>
<p>Note</p>
<p>如果使用<code>spring-boot-starter-artemis</code>，则将提供连接到现有 Artemis 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。将<code>org.apache.activemq:artemis-jms-server</code>添加到您的应用程序可让您使用嵌入式模式。</p>
<p>Artemis 配置由<code>spring.artemis.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.mode</span>=<span class="string">native</span></span><br><span class="line"><span class="meta">spring.artemis.host</span>=<span class="string">192.168.1.210</span></span><br><span class="line"><span class="meta">spring.artemis.port</span>=<span class="string">9876</span></span><br><span class="line"><span class="meta">spring.artemis.user</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.artemis.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>嵌入代理时，可以选择是否要启用持久性并列出应使其可用的目的地。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，也可以为高级队列和主题配置分别定义类型<code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>的 bean。</p>
<p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.cache.session-cache-size</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure>
<p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.artemis.pool.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.artemis.pool.max-connections</span>=<span class="string">50</span></span><br></pre></td></tr></table></figure>
<p>有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java">ArtemisProperties</a>。</p>
<p>不涉及 JNDI 查找，并且使用 Artemis 配置中的<code>name</code>属性或通过配置提供的名称来根据目的地名称解析目的地。</p>
<h3 id="使用JNDI连接工厂"><a href="#使用JNDI连接工厂" class="headerlink" title="使用JNDI连接工厂"></a>使用JNDI连接工厂</h3><p>如果您正在应用程序服务器中运行应用程序，则 Spring Boot 会尝试使用 JNDI 查找 JMS <code>ConnectionFactory</code>。默认情况下，选中<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。如果需要指定替代位置，则可以使用<code>spring.jms.jndi-name</code>属性，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.jms.jndi-name</span>=<span class="string">java:/MyConnectionFactory</span></span><br></pre></td></tr></table></figure>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring 的<code>JmsTemplate</code>是自动配置的，您可以将其直接自动连接到自己的 bean 中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(JmsTemplate jmsTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jmsTemplate = jmsTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html">JmsMessagingTemplate</a>可以类似的方式注入。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，则将其自动关联到自动配置的<code>JmsTemplate</code>。</p>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>存在 JMS 基础结构时，可以使用<code>@JmsListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>JmsListenerContainerFactory</code>，则会自动配置一个默认值。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，它将自动关联到默认工厂。</p>
<p>默认情况下，默认工厂是事务性的。如果您在存在<code>JtaTransactionManager</code>的基础结构中运行，则默认情况下会将其与侦听器容器关联。如果不是，则启用<code>sessionTransacted</code>标志。在后一种情况下，可以通过在侦听器方法(或其委托)上添加<code>@Transactional</code>来将本地数据存储事务与传入消息的处理相关联。这样可以确保本地事务完成后，传入消息得到确认。这还包括发送已在同一 JMS 会话上执行的响应消息。</p>
<p>以下组件在<code>someQueue</code>目标上创建侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/annotation/EnableJms.html">@EnableJms 的 Javadoc</a>。</p>
<p>如果您需要创建更多的<code>JmsListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>，您可以使用与自动配置的设置相同的设置来初始化<code>DefaultJmsListenerContainerFactory</code>。</p>
<p>例如，以下示例公开了另一个使用特定<code>MessageConverter</code>的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">JmsConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultJmsListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            DefaultJmsListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        DefaultJmsListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory());</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以在任何带有<code>@JmsListener</code>Comments 的方法中使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>高级消息队列协议(AMQP)是面向消息中间件的与平台无关的有线级别协议。 Spring AMQP 项目将 Spring 的核心概念应用于基于 AMQP 的消息传递解决方案的开发。 Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了许多便利，包括<code>spring-boot-starter-amqp</code>“ Starter”。</p>
<h3 id="RabbitMQ-支持"><a href="#RabbitMQ-支持" class="headerlink" title="RabbitMQ 支持"></a>RabbitMQ 支持</h3><p><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/">RabbitMQ</a>是基于 AMQP 协议的轻型，可靠，可伸缩和便携式消息代理。 Spring 使用<code>RabbitMQ</code>通过 AMQP 协议进行通信。</p>
<p>RabbitMQ 配置由<code>spring.rabbitmq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">secret</span></span><br></pre></td></tr></table></figure>
<p>如果上下文中存在<code>ConnectionNameStrategy</code> bean，它将自动用于命名由自动配置的<code>ConnectionFactory</code>创建的连接。有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java">RabbitProperties</a>。</p>
<p>Tip</p>
<p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://spring.io/blog/2010/06/14/understanding-amqp-the-protocol-used-by-rabbitmq/">了解 AMQP，RabbitMQ 使用的协议</a>。</p>
<h3 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h3><p>Spring 的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>是自动配置的，您可以将它们直接自动连接到自己的 bean 中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpAdmin amqpAdmin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.amqpAdmin = amqpAdmin;</span><br><span class="line">        <span class="keyword">this</span>.amqpTemplate = amqpTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html">RabbitMessagingTemplate</a>可以类似的方式注入。如果定义了<code>MessageConverter</code> bean，它将自动关联到自动配置的<code>AmqpTemplate</code>。</p>
<p>如有必要，任何定义为 bean 的<code>org.springframework.amqp.core.Queue</code>都会自动用于在 RabbitMQ 实例上声明相应的队列。</p>
<p>要重试操作，可以在<code>AmqpTemplate</code>上启用重试(例如，在代理连接丢失的情况下)：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.template.retry.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">spring.rabbitmq.template.retry.initial-interval</span>=<span class="string">2s</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，重试是禁用的。您还可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。</p>
<h3 id="接收消息-1"><a href="#接收消息-1" class="headerlink" title="接收消息"></a>接收消息</h3><p>存在 Rabbit 基础结构时，可以使用<code>@RabbitListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>RabbitListenerContainerFactory</code>，则会自动配置默认的<code>SimpleRabbitListenerContainerFactory</code>，并且可以使用<code>spring.rabbitmq.listener.type</code>属性切换到直接容器。如果定义了<code>MessageConverter</code>或<code>MessageRecoverer</code> bean，它将自动与默认工厂关联。</p>
<p>以下示例组件在<code>someQueue</code>队列上创建一个侦听器端点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/annotation/EnableRabbit.html">@EnableRabbit 的 Javadoc</a>。</p>
<p>如果您需要创建更多的<code>RabbitListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和<code>DirectRabbitListenerContainerFactoryConfigurer</code>，您可以使用它们设置与自动配置使用的工厂相同的设置来初始化<code>SimpleRabbitListenerContainerFactory</code>和<code>DirectRabbitListenerContainerFactory</code>。</p>
<p>Tip</p>
<p>选择哪种容器都没有关系。这两个 bean 通过自动配置公开。</p>
<p>例如，以下配置类公开了另一个使用特定<code>MessageConverter</code>的工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleRabbitListenerContainerFactory <span class="title">myFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        SimpleRabbitListenerContainerFactory factory =</span><br><span class="line">                <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">        configurer.configure(factory, connectionFactory);</span><br><span class="line">        factory.setMessageConverter(myMessageConverter());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，您可以使用任何带有<code>@RabbitListener</code>Comments 的方法来使用工厂，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;someQueue&quot;, containerFactory=&quot;myFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以启用重试来处理侦听器引发异常的情况。默认情况下，使用<code>RejectAndDontRequeueRecoverer</code>，但是您可以定义自己的<code>MessageRecoverer</code>。重试用尽后，如果将代理配置为这样做，则消息将被拒绝并被丢弃或路由到死信交换。默认情况下，重试是禁用的。您也可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。</p>
<p>Tip</p>
<p>默认情况下，如果禁用了重试，并且侦听器引发了异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>，以便尝试进行零次重新传递或抛出<code>AmqpRejectAndDontRequeueException</code>来指示应拒绝该消息。后者是启用重试并达到最大传递尝试次数时使用的机制。</p>
<h2 id="ApacheKafka支持"><a href="#ApacheKafka支持" class="headerlink" title="ApacheKafka支持"></a>ApacheKafka支持</h2><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a target="_blank" rel="noopener" href="https://kafka.apache.org/">Apache Kafka</a>。</p>
<p>Kafka 配置由<code>spring.kafka.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.bootstrap-servers</span>=<span class="string">localhost:9092</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.group-id</span>=<span class="string">myGroup</span></span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>要在启动时创建主题，请添加<code>NewTopic</code>类型的 Bean。如果该主题已经存在，则将忽略 Bean。</p>
<p>有关更多受支持的选项，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/kafka/KafkaProperties.java">KafkaProperties</a>。</p>
<h3 id="发送消息-1"><a href="#发送消息-1" class="headerlink" title="发送消息"></a>发送消息</h3><p>Spring 的<code>KafkaTemplate</code>是自动配置的，您可以直接在自己的 bean 中自动对其进行布线，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaTemplate kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBean</span><span class="params">(KafkaTemplate kafkaTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>如果定义了属性<code>spring.kafka.producer.transaction-id-prefix</code>，则会自动配置<code>KafkaTransactionManager</code>。同样，如果定义了<code>RecordMessageConverter</code> bean，它将自动与自动配置的<code>KafkaTemplate</code>关联。</p>
<h3 id="接收消息-2"><a href="#接收消息-2" class="headerlink" title="接收消息"></a>接收消息</h3><p>存在 Apache Kafka 基础结构时，可以使用<code>@KafkaListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>KafkaListenerContainerFactory</code>，则会使用<code>spring.kafka.listener.*</code>中定义的键自动配置一个默认值。</p>
<p>以下组件在<code>someTopic</code>主题上创建侦听器终结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener(topics = &quot;someTopic&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了<code>KafkaTransactionManager</code> bean，它将自动与容器工厂关联。同样，如果定义了<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code> bean，它将自动与默认工厂关联。</p>
<p>Tip</p>
<p>自定义<code>ChainedKafkaTransactionManager</code>必须标记为<code>@Primary</code>，因为它通常引用自动配置的<code>KafkaTransactionManager</code> bean。</p>
<h3 id="Kafka流"><a href="#Kafka流" class="headerlink" title="Kafka流"></a>Kafka流</h3><p>用于 Apache Kafka 的 Spring 提供了一个工厂 bean 来创建<code>StreamsBuilder</code>对象并 Management 其流的生命周期。只要<code>kafka-streams</code>在 Classpath 上并且通过<code>@EnableKafkaStreams</code>Comments 启用 Kafka Streams，Spring Boot 就会自动配置所需的<code>KafkaStreamsConfiguration</code> bean。</p>
<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器。可以使用<code>spring.kafka.streams.application-id</code>配置前者，如果未设置，则默认为<code>spring.application.name</code>。后者可以全局设置，也可以仅针对流进行覆盖。</p>
<p>使用专用属性可以使用几个附加属性。可以使用<code>spring.kafka.streams.properties</code>名称空间设置其他任意 Kafka 属性。另请参见<a href="#Kafka的其他属性">第 33.3.4 节“其他 Kafka 属性”</a>。</p>
<p>要使用工厂 bean，只需将<code>StreamsBuilder</code>连接到您的<code>@Bean</code>中，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableKafkaStreams</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaStreamsExampleConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KStream&lt;Integer, String&gt; <span class="title">kStream</span><span class="params">(StreamsBuilder streamsBuilder)</span> </span>&#123;</span><br><span class="line">        KStream&lt;Integer, String&gt; stream = streamsBuilder.stream(<span class="string">&quot;ks1In&quot;</span>);</span><br><span class="line">        stream.map((k, v) -&gt; <span class="keyword">new</span> KeyValue&lt;&gt;(k, v.toUpperCase())).to(<span class="string">&quot;ks1Out&quot;</span>,</span><br><span class="line">                Produced.with(Serdes.Integer(), <span class="keyword">new</span> JsonSerde&lt;&gt;()));</span><br><span class="line">        <span class="keyword">return</span> stream;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，由它创建的<code>StreamBuilder</code>对象 Management 的流将自动启动。您可以使用<code>spring.kafka.streams.auto-startup</code>属性来自定义此行为。</p>
<h3 id="Kafka的其他属性"><a href="#Kafka的其他属性" class="headerlink" title="Kafka的其他属性"></a>Kafka的其他属性</h3><p>自动配置支持的属性显示在<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#A.常见的应用程序属性">附录 A，通用应用程序属性</a>中。请注意，在大多数情况下，这些属性(连字符或 camelCase)直接 Map 到 Apache Kafka 点缀属性。有关详细信息，请参阅 Apache Kafka 文档。</p>
<p>这些属性的前几个属性适用于所有组件(生产者，使用者，Management 员和流)，但如果您希望使用不同的值，则可以在组件级别上指定。 Apache Kafka 会指定重要性为 HIGH，MEDIUM 或 LOW 的属性。 Spring Boot 自动配置支持所有 HIGH 重要性属性，一些选定的 MEDIUM 和 LOW 属性以及任何没有默认值的属性。</p>
<p>Kafka 支持的属性的子集仅可通过<code>KafkaProperties</code>类直接使用。如果希望使用不直接支持的其他属性来配置生产者或使用者，请使用以下属性：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.properties.prop.one</span>=<span class="string">first</span></span><br><span class="line"><span class="meta">spring.kafka.admin.properties.prop.two</span>=<span class="string">second</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties.prop.three</span>=<span class="string">third</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties.prop.four</span>=<span class="string">fourth</span></span><br><span class="line"><span class="meta">spring.kafka.streams.properties.prop.five</span>=<span class="string">fifth</span></span><br></pre></td></tr></table></figure>
<p>这将公共<code>prop.one</code> Kafka 属性设置为<code>first</code>(适用于生产者，Consumer 和 Management 员)，将<code>prop.two</code> admin 属性设置为<code>second</code>，将<code>prop.three</code>Consumer 属性设置为<code>third</code>，将<code>prop.four</code>生产者属性设置为<code>fourth</code>，并将<code>prop.five</code> streams 属性设置为<code>fifth</code>。</p>
<p>您还可以如下配置 Spring Kafka <code>JsonDeserializer</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.consumer.value-deserializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties.spring.json.value.default.type</span>=<span class="string">com.example.Invoice</span></span><br><span class="line"><span class="meta">spring.kafka.consumer.properties.spring.json.trusted.packages</span>=<span class="string">com.example,org.acme</span></span><br></pre></td></tr></table></figure>
<p>同样，您可以禁用在 Headers 中发送类型信息的<code>JsonSerializer</code>默认行为：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.kafka.producer.value-serializer</span>=<span class="string">org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class="line"><span class="meta">spring.kafka.producer.properties.spring.json.add.type.headers</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>以这种方式设置的属性将覆盖 Spring Boot 显式支持的任何配置项。</p>
<h1 id="使用RestTemplate调用REST服务"><a href="#使用RestTemplate调用REST服务" class="headerlink" title="使用RestTemplate调用REST服务"></a>使用RestTemplate调用REST服务</h1><p>如果您需要从应用程序中调用远程 REST 服务，则可以使用 Spring Framework 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html">RestTemplate</a>类。由于<code>RestTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>RestTemplate</code> bean。但是，它会自动配置<code>RestTemplateBuilder</code>，可以在需要时创建<code>RestTemplate</code>实例。自动配置的<code>RestTemplateBuilder</code>确保将明智的<code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Details <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, Details.class, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p><code>RestTemplateBuilder</code>包含许多可用于快速配置<code>RestTemplate</code>的有用方法。例如，要添加 BASIC 身份验证支持，可以使用<code>builder.basicAuthentication(&quot;user&quot;, &quot;password&quot;).build()</code>。</p>
<h2 id="RestTemplate自定义"><a href="#RestTemplate自定义" class="headerlink" title="RestTemplate自定义"></a>RestTemplate自定义</h2><p><code>RestTemplate</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。</p>
<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此自定义仅影响构建器的使用。</p>
<p>要进行应用程序范围的附加自定义，请使用<code>RestTemplateCustomizer</code> bean。所有此类 bean 都会自动注册到自动配置的<code>RestTemplateBuilder</code>中，并应用于使用它构建的任何模板。</p>
<p>以下示例显示了一个定制程序，该定制程序为除<code>192.168.0.5</code>之外的所有主机配置代理的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyCustomizer</span> <span class="keyword">implements</span> <span class="title">RestTemplateCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestTemplate restTemplate)</span> </span>&#123;</span><br><span class="line">        HttpHost proxy = <span class="keyword">new</span> HttpHost(<span class="string">&quot;proxy.example.com&quot;</span>);</span><br><span class="line">        HttpClient httpClient = HttpClientBuilder.create()</span><br><span class="line">                .setRoutePlanner(<span class="keyword">new</span> DefaultProxyRoutePlanner(proxy) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> HttpHost <span class="title">determineProxy</span><span class="params">(HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">                            HttpRequest request, HttpContext context)</span></span></span><br><span class="line"><span class="function">                            <span class="keyword">throws</span> HttpException </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (target.getHostName().equals(<span class="string">&quot;192.168.0.5&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.determineProxy(target, request, context);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;).build();</span><br><span class="line">        restTemplate.setRequestFactory(</span><br><span class="line">                <span class="keyword">new</span> HttpComponentsClientHttpRequestFactory(httpClient));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，最极端(也是很少使用)的选项是创建自己的<code>RestTemplateBuilder</code> bean。这样做会关闭<code>RestTemplateBuilder</code>的自动配置，并防止使用任何<code>RestTemplateCustomizer</code> bean。</p>
<h1 id="使用WebClient调用REST服务"><a href="#使用WebClient调用REST服务" class="headerlink" title="使用WebClient调用REST服务"></a>使用WebClient调用REST服务</h1><p>如果您的 Classpath 中包含 Spring WebFlux，则还可以选择使用<code>WebClient</code>来调用远程 REST 服务。与<code>RestTemplate</code>相比，此 Client 端具有更多的功能感，并且具有完全的 Reactive。您可以在专用的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-client">Spring Framework 文档中的部分</a>中了解有关<code>WebClient</code>的更多信息。</p>
<p>Spring Boot 为您创建并预配置了<code>WebClient.Builder</code>；强烈建议将其注入您的组件中并使用它来创建<code>WebClient</code>实例。 Spring Boot 正在配置该构建器以共享 HTTP 资源，以与服务器相同的方式反映编解码器的设置(请参阅<a href="#带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器">WebFlux HTTP 编解码器自动配置</a>，以及更多。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebClient.Builder webClientBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webClient = webClientBuilder.baseUrl(<span class="string">&quot;http://example.org&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Details&gt; <span class="title">someRestCall</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/&#123;name&#125;/details&quot;</span>, name)</span><br><span class="line">                        .retrieve().bodyToMono(Details.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="WebClient运行时"><a href="#WebClient运行时" class="headerlink" title="WebClient运行时"></a>WebClient运行时</h2><p>Spring Boot 将根据应用程序 Classpath 上可用的库自动检测要使用哪个<code>ClientHttpConnector</code>来驱动<code>WebClient</code>。目前，还支持 Reactor Netty 和 Jetty RS Client 端。</p>
<p>默认情况下，<code>spring-boot-starter-webflux</code>启动程序取决于<code>io.projectreactor.netty:reactor-netty</code>，这同时带来了服务器和 Client 端实现。如果选择使用 Jetty 作为反应式服务器，则应在 Jetty 反应式 HTTP Client 端库<code>org.eclipse.jetty:jetty-reactive-httpclient</code>上添加依赖项。对服务器和 Client 端使用相同的技术具有其优势，因为它将自动在 Client 端和服务器之间共享 HTTP 资源。</p>
<p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。</p>
<p>如果您希望为 Client 端覆盖该选择，则可以定义自己的<code>ClientHttpConnector</code> bean 并完全控制 Client 端配置。</p>
<p>您可以了解有关<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-client-builder">Spring Framework 参考文档中的 WebClient 配置选项</a>的更多信息。</p>
<h2 id="WebClient自定义"><a href="#WebClient自定义" class="headerlink" title="WebClient自定义"></a>WebClient自定义</h2><p><code>WebClient</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。</p>
<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>WebClient.Builder</code>，然后根据需要调用其方法。 <code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有 Client 端中。如果要使用同一构建器创建多个 Client 端，则也可以考虑使用<code>WebClient.Builder other = builder.clone();</code>克隆该构建器。</p>
<p>要对所有<code>WebClient.Builder</code>实例进行应用程序级的附加自定义，您可以声明<code>WebClientCustomizer</code> bean 并在注入点更改<code>WebClient.Builder</code>。</p>
<p>最后，您可以使用原始 API 并使用<code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或<code>WebClientCustomizer</code>。</p>
<h1 id="Validation"><a href="#Validation" class="headerlink" title="Validation"></a>Validation</h1><p>只要 JSR-303 实现(例如 Hibernate 验证器)位于 Classpath 上，就会自动启用 Bean 验证 1.1 支持的方法验证功能。这样就可以在 Bean 方法的参数和/或返回值上使用<code>javax.validation</code>约束 Comments。具有此类 Comments 方法的目标类需要在类型级别使用<code>@Validated</code>Comments 进行 Comments，以便在其方法中搜索内联约束 Comments。</p>
<p>例如，以下服务触发第一个参数的验证，确保其大小在 8 到 10 之间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Archive <span class="title">findByCodeAndAuthor</span><span class="params">(<span class="meta">@Size(min = 8, max = 10)</span> String code,</span></span></span><br><span class="line"><span class="function"><span class="params">            Author author)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h1><p>Spring 框架提供了一种使用<code>JavaMailSender</code>接口发送电子邮件的简单抽象方法，而 Spring Boot 为它提供了自动配置以及启动程序模块。</p>
<p>Tip</p>
<p>有关如何使用<code>JavaMailSender</code>的详细说明，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#mail">reference documentation</a>。</p>
<p>如果<code>spring.mail.host</code>和相关库(由<code>spring-boot-starter-mail</code>定义)可用，则如果不存在默认库<code>JavaMailSender</code>，则将创建该库。可以通过<code>spring.mail</code>名称空间中的配置项进一步自定义发送方。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java">MailProperties</a>。</p>
<p>特别是，某些默认超时值是无限的，您可能需要更改该值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.properties.mail.smtp.connectiontimeout</span>=<span class="string">5000</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.timeout</span>=<span class="string">3000</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.writetimeout</span>=<span class="string">5000</span></span><br></pre></td></tr></table></figure>
<p>也可以使用 JNDI 中的现有<code>Session</code>配置<code>JavaMailSender</code>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mail.jndi-name</span>=<span class="string">mail/Session</span></span><br></pre></td></tr></table></figure>
<p>设置<code>jndi-name</code>时，它优先于所有其他与会话相关的其他设置。</p>
<h1 id="JTA-的分布式事务"><a href="#JTA-的分布式事务" class="headerlink" title="JTA 的分布式事务"></a>JTA 的分布式事务</h1><p>Spring Boot 通过使用<a target="_blank" rel="noopener" href="http://www.atomikos.com/">Atomikos</a>或<a target="_blank" rel="noopener" href="https://github.com/bitronix/btm">Bitronix</a>嵌入式事务 Management 器，支持跨多个 XA 资源的分布式 JTA 事务。部署到合适的 Java EE 应用程序服务器时，还支持 JTA 事务。</p>
<p>当检测到 JTA 环境时，使用 Spring 的<code>JtaTransactionManager</code>来 Management 事务。自动配置的 JMS，DataSource 和 JPA Bean 已升级为支持 XA 事务。您可以使用标准的 Spring 习惯用法(例如<code>@Transactional</code>)来参与分布式事务。如果您在 JTA 环境中，并且仍要使用本地事务，则可以将<code>spring.jta.enabled</code>属性设置为<code>false</code>以禁用 JTA 自动配置。</p>
<h2 id="使用Atomikos事物管理器"><a href="#使用Atomikos事物管理器" class="headerlink" title="使用Atomikos事物管理器"></a>使用Atomikos事物管理器</h2><p><a target="_blank" rel="noopener" href="https://www.atomikos.com/">Atomikos</a>是流行的开源事务 Management 器，可以嵌入到您的 Spring Boot 应用程序中。您可以使用<code>spring-boot-starter-jta-atomikos</code> Starter 引入适当的 Atomikos 库。 Spring Boot 自动配置 Atomikos 并确保将适当的<code>depends-on</code>设置应用于您的 Spring Bean，以正确启动和关闭 Sequences。</p>
<p>默认情况下，Atomikos 事务日志将写入应用程序主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录。您可以通过在<code>application.properties</code>文件中设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.atomikos.properties</code>开头的属性也可以用于自定义 Atomikos <code>UserTransactionServiceImp</code>。有关完整的详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html">AtomikosProperties Javadoc</a>。</p>
<p>Note</p>
<p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Atomikos 实例配置一个唯一的 ID。默认情况下，此 ID 是运行 Atomikos 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</p>
<h2 id="使用Bitronix事物管理器"><a href="#使用Bitronix事物管理器" class="headerlink" title="使用Bitronix事物管理器"></a>使用Bitronix事物管理器</h2><p><a target="_blank" rel="noopener" href="https://github.com/bitronix/btm">Bitronix</a>是流行的开源 JTA 事务 Management 器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>Starter 程序将适当的 Bitronix 依赖项添加到您的项目中。与 Atomikos 一样，Spring Boot 自动配置 Bitronix 并对您的 bean 进行后处理，以确保启动和关闭 Sequences 正确。</p>
<p>默认情况下，Bitronix 事务日志文件(<code>part1.btm</code>和<code>part2.btm</code>)被写入应用程序主目录中的<code>transaction-logs</code>目录。您可以通过设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.bitronix.properties</code>开头的属性也绑定到<code>bitronix.tm.Configuration</code> bean，从而可以进行完全自定义。有关详情，请参见<a target="_blank" rel="noopener" href="https://github.com/bitronix/btm/wiki/Transaction-manager-configuration">Bitronix documentation</a>。</p>
<p>Note</p>
<p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Bitronix 实例配置唯一的 ID。默认情况下，此 ID 是运行 Bitronix 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</p>
<h2 id="使用JavaEE托管事务管理器"><a href="#使用JavaEE托管事务管理器" class="headerlink" title="使用JavaEE托管事务管理器"></a>使用JavaEE托管事务管理器</h2><p>如果将 Spring Boot 应用程序打包为<code>war</code>或<code>ear</code>文件并将其部署到 Java EE 应用程序服务器，则可以使用应用程序服务器的内置事务 Management 器。 Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>，<code>java:comp/TransactionManager</code>等)来自动配置事务 Management 器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器 Management 并通过 JNDI 公开。 Spring Boot 通过在 JNDI 路径(<code>java:/JmsXA</code>或<code>java:/XAConnectionFactory</code>)中查找<code>ConnectionFactory</code>来尝试自动配置 JMS，您可以使用<a href="#连接到JNDI数据源">spring.datasource.jndi-name property</a>来配置<code>DataSource</code>。</p>
<h2 id="混合XA和非XAJMS连接"><a href="#混合XA和非XAJMS连接" class="headerlink" title="混合XA和非XAJMS连接"></a>混合XA和非XAJMS连接</h2><p>使用 JTA 时，主要的 JMS <code>ConnectionFactory</code> bean 支持 XA，并参与分布式事务。在某些情况下，您可能希望通过使用非 XA <code>ConnectionFactory</code>处理某些 JMS 消息。例如，您的 JMS 处理逻辑可能需要比 XA 超时更长的时间。</p>
<p>如果要使用非 XA <code>ConnectionFactory</code>，则可以注入<code>nonXaJmsConnectionFactory</code> bean 而不是<code>@Primary</code> <code>jmsConnectionFactory</code> bean。为了保持一致性，还使用 Bean 别名<code>xaJmsConnectionFactory</code>提供了<code>jmsConnectionFactory</code> bean。</p>
<p>以下示例显示了如何注入<code>ConnectionFactory</code>个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inject the primary (XA aware) ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ConnectionFactory defaultConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;xaJmsConnectionFactory&quot;)</span></span><br><span class="line"><span class="keyword">private</span> ConnectionFactory xaConnectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inject the non-XA aware ConnectionFactory</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(&quot;nonXaJmsConnectionFactory&quot;)</span></span><br><span class="line"><span class="keyword">private</span> ConnectionFactory nonXaConnectionFactory;</span><br></pre></td></tr></table></figure>
<h2 id="支持备用嵌入式事务Management器"><a href="#支持备用嵌入式事务Management器" class="headerlink" title="支持备用嵌入式事务Management器"></a>支持备用嵌入式事务Management器</h2><p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java">XAConnectionFactoryWrapper</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java">XADataSourceWrapper</a>接口可用于支持其他嵌入式事务 Management 器。这些接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code> bean 并将它们作为常规<code>ConnectionFactory</code>和<code>DataSource</code> bean 公开，它们透明地注册了分布式事务。数据源和 JMS 自动配置使用 JTA 变体，前提是您拥有<code>JtaTransactionManager</code> bean 和在<code>ApplicationContext</code>中注册了适当的 XA 包装 bean。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java">BitronixXAConnectionFactoryWrapper</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java">BitronixXADataSourceWrapper</a>提供了有关如何编写 XA 包装程序的良好示例。</p>
<h1 id="Hazelcast"><a href="#Hazelcast" class="headerlink" title="Hazelcast"></a>Hazelcast</h1><p>如果<a target="_blank" rel="noopener" href="https://hazelcast.com/">Hazelcast</a>位于 Classpath 上，并且找到了合适的配置，则 Spring Boot 会自动配置一个<code>HazelcastInstance</code>，您可以将其插入到应用程序中。</p>
<p>如果定义一个<code>com.hazelcast.config.Config</code> bean，Spring Boot 将使用它。如果您的配置定义了一个实例名称，Spring Boot 会尝试查找一个现有实例，而不是创建一个新实例。</p>
<p>您还可以指定<code>hazelcast.xml</code>配置文件以通过配置使用，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.hazelcast.config</span>=<span class="string">classpath:config/my-hazelcast.xml</span></span><br></pre></td></tr></table></figure>
<p>否则，Spring Boot 会尝试从默认位置：工作目录中或 Classpath 根目录中的<code>hazelcast.xml</code>查找 Hazelcast 配置。我们还检查<code>hazelcast.config</code>系统属性是否设置。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="http://docs.hazelcast.org/docs/latest/manual/html-single/">Hazelcast documentation</a>。</p>
<p>如果<code>hazelcast-client</code>存在于 Classpath 中，则 Spring Boot 首先尝试通过检查以下配置选项来创建 Client 端：</p>
<ul>
<li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在。</li>
<li><code>spring.hazelcast.config</code>属性定义的配置文件。</li>
<li><code>hazelcast.client.config</code>系统属性的存在。</li>
<li>工作目录中或 Classpath 根目录中的<code>hazelcast-client.xml</code>。</li>
</ul>
<p>Note</p>
<p>Spring Boot 也具有<a href="#Hazelcast缓存">对 Hazelcast 的显式缓存支持</a>。如果启用了缓存，则<code>HazelcastInstance</code>将自动包装在<code>CacheManager</code>实现中。</p>
<h1 id="QuartzScheduler"><a href="#QuartzScheduler" class="headerlink" title="QuartzScheduler"></a>QuartzScheduler</h1><p>Spring Boot 为使用<a target="_blank" rel="noopener" href="http://www.quartz-scheduler.org/">Quartz scheduler</a>提供了许多便利，其中包括<code>spring-boot-starter-quartz</code>“ Starter”。如果 Quartz 可用，则会自动配置<code>Scheduler</code>(通过<code>SchedulerFactoryBean</code>抽象)。</p>
<p>以下类型的 Bean 被自动拾取并与<code>Scheduler</code>关联：</p>
<ul>
<li><code>JobDetail</code>：定义特定的作业。可以使用<code>JobBuilder</code> API 构建<code>JobDetail</code>实例。</li>
<li><code>Calendar</code> .</li>
<li><code>Trigger</code>：定义何时触发特定作业。</li>
</ul>
<p>默认情况下，使用内存中的<code>JobStore</code>。但是，如果您的应用程序中有<code>DataSource</code> bean 可用，并且相应地配置了<code>spring.quartz.job-store-type</code>属性，则可以配置基于 JDBC 的存储，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.job-store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></table></figure>
<p>使用 JDBC 存储时，可以在启动时初始化模式，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.quartz.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>Warning</p>
<p>默认情况下，使用 Quartz 库随附的标准脚本检测并初始化数据库。这些脚本删除现有表，并在每次重新启动时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性来提供自定义脚本。</p>
<p>要让 Quartz 使用除应用程序主<code>DataSource</code>之外的<code>DataSource</code>，请声明<code>DataSource</code> bean，并用<code>@QuartzDataSource</code>Comments 其<code>@Bean</code>方法。这样做可确保<code>SchedulerFactoryBean</code>使用 Quartz 专用的<code>DataSource</code>并用于模式初始化。</p>
<p>默认情况下，通过配置创建的作业将不会覆盖从持久性作业存储中读取的已注册作业。要启用覆盖现有作业定义的功能，请设置<code>spring.quartz.overwrite-existing-jobs</code>属性。</p>
<p>可以使用<code>spring.quartz</code>属性和<code>SchedulerFactoryBeanCustomizer</code> bean 自定义 Quartz Scheduler 配置，从而可以通过编程方式自定义<code>SchedulerFactoryBean</code>。可以使用<code>spring.quartz.properties.*</code>定制高级 Quartz 配置属性。</p>
<blockquote>
<p>Note</p>
<p>特别是，<code>Executor</code> bean 没有与调度程序相关联，因为 Quartz 提供了一种通过<code>spring.quartz.properties</code>配置调度程序的方法。如果您需要自定义任务 Actuator，请考虑实现<code>SchedulerFactoryBeanCustomizer</code>。</p>
</blockquote>
<p>作业可以定义设置器以注入数据 Map 属性。常规 bean 也可以类似的方式注入，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJob</span> <span class="keyword">extends</span> <span class="title">QuartzJobBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService myService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject &quot;MyService&quot; bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyService</span><span class="params">(MyService myService)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inject the &quot;name&quot; job data property</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">executeInternal</span><span class="params">(JobExecutionContext context)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="任务执行和计划"><a href="#任务执行和计划" class="headerlink" title="任务执行和计划"></a>任务执行和计划</h1><p>在上下文中没有<code>TaskExecutor</code> bean 的情况下，Spring Boot 会使用合理的默认值自动配置<code>ThreadPoolTaskExecutor</code>，这些默认值可以自动与异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理相关联。</p>
<p>线程池使用 8 个核心线程，这些线程可以根据负载增长和收缩。可以使用<code>spring.task.execution</code>名称空间对这些默认设置进行微调，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.task.execution.pool.max-threads</span>=<span class="string">16</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.queue-capacity</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">spring.task.execution.pool.keep-alive</span>=<span class="string">10s</span></span><br></pre></td></tr></table></figure>
<p>这会将线程池更改为使用有界队列，以便当队列已满(100 个任务)时，线程池最多增加到 16 个线程。当线程空闲 10 秒(而不是默认情况下的 60 秒)时，回收线程会使池的收缩更加激进。</p>
<p>如果需要将<code>ThreadPoolTaskScheduler</code>与计划的任务执行(<code>@EnableScheduling</code>)关联，也可以对其进行自动配置。默认情况下，线程池使用一个线程，可以使用<code>spring.task.scheduling</code>名称空间对这些设置进行微调。</p>
<p>如果需要创建自定义执行程序或调度程序，则<code>TaskExecutorBuilder</code> bean 和<code>TaskSchedulerBuilder</code> bean 在上下文中都可用。</p>
<h1 id="Spring整合"><a href="#Spring整合" class="headerlink" title="Spring整合"></a>Spring整合</h1><p>Spring Boot 为使用<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-integration/">Spring Integration</a>提供了许多便利，其中包括<code>spring-boot-starter-integration</code>“ Starter”。 Spring Integration 在消息传递以及其他传输(例如 HTTP，TCP 等)上提供了抽象。如果您的 Classpath 上有 Spring Integration，则可以通过<code>@EnableIntegration</code>Comments 对其进行初始化。</p>
<p>Spring Boot 还配置了一些功能，这些功能由其他 Spring Integration 模块的存在触发。如果<code>spring-integration-jmx</code>也在 Classpath 上，则消息处理统计信息将通过 JMX 发布。如果<code>spring-integration-jdbc</code>可用，则可以在启动时创建默认数据库架构，如以下行所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.integration.jdbc.initialize-schema</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>
<p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java">IntegrationAutoConfiguration</a>和<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java">IntegrationProperties</a>类。</p>
<p>默认情况下，如果存在 Micrometer <code>meterRegistry</code> bean，那么 Spring Integration Metrics 将由 Micrometer Management。如果您希望使用旧版 Spring Integration Metrics，请将<code>DefaultMetricsFactory</code> bean 添加到应用程序上下文中。</p>
<h1 id="SpringSession"><a href="#SpringSession" class="headerlink" title="SpringSession"></a>SpringSession</h1><p>Spring Boot 为广泛的数据存储提供<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-session/">Spring Session</a>自动配置。构建 Servlet Web 应用程序时，可以自动配置以下存储：</p>
<ul>
<li>JDBC</li>
<li>Redis</li>
<li>Hazelcast</li>
<li>MongoDB</li>
</ul>
<p>构建反应式 Web 应用程序时，可以自动配置以下存储：</p>
<ul>
<li>Redis</li>
<li>MongoDB</li>
</ul>
<p>如果 Classpath 上只有一个 Spring Session 模块，Spring Boot 会自动使用该存储实现。如果您有多个实现，则必须选择要用于存储会话的<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java">StoreType</a>。例如，要将 JDBC 用作后端存储，可以按以下方式配置应用程序：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.session.store-type</span>=<span class="string">jdbc</span></span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>您可以通过将<code>store-type</code>设置为<code>none</code>来禁用 Spring Session。</p>
<p>每个 Store 都有特定的其他设置。例如，可以为 JDBC 存储定制表的名称，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.session.jdbc.table-name</span>=<span class="string">SESSIONS</span></span><br></pre></td></tr></table></figure>
<p>要设置会话超时，您可以使用<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将回退到<code>server.servlet.session.timeout</code>的值。</p>
<h1 id="通过JMX进行监视和管理"><a href="#通过JMX进行监视和管理" class="headerlink" title="通过JMX进行监视和管理"></a>通过JMX进行监视和管理</h1><p>Java Management 扩展(JMX)提供了监视和 Management 应用程序的标准机制。默认情况下，Spring Boot 创建一个 ID 为<code>mbeanServer</code>的<code>MBeanServer</code> bean，并公开任何带有 Spring JMX Comments(<code>@ManagedResource</code>，<code>@ManagedAttribute</code>或<code>@ManagedOperation</code>)的 bean。</p>
<p>有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java">JmxAutoConfiguration</a>类。</p>
<h1 id="Testing"><a href="#Testing" class="headerlink" title="Testing"></a>Testing</h1><p>Spring Boot 提供了许多 Util 和 Comments，可以在测试应用程序时提供帮助。测试支持由两个模块提供：<code>spring-boot-test</code>包含核心项目，而<code>spring-boot-test-autoconfigure</code>支持自动配置测试。</p>
<p>大多数开发人员使用<code>spring-boot-starter-test</code>“Starter 程序”，该程序同时导入 Spring Boot 测试模块以及 JUnit，AssertJ，Hamcrest 和许多其他有用的库。</p>
<h2 id="测试范围依赖性"><a href="#测试范围依赖性" class="headerlink" title="测试范围依赖性"></a>测试范围依赖性</h2><p><code>spring-boot-starter-test</code>“Starter”(位于<code>test</code> <code>scope</code>中)包含以下提供的库：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://junit.org/">JUnit</a>：用于对 Java 应用程序进行单元测试的实际标准。</li>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#integration-testing">Spring Test</a>和 Spring Boot 测试：对 Spring Boot 应用程序的 Util 和集成测试支持。</li>
<li><a target="_blank" rel="noopener" href="https://joel-costigliola.github.io/assertj/">AssertJ</a>：流畅的 assert 库。</li>
<li><a target="_blank" rel="noopener" href="http://hamcrest.org/JavaHamcrest/">Hamcrest</a>：匹配器对象库(也称为约束或谓词)。</li>
<li><a target="_blank" rel="noopener" href="http://mockito.org/">Mockito</a>：Java 模拟框架。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/skyscreamer/JSONassert">JSONassert</a>：JSON 的 assert 库。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jayway/JsonPath">JsonPath</a>：JSON 的 XPath。</li>
</ul>
<p>通常，我们发现这些通用库在编写测试时很有用。如果这些库不满足您的需求，则可以添加自己的其他测试依赖项。</p>
<h2 id="测试Spring应用程序"><a href="#测试Spring应用程序" class="headerlink" title="测试Spring应用程序"></a>测试Spring应用程序</h2><p>依赖注入的主要优点之一是，它应该使您的代码更易于进行单元测试。您可以使用<code>new</code>运算符实例化对象，而无需使用 Spring。您也可以使用<em> mock objects </em>代替 true 的依赖。</p>
<p>通常，您需要超越单元测试并开始集成测试(使用 Spring <code>ApplicationContext</code>)。能够进行集成测试而无需部署应用程序或连接到其他基础结构，这很有用。</p>
<p>Spring 框架包括用于此类集成测试的专用测试模块。您可以直接向<code>org.springframework:spring-test</code>声明依赖项，也可以使用<code>spring-boot-starter-test</code>“启动器”将其引入。</p>
<p>如果以前没有使用过<code>spring-test</code>模块，则应先阅读 Spring Framework 参考文档的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testing">relevant section</a>。</p>
<h2 id="测试SpringBoot应用程序"><a href="#测试SpringBoot应用程序" class="headerlink" title="测试SpringBoot应用程序"></a>测试SpringBoot应用程序</h2><p>Spring Boot 应用程序是 Spring <code>ApplicationContext</code>，因此除了用普通的 Spring 上下文进行测试之外，无需执行任何其他特殊操作即可对其进行测试。</p>
<p>Note</p>
<p>仅当您使用<code>SpringApplication</code>创建它时，Spring Boot 的外部属性，日志记录和其他功能才默认安装在上下文中。</p>
<p>Spring Boot 提供了<code>@SpringBootTest</code>注解，可以在需要 Spring Boot 功能时用作标准<code>spring-test</code> <code>@ContextConfiguration</code>注解的替代方法。Comments 由<a href="#检测测试配置">通过 SpringApplication 创建在测试中使用的 ApplicationContext</a>起作用。除了<code>@SpringBootTest</code>之外，还为应用程序<a href="#自动配置的测试">测试更具体的切片</a>提供了许多其他 Comments。</p>
<p>Tip</p>
<p>如果您使用的是 JUnit 4，请不要忘记也将<code>@RunWith(SpringRunner.class)</code>添加到测试中，否则 Comments 将被忽略。如果您使用的是 JUnit 5，则无需添加等效的<code>@ExtendWith(SpringExtension)</code>作为<code>@SpringBootTest</code>，并且其他<code>@…Test</code>Comments 已经对其进行了 Comments。</p>
<p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。您可以使用<code>@SpringBootTest</code>的<code>webEnvironment</code>属性来进一步优化测试的运行方式：</p>
<ul>
<li><code>MOCK</code>(默认)：加载 Web <code>ApplicationContext</code>并提供模拟 Web 环境。使用此 Comments 时，不会启动嵌入式服务器。如果您的 Classpath 中没有 Web 环境，则此模式将透明地退回到创建常规的非 Web <code>ApplicationContext</code>。它可以与<a href="#在模拟环境中进行测试">@AutoConfigureMockMvc 或@AutoConfigureWebTestClient</a>结合使用，以对 Web 应用程序进行基于模拟的测试。</li>
<li><code>RANDOM_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动并在随机端口上侦听。</li>
<li><code>DEFINED_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动，并在已定义的端口(来自<code>application.properties</code>)或默认端口<code>8080</code>上进行侦听。</li>
<li><code>NONE</code>：使用<code>SpringApplication</code>加载<code>ApplicationContext</code>，但不提供<em>任何</em>网络环境(模拟或其他方式)。</li>
</ul>
<blockquote>
<p>Note</p>
<p>如果您的测试是<code>@Transactional</code>，则默认情况下它将在每个测试方法的末尾回滚事务。但是，由于将这种安排与<code>RANDOM_PORT</code>或<code>DEFINED_PORT</code>一起使用隐式提供了 true 的 servlet 环境，因此 HTTP Client 端和服务器在单独的线程中运行，因此在单独的事务中运行。在这种情况下，服务器上启动的任何事务都不会回滚。</p>
<p>Note</p>
<p>如果您的应用程序对 Management 服务器使用其他端口，则<code>@SpringBootTest</code>和<code>webEnvironment = WebEnvironment.RANDOM_PORT</code>还将在单独的随机端口上启动 Management 服务器。</p>
</blockquote>
<h3 id="检测Web应用程序类型"><a href="#检测Web应用程序类型" class="headerlink" title="检测Web应用程序类型"></a>检测Web应用程序类型</h3><p>如果 Spring MVC 可用，则配置基于常规 MVC 的应用程序上下文。如果您只有 Spring WebFlux，我们将检测到该情况并配置基于 WebFlux 的应用程序上下文。</p>
<p>如果两者都存在，则 Spring MVC 优先。如果要在这种情况下测试反应式 Web 应用程序，则必须设置<code>spring.main.web-application-type</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(properties = &quot;spring.main.web-application-type=reactive&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebFluxTests</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测测试配置"><a href="#检测测试配置" class="headerlink" title="检测测试配置"></a>检测测试配置</h3><p>如果您熟悉 Spring Test Framework，则可能会习惯使用<code>@ContextConfiguration(classes=…)</code>来指定要加载哪个 Spring <code>@Configuration</code>。另外，您可能经常在测试中使用嵌套的<code>@Configuration</code>类。</p>
<p>在测试 Spring Boot 应用程序时，通常不需要这样做。只要您没有明确定义 Spring Boot 的<code>@*Test</code>注解，它就会自动搜索您的主要配置。</p>
<p>搜索算法从包含测试的程序包开始工作，直到找到带有<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration</code>Comments 的类。只要您以一种明智的方式<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用SpringBoot/#构建代码">结构化代码</a>，通常就可以找到您的主要配置。</p>
<p>Note</p>
<p>如果您使用<a href="#自动配置的测试">测试 Comments 以测试应用程序的更具体部分</a>，则应避免在<a href="#用户配置和切片">Main 方法的应用程序类别</a>上添加特定于特定区域的配置设置。</p>
<p><code>@SpringBootApplication</code>的基础组件扫描配置定义了用于确保切片按预期工作的排除筛选器。如果在<code>@SpringBootApplication</code>Comments 的类上使用显式的<code>@ComponentScan</code>指令，请注意这些过滤器将被禁用。如果使用切片，则应重新定义它们。</p>
<p>如果要自定义主要配置，则可以使用嵌套的<code>@TestConfiguration</code>类。与将使用嵌套的<code>@Configuration</code>类代替应用程序的主要配置不同的是，除了使用应用程序的主要配置之外，还使用嵌套的<code>@TestConfiguration</code>类。</p>
<p>Note</p>
<p>Spring 的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置(无论如何发现)，加载上下文的潜在耗时过程就只会发生一次。</p>
<h3 id="排除测试配置"><a href="#排除测试配置" class="headerlink" title="排除测试配置"></a>排除测试配置</h3><p>如果您的应用程序使用组件扫描(例如，如果使用<code>@SpringBootApplication</code>或<code>@ComponentScan</code>)，则可能会偶然发现到处都是为特定测试创建的顶级配置类。</p>
<p>正如我们<a href="#检测测试配置">早看过</a>，<code>@TestConfiguration</code>可以在测试的内部类上使用以自定义主要配置。当放在顶级类上时，<code>@TestConfiguration</code>指示<code>src/test/java</code>中的类不应通过扫描来拾取。然后，可以在需要的位置显式导入该类，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Import(MyTestsConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note</p>
<p>如果您直接使用<code>@ComponentScan</code>(即不是通过<code>@SpringBootApplication</code>)，则需要向其注册<code>TypeExcludeFilter</code>。有关详情，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html">the Javadoc</a>。</p>
</blockquote>
<h3 id="在模拟环境中进行测试"><a href="#在模拟环境中进行测试" class="headerlink" title="在模拟环境中进行测试"></a>在模拟环境中进行测试</h3><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。如果您有要在此模拟环境下进行测试的 Web 终结点，则可以另外配置<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework">MockMvc</a>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockMvcExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/&quot;</span>)).andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>如果您只想关注 Web 层而不想开始完整的<code>ApplicationContext</code>，请考虑<a href="#自动配置的SpringMVC测试">使用@WebMvcTest 代替</a>。</p>
<p>或者，您可以配置<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests">WebTestClient</a>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureWebTestClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/&quot;</span>).exchange().expectStatus().isOk()</span><br><span class="line">                .expectBody(String.class).isEqualTo(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用正在运行的服务器进行测试"><a href="#使用正在运行的服务器进行测试" class="headerlink" title="使用正在运行的服务器进行测试"></a>使用正在运行的服务器进行测试</h3><p>如果需要启动完全运行的服务器，建议您使用随机端口。如果您使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，则每次运行测试时都会随机选择一个可用端口。</p>
<p><code>@LocalServerPort</code>注解可用于<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#在运行时发现HTTP端口">注入实际使用的端口</a>进入您的测试。为了方便起见，需要对启动的服务器进行 REST 调用的测试可以另外<code>@Autowire</code> a <a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests">WebTestClient</a>，该解析可以解析到正在运行的服务器的相对链接，并带有用于验证响应的专用 API，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortWebTestClientExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/&quot;</span>).exchange().expectStatus().isOk()</span><br><span class="line">                .expectBody(String.class).isEqualTo(&quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此设置在 Classpath 上需要<code>spring-webflux</code>。如果您不能或不会添加 webflux，Spring Boot 还将提供<code>TestRestTemplate</code>功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomPortTestRestTemplateExampleTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String body = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">&quot;/&quot;</span>, String.class);</span><br><span class="line">        assertThat(body).isEqualTo(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用JMX"><a href="#使用JMX" class="headerlink" title="使用JMX"></a>使用JMX</h3><p>由于测试上下文框架缓存上下文，因此默认情况下禁用 JMX 以防止相同组件在同一域上注册。如果此类测试需要访问<code>MBeanServer</code>，也请考虑将其标记为脏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(properties = &quot;spring.jmx.enabled=true&quot;)</span></span><br><span class="line"><span class="meta">@DirtiesContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleJmxTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MBeanServer mBeanServer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟bean和Spybean"><a href="#模拟bean和Spybean" class="headerlink" title="模拟bean和Spybean"></a>模拟bean和Spybean</h3><p>运行测试时，有时有必要在应用程序上下文中模拟某些组件。例如，您可能在开发期间无法使用某些远程服务的外观。当您要模拟在实际环境中可能难以触发的故障时，模拟功能也很有用。</p>
<p>Spring Boot 包含<code>@MockBean</code>注解，可用于为<code>ApplicationContext</code>中的 bean 定义 Mockito 模拟。您可以使用 Comments 添加新的 bean 或替换单个现有的 bean 定义。注解可以直接用于测试类，测试中的字段或<code>@Configuration</code>类和字段。在字段上使用时，还将注入创建的模拟的实例。每种测试方法后，模拟 bean 都会自动重置。</p>
<p>Note</p>
<p>如果您的测试使用 Spring Boot 的测试 Comments 之一(例如<code>@SpringBootTest</code>)，那么此功能将自动启用。要以其他方式使用此功能，必须显式添加侦听器，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestExecutionListeners(MockitoTestExecutionListener.class)</span></span><br></pre></td></tr></table></figure>
<p>下面的示例使用模拟实现替换现有的<code>RemoteService</code> bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> RemoteService remoteService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Reverser reverser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exampleTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// RemoteService has been injected into the reverser bean</span></span><br><span class="line">        given(<span class="keyword">this</span>.remoteService.someCall()).willReturn(<span class="string">&quot;mock&quot;</span>);</span><br><span class="line">        String reverse = reverser.reverseSomeCall();</span><br><span class="line">        assertThat(reverse).isEqualTo(<span class="string">&quot;kcom&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，您可以使用<code>@SpyBean</code>将任何现有的 bean 与 Mockito <code>spy</code>包装在一起。有关详细信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html">Javadoc</a>。</p>
<p>Note</p>
<p>Spring 的测试框架在测试之间缓存应用程序上下文，并为共享相同配置的测试重用上下文，而<code>@MockBean</code>或<code>@SpyBean</code>的使用会影响缓存键，这很可能会增加上下文的数量。</p>
<p>Tip</p>
<p>如果您使用<code>@SpyBean</code>监视具有通过名称引用参数的<code>@Cacheable</code>方法的 bean，则您的应用程序必须使用<code>-parameters</code>进行编译。这样可以确保一旦侦察到 bean，就可以将参数名称用于缓存基础结构。</p>
<h3 id="自动配置的测试"><a href="#自动配置的测试" class="headerlink" title="自动配置的测试"></a>自动配置的测试</h3><p>Spring Boot 的自动配置系统适用于应用程序，但有时对于测试来说可能有点过多。它通常仅有助于加载测试应用程序“切片”所需的配置部分。例如，您可能想要测试 Spring MVC 控制器是否正确 Map 了 URL，并且您不想在这些测试中涉及数据库调用，或者您想要测试 JPA 实体，并且对那些 JPA 实体不感兴趣。测试运行。</p>
<p><code>spring-boot-test-autoconfigure</code>模块包含许多 Comments，可用于自动配置此类“切片”。它们中的每一个都以类似的方式工作，提供了一个<code>@…Test</code>注解，该注解加载了<code>ApplicationContext</code>和一个或多个<code>@AutoConfigure…</code>注解，这些注解可用于自定义自动配置设置。</p>
<p>Note</p>
<p>每个切片将组件扫描限制为适当的组件，并加载一组非常受限制的自动配置类。如果您需要排除其中之一，则大多数<code>@…Test</code>Comments 都提供<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code>。</p>
<p>Note</p>
<p>不支持在一个测试中使用多个<code>@…Test</code>Comments 来包含多个“切片”。如果您需要多个“切片”，请选择<code>@…Test</code>Comments 之一，并手动添加其他“切片”的<code>@AutoConfigure…</code>Comments。</p>
<p>Tip</p>
<p>也可以将<code>@AutoConfigure…</code>Comments 与标准<code>@SpringBootTest</code>Comments 一起使用。如果您对“切片”应用程序不感兴趣，但需要一些自动配置的测试 bean，则可以使用此组合。</p>
<h3 id="自动配置的JSON测试"><a href="#自动配置的JSON测试" class="headerlink" title="自动配置的JSON测试"></a>自动配置的JSON测试</h3><p>要测试对象 JSON 序列化和反序列化是否按预期工作，可以使用<code>@JsonTest</code>注解。 <code>@JsonTest</code>自动配置可用的受支持的 JSON Map 器，该 Map 器可以是以下库之一：</p>
<ul>
<li>Jackson<code>ObjectMapper</code>，任何<code>@JsonComponent</code>beans 和任何 Jackson<code>Module</code> s</li>
<li><code>Gson</code></li>
<li><code>Jsonb</code></li>
</ul>
<p>Tip</p>
<p><code>@JsonTest</code>启用的自动配置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>如果需要配置自动配置的元素，则可以使用<code>@AutoConfigureJsonTesters</code>Comments。</p>
<p>Spring Boot 包括基于 AssertJ 的助手，这些助手与 JSONAssert 和 JsonPath 库一起使用，以检查 JSON 是否按预期方式显示。 <code>JacksonTester</code>，<code>GsonTester</code>，<code>JsonbTester</code>和<code>BasicJsonTester</code>类可以分别用于 Jackson，Gson，Jsonb 和 Strings。使用<code>@JsonTest</code>时，测试类上的任何帮助程序字段都可以为<code>@Autowired</code>。以下示例显示了 Jackson 的测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.json.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JsonTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJsonTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JacksonTester&lt;VehicleDetails&gt; json;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSerialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        VehicleDetails details = <span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>);</span><br><span class="line">        <span class="comment">// Assert against a `.json` file in the same package as the test</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).isEqualToJson(<span class="string">&quot;expected.json&quot;</span>);</span><br><span class="line">        <span class="comment">// Or use JSON path based assertions</span></span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).hasJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>);</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.write(details)).extractingJsonPathStringValue(<span class="string">&quot;@.make&quot;</span>)</span><br><span class="line">                .isEqualTo(<span class="string">&quot;Honda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;&#123;\&quot;make\&quot;:\&quot;Ford\&quot;,\&quot;model\&quot;:\&quot;Focus\&quot;&#125;&quot;</span>;</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parse(content))</span><br><span class="line">                .isEqualTo(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Ford&quot;</span>, <span class="string">&quot;Focus&quot;</span>));</span><br><span class="line">        assertThat(<span class="keyword">this</span>.json.parseObject(content).getMake()).isEqualTo(<span class="string">&quot;Ford&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>JSON 帮助程序类也可以直接在标准单元测试中使用。这样做，如果不使用<code>@JsonTest</code>，请在您的<code>@Before</code>方法中调用帮助程序的<code>initFields</code>方法。</p>
<h3 id="自动配置的SpringMVC测试"><a href="#自动配置的SpringMVC测试" class="headerlink" title="自动配置的SpringMVC测试"></a>自动配置的SpringMVC测试</h3><p>要测试 Spring MVC 控制器是否按预期工作，请使用<code>@WebMvcTest</code>注解。 <code>@WebMvcTest</code>自动配置 Spring MVC 基础结构，并将扫描的 Bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>和<code>HandlerMethodArgumentResolver</code>。使用此 Comments 时，不扫描常规的<code>@Component</code> bean。</p>
<p>Tip</p>
<p><code>@WebMvcTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>Tip</p>
<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</p>
<p>通常，<code>@WebMvcTest</code>限于单个控制器，并与<code>@MockBean</code>结合使用以为所需的协作者提供模拟实现。</p>
<p><code>@WebMvcTest</code>也会自动配置<code>MockMvc</code>。 Mock MVC 提供了一种强大的方法来快速测试 MVC 控制器，而无需启动完整的 HTTP 服务器。</p>
<p>Tip</p>
<p>您还可以通过用<code>@AutoConfigureMockMvc</code>Comments 非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>MockMvc</code>。以下示例使用<code>MockMvc</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk()).andExpect(content().string(<span class="string">&quot;Honda Civic&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>如果您需要配置自动配置的元素(例如，当应用 servlet 过滤器时)，则可以使用<code>@AutoConfigureMockMvc</code>注解中的属性。</p>
<p>如果使用 HtmlUnit 或 Selenium，则自动配置还会提供 HTMLUnit <code>WebClient</code> bean 和/或<code>WebDriver</code> bean。以下示例使用 HtmlUnit：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.BDDMockito.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHtmlUnitTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        HtmlPage page = <span class="keyword">this</span>.webClient.getPage(<span class="string">&quot;/sboot/vehicle.html&quot;</span>);</span><br><span class="line">        assertThat(page.getBody().getTextContent()).isEqualTo(<span class="string">&quot;Honda Civic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>默认情况下，Spring Boot 将<code>WebDriver</code> bean 放在特殊的“作用域”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不希望出现这种情况，可以将<code>@Scope(&quot;singleton&quot;)</code>添加到<code>WebDriver</code> <code>@Bean</code>定义中。</p>
<p>Warning</p>
<p>Spring Boot 创建的<code>webDriver</code>作用域将替换任何用户定义的同名作用域。如果定义自己的<code>webDriver</code>范围，则使用<code>@WebMvcTest</code>时可能会停止工作。</p>
<p>如果您在 Classpath 上具有 Spring Security，则<code>@WebMvcTest</code>还将扫描<code>WebSecurityConfigurer</code> bean。您可以使用 Spring Security 的测试支持，而不是完全禁用此类测试的安全性。有关如何使用 Spring Security 的<code>MockMvc</code>支持的更多详细信息，可以在此<em> <a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/#使用SpringSecurity进行测试">第 80 章，使用 Spring Security 进行测试</a> </em>操作方法部分中找到。</p>
<p>Tip</p>
<p>有时编写 Spring MVC 测试是不够的。 Spring Boot 可以帮助您运行<a href="#使用正在运行的服务器进行测试">使用实际服务器进行完整的端到端测试</a>。</p>
<h3 id="自动配置的SpringWebFlux测试"><a href="#自动配置的SpringWebFlux测试" class="headerlink" title="自动配置的SpringWebFlux测试"></a>自动配置的SpringWebFlux测试</h3><p>要测试<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//web-reactive.html">Spring WebFlux</a>控制器是否按预期工作，可以使用<code>@WebFluxTest</code>注解。 <code>@WebFluxTest</code>自动配置 Spring WebFlux 基础结构，并将扫描的 bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>和<code>WebFluxConfigurer</code>。使用<code>@WebFluxTest</code>注解时，不扫描常规<code>@Component</code> bean。</p>
<p>Tip</p>
<p><code>@WebFluxTest</code>启用的自动配置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>Tip</p>
<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</p>
<p><code>@WebFluxTest</code>通常仅限于单个控制器，并与<code>@MockBean</code>注解结合使用以为所需的协作者提供模拟实现。</p>
<p><code>@WebFluxTest</code>还自动配置<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient">WebTestClient</a>，它提供了一种强大的方法来快速测试 WebFlux 控制器而无需启动完整的 HTTP 服务器。</p>
<p>Tip</p>
<p>您还可以通过用<code>@AutoConfigureWebTestClient</code>Comments 非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>WebTestClient</code>。以下示例显示了同时使用<code>@WebFluxTest</code>和<code>WebTestClient</code>的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebFluxTest(UserVehicleController.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyControllerTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> WebTestClient webClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MockBean</span></span><br><span class="line">    <span class="keyword">private</span> UserVehicleService userVehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.userVehicleService.getVehicleDetails(<span class="string">&quot;sboot&quot;</span>))</span><br><span class="line">                .willReturn(<span class="keyword">new</span> VehicleDetails(<span class="string">&quot;Honda&quot;</span>, <span class="string">&quot;Civic&quot;</span>));</span><br><span class="line">        <span class="keyword">this</span>.webClient.get().uri(<span class="string">&quot;/sboot/vehicle&quot;</span>).accept(MediaType.TEXT_PLAIN)</span><br><span class="line">                .exchange()</span><br><span class="line">                .expectStatus().isOk()</span><br><span class="line">                .expectBody(String.class).isEqualTo(&quot;Honda Civic&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>WebFlux 应用程序仅支持此设置，因为在模拟的 Web 应用程序中使用<code>WebTestClient</code>目前仅适用于 WebFlux。</p>
<p>Note</p>
<p><code>@WebFluxTest</code>无法检测通过功能 Web 框架注册的路由。要在上下文中测试<code>RouterFunction</code> bean，请考虑自己通过<code>@Import</code>或使用<code>@SpringBootTest</code>导入<code>RouterFunction</code>。</p>
<p>Tip</p>
<p>有时编写 Spring WebFlux 测试是不够的。 Spring Boot 可以帮助您运行<a href="#使用正在运行的服务器进行测试">使用实际服务器进行完整的端到端测试</a>。</p>
<h3 id="自动配置的数据JPA测试"><a href="#自动配置的数据JPA测试" class="headerlink" title="自动配置的数据JPA测试"></a>自动配置的数据JPA测试</h3><p>您可以使用<code>@DataJpaTest</code>注解来测试 JPA 应用程序。默认情况下，它配置一个内存嵌入式数据库，扫描<code>@Entity</code>类，并配置 Spring Data JPA 存储库。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。</p>
<p>Tip</p>
<p><code>@DataJpaTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>默认情况下，数据 JPA 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">relevant section</a>。如果这不是您想要的，则可以按以下方式禁用测试或整个类的事务 Management：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据 JPA 测试还可以注入<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java">TestEntityManager</a> bean，它提供了专门为测试设计的标准 JPA <code>EntityManager</code>的替代方案。如果要在<code>@DataJpaTest</code>实例之外使用<code>TestEntityManager</code>，则也可以使用<code>@AutoConfigureTestEntityManager</code>Comments。如果需要，也可以提供<code>JdbcTemplate</code>。以下示例显示了正在使用的<code>@DataJpaTest</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.assertj.core.api.Assertions.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestEntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExample</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.entityManager.persist(<span class="keyword">new</span> User(<span class="string">&quot;sboot&quot;</span>, <span class="string">&quot;1234&quot;</span>));</span><br><span class="line">        User user = <span class="keyword">this</span>.repository.findByUsername(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getUsername()).isEqualTo(<span class="string">&quot;sboot&quot;</span>);</span><br><span class="line">        assertThat(user.getVin()).isEqualTo(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存嵌入式数据库通常运行良好，不需要任何安装，因此通常可以很好地进行测试。但是，如果您希望对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注解，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataJpaTest</span></span><br><span class="line"><span class="meta">@AutoConfigureTestDatabase(replace=Replace.NONE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRepositoryTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的JDBC测试"><a href="#自动配置的JDBC测试" class="headerlink" title="自动配置的JDBC测试"></a>自动配置的JDBC测试</h3><p><code>@JdbcTest</code>与<code>@DataJpaTest</code>类似，但适用于只需要<code>DataSource</code>并且不使用 Spring Data JDBC 的测试。默认情况下，它配置内存嵌入式数据库和<code>JdbcTemplate</code>。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。</p>
<p>Tip</p>
<p><code>@JdbcTest</code>启用的自动配置的列表可以为[见附录](<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments。">https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments。</a></p>
<p>缺省情况下，JDBC 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href="#自动配置的数据JPA测试">第 45.3.12 节，“自动配置的数据 JPA 测试”</a>”。)</p>
<h3 id="自动配置的数据JDBC测试"><a href="#自动配置的数据JDBC测试" class="headerlink" title="自动配置的数据JDBC测试"></a>自动配置的数据JDBC测试</h3><p><code>@DataJdbcTest</code>与<code>@JdbcTest</code>类似，但适用于使用 Spring Data JDBC 存储库的测试。默认情况下，它配置一个内存嵌入式数据库<code>JdbcTemplate</code>和 Spring Data JDBC 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。</p>
<p>Tip</p>
<p><code>@DataJdbcTest</code>启用的自动配置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>默认情况下，Data JDBC 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">relevant section</a>。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，即<a href="#自动配置的JDBC测试">在 JDBC 示例中显示</a>。</p>
<p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href="#自动配置的数据JPA测试">第 45.3.12 节，“自动配置的数据 JPA 测试”</a>”。)</p>
<h3 id="自动配置的jOOQ测试"><a href="#自动配置的jOOQ测试" class="headerlink" title="自动配置的jOOQ测试"></a>自动配置的jOOQ测试</h3><p>您可以以与<code>@JdbcTest</code>类似的方式使用<code>@JooqTest</code>，但可以用于与 jOOQ 相关的测试。由于 jOOQ 严重依赖与数据库模式相对应的基于 Java 的模式，因此使用现有的<code>DataSource</code>。如果要将其替换为内存数据库，则可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。 (有关将 jOOQ 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href="#使用jOOQ">第 30.6 节“使用 jOOQ”</a>”。)常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。</p>
<p>Tip</p>
<p><code>@JooqTest</code>启用的自动配置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p><code>@JooqTest</code>配置<code>DSLContext</code>。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。以下示例显示了正在使用的<code>@JooqTest</code>Comments：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.jooq.DSLContext;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.jooq.JooqTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JooqTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJooqTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DSLContext dslContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JOOQ 测试是事务性的，默认情况下会在每个测试结束时回滚。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，例如<a href="#自动配置的JDBC测试">在 JDBC 示例中显示</a>。</p>
<h3 id="自动配置的DataMongoDB测试"><a href="#自动配置的DataMongoDB测试" class="headerlink" title="自动配置的DataMongoDB测试"></a>自动配置的DataMongoDB测试</h3><p>您可以使用<code>@DataMongoTest</code>测试 MongoDB 应用程序。默认情况下，它配置内存嵌入式 MongoDB(如果可用)，配置<code>MongoTemplate</code>，扫描<code>@Document</code>类，并配置 Spring Data MongoDB 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 MongoDB 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href="#MongoDB">第 31.2 节“ MongoDB”</a>”。)</p>
<p>Tip</p>
<p><code>@DataMongoTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>此类显示正在使用的<code>@DataMongoTest</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataMongoTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MongoTemplate mongoTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存嵌入式 MongoDB 通常运行良好，不需要任何开发人员安装，因此通常可以很好地用于测试。但是，如果您希望对真实的 MongoDB 服务器运行测试，则应排除嵌入式 MongoDB 自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"> <span class="keyword">import</span> org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataMongoNonEmbeddedTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据Neo4j测试"><a href="#自动配置的数据Neo4j测试" class="headerlink" title="自动配置的数据Neo4j测试"></a>自动配置的数据Neo4j测试</h3><p>您可以使用<code>@DataNeo4jTest</code>测试 Neo4j 应用程序。默认情况下，它使用内存中嵌入式 Neo4j(如果有嵌入式驱动程序可用)，扫描<code>@NodeEntity</code>类，并配置 Spring Data Neo4j 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 Neo4J 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href="#Neo4j">第 31.3 节“ Neo4j”</a>”。)</p>
<p>Tip</p>
<p><code>@DataNeo4jTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataNeo4jTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataNeo4jTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，Data Neo4j 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions">relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataNeo4jTest</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleNonTransactionalTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据Redis测试"><a href="#自动配置的数据Redis测试" class="headerlink" title="自动配置的数据Redis测试"></a>自动配置的数据Redis测试</h3><p>您可以使用<code>@DataRedisTest</code>测试 Redis 应用程序。默认情况下，它将扫描<code>@RedisHash</code>类并配置 Spring Data Redis 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关在 Spring Boot 中使用 Redis 的更多信息，请参阅本章前面的“ <a href="#Redis">第 31.1 节“ Redis”</a>”。)</p>
<p>Tip</p>
<p><code>@DataRedisTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>以下示例显示了正在使用的<code>@DataRedisTest</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataRedisTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataRedisTests</span> </span>&#123;</span><br><span class="line">javajavajava</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> YourRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的数据LDAP测试"><a href="#自动配置的数据LDAP测试" class="headerlink" title="自动配置的数据LDAP测试"></a>自动配置的数据LDAP测试</h3><p>您可以使用<code>@DataLdapTest</code>测试 LDAP 应用程序。默认情况下，它配置内存嵌入式 LDAP(如果可用)，配置<code>LdapTemplate</code>，扫描<code>@Entry</code>类，并配置 Spring Data LDAP 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 LDAP 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href="#LDAP">第 31.9 节“ LDAP”</a>”。)</p>
<p>Tip</p>
<p><code>@DataLdapTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>以下示例显示了正在使用的<code>@DataLdapTest</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ldap.core.LdapTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataLdapTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LdapTemplate ldapTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存嵌入式 LDAP 通常非常适合测试，因为它速度快并且不需要安装任何开发人员。但是，如果您希望针对真实的 LDAP 服务器运行测试，则应排除嵌入式 LDAP 自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleDataLdapNonEmbeddedTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的RESTClient端"><a href="#自动配置的RESTClient端" class="headerlink" title="自动配置的RESTClient端"></a>自动配置的RESTClient端</h3><p>您可以使用<code>@RestClientTest</code>注解来测试 REST Client 端。默认情况下，它会自动配置 Jackson，GSON 和 Jsonb 支持，配置<code>RestTemplateBuilder</code>，并添加对<code>MockRestServiceServer</code>的支持。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。</p>
<p>Tip</p>
<p><code>@RestClientTest</code>启用的自动配置设置的列表可以为<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#测试自动配置Comments">见附录</a>。</p>
<p>应该使用<code>@RestClientTest</code>的<code>value</code>或<code>components</code>属性指定要测试的特定 bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@RestClientTest(RemoteVehicleDetailsService.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleRestClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RemoteVehicleDetailsService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockRestServiceServer server;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.server.expect(requestTo(<span class="string">&quot;/greet/details&quot;</span>))</span><br><span class="line">                .andRespond(withSuccess(<span class="string">&quot;hello&quot;</span>, MediaType.TEXT_PLAIN));</span><br><span class="line">        String greeting = <span class="keyword">this</span>.service.callRestService();</span><br><span class="line">        assertThat(greeting).isEqualTo(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动配置的SpringREST文档测试"><a href="#自动配置的SpringREST文档测试" class="headerlink" title="自动配置的SpringREST文档测试"></a>自动配置的SpringREST文档测试</h3><p>您可以在 Mock MVC，REST 保证或 WebTestClient 的测试中使用<code>@AutoConfigureRestDocs</code>注解来使用<a target="_blank" rel="noopener" href="https://projects.spring.io/spring-restdocs/">Spring REST 文件</a>。它消除了 Spring REST Docs 中对 JUnit 规则的需求。</p>
<p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录(如果使用 Maven，则使用<code>target/generated-snippets</code>；如果使用 Gradle，则使用<code>build/generated-snippets</code>)。它也可以用于配置出现在任何记录的 URI 中的主机，方案和端口。</p>
<h4 id="使用MockMVC自动配置的SpringRESTDocs测试"><a href="#使用MockMVC自动配置的SpringRESTDocs测试" class="headerlink" title="使用MockMVC自动配置的SpringRESTDocs测试"></a>使用MockMVC自动配置的SpringRESTDocs测试</h4><p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code> bean 以使用 Spring REST Docs。您可以使用<code>@Autowired</code>注入它，并像通常使用 Mock MVC 和 Spring REST Docs 一样在测试中使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@WebMvcTest(UserController.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mvc.perform(get(<span class="string">&quot;/users&quot;</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class="line">                .andExpect(status().isOk())</span><br><span class="line">                .andDo(document(<span class="string">&quot;list-users&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要对 Spring REST Docs 配置进行更多控制，而不是<code>@AutoConfigureRestDocs</code>属性所提供的控制，则可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RestDocsMockMvcConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(MockMvcRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要使用 Spring REST Docs 对参数化输出目录的支持，则可以创建<code>RestDocumentationResultHandler</code> bean。自动配置使用此结果处理程序调用<code>alwaysDo</code>，从而使每个<code>MockMvc</code>调用自动生成默认片段。以下示例显示正在定义的<code>RestDocumentationResultHandler</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandlerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestDocumentationResultHandler <span class="title">restDocumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MockMvcRestDocumentation.document(<span class="string">&quot;&#123;method-name&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具有-REST-保证的自动配置的-Spring-REST-文档测试"><a href="#具有-REST-保证的自动配置的-Spring-REST-文档测试" class="headerlink" title="具有 REST 保证的自动配置的 Spring REST 文档测试"></a>具有 REST 保证的自动配置的 Spring REST 文档测试</h4><p><code>@AutoConfigureRestDocs</code>使预配置为使用 Spring REST 文档的<code>RequestSpecification</code> bean 可用于您的测试。您可以使用<code>@Autowired</code>注入它，并像在使用 REST Assured 和 Spring REST Docs 时一样，在测试中使用它，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.restassured.specification.RequestSpecification;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> io.restassured.RestAssured.given;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.CoreMatchers.is;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@AutoConfigureRestDocs</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDocumentationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LocalServerPort</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RequestSpecification documentationSpec;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        given(<span class="keyword">this</span>.documentationSpec).filter(document(<span class="string">&quot;list-users&quot;</span>)).when()</span><br><span class="line">                .port(<span class="keyword">this</span>.port).get(<span class="string">&quot;/&quot;</span>).then().assertThat().statusCode(is(<span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您需要对 Spring REST Docs 配置进行更多控制而不是<code>@AutoConfigureRestDocs</code>属性提供的控制，则可以使用<code>RestDocsRestAssuredConfigurationCustomizer</code> bean，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizationConfiguration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RestDocsRestAssuredConfigurationCustomizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(RestAssuredRestDocumentationConfigurer configurer)</span> </span>&#123;</span><br><span class="line">        configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他自动配置和切片"><a href="#其他自动配置和切片" class="headerlink" title="其他自动配置和切片"></a>其他自动配置和切片</h3><p>每个切片提供一个或多个<code>@AutoConfigure…</code>注解，即定义应包含在切片中的自动配置。可以通过创建自定义<code>@AutoConfigure…</code>Comments 或仅通过向测试中添加<code>@ImportAutoConfiguration</code>来添加其他自动配置，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@JdbcTest</span></span><br><span class="line"><span class="meta">@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleJdbcTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>确保不要使用常规的<code>@Import</code>Comments 来导入自动配置，因为它们是由 Spring Boot 以特定方式处理的。</p>
<h3 id="用户配置和切片"><a href="#用户配置和切片" class="headerlink" title="用户配置和切片"></a>用户配置和切片</h3><p>如果您以明智的方式<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用SpringBoot/#构建代码">结构化代码</a>，则您的<code>@SpringBootApplication</code>类为<a href="#检测测试配置">默认使用</a>作为测试的配置。</p>
<p>因此，重要的是不要用特定于其功能特定区域的配置设置来乱扔应用程序的主类。</p>
<p>假设您正在使用 Spring Batch，并且依赖于它的自动配置。您可以按以下方式定义<code>@SpringBootApplication</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>因为此类是测试的源配置，所以任何切片测试实际上都尝试启动 Spring Batch，这绝对不是您想要执行的操作。建议的方法是将特定于区域的配置移到与您的应用程序相同级别的单独的<code>@Configuration</code>类，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchConfiguration</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>根据您应用程序的复杂性，您可以为自己的自定义设置一个<code>@Configuration</code>类，或者每个域区域一个类。后一种方法可让您在必要的测试中使用<code>@Import</code>注解启用它。</p>
<p>混乱的另一个来源是 Classpath 扫描。假设在以合理的方式组织代码的同时，您需要扫描其他程序包。您的应用程序可能类似于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123; &quot;com.example.app&quot;, &quot;org.acme.another&quot; &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplication</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>这样做有效地覆盖了默认的组件扫描指令，并且具有扫描这两个软件包的副作用，而与您选择的切片无关。例如，<code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移至单独的类是解决此问题的好方法。</p>
<p>Tip</p>
<p>如果这不是您的选择，则可以在测试层次结构中的某个位置创建<code>@SpringBootConfiguration</code>，以便代替它使用。另外，您可以为测试指定一个源，从而禁用查找默认源的行为。</p>
<h3 id="使用Spock测试SpringBoot应用程序"><a href="#使用Spock测试SpringBoot应用程序" class="headerlink" title="使用Spock测试SpringBoot应用程序"></a>使用Spock测试SpringBoot应用程序</h3><p>如果希望使用 Spock 测试 Spring Boot 应用程序，则应在应用程序的构建中添加对 Spock 的<code>spock-spring</code>模块的依赖。 <code>spock-spring</code>将 Spring 的测试框架集成到 Spock 中。建议您使用 Spock 1.2 或更高版本，以受益于 Spock 的 Spring Framework 和 Spring Boot 集成的许多改进。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="http://spockframework.org/spock/docs/1.2/modules.html#_spring_module">Spock 的 Spring 模块的文档</a>。</p>
<h2 id="测试Util"><a href="#测试Util" class="headerlink" title="测试Util"></a>测试Util</h2><p>一些测试 Util 类通常在测试您的应用程序时有用，它们被打包为<code>spring-boot</code>的一部分。</p>
<h3 id="ConfigFileApplicationContextInitializer"><a href="#ConfigFileApplicationContextInitializer" class="headerlink" title="ConfigFileApplicationContextInitializer"></a>ConfigFileApplicationContextInitializer</h3><p><code>ConfigFileApplicationContextInitializer</code>是<code>ApplicationContextInitializer</code>，您可以将其应用于测试以加载 Spring Boot <code>application.properties</code>文件。如不需要以下示例所示，可以在不需要<code>@SpringBootTest</code>提供的全部功能时使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration(classes = Config.class,</span></span><br><span class="line"><span class="meta">    initializers = ConfigFileApplicationContextInitializer.class)</span></span><br></pre></td></tr></table></figure>
<p>Note</p>
<p>单独使用<code>ConfigFileApplicationContextInitializer</code>不支持<code>@Value(&quot;$&#123;…&#125;&quot;)</code>注入。它唯一的工作就是确保将<code>application.properties</code>文件加载到 Spring 的<code>Environment</code>中。为了获得<code>@Value</code>支持，您需要另外配置<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code>，后者会为您自动配置一个。</p>
<h3 id="TestPropertyValues"><a href="#TestPropertyValues" class="headerlink" title="TestPropertyValues"></a>TestPropertyValues</h3><p><code>TestPropertyValues</code>可让您快速将属性添加到<code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>。您可以使用<code>key=value</code>字符串来调用它，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestPropertyValues.of(<span class="string">&quot;org=Spring&quot;</span>, <span class="string">&quot;name=Boot&quot;</span>).applyTo(env);</span><br></pre></td></tr></table></figure>
<h3 id="OutputCapture"><a href="#OutputCapture" class="headerlink" title="OutputCapture"></a>OutputCapture</h3><p><code>OutputCapture</code>是一个 JUnit <code>Rule</code>，可用于捕获<code>System.out</code>和<code>System.err</code>输出。您可以将捕获声明为<code>@Rule</code>，然后将<code>toString()</code>用于 assert，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Rule;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.hamcrest.Matchers.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> OutputCapture capture = <span class="keyword">new</span> OutputCapture();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testName</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        assertThat(capture.toString(), containsString(<span class="string">&quot;World&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TestRestTemplate"><a href="#TestRestTemplate" class="headerlink" title="TestRestTemplate"></a>TestRestTemplate</h3><p>Tip</p>
<p>Spring Framework 5.0 提供了一个新的<code>WebTestClient</code>，它适用于<a href="#自动配置的SpringWebFlux测试">WebFlux 集成测试</a>和<a href="#使用正在运行的服务器进行测试">WebFlux 和 MVC 端到端测试</a>。与<code>TestRestTemplate</code>不同，它为声明提供了流畅的 API。</p>
<p><code>TestRestTemplate</code>是 Spring <code>RestTemplate</code>的便捷替代方法，在集成测试中非常有用。您可以使用普通模板或发送基本 HTTP 身份验证(带有用户名和密码)的模板。在这两种情况下，模板都不会通过在服务器端错误上引发异常来以易于测试的方式运行。建议(但不是强制性的)使用 Apache HTTP Client(版本 4.3.2 或更高版本)。如果您在 Classpath 中具有该名称，则<code>TestRestTemplate</code>会通过适当配置 Client 端进行响应。如果确实使用 Apache 的 HTTP Client 端，则会启用一些其他易于测试的功能：</p>
<ul>
<li>不遵循重定向(因此您可以声明响应位置)。</li>
<li>Cookies 被忽略(因此模板是 Stateless 的)。</li>
</ul>
<p><code>TestRestTemplate</code>可以在集成测试中直接实例化，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template = <span class="keyword">new</span> TestRestTemplate();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(</span><br><span class="line">                <span class="string">&quot;http://myhost.example.com/example&quot;</span>, String.class).getHeaders();</span><br><span class="line">        assertThat(headers.getLocation()).hasHost(<span class="string">&quot;other.example.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果您将<code>@SpringBootTest</code>Comments 与<code>WebEnvironment.RANDOM_PORT</code>或<code>WebEnvironment.DEFINED_PORT</code>一起使用，则可以注入已完全配置的<code>TestRestTemplate</code>并开始使用它。如有必要，可以通过<code>RestTemplateBuilder</code> bean 应用其他定制。未指定主机和端口的所有 URL 都会自动连接到嵌入式服务器，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleWebClientTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HttpHeaders headers = <span class="keyword">this</span>.template.getForEntity(<span class="string">&quot;/example&quot;</span>, String.class)</span><br><span class="line">                .getHeaders();</span><br><span class="line">        assertThat(headers.getLocation()).hasHost(<span class="string">&quot;other.example.com&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestConfiguration</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RestTemplateBuilder <span class="title">restTemplateBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RestTemplateBuilder().setConnectTimeout(Duration.ofSeconds(<span class="number">1</span>))</span><br><span class="line">                    .setReadTimeout(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p>Spring Boot 为嵌入式 Tomcat，Jetty 和 Undertow 提供了 WebSockets 自动配置。如果将 war 文件部署到独立容器，Spring Boot 会假定该容器负责其 WebSocket 支持的配置。</p>
<p>Spring Framework 为 MVC Web 应用程序提供了<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#websocket">丰富的 WebSocket 支持</a>，可以通过<code>spring-boot-starter-websocket</code>模块轻松访问。</p>
<p>WebSocket 支持也可用于<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket">响应式 Web 应用程序</a>，并且需要在<code>spring-boot-starter-webflux</code>旁边包括 WebSocket API：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.websocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.websocket-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="WebService"><a href="#WebService" class="headerlink" title="WebService"></a>WebService</h1><p>Spring Boot 提供了 Web 服务自动配置，因此您所要做的就是定义<code>Endpoints</code>。</p>
<p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/">Spring Web Services 功能</a>可以通过<code>spring-boot-starter-webservices</code>模块轻松访问。</p>
<p>可以分别为您的 WSDL 和 XSD 自动创建<code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code> bean。为此，请配置其位置，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.webservices.wsdl-locations</span>=<span class="string">classpath:/wsdl</span></span><br></pre></td></tr></table></figure>
<h1 id="使用WebServiceTemplate调用Web服务"><a href="#使用WebServiceTemplate调用Web服务" class="headerlink" title="使用WebServiceTemplate调用Web服务"></a>使用WebServiceTemplate调用Web服务</h1><p>如果需要从应用程序调用远程 Web 服务，则可以使用<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/#client-web-service-template">WebServiceTemplate</a>类。由于<code>WebServiceTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>WebServiceTemplate</code> bean。但是，它会自动配置<code>WebServiceTemplateBuilder</code>，可以在需要时创建<code>WebServiceTemplate</code>实例。</p>
<p>以下代码显示了一个典型示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebServiceTemplate webServiceTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyService</span><span class="params">(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DetailsResp <span class="title">someWsCall</span><span class="params">(DetailsReq detailsReq)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> (DetailsResp) <span class="keyword">this</span>.webServiceTemplate.marshalSendAndReceive(detailsReq, <span class="keyword">new</span> SoapActionCallback(ACTION));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，<code>WebServiceTemplateBuilder</code>使用 Classpath 上可用的 HTTP Client 端库检测合适的基于 HTTP 的<code>WebServiceMessageSender</code>。您还可以如下自定义读取和连接超时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> WebServiceTemplate <span class="title">webServiceTemplate</span><span class="params">(WebServiceTemplateBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> builder.messageSenders(<span class="keyword">new</span> HttpWebServiceMessageSenderBuilder()</span><br><span class="line">            .setConnectTimeout(<span class="number">5000</span>).setReadTimeout(<span class="number">2000</span>).build()).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="创建自己的自动配置"><a href="#创建自己的自动配置" class="headerlink" title="创建自己的自动配置"></a>创建自己的自动配置</h1><p>如果您在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以 Binding 在外部 jar 中，并且仍由 Spring Boot 拾取。</p>
<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用的典型库。我们首先介绍构建自己的自动配置所需的知识，然后 continue 进行<a href="#创建自己的启动器">创建自定义启动器所需的典型步骤</a>。</p>
<p>Tip</p>
<p><a target="_blank" rel="noopener" href="https://github.com/snicoll-demos/spring-boot-master-auto-configuration">demo project</a>可用来展示如何逐步创建 Starter 者。</p>
<h2 id="了解自动配置的Bean"><a href="#了解自动配置的Bean" class="headerlink" title="了解自动配置的Bean"></a>了解自动配置的Bean</h2><p>在后台，自动配置是通过标准的<code>@Configuration</code>类实现的。其他<code>@Conditional</code>Comments 用于约束何时应应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>Comments。这样可以确保仅当找到相关的类并且没有声明自己的<code>@Configuration</code>时，自动配置才适用。</p>
<p>您可以浏览<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure">spring-boot-autoconfigure</a>的源代码以查看 Spring 提供的<code>@Configuration</code>类(请参见<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories">META-INF/spring.factories</a>文件)。</p>
<h2 id="查找自动配置的候选人"><a href="#查找自动配置的候选人" class="headerlink" title="查找自动配置的候选人"></a>查找自动配置的候选人</h2><p>Spring Boot 检查发布的 jar 中是否存在<code>META-INF/spring.factories</code>文件。该文件应在<code>EnableAutoConfiguration</code>键下列出您的配置类，如以下示例所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line"><span class="attr">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></td></tr></table></figure>
<p>如果需要按特定 Sequences 应用配置，则可以使用<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java">@AutoConfigureAfter</a>或<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java">@AutoConfigureBefore</a>注解。例如，如果您提供特定于 Web 的配置，则可能需要在<code>WebMvcAutoConfiguration</code>之后应用您的类。</p>
<p>如果要 Order 某些彼此之间没有直接知识的自动配置，则也可以使用<code>@AutoConfigureOrder</code>。该 Comments 与常规<code>@Order</code>Comments 具有相同的语义，但为自动配置类提供了专用 Sequences。</p>
<p>Note</p>
<p>自动配置必须以<em> only </em>的方式加载。确保在特定的软件包空间中定义了它们，尤其是它们绝不是组件扫描的目标。</p>
<h2 id="Condition注解"><a href="#Condition注解" class="headerlink" title="Condition注解"></a>Condition注解</h2><p>您几乎总是希望在自动配置类中包含一个或多个<code>@Conditional</code>注解。 <code>@ConditionalOnMissingBean</code>注解 是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。</p>
<p>Spring Boot 包含许多<code>@Conditional</code>注解，您可以通过 Comments<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用。这些 注解包括：</p>
<ul>
<li><a href="#Class条件">第 49.3.1 节“类条件”</a></li>
<li><a href="#Bean条件">第 49.3.2 节“ Bean 条件”</a></li>
<li><a href="#Property条件">第 49.3.3 节“属性条件”</a></li>
<li><a href="#Resource条件">第 49.3.4 节“资源条件”</a></li>
<li><a href="#WebApplication条件">第 49.3.5 节“ Web 应用程序条件”</a></li>
<li><a href="#SpEL表达条件">第 49.3.6 节“ SpEL 表达条件”</a></li>
</ul>
<h3 id="Class条件"><a href="#Class条件" class="headerlink" title="Class条件"></a>Class条件</h3><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解允许根据是否存在特定类来包含配置。由于 Comments 元数据是通过使用<a target="_blank" rel="noopener" href="http://asm.ow2.org/">ASM</a>进行解析的，因此即使该类实际上可能未出现在正在运行的应用程序 Classpath 上，您也可以使用<code>value</code>属性来引用真实的类。如果您希望通过使用<code>String</code>值来指定类名，则也可以使用<code>name</code>属性。</p>
<blockquote>
<p>Tip</p>
<p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元 Comments 的一部分来组成自己的组合 Comments，则必须使用<code>name</code>，因为在这种情况下无法引用该类。</p>
</blockquote>
<h3 id="Bean条件"><a href="#Bean条件" class="headerlink" title="Bean条件"></a>Bean条件</h3><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments 根据是否存在特定的 bean 来包含 bean。您可以使用<code>value</code>属性按类型指定 bean，或使用<code>name</code>按名称指定 bean。 <code>search</code>属性使您可以限制搜索 Bean 时应考虑的<code>ApplicationContext</code>层次结构。</p>
<p>当放置在<code>@Bean</code>方法上时，目标类型默认为该方法的返回类型，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyService <span class="title">myService</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的示例中，如果<code>ApplicationContext</code>中没有包含<code>MyService</code>类型的 bean，则将创建<code>myService</code> bean。</p>
<blockquote>
<p>Tip</p>
<p>您需要非常注意添加 bean 定义的 Sequences，因为这些条件是根据到目前为止已处理的内容来评估的。因此，我们建议在自动配置类上仅使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments(因为保证在添加任何用户定义的 Bean 定义后即可加载这些 Comments)。</p>
<p>Note</p>
<p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code>类的创建。在类级别使用这些条件与使用 Comments 标记每个包含的<code>@Bean</code>方法之间的唯一区别是，如果条件不匹配，则前者会阻止<code>@Configuration</code>类注册为 bean。</p>
</blockquote>
<h3 id="Property条件"><a href="#Property条件" class="headerlink" title="Property条件"></a>Property条件</h3><p><code>@ConditionalOnProperty</code>注解允许基于 Spring Environment 属性包含配置。使用<code>prefix</code>和<code>name</code>属性来指定应检查的属性。默认情况下，匹配存在且不等于<code>false</code>的任何属性。您还可以使用<code>havingValue</code>和<code>matchIfMissing</code>属性创建更高级的检查。</p>
<h3 id="Resource条件"><a href="#Resource条件" class="headerlink" title="Resource条件"></a>Resource条件</h3><p><code>@ConditionalOnResource</code>注解仅在存在特定资源时才包括配置。可以使用通常的 Spring 约定来指定资源，如以下示例所示：<code>file:/home/user/test.dat</code>。</p>
<h3 id="WebApplication条件"><a href="#WebApplication条件" class="headerlink" title="WebApplication条件"></a>WebApplication条件</h3><p>根据应用程序是否为“ Web 应用程序”，可以使用<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注解包含配置。 Web 应用程序是使用 Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有<code>StandardServletEnvironment</code>的任何应用程序。</p>
<h3 id="SpEL表达条件"><a href="#SpEL表达条件" class="headerlink" title="SpEL表达条件"></a>SpEL表达条件</h3><p><code>@ConditionalOnExpression</code>注解允许基于<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#expressions">SpEL expression</a>的结果包括配置。</p>
<h2 id="测试您的自动配置"><a href="#测试您的自动配置" class="headerlink" title="测试您的自动配置"></a>测试您的自动配置</h2><p>自动配置可能受许多因素影响：用户配置(<code>@Bean</code>定义和<code>Environment</code>定制)，条件评估(特定库的存在)和其他因素。具体而言，每个测试都应创建定义良好的<code>ApplicationContext</code>，以表示这些自定义项的组合。 <code>ApplicationContextRunner</code>提供了一种实现此目标的好方法。</p>
<p><code>ApplicationContextRunner</code>通常定义为测试类的一个字段，用于收集基本的通用配置。下面的示例确保始终调用<code>UserServiceAutoConfiguration</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">        .withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip</p>
<p>如果必须定义多个自动配置，则无需按与运行应用程序时完全相同的 Sequences 调用它们的声明。</p>
</blockquote>
<p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用一个用户配置(<code>UserConfiguration</code>)，并检查自动配置是否正确退出。调用<code>run</code>提供了可与<code>Assert4J</code>一起使用的回调上下文。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultServiceBacksOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class="line">            .run((context) -&gt; &#123;</span><br><span class="line">                assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">                assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class="line">                        context.getBean(UserConfiguration.class).myUserService());</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">myUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserService(<span class="string">&quot;mine&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以轻松自定义<code>Environment</code>，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceNameCanBeConfigured</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withPropertyValues(<span class="string">&quot;user.name=test123&quot;</span>).run((context) -&gt; &#123;</span><br><span class="line">        assertThat(context).hasSingleBean(UserService.class);</span><br><span class="line">        assertThat(context.getBean(UserService.class).getName()).isEqualTo(&quot;test123&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Running 者也可以用来显示<code>ConditionEvaluationReport</code>。该报告可以<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何在自动配置测试中使用<code>ConditionEvaluationReportLoggingListener</code>打印报告。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> autoConfigTest &#123;</span><br><span class="line">    ConditionEvaluationReportLoggingListener initializer = <span class="keyword">new</span> ConditionEvaluationReportLoggingListener(</span><br><span class="line">            LogLevel.INFO);</span><br><span class="line">    ApplicationContextRunner contextRunner = <span class="keyword">new</span> ApplicationContextRunner()</span><br><span class="line">            .withInitializer(initializer).run((context) -&gt; &#123;</span><br><span class="line">                    <span class="comment">// Do something...</span></span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟网络环境"><a href="#模拟网络环境" class="headerlink" title="模拟网络环境"></a>模拟网络环境</h3><p>如果您需要测试仅在 Servlet 或 Reactive Web 应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。</p>
<h3 id="覆盖Classpath"><a href="#覆盖Classpath" class="headerlink" title="覆盖Classpath"></a>覆盖Classpath</h3><p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。 Spring Boot 附带<code>FilteredClassLoader</code>，Running 者可以轻松使用。在以下示例中，我们 assert 如果不存在<code>UserService</code>，则会自动禁用自动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceIsIgnoredIfLibraryIsNotPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.contextRunner.withClassLoader(<span class="keyword">new</span> FilteredClassLoader(UserService.class))</span><br><span class="line">            .run((context) -&gt; assertThat(context).doesNotHaveBean(<span class="string">&quot;userService&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建自己的启动器"><a href="#创建自己的启动器" class="headerlink" title="创建自己的启动器"></a>创建自己的启动器</h2><p>库的完整 Spring BootStarter 程序可能包含以下组件：</p>
<ul>
<li>包含自动配置代码的<code>autoconfigure</code>模块。</li>
<li><code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系，以及通常有用的任何其他依赖关系。简而言之，添加启动程序应提供开始使用该库所需的一切。</li>
</ul>
<blockquote>
<p>Tip</p>
<p>如果不需要将这两个问题分开，则可以将自动配置代码和依赖性 Management 结合在一起。</p>
</blockquote>
<h3 id="Naming"><a href="#Naming" class="headerlink" title="Naming"></a>Naming</h3><p>您应该确保为启动器提供适当的名称空间。即使您使用其他 Maven <code>groupId</code>，也不要以<code>spring-boot</code>开头模块名称。将来，我们可能会为您自动配置的内容提供官方支持。</p>
<p>根据经验，您应该在启动器后命名一个组合模块。例如，假设您要为“ acme”创建启动程序，并且将自动配置模块命名为<code>acme-spring-boot-autoconfigure</code>，而启动程序则命名为<code>acme-spring-boot-starter</code>。如果只有一个将两者结合的模块，请将其命名为<code>acme-spring-boot-starter</code>。</p>
<p>另外，如果您的 Starter 者提供了配置密钥，请为其使用唯一的名称空间。特别是，不要在 Spring Boot 使用的名称空间中包含您的密钥(例如<code>server</code>，<code>management</code>，<code>spring</code>等)。如果使用相同的名称空间，将来我们可能会以破坏模块的方式修改这些名称空间。</p>
<p>确保<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#使用 Comments 处理器生成您自己的元数据">触发元数据生成</a>，以便您的按键也可以使用 IDE 协助。您可能需要查看生成的元数据(<code>META-INF/spring-configuration-metadata.json</code>)，以确保正确记录了您的密钥。</p>
<h3 id="自动配置模块"><a href="#自动配置模块" class="headerlink" title="自动配置模块"></a>自动配置模块</h3><p><code>autoconfigure</code>模块包含开始使用该库所需的所有内容。它还可能包含配置键定义(例如<code>@ConfigurationProperties</code>)和可用于进一步自定义组件初始化方式的任何回调接口。</p>
<p>Tip</p>
<p>您应该将对库的依赖关系标记为可选，以便可以更轻松地在项目中包含<code>autoconfigure</code>模块。如果这样做，则不提供该库，并且默认情况下，Spring Boot 会后退。</p>
<p>Spring Boot 使用 Comments 处理器来收集元数据文件(<code>META-INF/spring-autoconfigure-metadata.properties</code>)中自动配置的条件。如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于 Gradle 4.5 及更早版本，依赖关系应在<code>compileOnly</code>配置中声明，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compileOnly <span class="string">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Gradle 4.6 及更高版本中，依赖性应在<code>annotationProcessor</code>配置中声明，如以下示例所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    annotationProcessor <span class="string">&quot;org.springframework.boot:spring-boot-autoconfigure-processor&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Starter模块"><a href="#Starter模块" class="headerlink" title="Starter模块"></a>Starter模块</h3><p>起动器确实是一个空Jar子。其唯一目的是提供必要的依赖关系以使用库。您可以将其视为对 Starter 所需的看法。</p>
<p>不要对添加了启动器的项目做任何假设。如果您要自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的<em> default </em>依赖项可能会很困难，因为您应避免包括对于库的典型用法而言不必要的依赖项。换句话说，您不应包括可选的依赖项。</p>
<blockquote>
<p>Note</p>
<p>无论哪种方式，您的启动程序都必须直接或间接引用核心 Spring Boot 启动程序(<code>spring-boot-starter</code>)(即，如果您的启动程序依赖于另一个启动程序，则无需添加它)。如果仅使用您的自定义启动器创建项目，则通过使用该核心启动器来兑现 Spring Boot 的核心功能。</p>
</blockquote>
<h1 id="Kotlin支持"><a href="#Kotlin支持" class="headerlink" title="Kotlin支持"></a>Kotlin支持</h1><p><a target="_blank" rel="noopener" href="https://kotlinlang.org/">Kotlin</a>是针对 JVM(和其他平台)的静态类型的语言，它允许编写简洁明了的代码，同时为<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html">interoperability</a>提供以 Java 编写的现有库。</p>
<p>Spring Boot 通过利用其他 Spring 项目(例如 Spring Framework，Spring Data 和 Reactor)中的支持来提供 Kotlin 支持。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/languages.html#kotlin">Spring Framework Kotlin 支持文档</a>。</p>
<p>从 Spring Boot 和 Kotlin 开始的最简单方法是遵循<a target="_blank" rel="noopener" href="https://spring.io/guides/tutorials/spring-boot-kotlin/">本综合教程</a>。您可以通过<a target="_blank" rel="noopener" href="https://start.spring.io/#!language=kotlin">start.spring.io</a>创建新的 Kotlin 项目。如果需要支持，可以随时加入<a target="_blank" rel="noopener" href="http://slack.kotlinlang.org/">Kotlin Slack</a>的#spring Channels，或在<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring+kotlin">Stack Overflow</a>上使用<code>spring</code>和<code>kotlin</code>标签询问问题。</p>
<h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><p>Spring Boot 支持 Kotlin1.2.x。要使用 Kotlin，Classpath 上必须存在<code>org.jetbrains.kotlin:kotlin-stdlib</code>和<code>org.jetbrains.kotlin:kotlin-reflect</code>。也可以使用<code>kotlin-stdlib</code>变体<code>kotlin-stdlib-jdk7</code>和<code>kotlin-stdlib-jdk8</code>。</p>
<p>从<a target="_blank" rel="noopener" href="https://discuss.kotlinlang.org/t/classes-final-by-default/166">Kotlin 类默认为 final</a>开始，您可能需要配置<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support">kotlin-spring</a>插件，以便自动打开带有 Spring Comments 的类，以便对其进行代理。</p>
<p>在 Kotlin 中序列化/反序列化 JSON 数据需要<a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson-module-kotlin">Jackson 的 Kotlin 模块</a>。在 Classpath 上找到它会自动注册。如果存在 Jackson 和 Kotlin 但不存在 Jackson Kotlin 模块，则会记录一条警告消息。</p>
<p>Tip</p>
<p>如果一个人在<a target="_blank" rel="noopener" href="https://start.spring.io/#!language=kotlin">start.spring.io</a>上引导 Kotlin 项目，则默认情况下会提供这些依赖项和插件。</p>
<h2 id="Null-safety"><a href="#Null-safety" class="headerlink" title="Null-safety"></a>Null-safety</h2><p>Kotlin 的主要功能之一是<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>。它在编译时处理<code>null</code>值，而不是将问题推迟到运行时并遇到<code>NullPointerException</code>。这有助于消除常见的错误源，而无需支付<code>Optional</code>之类的包装器的费用。 Kotlin 还允许使用具有可空值的函数构造，如<a target="_blank" rel="noopener" href="http://www.baeldung.com/kotlin-null-safety">Kotlin 空安全综合指南</a>中所述。</p>
<p>尽管 Java 不允许人在其类型系统中表示空安全性，但 Spring Framework，Spring Data 和 Reactor 现在通过易于使用工具的注解为 API 提供了空安全性。默认情况下，Kotlin 中使用的 Java API 中的类型被识别为<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>，对此类型的空检查得到了放宽。 <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support">Kotlin 对 JSR 305 注解的支持</a>与可空性 Comments 结合使用，为 Kotlin 中的相关 Spring API 提供了空安全性。</p>
<p>可以通过添加带有以下选项的<code>-Xjsr305</code>编译器标志来配置 JSR 305 检查：<code>-Xjsr305=&#123;strict|warn|ignore&#125;</code>。默认行为与<code>-Xjsr305=warn</code>相同。必须使用<code>strict</code>值来考虑从 Spring API 推断出的 Kotlin 类型的空安全性，但应使用该知识，即使 Spring API 的空性声明即使在次要发行版之间也可能会演变，并且将来可能会添加更多检查，这一点应得到使用。</p>
<blockquote>
<p>Warning</p>
<p>尚不支持泛型类型参数，varargs 和数组元素的可空性。有关最新信息，请参见<a target="_blank" rel="noopener" href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a>。另外请注意，Spring Boot 自己的 API 是<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/issues/10712">尚未 Comments</a>。</p>
</blockquote>
<h2 id="KotlinAPI"><a href="#KotlinAPI" class="headerlink" title="KotlinAPI"></a>KotlinAPI</h2><h3 id="runApplication"><a href="#runApplication" class="headerlink" title="runApplication"></a>runApplication</h3><p>Spring Boot 提供了一种惯用的方式来使用<code>runApplication&lt;MyApplication&gt;(*args)</code>运行应用程序，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.runApplication</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    runApplication&lt;MyApplication&gt;(*args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是<code>SpringApplication.run(MyApplication::class.java, *args)</code>的直接替代。它还允许自定义应用程序，如以下示例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">runApplication&lt;MyApplication&gt;(*args) &#123;</span><br><span class="line">    setBannerMode(OFF)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><p>Kotlin <a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/extensions.html">extensions</a>提供了使用其他功能扩展现有类的功能。 Spring Boot Kotlin API 利用这些扩展为现有 API 添加了新的 Kotlin 专用便利。</p>
<p>提供了<code>TestRestTemplate</code>extensions，类似于 Spring Framework 为<code>RestOperations</code>在 Spring Framework 中提供的 extensions。除其他事项外，这些扩展使利用 Kotlin 修饰类型参数成为可能。</p>
<h2 id="依赖性管理"><a href="#依赖性管理" class="headerlink" title="依赖性管理"></a>依赖性管理</h2><p>为了避免在 Classpath 上混合使用不同版本的 Kotlin 依赖项，提供了以下 Kotlin 依赖项的依赖项 Management：</p>
<ul>
<li><code>kotlin-reflect</code></li>
<li><code>kotlin-runtime</code></li>
<li><code>kotlin-stdlib</code></li>
<li><code>kotlin-stdlib-jdk7</code></li>
<li><code>kotlin-stdlib-jdk8</code></li>
<li><code>kotlin-stdlib-jre7</code></li>
<li><code>kotlin-stdlib-jre8</code></li>
</ul>
<p>使用 Maven，可以通过<code>kotlin.version</code>属性自定义 Kotlin 版本，并为<code>kotlin-maven-plugin</code>提供插件 Management。使用 Gradle，Spring Boot 插件会自动将<code>kotlin.version</code>与 Kotlin 插件的版本对齐。</p>
<h2 id="ConfigurationProperties注解"><a href="#ConfigurationProperties注解" class="headerlink" title="ConfigurationProperties注解"></a>ConfigurationProperties注解</h2><p><code>@ConfigurationProperties</code>目前仅适用于<code>lateinit</code>或可为空的<code>var</code>属性(建议使用前者)，因为构造函数初始化的不可变类为<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/issues/8762">尚不支持</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(&quot;example.kotlin&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KotlinExampleProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    lateinit <span class="keyword">var</span> name: String</span><br><span class="line"></span><br><span class="line">    lateinit <span class="keyword">var</span> description: String</span><br><span class="line"></span><br><span class="line">    val myService = MyService()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        lateinit <span class="keyword">var</span> apiToken: String</span><br><span class="line"></span><br><span class="line">        lateinit <span class="keyword">var</span> uri: URI</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tip</p>
<p>要使用 Comments 处理器生成<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-附录/#使用Comments处理器生成您自己的元数据">您自己的元数据</a>，具有<code>spring-boot-configuration-processor</code>依赖性的<a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/kapt.html">kapt 应该配置</a>。</p>
<h2 id="Testing-1"><a href="#Testing-1" class="headerlink" title="Testing"></a>Testing</h2><p>虽然可以使用 JUnit 4(由<code>spring-boot-starter-test</code>提供的默认值)来测试 Kotlin 代码，但建议使用 JUnit 5. JUnit 5 使一个测试类可以实例化一次，并可以重新用于该类的所有测试。这样就可以在非静态方法上使用<code>@BeforeAll</code>和<code>@AfterAll</code>注解，这非常适合 Kotlin。</p>
<p>要使用 JUnit 5，请从<code>spring-boot-starter-test</code>中排除<code>junit:junit</code>依赖性，添加 JUnit 5 依赖性，并相应地配置 Maven 或 Gradle 插件。有关更多详细信息，请参见<a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-jupiter-samples">JUnit 5 文档</a>。您还需要<a target="_blank" rel="noopener" href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle-changing-default">将测试实例生命周期切换为“每个类”</a>。</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><ul>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/reference/">Kotlin 语言参考</a></li>
<li><a target="_blank" rel="noopener" href="http://slack.kotlinlang.org/">Kotlin Slack</a>(带有专用的#spring Channels)</li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/tagged/spring+kotlin">具有 Spring 和 Kotlin 标签的 Stackoverflow</a></li>
<li><a target="_blank" rel="noopener" href="https://try.kotlinlang.org/">在浏览器中尝试 Kotlin</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.jetbrains.com/kotlin/">Kotlin blog</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlin.link/">Awesome Kotlin</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/guides/tutorials/spring-boot-kotlin/">教程：使用 Spring Boot 和 Kotlin 构建 Web 应用程序</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin">使用 Kotlin 开发 Spring Boot 应用程序</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql">带有 Kotlin，Spring Boot 和 PostgreSQL 的地理空间 Messenger</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0">在 Spring Framework 5.0 中引入 Kotlin 支持</a></li>
<li><a target="_blank" rel="noopener" href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way">Spring Framework 5 Kotlin API 的功能方式</a></li>
</ul>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a>：常规 Spring Boot Spring Data JPA 项目</li>
<li><a target="_blank" rel="noopener" href="https://github.com/mixitconf/mixit">mixit</a>：Spring Boot 2 WebFlux Reactive Spring Data MongoDB</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/spring-kotlin-fullstack">spring-kotlin-fullstack</a>：WebFlux Kotlin 全栈示例，其中 Kotlin2js 用于前端，而不是 JavaScript 或 TypeScript</li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-petclinic/spring-petclinic-kotlin">spring-petclinic-kotlin</a>：Spring PetClinic 示例应用程序的 Kotlin 版本</li>
<li><a target="_blank" rel="noopener" href="https://github.com/sdeleuze/spring-kotlin-deepdive">spring-kotlin-deepdive</a>：从 Boot 1.0 Java 到 Boot 2.0 Kotlin 的逐步迁移</li>
</ul>
<h1 id="接下来要读什么"><a href="#接下来要读什么" class="headerlink" title="接下来要读什么"></a>接下来要读什么</h1><p>如果您想了解有关本节讨论的任何类的更多信息，可以签出<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api">Spring Boot API 文档</a>或浏览<a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE">直接源代码</a>。如果您有特定问题，请查看<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-使用方法指南/">how-to</a>部分。</p>
<p>如果您熟悉 Spring Boot 的核心功能，则可以 continue 阅读<a target="_blank" rel="noopener" href="https://route-nice.github.io/2020/08/31/SpringBoot官方文档翻译-SpringBoot-Actuator可用于生产的功能/">production-ready features</a>。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SpringBoot/" rel="tag"># SpringBoot</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-%E4%BD%BF%E7%94%A8SpringBoot/" rel="prev" title="SpringBoot官方文档翻译-使用SpringBoot">
      <i class="fa fa-chevron-left"></i> SpringBoot官方文档翻译-使用SpringBoot
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot-Actuator%E5%8F%AF%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E7%9A%84%E5%8A%9F%E8%83%BD/" rel="next" title="SpringBoot官方文档翻译-SpringBoot-Actuator可用于生产的功能">
      SpringBoot官方文档翻译-SpringBoot-Actuator可用于生产的功能 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.</span> <span class="nav-text">Spring应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5"><span class="nav-number">1.1.</span> <span class="nav-text">启动失败</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89banner"><span class="nav-number">1.2.</span> <span class="nav-text">自定义banner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89SpringApplication"><span class="nav-number">1.3.</span> <span class="nav-text">自定义SpringApplication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%99%A8API"><span class="nav-number">1.4.</span> <span class="nav-text">流式构建器API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">应用程序可用性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Liveness%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.1.</span> <span class="nav-text">Liveness状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Readiness%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.2.</span> <span class="nav-text">Readiness状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E7%94%A8%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.3.</span> <span class="nav-text">管理应用程序可用状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">1.6.</span> <span class="nav-text">应用程序事件和侦听器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Web%E7%8E%AF%E5%A2%83"><span class="nav-number">1.7.</span> <span class="nav-text">Web环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">访问应用程序参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ApplicationRunner%E6%88%96CommandLineRunner"><span class="nav-number">1.9.</span> <span class="nav-text">使用ApplicationRunner或CommandLineRunner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E9%80%80%E5%87%BA"><span class="nav-number">1.10.</span> <span class="nav-text">应用退出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%A1%E7%90%86%E5%91%98%E5%8A%9F%E8%83%BD"><span class="nav-number">1.11.</span> <span class="nav-text">管理员功能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%96%E9%83%A8%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">外部化配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%80%BC"><span class="nav-number">2.1.</span> <span class="nav-text">配置随机值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.</span> <span class="nav-text">访问命令行属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.</span> <span class="nav-text">应用程序属性文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-number">2.4.</span> <span class="nav-text">特定于配置文件的属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6"><span class="nav-number">2.5.</span> <span class="nav-text">属性中的占位符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E5%AF%86%E5%B1%9E%E6%80%A7"><span class="nav-number">2.6.</span> <span class="nav-text">加密属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8YAML%E4%BB%A3%E6%9B%BF%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.</span> <span class="nav-text">使用YAML代替属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BDYAML"><span class="nav-number">2.7.1.</span> <span class="nav-text">加载YAML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8Spring%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%B0%86YAML%E5%85%AC%E5%BC%80%E4%B8%BA%E5%B1%9E%E6%80%A7"><span class="nav-number">2.7.2.</span> <span class="nav-text">在Spring环境中将YAML公开为属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6YAML%E6%96%87%E6%A1%A3"><span class="nav-number">2.7.3.</span> <span class="nav-text">多配置文件YAML文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#YAML%E7%BC%BA%E7%82%B9"><span class="nav-number">2.7.4.</span> <span class="nav-text">YAML缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">2.8.</span> <span class="nav-text">类型安全的配置属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaBean%E5%B1%9E%E6%80%A7%E7%BB%91%E5%AE%9A"><span class="nav-number">2.8.1.</span> <span class="nav-text">JavaBean属性绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%91%E5%AE%9A"><span class="nav-number">2.8.2.</span> <span class="nav-text">构造器绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AFConfigurationProperties-annotated%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.3.</span> <span class="nav-text">开启ConfigurationProperties-annotated注解类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ConfigurationProperties-annotated%E6%B3%A8%E8%A7%A3%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.4.</span> <span class="nav-text">使用ConfigurationProperties-annotated注解类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">2.8.5.</span> <span class="nav-text">第三方配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E7%BB%91%E5%AE%9A"><span class="nav-number">2.8.6.</span> <span class="nav-text">宽松绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.8.7.</span> <span class="nav-text">合并复杂类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.8.8.</span> <span class="nav-text">属性转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Convertingdurations"><span class="nav-number">2.8.8.1.</span> <span class="nav-text">Convertingdurations</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.8.8.2.</span> <span class="nav-text">转换数据大小</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationProperties%E6%B3%A8%E8%A7%A3%E9%AA%8C%E8%AF%81"><span class="nav-number">2.8.9.</span> <span class="nav-text">ConfigurationProperties注解验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurationProperties%E6%B3%A8%E8%A7%A3%E4%B8%8EValue%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.8.10.</span> <span class="nav-text">ConfigurationProperties注解与Value注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Profiles"><span class="nav-number">3.</span> <span class="nav-text">Profiles</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0Active%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">添加Active配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">以编程方式设置配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.3.</span> <span class="nav-text">特定于配置文件的配置文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%97%A5%E5%BF%97"><span class="nav-number">4.</span> <span class="nav-text">日志</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">日志格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA"><span class="nav-number">4.2.</span> <span class="nav-text">控制台输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA"><span class="nav-number">4.2.1.</span> <span class="nav-text">颜色编码的输出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="nav-number">4.3.</span> <span class="nav-text">文件输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text">日志级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E7%BB%84"><span class="nav-number">4.5.</span> <span class="nav-text">日志组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE"><span class="nav-number">4.6.</span> <span class="nav-text">自定义日志配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Logback%E6%89%A9%E5%B1%95"><span class="nav-number">4.7.</span> <span class="nav-text">Logback扩展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">4.7.1.</span> <span class="nav-text">特定于配置文件的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%B1%9E%E6%80%A7"><span class="nav-number">4.7.2.</span> <span class="nav-text">环境属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">5.</span> <span class="nav-text">国际化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JSON"><span class="nav-number">6.</span> <span class="nav-text">JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Jackson"><span class="nav-number">6.1.</span> <span class="nav-text">Jackson</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gson"><span class="nav-number">6.2.</span> <span class="nav-text">Gson</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON-B"><span class="nav-number">6.3.</span> <span class="nav-text">JSON-B</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">7.</span> <span class="nav-text">开发Web应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringWebMVC%E6%A1%86%E6%9E%B6"><span class="nav-number">7.1.</span> <span class="nav-text">SpringWebMVC框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">7.1.1.</span> <span class="nav-text">SpringMVC自动配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HttpMessageConverters"><span class="nav-number">7.1.2.</span> <span class="nav-text">HttpMessageConverters</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89JSON%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="nav-number">7.1.3.</span> <span class="nav-text">自定义JSON序列化器和反序列化器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageCodesResolver"><span class="nav-number">7.1.4.</span> <span class="nav-text">MessageCodesResolver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="nav-number">7.1.5.</span> <span class="nav-text">静态内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2"><span class="nav-number">7.1.6.</span> <span class="nav-text">欢迎页面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87"><span class="nav-number">7.1.7.</span> <span class="nav-text">自定义图标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E5%92%8C%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86"><span class="nav-number">7.1.8.</span> <span class="nav-text">路径匹配和内容协商</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigurableWebBindingInitializer"><span class="nav-number">7.1.9.</span> <span class="nav-text">ConfigurableWebBindingInitializer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="nav-number">7.1.10.</span> <span class="nav-text">模板引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">7.1.11.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="nav-number">7.1.11.1.</span> <span class="nav-text">自定义错误页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MapSpringMVC%E4%B9%8B%E5%A4%96%E7%9A%84%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2"><span class="nav-number">7.1.11.2.</span> <span class="nav-text">MapSpringMVC之外的错误页面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringHATEOAS"><span class="nav-number">7.1.12.</span> <span class="nav-text">SpringHATEOAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS%E6%94%AF%E6%8C%81"><span class="nav-number">7.1.13.</span> <span class="nav-text">CORS支持</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringWebFlux%E6%A1%86%E6%9E%B6"><span class="nav-number">7.2.</span> <span class="nav-text">SpringWebFlux框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringWebFlux%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">7.2.1.</span> <span class="nav-text">SpringWebFlux自动配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89HttpMessageReaders%E5%92%8CHttpMessageWriters%E7%9A%84HTTP%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="nav-number">7.2.2.</span> <span class="nav-text">带有HttpMessageReaders和HttpMessageWriters的HTTP编解码器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9-1"><span class="nav-number">7.2.3.</span> <span class="nav-text">静态内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-1"><span class="nav-number">7.2.4.</span> <span class="nav-text">模板引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-1"><span class="nav-number">7.2.5.</span> <span class="nav-text">错误处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2-1"><span class="nav-number">7.2.5.1.</span> <span class="nav-text">自定义错误页面</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E9%A1%B5%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">7.2.6.</span> <span class="nav-text">网页过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAX-RS%E5%92%8CJersey"><span class="nav-number">7.3.</span> <span class="nav-text">JAX-RS和Jersey</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-number">7.4.</span> <span class="nav-text">嵌入式Servlet容器支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">7.4.1.</span> <span class="nav-text">Servlet,过滤器和侦听器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86Servlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E6%B3%A8%E5%86%8C%E4%B8%BASpringBean"><span class="nav-number">7.4.1.1.</span> <span class="nav-text">将Servlet,过滤器和侦听器注册为SpringBean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Servlet%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">7.4.2.</span> <span class="nav-text">Servlet上下文初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%AB%E6%8F%8FServlet-%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">扫描Servlet,过滤器和侦听器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ServletWebServerApplicationContext"><span class="nav-number">7.4.3.</span> <span class="nav-text">ServletWebServerApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8"><span class="nav-number">7.4.4.</span> <span class="nav-text">自定义嵌入式Servlet容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%AE%9A%E5%88%B6"><span class="nav-number">7.4.4.1.</span> <span class="nav-text">程序定制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%87%AA%E5%AE%9A%E4%B9%89ConfigurableServletWebServerFactory"><span class="nav-number">7.4.4.2.</span> <span class="nav-text">直接自定义ConfigurableServletWebServerFactory</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSP%E9%99%90%E5%88%B6"><span class="nav-number">7.4.5.</span> <span class="nav-text">JSP限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81"><span class="nav-number">7.5.</span> <span class="nav-text">嵌入式反应式服务器支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactive%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE"><span class="nav-number">7.6.</span> <span class="nav-text">Reactive服务器资源配置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B3%E6%BB%91%E5%85%B3%E9%97%AD"><span class="nav-number">8.</span> <span class="nav-text">平滑关闭</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RSocket"><span class="nav-number">9.</span> <span class="nav-text">RSocket</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Security"><span class="nav-number">10.</span> <span class="nav-text">Security</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">10.1.</span> <span class="nav-text">MVC安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebFlux%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">10.2.</span> <span class="nav-text">WebFlux安全性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth2"><span class="nav-number">10.3.</span> <span class="nav-text">OAuth2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Client"><span class="nav-number">10.3.1.</span> <span class="nav-text">Client</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%8F%90%E4%BE%9B%E5%95%86%E7%9A%84OAuth2Client%E7%AB%AF%E6%B3%A8%E5%86%8C"><span class="nav-number">10.3.1.1.</span> <span class="nav-text">通用提供商的OAuth2Client端注册</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">10.3.2.</span> <span class="nav-text">资源服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">10.3.3.</span> <span class="nav-text">授权服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Actuator%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-number">10.4.</span> <span class="nav-text">Actuator安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E4%BF%9D%E6%8A%A4"><span class="nav-number">10.4.1.</span> <span class="nav-text">跨站点请求伪造保护</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8SQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">11.</span> <span class="nav-text">使用SQL数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-number">11.1.</span> <span class="nav-text">配置数据源</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81"><span class="nav-number">11.1.1.</span> <span class="nav-text">嵌入式数据库支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%94%9F%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">11.1.2.</span> <span class="nav-text">连接到生产数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0JNDI%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="nav-number">11.1.3.</span> <span class="nav-text">连接到JNDI数据源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JdbcTemplate"><span class="nav-number">11.2.</span> <span class="nav-text">使用JdbcTemplate</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JPA%E5%92%8CSpringDataJPA"><span class="nav-number">11.3.</span> <span class="nav-text">JPA和SpringDataJPA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="nav-number">11.3.1.</span> <span class="nav-text">实体类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataJPA%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">11.3.2.</span> <span class="nav-text">SpringDataJPA存储库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4JPA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">11.3.3.</span> <span class="nav-text">创建和删除JPA数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%89%93%E5%BC%80EntityManager"><span class="nav-number">11.3.4.</span> <span class="nav-text">在视图中打开EntityManager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataJDBC"><span class="nav-number">11.4.</span> <span class="nav-text">SpringDataJDBC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8H2%E7%9A%84Web-%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="nav-number">11.5.</span> <span class="nav-text">使用H2的Web 控制台</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9H2%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">11.5.1.</span> <span class="nav-text">更改H2控制台的路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8jOOQ"><span class="nav-number">11.6.</span> <span class="nav-text">使用jOOQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">11.6.1.</span> <span class="nav-text">代码生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8DSLContext"><span class="nav-number">11.6.2.</span> <span class="nav-text">使用DSLContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jOOQSQL%E6%96%B9%E8%A8%80"><span class="nav-number">11.6.3.</span> <span class="nav-text">jOOQSQL方言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89jOOQ"><span class="nav-number">11.6.4.</span> <span class="nav-text">自定义jOOQ</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8NoSQL%E6%8A%80%E6%9C%AF"><span class="nav-number">12.</span> <span class="nav-text">使用NoSQL技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">12.1.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Redis"><span class="nav-number">12.1.1.</span> <span class="nav-text">连接到Redis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB"><span class="nav-number">12.2.</span> <span class="nav-text">MongoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">12.2.1.</span> <span class="nav-text">连接到MongoDB数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MongoTemplate"><span class="nav-number">12.2.2.</span> <span class="nav-text">MongoTemplate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataMongoDB%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.2.3.</span> <span class="nav-text">SpringDataMongoDB存储库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FMongo"><span class="nav-number">12.2.4.</span> <span class="nav-text">嵌入式Mongo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Neo4j"><span class="nav-number">12.3.</span> <span class="nav-text">Neo4j</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Neo4j%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">12.3.1.</span> <span class="nav-text">连接到Neo4j数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%BC%8F"><span class="nav-number">12.3.2.</span> <span class="nav-text">使用嵌入式模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Neo4jSession"><span class="nav-number">12.3.3.</span> <span class="nav-text">Neo4jSession</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataNeo4j%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.3.4.</span> <span class="nav-text">SpringDataNeo4j存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Gemfire"><span class="nav-number">12.4.</span> <span class="nav-text">Gemfire</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Solr"><span class="nav-number">12.5.</span> <span class="nav-text">Solr</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Solr"><span class="nav-number">12.5.1.</span> <span class="nav-text">连接到Solr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataSolr%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.5.2.</span> <span class="nav-text">SpringDataSolr存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">12.6.</span> <span class="nav-text">Elasticsearch</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87-RESTClient%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%88%B0Elasticsearch"><span class="nav-number">12.6.1.</span> <span class="nav-text">通过 RESTClient端连接到Elasticsearch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Jest%E8%BF%9E%E6%8E%A5%E5%88%B0Elasticsearch"><span class="nav-number">12.6.2.</span> <span class="nav-text">使用Jest连接到Elasticsearch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spring%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%88%B0Elasticsearch"><span class="nav-number">12.6.3.</span> <span class="nav-text">使用Spring数据连接到Elasticsearch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataElasticsearch%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.6.4.</span> <span class="nav-text">SpringDataElasticsearch存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cassandra"><span class="nav-number">12.7.</span> <span class="nav-text">Cassandra</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Cassandra"><span class="nav-number">12.7.1.</span> <span class="nav-text">连接到Cassandra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataCassandra%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.7.2.</span> <span class="nav-text">SpringDataCassandra存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Couchbase"><span class="nav-number">12.8.</span> <span class="nav-text">Couchbase</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0Couchbase"><span class="nav-number">12.8.1.</span> <span class="nav-text">连接到Couchbase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataCouchbase%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.8.2.</span> <span class="nav-text">SpringDataCouchbase存储库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LDAP"><span class="nav-number">12.9.</span> <span class="nav-text">LDAP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0LDAP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">12.9.1.</span> <span class="nav-text">连接到LDAP服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataLDAP%E5%AD%98%E5%82%A8%E5%BA%93"><span class="nav-number">12.9.2.</span> <span class="nav-text">SpringDataLDAP存储库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%86%85%E5%AD%98LDAP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">12.9.3.</span> <span class="nav-text">嵌入式内存LDAP服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InfluxDB"><span class="nav-number">12.10.</span> <span class="nav-text">InfluxDB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0nfluxDB"><span class="nav-number">12.10.1.</span> <span class="nav-text">连接到nfluxDB</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Caching"><span class="nav-number">13.</span> <span class="nav-text">Caching</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F"><span class="nav-number">13.1.</span> <span class="nav-text">支持的缓存提供程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Generic"><span class="nav-number">13.1.1.</span> <span class="nav-text">Generic</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JCache-JSR-107"><span class="nav-number">13.1.2.</span> <span class="nav-text">JCache(JSR-107)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EhCache2-x"><span class="nav-number">13.1.3.</span> <span class="nav-text">EhCache2.x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hazelcast%E7%BC%93%E5%AD%98"><span class="nav-number">13.1.4.</span> <span class="nav-text">Hazelcast缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Infinispan"><span class="nav-number">13.1.5.</span> <span class="nav-text">Infinispan</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Couchbase-1"><span class="nav-number">13.1.6.</span> <span class="nav-text">Couchbase</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-1"><span class="nav-number">13.1.7.</span> <span class="nav-text">Redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Caffeine"><span class="nav-number">13.1.8.</span> <span class="nav-text">Caffeine</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Simple"><span class="nav-number">13.1.9.</span> <span class="nav-text">Simple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#None"><span class="nav-number">13.1.10.</span> <span class="nav-text">None</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B6%88%E6%81%AF"><span class="nav-number">14.</span> <span class="nav-text">消息</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JMS"><span class="nav-number">14.1.</span> <span class="nav-text">JMS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ActiveMQ%E6%94%AF%E6%8C%81"><span class="nav-number">14.1.1.</span> <span class="nav-text">ActiveMQ支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Artemis%E6%94%AF%E6%8C%81"><span class="nav-number">14.1.2.</span> <span class="nav-text">Artemis支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JNDI%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%8E%82"><span class="nav-number">14.1.3.</span> <span class="nav-text">使用JNDI连接工厂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">14.1.4.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="nav-number">14.1.5.</span> <span class="nav-text">接收消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMQP"><span class="nav-number">14.2.</span> <span class="nav-text">AMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ-%E6%94%AF%E6%8C%81"><span class="nav-number">14.2.1.</span> <span class="nav-text">RabbitMQ 支持</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF"><span class="nav-number">14.2.2.</span> <span class="nav-text">发送信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-1"><span class="nav-number">14.2.3.</span> <span class="nav-text">接收消息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ApacheKafka%E6%94%AF%E6%8C%81"><span class="nav-number">14.3.</span> <span class="nav-text">ApacheKafka支持</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF-1"><span class="nav-number">14.3.1.</span> <span class="nav-text">发送消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF-2"><span class="nav-number">14.3.2.</span> <span class="nav-text">接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka%E6%B5%81"><span class="nav-number">14.3.3.</span> <span class="nav-text">Kafka流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kafka%E7%9A%84%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7"><span class="nav-number">14.3.4.</span> <span class="nav-text">Kafka的其他属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8RestTemplate%E8%B0%83%E7%94%A8REST%E6%9C%8D%E5%8A%A1"><span class="nav-number">15.</span> <span class="nav-text">使用RestTemplate调用REST服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RestTemplate%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="nav-number">15.1.</span> <span class="nav-text">RestTemplate自定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8WebClient%E8%B0%83%E7%94%A8REST%E6%9C%8D%E5%8A%A1"><span class="nav-number">16.</span> <span class="nav-text">使用WebClient调用REST服务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#WebClient%E8%BF%90%E8%A1%8C%E6%97%B6"><span class="nav-number">16.1.</span> <span class="nav-text">WebClient运行时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WebClient%E8%87%AA%E5%AE%9A%E4%B9%89"><span class="nav-number">16.2.</span> <span class="nav-text">WebClient自定义</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Validation"><span class="nav-number">17.</span> <span class="nav-text">Validation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="nav-number">18.</span> <span class="nav-text">发送电子邮件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JTA-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">19.</span> <span class="nav-text">JTA 的分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Atomikos%E4%BA%8B%E7%89%A9%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">19.1.</span> <span class="nav-text">使用Atomikos事物管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Bitronix%E4%BA%8B%E7%89%A9%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">19.2.</span> <span class="nav-text">使用Bitronix事物管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JavaEE%E6%89%98%E7%AE%A1%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8"><span class="nav-number">19.3.</span> <span class="nav-text">使用JavaEE托管事务管理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E5%90%88XA%E5%92%8C%E9%9D%9EXAJMS%E8%BF%9E%E6%8E%A5"><span class="nav-number">19.4.</span> <span class="nav-text">混合XA和非XAJMS连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%A4%87%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%8B%E5%8A%A1Management%E5%99%A8"><span class="nav-number">19.5.</span> <span class="nav-text">支持备用嵌入式事务Management器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hazelcast"><span class="nav-number">20.</span> <span class="nav-text">Hazelcast</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#QuartzScheduler"><span class="nav-number">21.</span> <span class="nav-text">QuartzScheduler</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%92%8C%E8%AE%A1%E5%88%92"><span class="nav-number">22.</span> <span class="nav-text">任务执行和计划</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88"><span class="nav-number">23.</span> <span class="nav-text">Spring整合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringSession"><span class="nav-number">24.</span> <span class="nav-text">SpringSession</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E8%BF%87JMX%E8%BF%9B%E8%A1%8C%E7%9B%91%E8%A7%86%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">25.</span> <span class="nav-text">通过JMX进行监视和管理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Testing"><span class="nav-number">26.</span> <span class="nav-text">Testing</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="nav-number">26.1.</span> <span class="nav-text">测试范围依赖性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95Spring%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">26.2.</span> <span class="nav-text">测试Spring应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95SpringBoot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">26.3.</span> <span class="nav-text">测试SpringBoot应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8BWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B"><span class="nav-number">26.3.1.</span> <span class="nav-text">检测Web应用程序类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="nav-number">26.3.2.</span> <span class="nav-text">检测测试配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE"><span class="nav-number">26.3.3.</span> <span class="nav-text">排除测试配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.4.</span> <span class="nav-text">在模拟环境中进行测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.5.</span> <span class="nav-text">使用正在运行的服务器进行测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8JMX"><span class="nav-number">26.3.6.</span> <span class="nav-text">使用JMX</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9Fbean%E5%92%8CSpybean"><span class="nav-number">26.3.7.</span> <span class="nav-text">模拟bean和Spybean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.8.</span> <span class="nav-text">自动配置的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84JSON%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.9.</span> <span class="nav-text">自动配置的JSON测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84SpringMVC%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.10.</span> <span class="nav-text">自动配置的SpringMVC测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84SpringWebFlux%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.11.</span> <span class="nav-text">自动配置的SpringWebFlux测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AEJPA%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.12.</span> <span class="nav-text">自动配置的数据JPA测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84JDBC%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.13.</span> <span class="nav-text">自动配置的JDBC测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AEJDBC%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.14.</span> <span class="nav-text">自动配置的数据JDBC测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84jOOQ%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.15.</span> <span class="nav-text">自动配置的jOOQ测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84DataMongoDB%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.16.</span> <span class="nav-text">自动配置的DataMongoDB测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AENeo4j%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.17.</span> <span class="nav-text">自动配置的数据Neo4j测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AERedis%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.18.</span> <span class="nav-text">自动配置的数据Redis测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AELDAP%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.19.</span> <span class="nav-text">自动配置的数据LDAP测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84RESTClient%E7%AB%AF"><span class="nav-number">26.3.20.</span> <span class="nav-text">自动配置的RESTClient端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84SpringREST%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.21.</span> <span class="nav-text">自动配置的SpringREST文档测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8MockMVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84SpringRESTDocs%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.21.1.</span> <span class="nav-text">使用MockMVC自动配置的SpringRESTDocs测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E6%9C%89-REST-%E4%BF%9D%E8%AF%81%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-REST-%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95"><span class="nav-number">26.3.21.2.</span> <span class="nav-text">具有 REST 保证的自动配置的 Spring REST 文档测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87"><span class="nav-number">26.3.22.</span> <span class="nav-text">其他自动配置和切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87"><span class="nav-number">26.3.23.</span> <span class="nav-text">用户配置和切片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Spock%E6%B5%8B%E8%AF%95SpringBoot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">26.3.24.</span> <span class="nav-text">使用Spock测试SpringBoot应用程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95Util"><span class="nav-number">26.4.</span> <span class="nav-text">测试Util</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConfigFileApplicationContextInitializer"><span class="nav-number">26.4.1.</span> <span class="nav-text">ConfigFileApplicationContextInitializer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TestPropertyValues"><span class="nav-number">26.4.2.</span> <span class="nav-text">TestPropertyValues</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutputCapture"><span class="nav-number">26.4.3.</span> <span class="nav-text">OutputCapture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TestRestTemplate"><span class="nav-number">26.4.4.</span> <span class="nav-text">TestRestTemplate</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebSockets"><span class="nav-number">27.</span> <span class="nav-text">WebSockets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebService"><span class="nav-number">28.</span> <span class="nav-text">WebService</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8WebServiceTemplate%E8%B0%83%E7%94%A8Web%E6%9C%8D%E5%8A%A1"><span class="nav-number">29.</span> <span class="nav-text">使用WebServiceTemplate调用Web服务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">30.</span> <span class="nav-text">创建自己的自动配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Bean"><span class="nav-number">30.1.</span> <span class="nav-text">了解自动配置的Bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%80%99%E9%80%89%E4%BA%BA"><span class="nav-number">30.2.</span> <span class="nav-text">查找自动配置的候选人</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Condition%E6%B3%A8%E8%A7%A3"><span class="nav-number">30.3.</span> <span class="nav-text">Condition注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.1.</span> <span class="nav-text">Class条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.2.</span> <span class="nav-text">Bean条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Property%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.3.</span> <span class="nav-text">Property条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.4.</span> <span class="nav-text">Resource条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WebApplication%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.5.</span> <span class="nav-text">WebApplication条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpEL%E8%A1%A8%E8%BE%BE%E6%9D%A1%E4%BB%B6"><span class="nav-number">30.3.6.</span> <span class="nav-text">SpEL表达条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%82%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE"><span class="nav-number">30.4.</span> <span class="nav-text">测试您的自动配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83"><span class="nav-number">30.4.1.</span> <span class="nav-text">模拟网络环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96Classpath"><span class="nav-number">30.4.2.</span> <span class="nav-text">覆盖Classpath</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%AF%E5%8A%A8%E5%99%A8"><span class="nav-number">30.5.</span> <span class="nav-text">创建自己的启动器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Naming"><span class="nav-number">30.5.1.</span> <span class="nav-text">Naming</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="nav-number">30.5.2.</span> <span class="nav-text">自动配置模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Starter%E6%A8%A1%E5%9D%97"><span class="nav-number">30.5.3.</span> <span class="nav-text">Starter模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kotlin%E6%94%AF%E6%8C%81"><span class="nav-number">31.</span> <span class="nav-text">Kotlin支持</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Requirements"><span class="nav-number">31.1.</span> <span class="nav-text">Requirements</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Null-safety"><span class="nav-number">31.2.</span> <span class="nav-text">Null-safety</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KotlinAPI"><span class="nav-number">31.3.</span> <span class="nav-text">KotlinAPI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#runApplication"><span class="nav-number">31.3.1.</span> <span class="nav-text">runApplication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Extensions"><span class="nav-number">31.3.2.</span> <span class="nav-text">Extensions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%80%A7%E7%AE%A1%E7%90%86"><span class="nav-number">31.4.</span> <span class="nav-text">依赖性管理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConfigurationProperties%E6%B3%A8%E8%A7%A3"><span class="nav-number">31.5.</span> <span class="nav-text">ConfigurationProperties注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Testing-1"><span class="nav-number">31.6.</span> <span class="nav-text">Testing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Resources"><span class="nav-number">31.7.</span> <span class="nav-text">Resources</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB"><span class="nav-number">31.7.1.</span> <span class="nav-text">进一步阅读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Examples"><span class="nav-number">31.7.2.</span> <span class="nav-text">Examples</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%A6%81%E8%AF%BB%E4%BB%80%E4%B9%88"><span class="nav-number">32.</span> <span class="nav-text">接下来要读什么</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Route-nice"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Route-nice</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/route-nice" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;route-nice" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:route.lvy.roman@gmail.com" title="E-Mail → mailto:route.lvy.roman@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Route-nice</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://route-nice.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://yoursite.com/2020/08/31/SpringBoot%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91-SpringBoot%E5%8A%9F%E8%83%BD/";
    this.page.identifier = "2020/08/31/SpringBoot官方文档翻译-SpringBoot功能/";
    this.page.title = "SpringBoot官方文档翻译-SpringBoot功能";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://route-nice.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
